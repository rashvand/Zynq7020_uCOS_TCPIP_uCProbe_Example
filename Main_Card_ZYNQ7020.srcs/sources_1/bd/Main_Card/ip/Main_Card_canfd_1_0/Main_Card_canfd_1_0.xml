<?xml version="1.0" encoding="UTF-8"?>
<spirit:component xmlns:xilinx="http://www.xilinx.com" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <spirit:vendor>xilinx.com</spirit:vendor>
  <spirit:library>customized_ip</spirit:library>
  <spirit:name>Main_Card_canfd_1_0</spirit:name>
  <spirit:version>1.0</spirit:version>
  <spirit:busInterfaces>
    <spirit:busInterface>
      <spirit:name>interrupt</spirit:name>
      <spirit:displayName>interrupt</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="interrupt" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="interrupt_rtl" spirit:version="1.0"/>
      <spirit:master/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>INTERRUPT</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ip2bus_intrevent</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>SENSITIVITY</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.INTERRUPT.SENSITIVITY">LEVEL_HIGH</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PortWidth</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.INTERRUPT.PortWidth">1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>CAN_S_AXI_LITE</spirit:name>
      <spirit:displayName>CAN_S_AXI_LITE</spirit:displayName>
      <spirit:description>axi lite interface for core</spirit:description>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="aximm" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="aximm_rtl" spirit:version="1.0"/>
      <spirit:slave>
        <spirit:memoryMapRef spirit:memoryMapRef="S_AXI_LITE"/>
      </spirit:slave>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARADDR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_araddr</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_arready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_arvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWADDR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_awaddr</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_awready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_awvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_bready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BRESP</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_bresp</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_bvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RDATA</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rdata</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RRESP</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rresp</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WDATA</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wdata</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>DATA_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.DATA_WIDTH">32</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PROTOCOL</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.PROTOCOL">AXI4LITE</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>FREQ_HZ</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.FREQ_HZ">100000000</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ID_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.ID_WIDTH">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ADDR_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.ADDR_WIDTH">15</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>AWUSER_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.AWUSER_WIDTH">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ARUSER_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.ARUSER_WIDTH">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>WUSER_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.WUSER_WIDTH">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>RUSER_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.RUSER_WIDTH">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>BUSER_WIDTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.BUSER_WIDTH">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>READ_WRITE_MODE</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.READ_WRITE_MODE">READ_WRITE</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_BURST</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_BURST">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_LOCK</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_LOCK">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_PROT</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_PROT">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_CACHE</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_CACHE">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_QOS</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_QOS">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_REGION</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_REGION">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_WSTRB</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_WSTRB">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_BRESP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_BRESP">1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>HAS_RRESP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_RRESP">1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>SUPPORTS_NARROW_BURST</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.SUPPORTS_NARROW_BURST">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>NUM_READ_OUTSTANDING</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.NUM_READ_OUTSTANDING">2</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>NUM_WRITE_OUTSTANDING</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.NUM_WRITE_OUTSTANDING">2</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>MAX_BURST_LENGTH</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.MAX_BURST_LENGTH">1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PHASE</spirit:name>
          <spirit:value spirit:format="float" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.PHASE">0.000</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>CLK_DOMAIN</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.CLK_DOMAIN">Main_Card_processing_system7_0_0_FCLK_CLK0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>NUM_READ_THREADS</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.NUM_READ_THREADS">1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>NUM_WRITE_THREADS</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.NUM_WRITE_THREADS">1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>RUSER_BITS_PER_BYTE</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.RUSER_BITS_PER_BYTE">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>WUSER_BITS_PER_BYTE</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.WUSER_BITS_PER_BYTE">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
      <spirit:vendorExtensions>
        <xilinx:busInterfaceInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="BUSIF_ENABLEMENT.CAN_S_AXI_LITE" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=0)">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:busInterfaceInfo>
      </spirit:vendorExtensions>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>CAN_S_APB</spirit:name>
      <spirit:displayName>CAN_S_APB</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="apb" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="apb_rtl" spirit:version="1.0"/>
      <spirit:slave>
        <spirit:memoryMapRef spirit:memoryMapRef="S_APB_LITE"/>
      </spirit:slave>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PADDR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_paddr</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PENABLE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_penable</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PRDATA</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_prdata</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_pready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PSEL</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_psel</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PSLVERR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_perror</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PWDATA</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_pwdata</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>PWRITE</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_pwrite</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:vendorExtensions>
        <xilinx:busInterfaceInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="BUSIF_ENABLEMENT.CAN_S_APB" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=1)">false</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:busInterfaceInfo>
      </spirit:vendorExtensions>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>s_axi_aclk_i</spirit:name>
      <spirit:displayName>s_axi_aclk</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_aclk</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_BUSIF</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.S_AXI_ACLK_I.ASSOCIATED_BUSIF">CAN_S_AXI_LITE</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_RESET</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.S_AXI_ACLK_I.ASSOCIATED_RESET">s_axi_aresetn</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>FREQ_HZ</spirit:name>
          <spirit:displayName>AXI clock frequency</spirit:displayName>
          <spirit:description>specify frequency of the clock connected to port s_axi_aclk</spirit:description>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.S_AXI_ACLK_I.FREQ_HZ">100000000</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PHASE</spirit:name>
          <spirit:value spirit:format="float" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.S_AXI_ACLK_I.PHASE">0.000</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>CLK_DOMAIN</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.S_AXI_ACLK_I.CLK_DOMAIN">Main_Card_processing_system7_0_0_FCLK_CLK0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.S_AXI_ACLK_I.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
      <spirit:vendorExtensions>
        <xilinx:busInterfaceInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="BUSIF_ENABLEMENT.s_axi_aclk_i" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=0)">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:busInterfaceInfo>
      </spirit:vendorExtensions>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>s_axi_aresetn</spirit:name>
      <spirit:displayName>s_axi_aresetn</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="reset" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="reset_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_aresetn</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>POLARITY</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.S_AXI_ARESETN.POLARITY">ACTIVE_LOW</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.S_AXI_ARESETN.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
      <spirit:vendorExtensions>
        <xilinx:busInterfaceInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="BUSIF_ENABLEMENT.s_axi_aresetn" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=0)">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:busInterfaceInfo>
      </spirit:vendorExtensions>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>apb_pclk_i</spirit:name>
      <spirit:displayName>apb_pclk</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_pclk</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_BUSIF</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.APB_PCLK_I.ASSOCIATED_BUSIF">CAN_S_APB</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_RESET</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.APB_PCLK_I.ASSOCIATED_RESET">apb_resetn</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>FREQ_HZ</spirit:name>
          <spirit:displayName>APB clock frequency</spirit:displayName>
          <spirit:description>specify frequency of the clock connected to port apb_pclk</spirit:description>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.APB_PCLK_I.FREQ_HZ">100000000</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PHASE</spirit:name>
          <spirit:value spirit:format="float" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.APB_PCLK_I.PHASE">0.000</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>CLK_DOMAIN</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.APB_PCLK_I.CLK_DOMAIN"/>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.APB_PCLK_I.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
      <spirit:vendorExtensions>
        <xilinx:busInterfaceInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="BUSIF_ENABLEMENT.apb_pclk_i" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=1)">false</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:busInterfaceInfo>
      </spirit:vendorExtensions>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>apb_resetn</spirit:name>
      <spirit:displayName>apb_resetn</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="reset" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="reset_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>apb_resetn</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>POLARITY</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.APB_RESETN.POLARITY">ACTIVE_LOW</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.APB_RESETN.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
      <spirit:vendorExtensions>
        <xilinx:busInterfaceInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="BUSIF_ENABLEMENT.apb_resetn" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=1)">false</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:busInterfaceInfo>
      </spirit:vendorExtensions>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>CAN_INTERFACE</spirit:name>
      <spirit:displayName>CAN_INTERFACE</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="can" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="can_rtl" spirit:version="1.0"/>
      <spirit:master/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>can_clk</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RX</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>can_phy_rx</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>TX</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>can_phy_tx</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>can_clk_i</spirit:name>
      <spirit:displayName>can_clk</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>can_clk</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_BUSIF</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.CAN_CLK_I.ASSOCIATED_BUSIF">CAN_INTERFACE</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>FREQ_HZ</spirit:name>
          <spirit:displayName>CAN clock frequency</spirit:displayName>
          <spirit:description>specify frequency of the clock connected to port can_clk</spirit:description>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_I.FREQ_HZ">40000000</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PHASE</spirit:name>
          <spirit:value spirit:format="float" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_I.PHASE">0.000</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>CLK_DOMAIN</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_I.CLK_DOMAIN"/>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_RESET</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_I.ASSOCIATED_RESET"/>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_I.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>can_clk_x2_i</spirit:name>
      <spirit:displayName>can_clk_x2</spirit:displayName>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>can_clk_x2</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>FREQ_HZ</spirit:name>
          <spirit:displayName>CAN_X2 clock frequency</spirit:displayName>
          <spirit:description>specify frequency of the clock connected to port can_clk_x2</spirit:description>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_X2_I.FREQ_HZ">80000000</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>PHASE</spirit:name>
          <spirit:value spirit:format="float" spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_X2_I.PHASE">0.0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>CLK_DOMAIN</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_X2_I.CLK_DOMAIN">/clk_wiz_1_clk_out1</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_BUSIF</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_X2_I.ASSOCIATED_BUSIF"/>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_RESET</spirit:name>
          <spirit:value spirit:resolve="generated" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_X2_I.ASSOCIATED_RESET"/>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>none</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>INSERT_VIP</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.CAN_CLK_X2_I.INSERT_VIP">0</spirit:value>
          <spirit:vendorExtensions>
            <xilinx:parameterInfo>
              <xilinx:parameterUsage>simulation.rtl</xilinx:parameterUsage>
            </xilinx:parameterInfo>
          </spirit:vendorExtensions>
        </spirit:parameter>
      </spirit:parameters>
    </spirit:busInterface>
  </spirit:busInterfaces>
  <spirit:memoryMaps>
    <spirit:memoryMap>
      <spirit:name>S_APB_LITE</spirit:name>
      <spirit:displayName>CANFD_MEM</spirit:displayName>
      <spirit:description>Memory Map for CANFD</spirit:description>
      <spirit:addressBlock>
        <spirit:name>Reg</spirit:name>
        <spirit:displayName>Reg</spirit:displayName>
        <spirit:description>Register Block</spirit:description>
        <spirit:baseAddress spirit:format="long">0</spirit:baseAddress>
        <spirit:range spirit:format="long">4096</spirit:range>
        <spirit:width spirit:format="long">32</spirit:width>
        <spirit:usage>register</spirit:usage>
        <spirit:access>read-write</spirit:access>
        <spirit:register>
          <spirit:name>SRR</spirit:name>
          <spirit:displayName>Software Reset Register</spirit:displayName>
          <spirit:description>Software Reset Register</spirit:description>
          <spirit:addressOffset>0x0000</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>SRST</spirit:name>
            <spirit:displayName>Software Reset</spirit:displayName>
            <spirit:description>The software reset bit for the core.
1 - core is reset.
If a 1 is written to this bit, all the core configuration registers (including the SRR) are reset.
Reads to this bit always return a 0.
Note - After performing soft or hard reset, wait for 8 AXI Clock cycles before initiating next AXILite transaction.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CEN</spirit:name>
            <spirit:displayName>CAN Enable</spirit:displayName>
            <spirit:description>The Enable bit for the core.
1 - The core is in Loopback, Sleep, Snoop or Normal mode depending on the LBACK, SLEEP and SNOOP bits in the MSR.
0 - The core is in the Configuration mode.
Note - If the CEN bit is changed during core operation, it is recommended to reset the core so that operations start afresh.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>MSR</spirit:name>
          <spirit:displayName>Mode Select Register</spirit:displayName>
          <spirit:description>Mode Select Register</spirit:description>
          <spirit:addressOffset>0x0004</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>SLEEP</spirit:name>
            <spirit:displayName>Sleep Mode Select/Request</spirit:displayName>
            <spirit:description>The Sleep Mode request bit.
1 - Request core to be in Sleep mode.
0 - No such request.
This bit is cleared when the core wakes up from the Sleep mode.
In order for core to enter Sleep mode, LBACK and SNOOP bits in this register should be set to ’0’.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBACK</spirit:name>
            <spirit:displayName>Loop Back Mode Select/Request</spirit:displayName>
            <spirit:description>The Loop Back Mode Request bit.
1 - Request core to be in Loop Back mode.
0 - No such request.
This bit can be written to only when CEN bit in SRR is &apos;0.&apos;
In order for core to enter LBACK mode, SLEEP and SNOOP bits in this register should be set to &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNOOP</spirit:name>
            <spirit:displayName>SNOOP Mode Select</spirit:displayName>
            <spirit:description>The Snoop Mode Request bit.
1 - Request core to be in Snoop mode.
0 - No such request.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
The user has to make sure that SNOOP mode is programmed only after system reset or software reset.
In order for core to enter Snoop mode, LBACK and SLEEP bits in this register should be set to &apos;0&apos;.
The features of Snoop mode are      Core transmits recessive bits on to CAN bus     Receives messages that are transmitted by other nodes but does not ACK. Stores received messages in RxBRAM based on programmed ID filtering.     Error counters are disabled and cleared to 0. Reads to error counter register will return zero.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BRSD</spirit:name>
            <spirit:displayName>CANFD Bit Rate Switch Disable Override</spirit:displayName>
            <spirit:description>1 - Makes core transmit CANFD frames only in nominal bit rate (by overriding Tx Message element setting).
0 - Makes core transmit CANFD frames as per BRS bit in TX Message element.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DAR</spirit:name>
            <spirit:displayName>Disable Auto Retransmission</spirit:displayName>
            <spirit:description>1 - Disable Auto retransmission to provide single shot transmission.
0 - Auto retransmission enabled.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DPEE</spirit:name>
            <spirit:displayName>Disable Protocol Exception Event detection/generation</spirit:displayName>
            <spirit:description>1 - Disable Protocol Exception Event detection/generation by CANFD receiver if &quot;res&quot; bit in CANFD frame is detected as 1. 
In this case, CANFD receiver will generate Form error.
0 - PEE detection/generation is enabled.  If CANFD receiver detects &quot;res&quot; bit as 1, it will go to Bus Integration
state (PEE_config) and waits for Bus Idle condition (11 consecutive nominal recessive bits). Error counter remains unchanged.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SBR</spirit:name>
            <spirit:displayName>Start Bus-Off Recovery Request</spirit:displayName>
            <spirit:description>1 - Start Bus-off Recovery Request.
0 - No such request.
Node stays in Bus-off state until SBR bit is set to &apos;1&apos; (provided ABR bit in this register is not set).
This bit can be written only when node is in Bus-off state. 
This bit auto clears after node completes the bus-off recovery or leave bus-off state due to hard/soft reset or CEN de-assertion. 
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ABR</spirit:name>
            <spirit:displayName>Auto Bus-Off Recovery Request</spirit:displayName>
            <spirit:description>1 - Auto Bus-off Recovery Request.
0 - No such request.
If this bit is set, node do auto bus-off recovery irrespective of SBR setting in this register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>BRPR</spirit:name>
          <spirit:displayName>Nominal Baud Rate Prescalar Register</spirit:displayName>
          <spirit:description>Nominal Baud Rate Prescalar Register</spirit:description>
          <spirit:addressOffset>0x0008</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>BRP</spirit:name>
            <spirit:displayName>Nomunal Baud Rate Prescalar</spirit:displayName>
            <spirit:description>These bits indicate the prescaler value. 
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>BTR</spirit:name>
          <spirit:displayName>Nominal Bit Timing Register</spirit:displayName>
          <spirit:description>Nominal Bit Timing Register</spirit:description>
          <spirit:addressOffset>0x000C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TS1</spirit:name>
            <spirit:displayName>Timing Segement1</spirit:displayName>
            <spirit:description>Indicates the Sum of Propagation Segment and Phase Segment 1 as specified in the standard for Nominal Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TS2</spirit:name>
            <spirit:displayName>Timing Segement2</spirit:displayName>
            <spirit:description>Indicates the Phase Segment 2 as specified in the CANFD standard for Nominal Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">4</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SJW</spirit:name>
            <spirit:displayName>Synchronization Jump Width</spirit:displayName>
            <spirit:description>Indicates the Synchronization Jump Width as specified in the CANFD standard for Nominal Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">4</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ECR</spirit:name>
          <spirit:displayName>Error Count Register</spirit:displayName>
          <spirit:description>Error Count Register</spirit:description>
          <spirit:addressOffset>0x0010</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TEC</spirit:name>
            <spirit:displayName>Transmit Error Count</spirit:displayName>
            <spirit:description>Indicates the value of Transmit Error Counter.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>REC</spirit:name>
            <spirit:displayName>Recieve Error Count</spirit:displayName>
            <spirit:description>Indicates the value of Recieve Error Counter.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ESR</spirit:name>
          <spirit:displayName>Error Status Register</spirit:displayName>
          <spirit:description>Error Status Register</spirit:description>
          <spirit:addressOffset>0x0014</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CRCER</spirit:name>
            <spirit:displayName>CRC Error</spirit:displayName>
            <spirit:description>Indicates a CRC error has occurred.
1 - Indicates a CRC error has occurred.
0 - Indicates a CRC error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FMER</spirit:name>
            <spirit:displayName>Form Error</spirit:displayName>
            <spirit:description>Indicates an error in one of the fixed form fields in the message frame.
1 - Indicates a form error has occurred.
0 - Indicates a form error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>STER</spirit:name>
            <spirit:displayName>Stuff Error</spirit:displayName>
            <spirit:description>Indicates an error if there is a stuffing violation.
1 - Indicates a stuff error has occurred.
0 - Indicates a stuff error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BERR</spirit:name>
            <spirit:displayName>Bit Error</spirit:displayName>
            <spirit:description>Indicates the received bit is not the same as the transmitted bit during bus communication.
1 - Indicates a bit error has occurred.
0 - Indicates a bit error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ACKER</spirit:name>
            <spirit:displayName>ACK Error</spirit:displayName>
            <spirit:description>Indicates an acknowledgement error.
1 - Indicates an acknowledgement error has occurred.
0 - Indicates an acknowledgement error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_CRCER</spirit:name>
            <spirit:displayName>CRC Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates CRC error occurred in Data  Phase (Fast) data rate
0 - Indicates CRC error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_FMER</spirit:name>
            <spirit:displayName>Form Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates form error occurred in Data Phase (Fast) data rate
0 - Indicates form error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_STER</spirit:name>
            <spirit:displayName>Stuff Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates stuff error occurred in Data Phase (Fast) data rate
0 - Indicates stuff error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_BERR</spirit:name>
            <spirit:displayName>Bit Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates bit error occurred in Data Phase (Fast) data rate.
0 - Indicates bit error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>SR</spirit:name>
          <spirit:displayName>Status Register</spirit:displayName>
          <spirit:description>Status Register</spirit:description>
          <spirit:addressOffset>0x0018</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CONFIG</spirit:name>
            <spirit:displayName>Configuration Mode Indicator</spirit:displayName>
            <spirit:description>Indicates the core is in Configuration mode.
1 - Indicates the core is in Configuration mode.
0 - Indicates the core is not in Configuration mode.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBACK</spirit:name>
            <spirit:displayName>Loop Back Mode</spirit:displayName>
            <spirit:description>Indicates the core is in Loopback mode.
1 - Indicates the core is in Loopback mode.
0 - Indicates the core is not in Loopback mode.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLEEP</spirit:name>
            <spirit:displayName>Sleep Mode</spirit:displayName>
            <spirit:description>Indicates the core is in Sleep mode.
1 - Indicates the core is in Sleep mode.
0 - Indicates the core is not in Sleep mode.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>NORMAL</spirit:name>
            <spirit:displayName>Normal Mode</spirit:displayName>
            <spirit:description>Indicates the core is in Normal Mode.
1 - Indicates the core is in Normal Mode.
0 - Indicates the core is not in Normal mode.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BIDLE</spirit:name>
            <spirit:displayName>Bus Idle</spirit:displayName>
            <spirit:description>Indicates the CAN bus status.
1 - Indicates no bus communication is taking place.
0 - Indicates the core is either in Configuration mode or the bus is busy.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BBSY</spirit:name>
            <spirit:displayName>BBSY</spirit:displayName>
            <spirit:description>Indicates the CAN bus status.
1 - Indicates that the core is either receiving a message or transmitting a message.
0 - Indicates that the core is either in Configuration mode or the bus is idle.
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERRWRN</spirit:name>
            <spirit:displayName>ERRWRN</spirit:displayName>
            <spirit:description>Indicates that either the Transmit Error counter or the Receive Error counter has exceeded a value of 96.
1 - One or more error counters have a value 96.
0 - Neither of the error counters has a value 96.
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ESTAT</spirit:name>
            <spirit:displayName>Error Status</spirit:displayName>
            <spirit:description>Indicates the error status of the core.
00 - Indicates Configuration Mode (CONFIG = 1). Error State is undefined.
01 - Indicates Error Active State.
11 - Indicates Error Passive State.
10 - Indicates Bus Off State.
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">2</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PEE CONFIG</spirit:name>
            <spirit:displayName>PEE Mode Indicator</spirit:displayName>
            <spirit:description>1 - Indicates the core is in PEE Mode (Bus Integration State).
When this bit is set then BBSY and NORMAL status bits in SR register does not mean anything.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BSFR_CONFIG</spirit:name>
            <spirit:displayName>Bus-off Recovery Mode Indicator</spirit:displayName>
            <spirit:description>1 - Indicates the core is in Bus-off Recovery Mode (Bus Integration State)
When this bit is set then BBSY and NORMAL status bits in SR register does not mean anything.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>NISO</spirit:name>
            <spirit:displayName>Non-ISO Core</spirit:displayName>
            <spirit:description>1 - Core is NISO (generated with C_IS_NISO = 1)
0 - Core is ISO (generated with C_IS_NISO = 0)
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNOOP</spirit:name>
            <spirit:displayName>SNOOP Mode</spirit:displayName>
            <spirit:description>1 - Indicates controller is in Snoop mode provided Normal mode bit is also set in this register.
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDCV</spirit:name>
            <spirit:displayName>Transceiver Delay Compensation value</spirit:displayName>
            <spirit:description>This field gives the position of secondary sample point (defined as sum of TDCOFF and measured delay  
for EDL to r0 fall edge from TX to RX) in CAN clocks. 
This field is for status purpose.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">7</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ISR</spirit:name>
          <spirit:displayName>Interrupt Status Register</spirit:displayName>
          <spirit:description>Interrupt Status Register</spirit:description>
          <spirit:addressOffset>0x001C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ARBLST</spirit:name>
            <spirit:displayName>Arbitration Lost Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that arbitration was lost during message transmission.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXOK</spirit:name>
            <spirit:displayName>Transmission Successful Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that a message was transmitted successfully.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PEE</spirit:name>
            <spirit:displayName>Protocol Exception Event Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core (CANFD) has detected PEE event.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BSFRD</spirit:name>
            <spirit:displayName>Bus-Off Recovery Done Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core recovered from Bus Off state.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXOK</spirit:name>
            <spirit:displayName>New Message Recieved Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that a message was received successfully and stored into the RX FIFO.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXFOFLW</spirit:name>
            <spirit:displayName>Rx  FIFO Overflow interrupt (FIFO mode)</spirit:displayName>
            <spirit:description>1 - Indicates that a message has been lost. This condition occurs when a new message is being received and the Receive FIFO is Full.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR only valid in FIFO Mode.
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERROR</spirit:name>
            <spirit:displayName>Error Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that an error occurred during message transmission or reception.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BSOFF</spirit:name>
            <spirit:displayName>Bus Off Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core entered the Bus Off state.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLP</spirit:name>
            <spirit:displayName>Sleep Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the CAN core entered Sleep mode.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>WKUP</spirit:name>
            <spirit:displayName>Wakeup Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core entered Normal mode from Sleep Mode
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXFWMFLL</spirit:name>
            <spirit:displayName>Rx FIFO Watermark Full interrupt (FIFO mode)</spirit:displayName>
            <spirit:description>1 - Indicates that Rx FIFO is full based on watermark programming.
The interrupt continues to assert as long as the RX FIFO count is above RX FIFO Full watermark.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXRRS</spirit:name>
            <spirit:displayName>Tx Buffer Ready Request Served Interrupt</spirit:displayName>
            <spirit:description>1 - Indicates that a Buffer Ready request was cleared.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXCRS</spirit:name>
            <spirit:displayName>Tx Cancellation Request Served Interrupt</spirit:displayName>
            <spirit:description>1 - Indicates that a Cancellation request was cleared.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXRBF</spirit:name>
            <spirit:displayName>Rx Buffer Bull Interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>1 - Indicates that a receive buffer has received a message and become full.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXBOFLW</spirit:name>
            <spirit:displayName>Rx Buffer Overflow interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>1 - Indicates that a message has been lost due to buffer condition. Buffer index is captured in RXBOFLW_BI field.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXMNF</spirit:name>
            <spirit:displayName>Rx Match Not Finished</spirit:displayName>
            <spirit:description>1 - Indicates that Match process did not finish until the start of 6th Bit in EOF field and frame was discarded.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXLRM_BI</spirit:name>
            <spirit:displayName>Rx Buffer Index for Last Received  message (Mailbox mode)</spirit:displayName>
            <spirit:description>Gives Rx Buffer index for last received message.
This field has meaning only if RXOK bit is set in this register.
This field is cleared at hard/soft reset or when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXBOFLW_BI</spirit:name>
            <spirit:displayName>Rx Buffer index for Overflow interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>Gives Rx Buffer index for which overflow event is generated.
This field is automatically cleared to default if RXBOFLW bit is cleared in this register.
In case more than one overflow event happens (before host could clear RXBOFLW), RXBOFLW_BI will show overflow index for the last event.
This field has meaning only if Overflow interrupt RXBOFLW bit is set.
This field is also cleared at hard/soft reset or when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IER</spirit:name>
          <spirit:displayName>Interrupt Enable Register</spirit:displayName>
          <spirit:description>Interrupt Enable Register</spirit:description>
          <spirit:addressOffset>0x0020</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>EARBLOST</spirit:name>
            <spirit:displayName>Arbitration Lost Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if ARBLST bit in ISR is set.
0 - Disable interrupt generation if ARBLST bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ETXOK</spirit:name>
            <spirit:displayName>Transmission successful interrupt enable</spirit:displayName>
            <spirit:description>1 = Enable interrupt generation if TXOK bit in ISR is set.
0 = Disable interrupt generation if TXOK bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EPEE</spirit:name>
            <spirit:displayName>Protocol Exception Event interrupt enable</spirit:displayName>
            <spirit:description>Protocol Exception Event interrupt enable
1 - Enable interrupt generation if PEE bit in ISR is set.
0 - Disable interrupt generation if PEE bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EBSFRD</spirit:name>
            <spirit:displayName>Bus-off Recovery Done interrupt enable</spirit:displayName>
            <spirit:description>Bus-off Recovery Done interrupt enable
1 - Enable interrupt generation if BSFRD bit in ISR is set.
0 - Disable interrupt generation if BSFRD bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXOK</spirit:name>
            <spirit:displayName>New message Received interrupt enable</spirit:displayName>
            <spirit:description>New message Received interrupt enable
1 - Enable interrupt generation if RXOK bit in ISR is set.
0 - Disable interrupt generation if RXOK bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERFXOFLW</spirit:name>
            <spirit:displayName>Rx FIFO Overflow interrupt Enable (FIFO Mode)</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RFXOFLW bit in ISR is set.
0 - Disable interrupt generation if RFXOFLW bit in ISR is set.
Only valid in FIFO Mode
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EERROR</spirit:name>
            <spirit:displayName>Error interrupt enable</spirit:displayName>
            <spirit:description>Error interrupt enable
1 - Enable interrupt generation if ERROR bit in ISR is set.
0 - Disable interrupt generation if ERROR bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EBSOFF</spirit:name>
            <spirit:displayName>Bus OFF interrupt enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if BSOFF bit in ISR is set.
0 - Disable interrupt generation if BSOFF bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ESLP</spirit:name>
            <spirit:displayName>Sleep interrupt enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if SLP bit in ISR is set.
0 - Disable interrupt generation if SLP bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EWKUP</spirit:name>
            <spirit:displayName>Wakeup interrupt enable</spirit:displayName>
            <spirit:description>Wakeup interrupt enable
1 - Enable interrupt generation if WKUP bit in ISR is set.
0 - Disable interrupt generation if WKUP bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXFWMFLL</spirit:name>
            <spirit:displayName>Rx  FIFO Watermark Full interrupt Enable (FIFO Mode)</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RXFWMFLL bit in ISR is set.
0 - Disable interrupt generation if RXFWMFLL bit in ISR is set.
Only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ETXRRS</spirit:name>
            <spirit:displayName>Tx Buffer Ready Request Served Interrupt Enable</spirit:displayName>
            <spirit:description>Tx Buffer Ready Request Served Interrupt Enable
1 - Enable interrupt generation if TXRRS bit in ISR is set.
0 - Disable interrupt generation if TXRRS bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ETXCRS</spirit:name>
            <spirit:displayName>Tx Cancellation Request Served Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if TXCRS bit in ISR is set.
0 - Disable interrupt generation if TXCRS bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXRBF</spirit:name>
            <spirit:displayName>Rx Buffer Bull Interrupt Enable (Mailbox mode)</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RXRBF bit in ISR is set.
0 - Disable interrupt generation if RXRBF bit in ISR is set.
Only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXBOFLW</spirit:name>
            <spirit:displayName>Rx Buffer Overflow interrupt Enable (Mailbox mode)</spirit:displayName>
            <spirit:description>1 = Enable interrupt generation if RXBOFLW bit in ISR is set.
0 = Disable interrupt generation if RXBOFLW bit in ISR is set.
Only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXMNF</spirit:name>
            <spirit:displayName>Rx Match Not Finished interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RXMNF bit in ISR is set.
0 - Disable interrupt generation if RXMNF bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ICR</spirit:name>
          <spirit:displayName>Interrupt Clear Register</spirit:displayName>
          <spirit:description>Interrupt Clear Register</spirit:description>
          <spirit:addressOffset>0x0024</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CARBLOST</spirit:name>
            <spirit:displayName>Clear Arbitration lost interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTXOK</spirit:name>
            <spirit:displayName>Clear Transmission successful interrupt</spirit:displayName>
            <spirit:description>1 - Clear Transmission successful interrupt.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CPEE</spirit:name>
            <spirit:displayName>Clear Protocol Exception Event interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBSFRD</spirit:name>
            <spirit:displayName>Clear Bus-off Recovery Done interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXOK</spirit:name>
            <spirit:displayName>Clear New message Received interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRFXOFLW</spirit:name>
            <spirit:displayName>Clear Rx FIFO Overflow interrupt (FIFO Mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
only valid in FIFO Mode
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CERROR</spirit:name>
            <spirit:displayName>Clear Error interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBSOFF</spirit:name>
            <spirit:displayName>Clear Bus OFF interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSLP</spirit:name>
            <spirit:displayName>Clear Sleep interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CWKUP</spirit:name>
            <spirit:displayName>Clear Wakeup interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXFWMFLL</spirit:name>
            <spirit:displayName>Clear Rx  FIFO Watermark Full interrupt (FIFO Mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
Only valid in FIFO Mode
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTXRRS</spirit:name>
            <spirit:displayName>Clear Tx Buffer Ready Request Served Interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTXCRS</spirit:name>
            <spirit:displayName>Clear Tx Cancellation Request Served Interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXRBF</spirit:name>
            <spirit:displayName>Clear Rx Buffer Full Interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXBOFLW</spirit:name>
            <spirit:displayName>Clear Rx Buffer Overflow interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXMNF</spirit:name>
            <spirit:displayName>Clear Rx Match Not Finished interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TSR</spirit:name>
          <spirit:displayName>Time Stamp Register</spirit:displayName>
          <spirit:description>Time Stamp Register</spirit:description>
          <spirit:addressOffset>0x0028</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTS</spirit:name>
            <spirit:displayName>Clear TimeStamp Counter</spirit:displayName>
            <spirit:description>Internal free running counter is cleared to 0 when CTS=1. 
This bit only needs to be written once with a &apos;1&apos; to clear the counter. 
The bit will always read as &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TIMESTAMP_CNT</spirit:name>
            <spirit:displayName>Time Stamp Counter Value</spirit:displayName>
            <spirit:description>This Status field gives running value of the time stamp counter. 
This  field is cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>DPBRPR</spirit:name>
          <spirit:displayName>Data Phase Baud Rate Prescalar Register</spirit:displayName>
          <spirit:description>Data Phase Baud Rate Prescalar Register</spirit:description>
          <spirit:addressOffset>0x0088</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>DP_BRP</spirit:name>
            <spirit:displayName>Data Phase Baud Rate Prescaler</spirit:displayName>
            <spirit:description>These bits indicate the prescaler value for Data Bit Timing as specified in the CANFD standard.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDCOFF</spirit:name>
            <spirit:displayName>Transceiver Delay Compensation Offset</spirit:displayName>
            <spirit:description>This offset is specified in CAN clock cycles and is added to the measured transnitter delay to place the Secondary Sample Point (SSP) at appropriate position (for ex. set this to half data bit time in terms of CAN clock cycles to place SSP in the middle of the data bit).
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">5</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDC</spirit:name>
            <spirit:displayName>Transceiver Delay Compensation(TDC) Enable</spirit:displayName>
            <spirit:description>1 - Enables TDC function as specified in the CANFD standard
0 - TDC is disabled
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>DPBTR</spirit:name>
          <spirit:displayName>Data Phase Bit Timing Register</spirit:displayName>
          <spirit:description>Data Phase Bit Timing Register</spirit:description>
          <spirit:addressOffset>0x008C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>DP_TS1</spirit:name>
            <spirit:displayName>Data Phase Time Segment1</spirit:displayName>
            <spirit:description>Indicates the Sum of Propagation Segment and Phase Segment 1 as specified in the CANFD standard for Data Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">4</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP_TS2</spirit:name>
            <spirit:displayName>Data Phase Time Segment2</spirit:displayName>
            <spirit:description>Indicates the Phase Segment 2 as specified in the CANFD standard for Data Bit Timing. 
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">3</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP_SJW</spirit:name>
            <spirit:displayName>Data Phase Synchronization Jump Width</spirit:displayName>
            <spirit:description>Indicates the Synchronization Jump Width as specified in the CANFD standard for Data Bit Timing. 
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">3</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TRR</spirit:name>
          <spirit:displayName>Tx Buffer Ready Request Register</spirit:displayName>
          <spirit:description>Tx Buffer Ready Request Register</spirit:description>
          <spirit:addressOffset>0x0090</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RR</spirit:name>
            <spirit:displayName>Tx Buffer Ready Request</spirit:displayName>
            <spirit:description>This is control bit corresponds to TBi message in Tx BRAM.
Host writes 1 to indicate buffer is ready for transmission. Core clears this bit when   Buffer transmission is completed on CAN Bus or   If core is in DAR mode, then after one transmission attempt on CAN bus [either successful or unsuccessful (i.e. arbitration lost or error)] or   If message is cancelled due to cancellation request or   Any combination of Above Host writes are ignored when this bit is 1.
Note - This register remains in reset when SNOOP mode is enabled.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IETRS</spirit:name>
          <spirit:displayName>Interrupt Enable Tx Buffer Ready Request Served/Cleared Register</spirit:displayName>
          <spirit:description>Interrupt Enable Tx Buffer Ready Request Served/Cleared Register</spirit:description>
          <spirit:addressOffset>0x0094</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERRS</spirit:name>
            <spirit:displayName>Tx Buffer_i Ready Req Served/Cleared Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting TXRRS bit in ISR when RRi bit in TRR register clears.
0 - TXRRS bit in ISR will not set if  RRi bit in TRR register clears.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TCR</spirit:name>
          <spirit:displayName>Tx Buffer Cancellation Request Register</spirit:displayName>
          <spirit:description>Tx Buffer Cancellation Request Register</spirit:description>
          <spirit:addressOffset>0x0098</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CR</spirit:name>
            <spirit:displayName>Tx Buffer_0 Cancel Request</spirit:displayName>
            <spirit:description>This is cancellation request bit corresponds to RR0 bit in TRR register.
Host writes 1 to indicate cancellation request of corresponding buffer ready request (i.e. RR0 bit in TRR register). Core clears this bit when cancellation request is completed. 
Host writes to this bit are ignored if CR0 is 1 or RR0 bit of TRR register is 0.
If the buffer is already locked for transmission by Transfer Layer then cancellation is performed at the end of transmission cycle irrespective whether frame transmitted successfully or failed
i.e. if message is failed due to arbitration loss or any error, then message will be cancelled (no retransmission attempt) and cancellation request will be cleared. Alongwith RR0 bit will get cleared.
If message is transmitted successfully, then RR0 bit will clear and cancellation request will be cleared anyway.
Note : If internal buffer scheduling round is in progress, then cancellation consideration is postponed till it is over.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IETCS</spirit:name>
          <spirit:displayName>Interrupt Enable Tx Buffer Cancellation Request Served/Cleared Register</spirit:displayName>
          <spirit:description>Interrupt Enable Tx Buffer Cancellation Request Served/Cleared Register</spirit:description>
          <spirit:addressOffset>0x009C</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ECRS</spirit:name>
            <spirit:displayName>Tx Buffer_0 Transmission Served/Cleared Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting TXCRS bit in ISR when CR0 bit in TCS register clears.
0 - TXCRS bit in ISR will not set if  CR0 bit in TRR register clears.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>RCS0</spirit:name>
          <spirit:displayName>Rx Buffer Control Status Register0</spirit:displayName>
          <spirit:description>Rx Buffer Control Status Register0</spirit:description>
          <spirit:addressOffset>0x00B0</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>HCB</spirit:name>
            <spirit:displayName>Host Control bit for Rx Bufferi</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Active i.e. ID Field of RB buffer and corresponding Mask register are programmed by Host and this buffer can receive message. 
0 - Buffer is Inactive 
Note - Host can change this bit anytime.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSB</spirit:name>
            <spirit:displayName>Core Status bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Full i.e. core has received message in this buffer.
0 - Buffer is not Full 
Note - Host clears this bit by writing &apos;1&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.RCS0" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>RCS1</spirit:name>
          <spirit:displayName>Rx Buffer Control Status Register1</spirit:displayName>
          <spirit:description>Rx Buffer Control Status Register1</spirit:description>
          <spirit:addressOffset>0x00B4</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>HCB_1</spirit:name>
            <spirit:displayName>Host Control bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Active i.e. ID Field of RB16 buffer and corresponding Mask register are programmed by Host 
and this buffer can receive message.
0 - Buffer is Inactive 
Note:Host can change this bit anytime.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSB_1</spirit:name>
            <spirit:displayName>Core Status bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Full i.e. core has received message in this buffer.
0 - Buffer is not Full 
Note : Host clears this bit by writing &apos;1&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.RCS1" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1) and (spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_RX_MB_BUF&apos;))>16)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>RCS2</spirit:name>
          <spirit:displayName>Rx Buffer Control Status Register2</spirit:displayName>
          <spirit:description>Rx Buffer Control Status Register2</spirit:description>
          <spirit:addressOffset>0x00B8</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>HCB_2</spirit:name>
            <spirit:displayName>Host Control bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Active i.e. ID Field of RB32 buffer and corresponding Mask register are programmed by Host 
and this buffer can receive message.
0 - Buffer is Inactive 
Note:Host can change this bit anytime.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSB_2</spirit:name>
            <spirit:displayName>Core Status bit for Rx Buffer_2</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Full i.e. core has received message in this buffer.
0 - Buffer is not Full 
Note : Host clears this bit by writing &apos;1&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.RCS2" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1) and (spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_RX_MB_BUF&apos;))>32)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>IEBRF0</spirit:name>
          <spirit:displayName>Interrupt Enable Rx Buffer Full Register0</spirit:displayName>
          <spirit:description>Interrupt Enable Rx Buffer Full Register0</spirit:description>
          <spirit:addressOffset>0x00C0</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERBF</spirit:name>
            <spirit:displayName>Rx Buffer Full Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting RXBFL bit in ISR when Rx Buffer 0 becomes Full.
0 - RXBFL bit in ISR will not set if  Rx Buffer 0  becomes Full.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.IEBRF0" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>IEBRF1</spirit:name>
          <spirit:displayName>Interrupt Enable Rx Buffer Full Register1</spirit:displayName>
          <spirit:description>Interrupt Enable Rx Buffer Full Register1</spirit:description>
          <spirit:addressOffset>0x00C4</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERBF_2</spirit:name>
            <spirit:displayName>Rx Buffer Full Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting RXBFL bit in ISR when Rx Buffer 32 becomes Full.
0 - RXBFL bit in ISR will not set if  Rx Buffer 32  becomes Full.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.IEBRF1" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1) and (spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_RX_MB_BUF&apos;))>32)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>AFR</spirit:name>
          <spirit:displayName>Acceptance Filter(control) Register</spirit:displayName>
          <spirit:description>Acceptance Filter(control) Register</spirit:description>
          <spirit:addressOffset>0x00E0</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>UAF</spirit:name>
            <spirit:displayName>Use Acceptance Filter Mask pair 1</spirit:displayName>
            <spirit:description>Enables the use of acceptance filter mask pair i.
1 - Indicates Acceptance Filter Mask Register 0 (AFMR0 or M0) and Acceptance Filter ID Register 0 (AFID0 or F0) pair is used for acceptance filtering.
0 - Indicates AFMR0 and AFID0 pair is not used for acceptance filtering.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.AFR" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>FSR</spirit:name>
          <spirit:displayName>Rx FIFO Status Register</spirit:displayName>
          <spirit:description>Rx FIFO Status Register</spirit:description>
          <spirit:addressOffset>0x00E8</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RI</spirit:name>
            <spirit:displayName>Read Index</spirit:displayName>
            <spirit:description>Each time IRI bit is set, core increments read index by +1 (provided FILL level is not 0) and maintained it for Host to access 
next available message.
RI = 0x0 -> Next message read starts from location = 0x1100 (to 0x1147)
RI = 0x1 -> Next message read starts from location = 0x1148 (to 0x118F)...
RI = 0x1F -> Next message read starts from location = 0x19B8 (to 0x19FF)
RI is maintained if CEN bit is cleared.
RI gets reset to 0 if soft or hard reset is asserted.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">5</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>IRI</spirit:name>
            <spirit:displayName>Increment Read Index by 1</spirit:displayName>
            <spirit:description>With each Host writes setting this bit as 1, core increments Read index (RI field) by 1 and update fill level (i.e. decrement  by 1).
If FILL level is 0, setting this bit has no effect. Note that FILL level may remain unchanged when IRI is written if core is just finishing a successful receive and incrementing internal write index.
This bit always read as 0.
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FL</spirit:name>
            <spirit:displayName>Fill Level</spirit:displayName>
            <spirit:description>Number of stored message in Receive FIFO starting from RI index given in this register.
For example, if FL = 0x5 and RI = 0x3 then Rx FIFO has 5 messages starting from Read Index 3 (Start address 0x1190).
FL is maintained if CEN bit is cleared.
FL gets reset to 0 if soft or hard reset is asserted.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.FSR" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>WMR</spirit:name>
          <spirit:displayName>Rx FIFO Watermark Register</spirit:displayName>
          <spirit:description>Rx FIFO Watermark Register</spirit:description>
          <spirit:addressOffset>0x00EC</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0xf</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RXFWM</spirit:name>
            <spirit:displayName>Rx FIFO Full Watermark</spirit:displayName>
            <spirit:description>RXFIFO generates FULL interrupt based on the value programmed in this field.
User should set it within (1-31) range. 
The RX FIFO Full Watermark interrupt in ISR register continues to assert as long as the RX FIFO Fill Level is above RX FIFO Full watermark.
This field can be written to only when CEN bit in SRR is &apos;0&apos;
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">5</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.WMR" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_START</spirit:name>
          <spirit:displayName>Tx Buffer Start Address</spirit:displayName>
          <spirit:description>Tx Buffer Start Address</spirit:description>
          <spirit:addressOffset>0x0100</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_END</spirit:name>
          <spirit:displayName>Tx Buffer End Address</spirit:displayName>
          <spirit:description>Tx Buffer End Address</spirit:description>
          <spirit:addressOffset>0x09FC</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>RX_BUFFER_START</spirit:name>
          <spirit:displayName>Rx Buffer Start Address</spirit:displayName>
          <spirit:description>Rx Buffer Start Address</spirit:description>
          <spirit:addressOffset>0x1100</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_END_FIFO</spirit:name>
          <spirit:displayName>Rx Buffer End Address</spirit:displayName>
          <spirit:description>Rx Buffer End Address</spirit:description>
          <spirit:addressOffset>0x19FC</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.TX_BUFFER_END_FIFO" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_END_MB</spirit:name>
          <spirit:displayName>Rx Buffer End Address</spirit:displayName>
          <spirit:description>Rx Buffer End Address</spirit:description>
          <spirit:addressOffset>0x1E7C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_APB_LITE.REG.TX_BUFFER_END_MB" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
      </spirit:addressBlock>
    </spirit:memoryMap>
    <spirit:memoryMap>
      <spirit:name>S_AXI_LITE</spirit:name>
      <spirit:displayName>CANFD_MEM</spirit:displayName>
      <spirit:description>Memory Map for CANFD</spirit:description>
      <spirit:addressBlock>
        <spirit:name>Reg</spirit:name>
        <spirit:displayName>Reg</spirit:displayName>
        <spirit:description>Register Block</spirit:description>
        <spirit:baseAddress spirit:format="long">0</spirit:baseAddress>
        <spirit:range spirit:format="long">4096</spirit:range>
        <spirit:width spirit:format="long">32</spirit:width>
        <spirit:usage>register</spirit:usage>
        <spirit:access>read-write</spirit:access>
        <spirit:register>
          <spirit:name>SRR</spirit:name>
          <spirit:displayName>Software Reset Register</spirit:displayName>
          <spirit:description>Software Reset Register</spirit:description>
          <spirit:addressOffset>0x0000</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>SRST</spirit:name>
            <spirit:displayName>Software Reset</spirit:displayName>
            <spirit:description>The software reset bit for the core.
1 - core is reset.
If a 1 is written to this bit, all the core configuration registers (including the SRR) are reset.
Reads to this bit always return a 0.
Note - After performing soft or hard reset, wait for 8 AXI Clock cycles before initiating next AXILite transaction.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CEN</spirit:name>
            <spirit:displayName>CAN Enable</spirit:displayName>
            <spirit:description>The Enable bit for the core.
1 - The core is in Loopback, Sleep, Snoop or Normal mode depending on the LBACK, SLEEP and SNOOP bits in the MSR.
0 - The core is in the Configuration mode.
Note - If the CEN bit is changed during core operation, it is recommended to reset the core so that operations start afresh.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>MSR</spirit:name>
          <spirit:displayName>Mode Select Register</spirit:displayName>
          <spirit:description>Mode Select Register</spirit:description>
          <spirit:addressOffset>0x0004</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>SLEEP</spirit:name>
            <spirit:displayName>Sleep Mode Select/Request</spirit:displayName>
            <spirit:description>The Sleep Mode request bit.
1 - Request core to be in Sleep mode.
0 - No such request.
This bit is cleared when the core wakes up from the Sleep mode.
In order for core to enter Sleep mode, LBACK and SNOOP bits in this register should be set to ’0’.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBACK</spirit:name>
            <spirit:displayName>Loop Back Mode Select/Request</spirit:displayName>
            <spirit:description>The Loop Back Mode Request bit.
1 - Request core to be in Loop Back mode.
0 - No such request.
This bit can be written to only when CEN bit in SRR is &apos;0.&apos;
In order for core to enter LBACK mode, SLEEP and SNOOP bits in this register should be set to &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNOOP</spirit:name>
            <spirit:displayName>SNOOP Mode Select</spirit:displayName>
            <spirit:description>The Snoop Mode Request bit.
1 - Request core to be in Snoop mode.
0 - No such request.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
The user has to make sure that SNOOP mode is programmed only after system reset or software reset.
In order for core to enter Snoop mode, LBACK and SLEEP bits in this register should be set to &apos;0&apos;.
The features of Snoop mode are      Core transmits recessive bits on to CAN bus     Receives messages that are transmitted by other nodes but does not ACK. Stores received messages in RxBRAM based on programmed ID filtering.     Error counters are disabled and cleared to 0. Reads to error counter register will return zero.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BRSD</spirit:name>
            <spirit:displayName>CANFD Bit Rate Switch Disable Override</spirit:displayName>
            <spirit:description>1 - Makes core transmit CANFD frames only in nominal bit rate (by overriding Tx Message element setting).
0 - Makes core transmit CANFD frames as per BRS bit in TX Message element.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DAR</spirit:name>
            <spirit:displayName>Disable Auto Retransmission</spirit:displayName>
            <spirit:description>1 - Disable Auto retransmission to provide single shot transmission.
0 - Auto retransmission enabled.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DPEE</spirit:name>
            <spirit:displayName>Disable Protocol Exception Event detection/generation</spirit:displayName>
            <spirit:description>1 - Disable Protocol Exception Event detection/generation by CANFD receiver if &quot;res&quot; bit in CANFD frame is detected as 1. 
In this case, CANFD receiver will generate Form error.
0 - PEE detection/generation is enabled.  If CANFD receiver detects &quot;res&quot; bit as 1, it will go to Bus Integration
state (PEE_config) and waits for Bus Idle condition (11 consecutive nominal recessive bits). Error counter remains unchanged.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SBR</spirit:name>
            <spirit:displayName>Start Bus-Off Recovery Request</spirit:displayName>
            <spirit:description>1 - Start Bus-off Recovery Request.
0 - No such request.
Node stays in Bus-off state until SBR bit is set to &apos;1&apos; (provided ABR bit in this register is not set).
This bit can be written only when node is in Bus-off state. 
This bit auto clears after node completes the bus-off recovery or leave bus-off state due to hard/soft reset or CEN de-assertion. 
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ABR</spirit:name>
            <spirit:displayName>Auto Bus-Off Recovery Request</spirit:displayName>
            <spirit:description>1 - Auto Bus-off Recovery Request.
0 - No such request.
If this bit is set, node do auto bus-off recovery irrespective of SBR setting in this register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>BRPR</spirit:name>
          <spirit:displayName>Nominal Baud Rate Prescalar Register</spirit:displayName>
          <spirit:description>Nominal Baud Rate Prescalar Register</spirit:description>
          <spirit:addressOffset>0x0008</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>BRP</spirit:name>
            <spirit:displayName>Nomunal Baud Rate Prescalar</spirit:displayName>
            <spirit:description>These bits indicate the prescaler value. 
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>BTR</spirit:name>
          <spirit:displayName>Nominal Bit Timing Register</spirit:displayName>
          <spirit:description>Nominal Bit Timing Register</spirit:description>
          <spirit:addressOffset>0x000C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TS1</spirit:name>
            <spirit:displayName>Timing Segement1</spirit:displayName>
            <spirit:description>Indicates the Sum of Propagation Segment and Phase Segment 1 as specified in the standard for Nominal Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TS2</spirit:name>
            <spirit:displayName>Timing Segement2</spirit:displayName>
            <spirit:description>Indicates the Phase Segment 2 as specified in the CANFD standard for Nominal Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">4</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SJW</spirit:name>
            <spirit:displayName>Synchronization Jump Width</spirit:displayName>
            <spirit:description>Indicates the Synchronization Jump Width as specified in the CANFD standard for Nominal Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">4</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ECR</spirit:name>
          <spirit:displayName>Error Count Register</spirit:displayName>
          <spirit:description>Error Count Register</spirit:description>
          <spirit:addressOffset>0x0010</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TEC</spirit:name>
            <spirit:displayName>Transmit Error Count</spirit:displayName>
            <spirit:description>Indicates the value of Transmit Error Counter.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>REC</spirit:name>
            <spirit:displayName>Recieve Error Count</spirit:displayName>
            <spirit:description>Indicates the value of Recieve Error Counter.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ESR</spirit:name>
          <spirit:displayName>Error Status Register</spirit:displayName>
          <spirit:description>Error Status Register</spirit:description>
          <spirit:addressOffset>0x0014</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CRCER</spirit:name>
            <spirit:displayName>CRC Error</spirit:displayName>
            <spirit:description>Indicates a CRC error has occurred.
1 - Indicates a CRC error has occurred.
0 - Indicates a CRC error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FMER</spirit:name>
            <spirit:displayName>Form Error</spirit:displayName>
            <spirit:description>Indicates an error in one of the fixed form fields in the message frame.
1 - Indicates a form error has occurred.
0 - Indicates a form error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>STER</spirit:name>
            <spirit:displayName>Stuff Error</spirit:displayName>
            <spirit:description>Indicates an error if there is a stuffing violation.
1 - Indicates a stuff error has occurred.
0 - Indicates a stuff error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BERR</spirit:name>
            <spirit:displayName>Bit Error</spirit:displayName>
            <spirit:description>Indicates the received bit is not the same as the transmitted bit during bus communication.
1 - Indicates a bit error has occurred.
0 - Indicates a bit error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ACKER</spirit:name>
            <spirit:displayName>ACK Error</spirit:displayName>
            <spirit:description>Indicates an acknowledgement error.
1 - Indicates an acknowledgement error has occurred.
0 - Indicates an acknowledgement error has not occurred on the bus after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_CRCER</spirit:name>
            <spirit:displayName>CRC Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates CRC error occurred in Data  Phase (Fast) data rate
0 - Indicates CRC error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_FMER</spirit:name>
            <spirit:displayName>Form Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates form error occurred in Data Phase (Fast) data rate
0 - Indicates form error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_STER</spirit:name>
            <spirit:displayName>Stuff Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates stuff error occurred in Data Phase (Fast) data rate
0 - Indicates stuff error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>F_BERR</spirit:name>
            <spirit:displayName>Bit Error Status in Fast Data Rate</spirit:displayName>
            <spirit:description>1 - Indicates bit error occurred in Data Phase (Fast) data rate.
0 - Indicates bit error has not occurred in Data Phase (Fast) data rate after the last write to this bit.
If this bit is set, writing a 1 clears it.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToToggle</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>SR</spirit:name>
          <spirit:displayName>Status Register</spirit:displayName>
          <spirit:description>Status Register</spirit:description>
          <spirit:addressOffset>0x0018</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CONFIG</spirit:name>
            <spirit:displayName>Configuration Mode Indicator</spirit:displayName>
            <spirit:description>Indicates the core is in Configuration mode.
1 - Indicates the core is in Configuration mode.
0 - Indicates the core is not in Configuration mode.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>LBACK</spirit:name>
            <spirit:displayName>Loop Back Mode</spirit:displayName>
            <spirit:description>Indicates the core is in Loopback mode.
1 - Indicates the core is in Loopback mode.
0 - Indicates the core is not in Loopback mode.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLEEP</spirit:name>
            <spirit:displayName>Sleep Mode</spirit:displayName>
            <spirit:description>Indicates the core is in Sleep mode.
1 - Indicates the core is in Sleep mode.
0 - Indicates the core is not in Sleep mode.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>NORMAL</spirit:name>
            <spirit:displayName>Normal Mode</spirit:displayName>
            <spirit:description>Indicates the core is in Normal Mode.
1 - Indicates the core is in Normal Mode.
0 - Indicates the core is not in Normal mode.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BIDLE</spirit:name>
            <spirit:displayName>Bus Idle</spirit:displayName>
            <spirit:description>Indicates the CAN bus status.
1 - Indicates no bus communication is taking place.
0 - Indicates the core is either in Configuration mode or the bus is busy.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BBSY</spirit:name>
            <spirit:displayName>BBSY</spirit:displayName>
            <spirit:description>Indicates the CAN bus status.
1 - Indicates that the core is either receiving a message or transmitting a message.
0 - Indicates that the core is either in Configuration mode or the bus is idle.
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERRWRN</spirit:name>
            <spirit:displayName>ERRWRN</spirit:displayName>
            <spirit:description>Indicates that either the Transmit Error counter or the Receive Error counter has exceeded a value of 96.
1 - One or more error counters have a value 96.
0 - Neither of the error counters has a value 96.
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ESTAT</spirit:name>
            <spirit:displayName>Error Status</spirit:displayName>
            <spirit:description>Indicates the error status of the core.
00 - Indicates Configuration Mode (CONFIG = 1). Error State is undefined.
01 - Indicates Error Active State.
11 - Indicates Error Passive State.
10 - Indicates Bus Off State.
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">2</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PEE CONFIG</spirit:name>
            <spirit:displayName>PEE Mode Indicator</spirit:displayName>
            <spirit:description>1 - Indicates the core is in PEE Mode (Bus Integration State).
When this bit is set then BBSY and NORMAL status bits in SR register does not mean anything.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BSFR_CONFIG</spirit:name>
            <spirit:displayName>Bus-off Recovery Mode Indicator</spirit:displayName>
            <spirit:description>1 - Indicates the core is in Bus-off Recovery Mode (Bus Integration State)
When this bit is set then BBSY and NORMAL status bits in SR register does not mean anything.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>NISO</spirit:name>
            <spirit:displayName>Non-ISO Core</spirit:displayName>
            <spirit:description>1 - Core is NISO (generated with C_IS_NISO = 1)
0 - Core is ISO (generated with C_IS_NISO = 0)
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SNOOP</spirit:name>
            <spirit:displayName>SNOOP Mode</spirit:displayName>
            <spirit:description>1 - Indicates controller is in Snoop mode provided Normal mode bit is also set in this register.
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDCV</spirit:name>
            <spirit:displayName>Transceiver Delay Compensation value</spirit:displayName>
            <spirit:description>This field gives the position of secondary sample point (defined as sum of TDCOFF and measured delay  
for EDL to r0 fall edge from TX to RX) in CAN clocks. 
This field is for status purpose.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">7</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ISR</spirit:name>
          <spirit:displayName>Interrupt Status Register</spirit:displayName>
          <spirit:description>Interrupt Status Register</spirit:description>
          <spirit:addressOffset>0x001C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ARBLST</spirit:name>
            <spirit:displayName>Arbitration Lost Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that arbitration was lost during message transmission.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXOK</spirit:name>
            <spirit:displayName>Transmission Successful Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that a message was transmitted successfully.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PEE</spirit:name>
            <spirit:displayName>Protocol Exception Event Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core (CANFD) has detected PEE event.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BSFRD</spirit:name>
            <spirit:displayName>Bus-Off Recovery Done Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core recovered from Bus Off state.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXOK</spirit:name>
            <spirit:displayName>New Message Recieved Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that a message was received successfully and stored into the RX FIFO.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXFOFLW</spirit:name>
            <spirit:displayName>Rx  FIFO Overflow interrupt (FIFO mode)</spirit:displayName>
            <spirit:description>1 - Indicates that a message has been lost. This condition occurs when a new message is being received and the Receive FIFO is Full.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR only valid in FIFO Mode.
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERROR</spirit:name>
            <spirit:displayName>Error Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that an error occurred during message transmission or reception.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BSOFF</spirit:name>
            <spirit:displayName>Bus Off Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core entered the Bus Off state.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SLP</spirit:name>
            <spirit:displayName>Sleep Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the CAN core entered Sleep mode.
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>WKUP</spirit:name>
            <spirit:displayName>Wakeup Interrupt</spirit:displayName>
            <spirit:description>1 - indicates that the core entered Normal mode from Sleep Mode
This bit can be cleared by writing to the ICR.
This bit is also cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXFWMFLL</spirit:name>
            <spirit:displayName>Rx FIFO Watermark Full interrupt (FIFO mode)</spirit:displayName>
            <spirit:description>1 - Indicates that Rx FIFO is full based on watermark programming.
The interrupt continues to assert as long as the RX FIFO count is above RX FIFO Full watermark.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXRRS</spirit:name>
            <spirit:displayName>Tx Buffer Ready Request Served Interrupt</spirit:displayName>
            <spirit:description>1 - Indicates that a Buffer Ready request was cleared.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TXCRS</spirit:name>
            <spirit:displayName>Tx Cancellation Request Served Interrupt</spirit:displayName>
            <spirit:description>1 - Indicates that a Cancellation request was cleared.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXRBF</spirit:name>
            <spirit:displayName>Rx Buffer Bull Interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>1 - Indicates that a receive buffer has received a message and become full.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXBOFLW</spirit:name>
            <spirit:displayName>Rx Buffer Overflow interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>1 - Indicates that a message has been lost due to buffer condition. Buffer index is captured in RXBOFLW_BI field.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXMNF</spirit:name>
            <spirit:displayName>Rx Match Not Finished</spirit:displayName>
            <spirit:description>1 - Indicates that Match process did not finish until the start of 6th Bit in EOF field and frame was discarded.
This bit can be cleared by writing to the respective bit in ICR.
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXLRM_BI</spirit:name>
            <spirit:displayName>Rx Buffer Index for Last Received  message (Mailbox mode)</spirit:displayName>
            <spirit:description>Gives Rx Buffer index for last received message.
This field has meaning only if RXOK bit is set in this register.
This field is cleared at hard/soft reset or when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RXBOFLW_BI</spirit:name>
            <spirit:displayName>Rx Buffer index for Overflow interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>Gives Rx Buffer index for which overflow event is generated.
This field is automatically cleared to default if RXBOFLW bit is cleared in this register.
In case more than one overflow event happens (before host could clear RXBOFLW), RXBOFLW_BI will show overflow index for the last event.
This field has meaning only if Overflow interrupt RXBOFLW bit is set.
This field is also cleared at hard/soft reset or when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>24</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IER</spirit:name>
          <spirit:displayName>Interrupt Enable Register</spirit:displayName>
          <spirit:description>Interrupt Enable Register</spirit:description>
          <spirit:addressOffset>0x0020</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>EARBLOST</spirit:name>
            <spirit:displayName>Arbitration Lost Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if ARBLST bit in ISR is set.
0 - Disable interrupt generation if ARBLST bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ETXOK</spirit:name>
            <spirit:displayName>Transmission successful interrupt enable</spirit:displayName>
            <spirit:description>1 = Enable interrupt generation if TXOK bit in ISR is set.
0 = Disable interrupt generation if TXOK bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EPEE</spirit:name>
            <spirit:displayName>Protocol Exception Event interrupt enable</spirit:displayName>
            <spirit:description>Protocol Exception Event interrupt enable
1 - Enable interrupt generation if PEE bit in ISR is set.
0 - Disable interrupt generation if PEE bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EBSFRD</spirit:name>
            <spirit:displayName>Bus-off Recovery Done interrupt enable</spirit:displayName>
            <spirit:description>Bus-off Recovery Done interrupt enable
1 - Enable interrupt generation if BSFRD bit in ISR is set.
0 - Disable interrupt generation if BSFRD bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXOK</spirit:name>
            <spirit:displayName>New message Received interrupt enable</spirit:displayName>
            <spirit:description>New message Received interrupt enable
1 - Enable interrupt generation if RXOK bit in ISR is set.
0 - Disable interrupt generation if RXOK bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERFXOFLW</spirit:name>
            <spirit:displayName>Rx FIFO Overflow interrupt Enable (FIFO Mode)</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RFXOFLW bit in ISR is set.
0 - Disable interrupt generation if RFXOFLW bit in ISR is set.
Only valid in FIFO Mode
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EERROR</spirit:name>
            <spirit:displayName>Error interrupt enable</spirit:displayName>
            <spirit:description>Error interrupt enable
1 - Enable interrupt generation if ERROR bit in ISR is set.
0 - Disable interrupt generation if ERROR bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EBSOFF</spirit:name>
            <spirit:displayName>Bus OFF interrupt enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if BSOFF bit in ISR is set.
0 - Disable interrupt generation if BSOFF bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ESLP</spirit:name>
            <spirit:displayName>Sleep interrupt enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if SLP bit in ISR is set.
0 - Disable interrupt generation if SLP bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EWKUP</spirit:name>
            <spirit:displayName>Wakeup interrupt enable</spirit:displayName>
            <spirit:description>Wakeup interrupt enable
1 - Enable interrupt generation if WKUP bit in ISR is set.
0 - Disable interrupt generation if WKUP bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXFWMFLL</spirit:name>
            <spirit:displayName>Rx  FIFO Watermark Full interrupt Enable (FIFO Mode)</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RXFWMFLL bit in ISR is set.
0 - Disable interrupt generation if RXFWMFLL bit in ISR is set.
Only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ETXRRS</spirit:name>
            <spirit:displayName>Tx Buffer Ready Request Served Interrupt Enable</spirit:displayName>
            <spirit:description>Tx Buffer Ready Request Served Interrupt Enable
1 - Enable interrupt generation if TXRRS bit in ISR is set.
0 - Disable interrupt generation if TXRRS bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ETXCRS</spirit:name>
            <spirit:displayName>Tx Cancellation Request Served Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if TXCRS bit in ISR is set.
0 - Disable interrupt generation if TXCRS bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXRBF</spirit:name>
            <spirit:displayName>Rx Buffer Bull Interrupt Enable (Mailbox mode)</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RXRBF bit in ISR is set.
0 - Disable interrupt generation if RXRBF bit in ISR is set.
Only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXBOFLW</spirit:name>
            <spirit:displayName>Rx Buffer Overflow interrupt Enable (Mailbox mode)</spirit:displayName>
            <spirit:description>1 = Enable interrupt generation if RXBOFLW bit in ISR is set.
0 = Disable interrupt generation if RXBOFLW bit in ISR is set.
Only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERXMNF</spirit:name>
            <spirit:displayName>Rx Match Not Finished interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enable interrupt generation if RXMNF bit in ISR is set.
0 - Disable interrupt generation if RXMNF bit in ISR is set.
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ICR</spirit:name>
          <spirit:displayName>Interrupt Clear Register</spirit:displayName>
          <spirit:description>Interrupt Clear Register</spirit:description>
          <spirit:addressOffset>0x0024</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CARBLOST</spirit:name>
            <spirit:displayName>Clear Arbitration lost interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTXOK</spirit:name>
            <spirit:displayName>Clear Transmission successful interrupt</spirit:displayName>
            <spirit:description>1 - Clear Transmission successful interrupt.
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CPEE</spirit:name>
            <spirit:displayName>Clear Protocol Exception Event interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBSFRD</spirit:name>
            <spirit:displayName>Clear Bus-off Recovery Done interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXOK</spirit:name>
            <spirit:displayName>Clear New message Received interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRFXOFLW</spirit:name>
            <spirit:displayName>Clear Rx FIFO Overflow interrupt (FIFO Mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
only valid in FIFO Mode
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CERROR</spirit:name>
            <spirit:displayName>Clear Error interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CBSOFF</spirit:name>
            <spirit:displayName>Clear Bus OFF interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSLP</spirit:name>
            <spirit:displayName>Clear Sleep interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CWKUP</spirit:name>
            <spirit:displayName>Clear Wakeup interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXFWMFLL</spirit:name>
            <spirit:displayName>Clear Rx  FIFO Watermark Full interrupt (FIFO Mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
Only valid in FIFO Mode
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTXRRS</spirit:name>
            <spirit:displayName>Clear Tx Buffer Ready Request Served Interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTXCRS</spirit:name>
            <spirit:displayName>Clear Tx Cancellation Request Served Interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXRBF</spirit:name>
            <spirit:displayName>Clear Rx Buffer Full Interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXBOFLW</spirit:name>
            <spirit:displayName>Clear Rx Buffer Overflow interrupt (Mailbox mode)</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
only valid in MailBox Mode
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CRXMNF</spirit:name>
            <spirit:displayName>Clear Rx Match Not Finished interrupt</spirit:displayName>
            <spirit:description>Writing a 1 to this bit clears the respective bit in the ISR. Reads always 0.
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TSR</spirit:name>
          <spirit:displayName>Time Stamp Register</spirit:displayName>
          <spirit:description>Time Stamp Register</spirit:description>
          <spirit:addressOffset>0x0028</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTS</spirit:name>
            <spirit:displayName>Clear TimeStamp Counter</spirit:displayName>
            <spirit:description>Internal free running counter is cleared to 0 when CTS=1. 
This bit only needs to be written once with a &apos;1&apos; to clear the counter. 
The bit will always read as &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TIMESTAMP_CNT</spirit:name>
            <spirit:displayName>Time Stamp Counter Value</spirit:displayName>
            <spirit:description>This Status field gives running value of the time stamp counter. 
This  field is cleared when a 0 is written to the CEN bit in the SRR.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>DPBRPR</spirit:name>
          <spirit:displayName>Data Phase Baud Rate Prescalar Register</spirit:displayName>
          <spirit:description>Data Phase Baud Rate Prescalar Register</spirit:description>
          <spirit:addressOffset>0x0088</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>DP_BRP</spirit:name>
            <spirit:displayName>Data Phase Baud Rate Prescaler</spirit:displayName>
            <spirit:description>These bits indicate the prescaler value for Data Bit Timing as specified in the CANFD standard.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">8</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDCOFF</spirit:name>
            <spirit:displayName>Transceiver Delay Compensation Offset</spirit:displayName>
            <spirit:description>This offset is specified in CAN clock cycles and is added to the measured transnitter delay to place the Secondary Sample Point (SSP) at appropriate position (for ex. set this to half data bit time in terms of CAN clock cycles to place SSP in the middle of the data bit).
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">5</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TDC</spirit:name>
            <spirit:displayName>Transceiver Delay Compensation(TDC) Enable</spirit:displayName>
            <spirit:description>1 - Enables TDC function as specified in the CANFD standard
0 - TDC is disabled
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>DPBTR</spirit:name>
          <spirit:displayName>Data Phase Bit Timing Register</spirit:displayName>
          <spirit:description>Data Phase Bit Timing Register</spirit:description>
          <spirit:addressOffset>0x008C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>DP_TS1</spirit:name>
            <spirit:displayName>Data Phase Time Segment1</spirit:displayName>
            <spirit:description>Indicates the Sum of Propagation Segment and Phase Segment 1 as specified in the CANFD standard for Data Bit Timing.
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">4</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP_TS2</spirit:name>
            <spirit:displayName>Data Phase Time Segment2</spirit:displayName>
            <spirit:description>Indicates the Phase Segment 2 as specified in the CANFD standard for Data Bit Timing. 
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">3</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DP_SJW</spirit:name>
            <spirit:displayName>Data Phase Synchronization Jump Width</spirit:displayName>
            <spirit:description>Indicates the Synchronization Jump Width as specified in the CANFD standard for Data Bit Timing. 
The actual value is one more than the value written to the register.
This bit can be written only when CEN bit in SRR is &apos;0&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">3</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TRR</spirit:name>
          <spirit:displayName>Tx Buffer Ready Request Register</spirit:displayName>
          <spirit:description>Tx Buffer Ready Request Register</spirit:description>
          <spirit:addressOffset>0x0090</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RR</spirit:name>
            <spirit:displayName>Tx Buffer Ready Request</spirit:displayName>
            <spirit:description>This is control bit corresponds to TBi message in Tx BRAM.
Host writes 1 to indicate buffer is ready for transmission. Core clears this bit when   Buffer transmission is completed on CAN Bus or   If core is in DAR mode, then after one transmission attempt on CAN bus [either successful or unsuccessful (i.e. arbitration lost or error)] or   If message is cancelled due to cancellation request or   Any combination of Above Host writes are ignored when this bit is 1.
Note - This register remains in reset when SNOOP mode is enabled.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IETRS</spirit:name>
          <spirit:displayName>Interrupt Enable Tx Buffer Ready Request Served/Cleared Register</spirit:displayName>
          <spirit:description>Interrupt Enable Tx Buffer Ready Request Served/Cleared Register</spirit:description>
          <spirit:addressOffset>0x0094</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERRS</spirit:name>
            <spirit:displayName>Tx Buffer_i Ready Req Served/Cleared Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting TXRRS bit in ISR when RRi bit in TRR register clears.
0 - TXRRS bit in ISR will not set if  RRi bit in TRR register clears.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TCR</spirit:name>
          <spirit:displayName>Tx Buffer Cancellation Request Register</spirit:displayName>
          <spirit:description>Tx Buffer Cancellation Request Register</spirit:description>
          <spirit:addressOffset>0x0098</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CR</spirit:name>
            <spirit:displayName>Tx Buffer_0 Cancel Request</spirit:displayName>
            <spirit:description>This is cancellation request bit corresponds to RR0 bit in TRR register.
Host writes 1 to indicate cancellation request of corresponding buffer ready request (i.e. RR0 bit in TRR register). Core clears this bit when cancellation request is completed. 
Host writes to this bit are ignored if CR0 is 1 or RR0 bit of TRR register is 0.
If the buffer is already locked for transmission by Transfer Layer then cancellation is performed at the end of transmission cycle irrespective whether frame transmitted successfully or failed
i.e. if message is failed due to arbitration loss or any error, then message will be cancelled (no retransmission attempt) and cancellation request will be cleared. Alongwith RR0 bit will get cleared.
If message is transmitted successfully, then RR0 bit will clear and cancellation request will be cleared anyway.
Note : If internal buffer scheduling round is in progress, then cancellation consideration is postponed till it is over.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IETCS</spirit:name>
          <spirit:displayName>Interrupt Enable Tx Buffer Cancellation Request Served/Cleared Register</spirit:displayName>
          <spirit:description>Interrupt Enable Tx Buffer Cancellation Request Served/Cleared Register</spirit:description>
          <spirit:addressOffset>0x009C</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ECRS</spirit:name>
            <spirit:displayName>Tx Buffer_0 Transmission Served/Cleared Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting TXCRS bit in ISR when CR0 bit in TCS register clears.
0 - TXCRS bit in ISR will not set if  CR0 bit in TRR register clears.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>RCS0</spirit:name>
          <spirit:displayName>Rx Buffer Control Status Register0</spirit:displayName>
          <spirit:description>Rx Buffer Control Status Register0</spirit:description>
          <spirit:addressOffset>0x00B0</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>HCB</spirit:name>
            <spirit:displayName>Host Control bit for Rx Bufferi</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Active i.e. ID Field of RB buffer and corresponding Mask register are programmed by Host and this buffer can receive message. 
0 - Buffer is Inactive 
Note - Host can change this bit anytime.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSB</spirit:name>
            <spirit:displayName>Core Status bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Full i.e. core has received message in this buffer.
0 - Buffer is not Full 
Note - Host clears this bit by writing &apos;1&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.RCS0" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>RCS1</spirit:name>
          <spirit:displayName>Rx Buffer Control Status Register1</spirit:displayName>
          <spirit:description>Rx Buffer Control Status Register1</spirit:description>
          <spirit:addressOffset>0x00B4</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>HCB_1</spirit:name>
            <spirit:displayName>Host Control bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Active i.e. ID Field of RB16 buffer and corresponding Mask register are programmed by Host 
and this buffer can receive message.
0 - Buffer is Inactive 
Note:Host can change this bit anytime.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSB_1</spirit:name>
            <spirit:displayName>Core Status bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Full i.e. core has received message in this buffer.
0 - Buffer is not Full 
Note : Host clears this bit by writing &apos;1&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.RCS1" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1) and (spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_RX_MB_BUF&apos;))>16)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>RCS2</spirit:name>
          <spirit:displayName>Rx Buffer Control Status Register2</spirit:displayName>
          <spirit:description>Rx Buffer Control Status Register2</spirit:description>
          <spirit:addressOffset>0x00B8</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>HCB_2</spirit:name>
            <spirit:displayName>Host Control bit for Rx Buffer</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Active i.e. ID Field of RB32 buffer and corresponding Mask register are programmed by Host 
and this buffer can receive message.
0 - Buffer is Inactive 
Note:Host can change this bit anytime.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CSB_2</spirit:name>
            <spirit:displayName>Core Status bit for Rx Buffer_2</spirit:displayName>
            <spirit:description>1 - Indicates Buffer is Full i.e. core has received message in this buffer.
0 - Buffer is not Full 
Note : Host clears this bit by writing &apos;1&apos;.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.RCS2" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1) and (spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_RX_MB_BUF&apos;))>32)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>IEBRF0</spirit:name>
          <spirit:displayName>Interrupt Enable Rx Buffer Full Register0</spirit:displayName>
          <spirit:description>Interrupt Enable Rx Buffer Full Register0</spirit:description>
          <spirit:addressOffset>0x00C0</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERBF</spirit:name>
            <spirit:displayName>Rx Buffer Full Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting RXBFL bit in ISR when Rx Buffer 0 becomes Full.
0 - RXBFL bit in ISR will not set if  Rx Buffer 0  becomes Full.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.IEBRF0" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>IEBRF1</spirit:name>
          <spirit:displayName>Interrupt Enable Rx Buffer Full Register1</spirit:displayName>
          <spirit:description>Interrupt Enable Rx Buffer Full Register1</spirit:description>
          <spirit:addressOffset>0x00C4</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERBF_2</spirit:name>
            <spirit:displayName>Rx Buffer Full Interrupt Enable</spirit:displayName>
            <spirit:description>1 - Enables setting RXBFL bit in ISR when Rx Buffer 32 becomes Full.
0 - RXBFL bit in ISR will not set if  Rx Buffer 32  becomes Full.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">16</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.IEBRF1" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1) and (spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_RX_MB_BUF&apos;))>32)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>AFR</spirit:name>
          <spirit:displayName>Acceptance Filter(control) Register</spirit:displayName>
          <spirit:description>Acceptance Filter(control) Register</spirit:description>
          <spirit:addressOffset>0x00E0</spirit:addressOffset>
          <spirit:size spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>UAF</spirit:name>
            <spirit:displayName>Use Acceptance Filter Mask pair 1</spirit:displayName>
            <spirit:description>Enables the use of acceptance filter mask pair i.
1 - Indicates Acceptance Filter Mask Register 0 (AFMR0 or M0) and Acceptance Filter ID Register 0 (AFID0 or F0) pair is used for acceptance filtering.
0 - Indicates AFMR0 and AFID0 pair is not used for acceptance filtering.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.NUM_OF_TX_BUF&apos;)))">32</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.AFR" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>FSR</spirit:name>
          <spirit:displayName>Rx FIFO Status Register</spirit:displayName>
          <spirit:description>Rx FIFO Status Register</spirit:description>
          <spirit:addressOffset>0x00E8</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RI</spirit:name>
            <spirit:displayName>Read Index</spirit:displayName>
            <spirit:description>Each time IRI bit is set, core increments read index by +1 (provided FILL level is not 0) and maintained it for Host to access 
next available message.
RI = 0x0 -> Next message read starts from location = 0x1100 (to 0x1147)
RI = 0x1 -> Next message read starts from location = 0x1148 (to 0x118F)...
RI = 0x1F -> Next message read starts from location = 0x19B8 (to 0x19FF)
RI is maintained if CEN bit is cleared.
RI gets reset to 0 if soft or hard reset is asserted.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">5</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>IRI</spirit:name>
            <spirit:displayName>Increment Read Index by 1</spirit:displayName>
            <spirit:description>With each Host writes setting this bit as 1, core increments Read index (RI field) by 1 and update fill level (i.e. decrement  by 1).
If FILL level is 0, setting this bit has no effect. Note that FILL level may remain unchanged when IRI is written if core is just finishing a successful receive and incrementing internal write index.
This bit always read as 0.
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">1</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FL</spirit:name>
            <spirit:displayName>Fill Level</spirit:displayName>
            <spirit:description>Number of stored message in Receive FIFO starting from RI index given in this register.
For example, if FL = 0x5 and RI = 0x3 then Rx FIFO has 5 messages starting from Read Index 3 (Start address 0x1190).
FL is maintained if CEN bit is cleared.
FL gets reset to 0 if soft or hard reset is asserted.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">6</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.FSR" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>WMR</spirit:name>
          <spirit:displayName>Rx FIFO Watermark Register</spirit:displayName>
          <spirit:description>Rx FIFO Watermark Register</spirit:description>
          <spirit:addressOffset>0x00EC</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0xf</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RXFWM</spirit:name>
            <spirit:displayName>Rx FIFO Full Watermark</spirit:displayName>
            <spirit:description>RXFIFO generates FULL interrupt based on the value programmed in this field.
User should set it within (1-31) range. 
The RX FIFO Full Watermark interrupt in ISR register continues to assert as long as the RX FIFO Fill Level is above RX FIFO Full watermark.
This field can be written to only when CEN bit in SRR is &apos;0&apos;
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth spirit:format="long">5</spirit:bitWidth>
            <spirit:volatile>true</spirit:volatile>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.WMR" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_START</spirit:name>
          <spirit:displayName>Tx Buffer Start Address</spirit:displayName>
          <spirit:description>Tx Buffer Start Address</spirit:description>
          <spirit:addressOffset>0x0100</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_END</spirit:name>
          <spirit:displayName>Tx Buffer End Address</spirit:displayName>
          <spirit:description>Tx Buffer End Address</spirit:description>
          <spirit:addressOffset>0x09FC</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>RX_BUFFER_START</spirit:name>
          <spirit:displayName>Rx Buffer Start Address</spirit:displayName>
          <spirit:description>Rx Buffer Start Address</spirit:description>
          <spirit:addressOffset>0x1100</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_END_FIFO</spirit:name>
          <spirit:displayName>Rx Buffer End Address</spirit:displayName>
          <spirit:description>Rx Buffer End Address</spirit:description>
          <spirit:addressOffset>0x19FC</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.TX_BUFFER_END_FIFO" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=0)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TX_BUFFER_END_MB</spirit:name>
          <spirit:displayName>Rx Buffer End Address</spirit:displayName>
          <spirit:description>Rx Buffer End Address</spirit:description>
          <spirit:addressOffset>0x1E7C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:volatile>true</spirit:volatile>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI_LITE.REG.TX_BUFFER_END_MB" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.RX_MODE&apos;))=1)">false</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
      </spirit:addressBlock>
    </spirit:memoryMap>
  </spirit:memoryMaps>
  <spirit:model>
    <spirit:views>
      <spirit:view>
        <spirit:name>xilinx_verilogsynthesis</spirit:name>
        <spirit:displayName>Verilog Synthesis</spirit:displayName>
        <spirit:envIdentifier>verilogSource:vivado.xilinx.com:synthesis</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>canfd_v2_0_1</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogsynthesis_xilinx_com_ip_blk_mem_gen_8_4__ref_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogsynthesis_xilinx_com_ip_lib_bmg_1_0__ref_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogsynthesis_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>GENtimestamp</spirit:name>
            <spirit:value>Thu Jul 29 15:46:46 UTC 2021</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductCRC</spirit:name>
            <spirit:value>9:2b678b90</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductLicenses</spirit:name>
            <spirit:value>canfd@2018.11(SOURCE)</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_synthesisconstraints</spirit:name>
        <spirit:displayName>Synthesis Constraints</spirit:displayName>
        <spirit:envIdentifier>:vivado.xilinx.com:synthesis.constraints</spirit:envIdentifier>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_synthesisconstraints_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>GENtimestamp</spirit:name>
            <spirit:value>Thu Jul 29 15:46:46 UTC 2021</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductCRC</spirit:name>
            <spirit:value>9:2b678b90</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductLicenses</spirit:name>
            <spirit:value>canfd@2018.11(SOURCE)</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_verilogsynthesiswrapper</spirit:name>
        <spirit:displayName>Verilog Synthesis Wrapper</spirit:displayName>
        <spirit:envIdentifier>verilogSource:vivado.xilinx.com:synthesis.wrapper</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>Main_Card_canfd_1_0</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogsynthesiswrapper_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>GENtimestamp</spirit:name>
            <spirit:value>Thu Jul 29 15:46:46 UTC 2021</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductCRC</spirit:name>
            <spirit:value>9:2b678b90</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductLicenses</spirit:name>
            <spirit:value>canfd@2018.11(SOURCE)</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_verilogbehavioralsimulation</spirit:name>
        <spirit:displayName>Verilog Simulation</spirit:displayName>
        <spirit:envIdentifier>verilogSource:vivado.xilinx.com:simulation</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>canfd_v2_0_1</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogbehavioralsimulation_xilinx_com_ip_blk_mem_gen_8_4__ref_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogbehavioralsimulation_xilinx_com_ip_lib_bmg_1_0__ref_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogbehavioralsimulation_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>GENtimestamp</spirit:name>
            <spirit:value>Thu Jul 29 15:46:46 UTC 2021</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductCRC</spirit:name>
            <spirit:value>9:e6b31e2d</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductLicenses</spirit:name>
            <spirit:value>canfd@2018.11(SOURCE)</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_verilogsimulationwrapper</spirit:name>
        <spirit:displayName>Verilog Simulation Wrapper</spirit:displayName>
        <spirit:envIdentifier>verilogSource:vivado.xilinx.com:simulation.wrapper</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>Main_Card_canfd_1_0</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogsimulationwrapper_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>GENtimestamp</spirit:name>
            <spirit:value>Thu Jul 29 15:46:46 UTC 2021</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductCRC</spirit:name>
            <spirit:value>9:e6b31e2d</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductLicenses</spirit:name>
            <spirit:value>canfd@2018.11(SOURCE)</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_externalfiles</spirit:name>
        <spirit:displayName>External Files</spirit:displayName>
        <spirit:envIdentifier>:vivado.xilinx.com:external.files</spirit:envIdentifier>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_externalfiles_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>GENtimestamp</spirit:name>
            <spirit:value>Thu Jul 29 15:50:57 UTC 2021</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductCRC</spirit:name>
            <spirit:value>9:2b678b90</spirit:value>
          </spirit:parameter>
          <spirit:parameter>
            <spirit:name>outputProductLicenses</spirit:name>
            <spirit:value>canfd@2018.11(SOURCE)</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
    </spirit:views>
    <spirit:ports>
      <spirit:port>
        <spirit:name>can_clk</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>can_clk_x2</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>can_phy_tx</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>can_phy_rx</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ip2bus_intrevent</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_pclk</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
          <spirit:driver>
            <spirit:defaultValue spirit:format="long">0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PORT_ENABLEMENT.apb_pclk" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=1)">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_resetn</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
          <spirit:driver>
            <spirit:defaultValue spirit:format="long">1</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PORT_ENABLEMENT.apb_resetn" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=1)">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_pwdata</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_DATA_WIDTH&apos;)) - 1)">31</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_pwdata">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_pwrite</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_pwrite">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_paddr</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_ADDR_WIDTH&apos;)) - 1)">14</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_paddr">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_psel</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_psel">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_penable</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_penable">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_prdata</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_DATA_WIDTH&apos;)) - 1)">31</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_prdata">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_pready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_pready">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>apb_perror</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:id="PORT_ENABLEMENT.apb_perror">false</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_aclk</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
          <spirit:driver>
            <spirit:defaultValue spirit:format="long">0</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PORT_ENABLEMENT.s_axi_aclk" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=0)">true</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_aresetn</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
          <spirit:driver>
            <spirit:defaultValue spirit:format="long">1</spirit:defaultValue>
          </spirit:driver>
        </spirit:wire>
        <spirit:vendorExtensions>
          <xilinx:portInfo>
            <xilinx:enablement>
              <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PORT_ENABLEMENT.s_axi_aresetn" xilinx:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_EN_APB&apos;))=0)">true</xilinx:isEnabled>
            </xilinx:enablement>
          </xilinx:portInfo>
        </spirit:vendorExtensions>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_awaddr</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_ADDR_WIDTH&apos;)) - 1)">14</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_awvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_awready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wdata</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_DATA_WIDTH&apos;)) - 1)">31</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_bresp</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">1</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_bvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_bready</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_araddr</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_ADDR_WIDTH&apos;)) - 1)">14</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_arvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_arready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rdata</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_S_AXI_DATA_WIDTH&apos;)) - 1)">31</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rresp</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">1</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rready</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
    </spirit:ports>
    <spirit:modelParameters>
      <spirit:modelParameter xsi:type="spirit:nameValueTypeType" spirit:dataType="string">
        <spirit:name>C_FAMILY</spirit:name>
        <spirit:value spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_FAMILY">zynq</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_S_AXI_ADDR_WIDTH</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_S_AXI_ADDR_WIDTH">15</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_S_AXI_DATA_WIDTH</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_S_AXI_DATA_WIDTH">32</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_RX_FIFO_0_DEPTH</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_RX_FIFO_0_DEPTH">64</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>EN_RX_FIFO_1</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.EN_RX_FIFO_1">1</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_RX_FIFO_1_DEPTH</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_RX_FIFO_1_DEPTH">64</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_S2C_MTBF_STAGES</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_S2C_MTBF_STAGES">2</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_C2S_MTBF_STAGES</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_C2S_MTBF_STAGES">4</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_IS_NISO</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_IS_NISO">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>RX_MODE</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.RX_MODE">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_EN_APB</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_EN_APB">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_EINJ_MODE</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_EINJ_MODE">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>NUM_OF_RX_MB_BUF</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.NUM_OF_RX_MB_BUF">48</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>NUM_OF_TX_BUF</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.NUM_OF_TX_BUF">32</spirit:value>
      </spirit:modelParameter>
    </spirit:modelParameters>
  </spirit:model>
  <spirit:choices>
    <spirit:choice>
      <spirit:name>choice_list_0b4f952b</spirit:name>
      <spirit:enumeration>16</spirit:enumeration>
      <spirit:enumeration>32</spirit:enumeration>
      <spirit:enumeration>48</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>choice_list_61cc1938</spirit:name>
      <spirit:enumeration>32</spirit:enumeration>
      <spirit:enumeration>16</spirit:enumeration>
      <spirit:enumeration>8</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>choice_list_6727dfa6</spirit:name>
      <spirit:enumeration>1</spirit:enumeration>
      <spirit:enumeration>0</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>choice_list_99ba8646</spirit:name>
      <spirit:enumeration>32</spirit:enumeration>
      <spirit:enumeration>64</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>choice_pairs_7ef98ba7</spirit:name>
      <spirit:enumeration spirit:text="AXI_Lite">0</spirit:enumeration>
      <spirit:enumeration spirit:text="APB">1</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>choice_pairs_c5018f8d</spirit:name>
      <spirit:enumeration spirit:text="Sequential">0</spirit:enumeration>
      <spirit:enumeration spirit:text="MailBox">1</spirit:enumeration>
    </spirit:choice>
  </spirit:choices>
  <spirit:fileSets>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogsynthesis_xilinx_com_ip_blk_mem_gen_8_4__ref_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>../../ipshared/c001/hdl/blk_mem_gen_v8_4_vhsyn_rfs.vhd</spirit:name>
        <spirit:fileType>vhdlSource</spirit:fileType>
        <spirit:logicalName>blk_mem_gen_v8_4_3</spirit:logicalName>
      </spirit:file>
      <spirit:vendorExtensions>
        <xilinx:subCoreRef>
          <xilinx:componentRef xilinx:vendor="xilinx.com" xilinx:library="ip" xilinx:name="blk_mem_gen" xilinx:version="8.4" xilinx:isGenerated="true" xilinx:checksum="0137cb81">
            <xilinx:mode xilinx:name="copy_mode"/>
          </xilinx:componentRef>
        </xilinx:subCoreRef>
      </spirit:vendorExtensions>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogsynthesis_xilinx_com_ip_lib_bmg_1_0__ref_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>../../ipshared/7268/hdl/lib_bmg_v1_0_rfs.vhd</spirit:name>
        <spirit:fileType>vhdlSource</spirit:fileType>
        <spirit:logicalName>lib_bmg_v1_0_12</spirit:logicalName>
      </spirit:file>
      <spirit:vendorExtensions>
        <xilinx:subCoreRef>
          <xilinx:componentRef xilinx:vendor="xilinx.com" xilinx:library="ip" xilinx:name="lib_bmg" xilinx:version="1.0" xilinx:isGenerated="true" xilinx:checksum="27171adb">
            <xilinx:mode xilinx:name="copy_mode"/>
          </xilinx:componentRef>
        </xilinx:subCoreRef>
      </spirit:vendorExtensions>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogsynthesis_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>../../ipshared/0d2d/hdl/canfd_v2_0_vl_rfs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:logicalName>canfd_v2_0_1</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ipshared/0d2d/hdl/canfd_v2_0_1_can_ip_pkg.vh</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
        <spirit:logicalName>canfd_v2_0_1</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0.xdc</spirit:name>
        <spirit:userFileType>xdc</spirit:userFileType>
      </spirit:file>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0_clocks.xdc</spirit:name>
        <spirit:userFileType>xdc</spirit:userFileType>
        <spirit:define>
          <spirit:name>processing_order</spirit:name>
          <spirit:value>late</spirit:value>
        </spirit:define>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_synthesisconstraints_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0_ooc.xdc</spirit:name>
        <spirit:userFileType>xdc</spirit:userFileType>
        <spirit:userFileType>USED_IN_implementation</spirit:userFileType>
        <spirit:userFileType>USED_IN_out_of_context</spirit:userFileType>
        <spirit:userFileType>USED_IN_synthesis</spirit:userFileType>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogsynthesiswrapper_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>synth/Main_Card_canfd_1_0.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogbehavioralsimulation_xilinx_com_ip_blk_mem_gen_8_4__ref_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>../../ipshared/c001/simulation/blk_mem_gen_v8_4.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:userFileType>USED_IN_ipstatic</spirit:userFileType>
        <spirit:logicalName>blk_mem_gen_v8_4_3</spirit:logicalName>
        <spirit:exportedName>blk_mem_gen_v8_4_3</spirit:exportedName>
      </spirit:file>
      <spirit:vendorExtensions>
        <xilinx:subCoreRef>
          <xilinx:componentRef xsi:type="xilinx:componentRefType" xilinx:vendor="xilinx.com" xilinx:library="ip" xilinx:name="blk_mem_gen" xilinx:version="8.4" xilinx:isGenerated="true" xilinx:checksum="16b5b18d">
            <xilinx:mode xilinx:name="copy_mode"/>
          </xilinx:componentRef>
        </xilinx:subCoreRef>
      </spirit:vendorExtensions>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogbehavioralsimulation_xilinx_com_ip_lib_bmg_1_0__ref_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>../../ipshared/7268/hdl/lib_bmg_v1_0_rfs.vhd</spirit:name>
        <spirit:fileType>vhdlSource</spirit:fileType>
        <spirit:userFileType>USED_IN_ipstatic</spirit:userFileType>
        <spirit:logicalName>lib_bmg_v1_0_12</spirit:logicalName>
      </spirit:file>
      <spirit:vendorExtensions>
        <xilinx:subCoreRef>
          <xilinx:componentRef xilinx:vendor="xilinx.com" xilinx:library="ip" xilinx:name="lib_bmg" xilinx:version="1.0" xilinx:isGenerated="true" xilinx:checksum="27171adb">
            <xilinx:mode xilinx:name="copy_mode"/>
          </xilinx:componentRef>
        </xilinx:subCoreRef>
      </spirit:vendorExtensions>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogbehavioralsimulation_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>../../ipshared/0d2d/hdl/canfd_v2_0_vl_rfs.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:userFileType>USED_IN_ipstatic</spirit:userFileType>
        <spirit:logicalName>canfd_v2_0_1</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>../../ipshared/0d2d/hdl/canfd_v2_0_1_can_ip_pkg.vh</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:userFileType>USED_IN_ipstatic</spirit:userFileType>
        <spirit:isIncludeFile>true</spirit:isIncludeFile>
        <spirit:logicalName>canfd_v2_0_1</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogsimulationwrapper_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>sim/Main_Card_canfd_1_0.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_externalfiles_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0.dcp</spirit:name>
        <spirit:userFileType>dcp</spirit:userFileType>
        <spirit:userFileType>USED_IN_implementation</spirit:userFileType>
        <spirit:userFileType>USED_IN_synthesis</spirit:userFileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0_stub.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:userFileType>USED_IN_synth_blackbox_stub</spirit:userFileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0_stub.vhdl</spirit:name>
        <spirit:fileType>vhdlSource</spirit:fileType>
        <spirit:userFileType>USED_IN_synth_blackbox_stub</spirit:userFileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0_sim_netlist.v</spirit:name>
        <spirit:fileType>verilogSource</spirit:fileType>
        <spirit:userFileType>USED_IN_simulation</spirit:userFileType>
        <spirit:userFileType>USED_IN_single_language</spirit:userFileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
      <spirit:file>
        <spirit:name>Main_Card_canfd_1_0_sim_netlist.vhdl</spirit:name>
        <spirit:fileType>vhdlSource</spirit:fileType>
        <spirit:userFileType>USED_IN_simulation</spirit:userFileType>
        <spirit:userFileType>USED_IN_single_language</spirit:userFileType>
        <spirit:logicalName>xil_defaultlib</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
  </spirit:fileSets>
  <spirit:description>The Xilinx CANFD core solution is a full featured yet compact core. It conforms to the ISO 11898-1:2015, CAN 2.0A and CAN 2.0 B Standards. Bits rates greater than 4 Mbps are supported. The full version of the CANFD core can be purchased and downloaded from the Xilinx IP Center: http://www.xilinx.com/ipcenter/.          Note that CAN FD IP user needs to buy Protocol License from Robert Bosch to before selling a device containing the CAN FD IP core</spirit:description>
  <spirit:parameters>
    <spirit:parameter>
      <spirit:name>Component_Name</spirit:name>
      <spirit:value spirit:resolve="user" spirit:id="PARAM_VALUE.Component_Name" spirit:order="1">Main_Card_canfd_1_0</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.Component_Name">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>NUM_OF_TX_BUF</spirit:name>
      <spirit:displayName>Tx Buffers</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.NUM_OF_TX_BUF" spirit:choiceRef="choice_list_61cc1938" spirit:order="2">32</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.NUM_OF_TX_BUF">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>RX_MODE</spirit:name>
      <spirit:displayName>Rx Mode</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.RX_MODE" spirit:choiceRef="choice_pairs_c5018f8d" spirit:order="3">0</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.RX_MODE">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>NUM_OF_RX_MB_BUF</spirit:name>
      <spirit:displayName>Rx Buffers</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.NUM_OF_RX_MB_BUF" spirit:choiceRef="choice_list_0b4f952b" spirit:order="4">48</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.NUM_OF_RX_MB_BUF">false</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>C_EINJ_MODE</spirit:name>
      <spirit:displayName>Error Injection Mode Enabled</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.C_EINJ_MODE" spirit:choiceRef="choice_list_6727dfa6" spirit:order="5">0</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.C_EINJ_MODE">false</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>C_IS_NISO</spirit:name>
      <spirit:displayName>Enable ISO Mode</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.C_IS_NISO" spirit:choiceRef="choice_list_6727dfa6" spirit:order="6">0</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.C_IS_NISO">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>C_SELECT_XPM</spirit:name>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.C_SELECT_XPM" spirit:choiceRef="choice_list_6727dfa6" spirit:order="10">1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>C_RX_FIFO_0_DEPTH</spirit:name>
      <spirit:displayName>Rx FIFO-0 Depth</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.C_RX_FIFO_0_DEPTH" spirit:choiceRef="choice_list_99ba8646" spirit:order="11">64</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.C_RX_FIFO_0_DEPTH">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>EN_RX_FIFO_1</spirit:name>
      <spirit:displayName>Enable Rx FIFO-1</spirit:displayName>
      <spirit:value spirit:format="bool" spirit:resolve="user" spirit:id="PARAM_VALUE.EN_RX_FIFO_1" spirit:order="12">true</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.EN_RX_FIFO_1">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>C_RX_FIFO_1_DEPTH</spirit:name>
      <spirit:displayName>Rx FIFO-1 Depth</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.C_RX_FIFO_1_DEPTH" spirit:choiceRef="choice_list_99ba8646" spirit:order="13">64</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.C_RX_FIFO_1_DEPTH">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>C_EN_APB</spirit:name>
      <spirit:displayName>Processor Interface</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.C_EN_APB" spirit:choiceRef="choice_pairs_7ef98ba7" spirit:order="23">0</spirit:value>
      <spirit:vendorExtensions>
        <xilinx:parameterInfo>
          <xilinx:enablement>
            <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="PARAM_ENABLEMENT.C_EN_APB">true</xilinx:isEnabled>
          </xilinx:enablement>
        </xilinx:parameterInfo>
      </spirit:vendorExtensions>
    </spirit:parameter>
  </spirit:parameters>
  <spirit:vendorExtensions>
    <xilinx:coreExtensions>
      <xilinx:displayName>CANFD</xilinx:displayName>
      <xilinx:xpmLibraries>
        <xilinx:xpmLibrary>XPM_MEMORY</xilinx:xpmLibrary>
        <xilinx:xpmLibrary>XPM_CDC</xilinx:xpmLibrary>
      </xilinx:xpmLibraries>
      <xilinx:coreRevision>1</xilinx:coreRevision>
      <xilinx:licenseKeys>
        <xilinx:licenseKey>canfd@2018.11</xilinx:licenseKey>
      </xilinx:licenseKeys>
      <xilinx:configElementInfos>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_CLK_X2_I.CLK_DOMAIN" xilinx:valueSource="ip_propagated" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_CLK_X2_I.FREQ_HZ" xilinx:valueSource="ip_propagated" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_CLK_X2_I.PHASE" xilinx:valueSource="ip_propagated" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.ADDR_WIDTH" xilinx:valueSource="auto" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.ARUSER_WIDTH" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.AWUSER_WIDTH" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.BUSER_WIDTH" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.CLK_DOMAIN" xilinx:valueSource="default_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.DATA_WIDTH" xilinx:valueSource="auto" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.FREQ_HZ" xilinx:valueSource="user_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_BRESP" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_BURST" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_CACHE" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_LOCK" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_PROT" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_QOS" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_REGION" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_RRESP" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.HAS_WSTRB" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.ID_WIDTH" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.MAX_BURST_LENGTH" xilinx:valueSource="ip_propagated" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.NUM_READ_OUTSTANDING" xilinx:valueSource="default_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.NUM_WRITE_OUTSTANDING" xilinx:valueSource="default_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.PROTOCOL" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.READ_WRITE_MODE" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.RUSER_WIDTH" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.SUPPORTS_NARROW_BURST" xilinx:valueSource="ip_propagated" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.CAN_S_AXI_LITE.WUSER_WIDTH" xilinx:valueSource="constant" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.INTERRUPT.PortWidth" xilinx:valueSource="default_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_ACLK_I.CLK_DOMAIN" xilinx:valueSource="default_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXI_ACLK_I.FREQ_HZ" xilinx:valueSource="user_prop" xilinx:valuePermission="bd"/>
        <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.C_EN_APB" xilinx:valueSource="user"/>
      </xilinx:configElementInfos>
    </xilinx:coreExtensions>
    <xilinx:packagingInfo>
      <xilinx:xilinxVersion>2019.1</xilinx:xilinxVersion>
      <xilinx:checksum xilinx:scope="busInterfaces" xilinx:value="5629fb56"/>
      <xilinx:checksum xilinx:scope="memoryMaps" xilinx:value="00000000"/>
      <xilinx:checksum xilinx:scope="fileGroups" xilinx:value="f3d89d13"/>
      <xilinx:checksum xilinx:scope="ports" xilinx:value="57144fc6"/>
      <xilinx:checksum xilinx:scope="hdlParameters" xilinx:value="097c09d3"/>
      <xilinx:checksum xilinx:scope="parameters" xilinx:value="586f99df"/>
    </xilinx:packagingInfo>
  </spirit:vendorExtensions>
</spirit:component>
