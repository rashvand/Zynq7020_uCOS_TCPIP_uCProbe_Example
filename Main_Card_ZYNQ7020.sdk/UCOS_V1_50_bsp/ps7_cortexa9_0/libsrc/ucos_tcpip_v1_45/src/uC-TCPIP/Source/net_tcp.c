/*
*********************************************************************************************************
*                                              uC/TCP-IP
*                                      The Embedded TCP/IP Suite
*
*                    Copyright 2004-2021 Silicon Laboratories Inc. www.silabs.com
*
*                                 SPDX-License-Identifier: APACHE-2.0
*
*               This software is subject to an open source license and is distributed by
*                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
*                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
*
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*
*                                          NETWORK TCP LAYER
*                                   (TRANSMISSION CONTROL PROTOCOL)
*
* Filename : net_tcp.c
* Version  : V3.06.01
*********************************************************************************************************
* Note(s)  : (1) Supports Transmission Control Protocol as described in RFC #793 with the following
*                restrictions/constraints :
*
*                (a) TCP Security & Precedence NOT supported               RFC # 793, Section 3.6
*
*                (b) TCP Urgent Data           NOT supported               RFC # 793, Section 3.7
*                                                                           'The Communication of
*                                                                             Urgent Information'
*
*                (c) The following TCP options NOT supported :
*
*                    (1) Window Scale                                      RFC #1072, Section 2
*                                                                          RFC #1323, Section 2
*                    (2) Selective Acknowledgement (SACK)                  RFC #1072, Section 3
*                                                                          RFC #2018
*                                                                          RFC #2883
*                    (3) TCP Echo                                          RFC #1072, Section 4
*                    (4) Timestamp                                         RFC #1323, Section 3.2
*                    (5) Protection Against Wrapped Sequences (PAWS)       RFC #1323, Section 4
*
*                (d) IP-Options-to-TCP-Connection                          RFC #1122, Section 4.2.3.8
*                           Handling NOT supported #### NET-804
*
*                (e) ICMP-Error-Message-to-TCP-Connection                  RFC #1122, Section 4.2.3.9
*                           Handling NOT currently supported #### NET-805
*
*            (2) TCP Layer assumes/requires Network Socket Layer (see 'net_sock.h  MODULE  Note #1a2').
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*********************************************************************************************************
*                                            INCLUDE FILES
*********************************************************************************************************
*********************************************************************************************************
*/

#define    MICRIUM_SOURCE
#define    NET_TCP_MODULE
#include  "net_tcp.h"
#include  "net_cfg_net.h"

#ifdef  NET_IPv4_MODULE_EN
#include  "../IP/IPv4/net_icmpv4.h"
#endif
#ifdef  NET_IPv6_MODULE_EN
#include  "../IP/IPv6/net_icmpv6.h"
#endif

#ifdef  NET_TCP_CFG_RANDOM_ISN_GEN
#include  "../Modules/Common/net_md5.h"
#endif

#include  "net.h"
#include  "net_buf.h"
#include  "net_conn.h"
#include  "net_util.h"
#include  "../IF/net_if.h"


/*
*********************************************************************************************************
*********************************************************************************************************
*                                               MODULE
*********************************************************************************************************
*********************************************************************************************************
*/

#ifdef  NET_TCP_MODULE_EN


/*
*********************************************************************************************************
*********************************************************************************************************
*                                            LOCAL DEFINES
*********************************************************************************************************
*********************************************************************************************************
*/

#define  NET_TCP_RX_Q_NAME               "Net TCP Rx Q signal"
#define  NET_TCP_TX_Q_NAME               "Net TCP Tx Q signal"

#ifdef   NET_TCP_CFG_RANDOM_ISN_GEN
#define  NET_TCP_SECRET_KEY_SIZE                            4u  /* Nbr of 32-bit integers that comprise ISN secret key. */
#endif


/*
*********************************************************************************************************
*                              TCP CONNECTION CONFIGURATION CODE DEFINES
*
* Note(s) : (1) (a) TCP connection configuration codes used as arguments for various NetTCP_ConnCfg() functions.
*
*               (b) TCP connection configuration codes bit-field flags logically OR'd.
*********************************************************************************************************
*/

#define  NET_TCP_CONN_CFG_NONE                           DEF_BIT_NONE


#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_LOCAL             DEF_BIT_00
#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_REMOTE            DEF_BIT_01
#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN              DEF_BIT_02
#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL              (NET_TCP_CONN_CFG_MAX_SEG_SIZE_LOCAL  | \
                                                         NET_TCP_CONN_CFG_MAX_SEG_SIZE_REMOTE | \
                                                         NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN   )

#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_MASK              NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL


#define  NET_TCP_CONN_CFG_WIN_SIZE_RX                    DEF_BIT_02
#define  NET_TCP_CONN_CFG_WIN_SIZE_TX                    DEF_BIT_03
#define  NET_TCP_CONN_CFG_WIN_SIZE_CONN                 (NET_TCP_CONN_CFG_WIN_SIZE_RX | \
                                                         NET_TCP_CONN_CFG_WIN_SIZE_TX )
#define  NET_TCP_CONN_CFG_WIN_SIZE_ALL                   NET_TCP_CONN_CFG_WIN_SIZE_CONN

#define  NET_TCP_CONN_CFG_WIN_SIZE_MASK                  NET_TCP_CONN_CFG_WIN_SIZE_ALL


#define  NET_TCP_CONN_CFG_TX_RTT_RTO                     DEF_BIT_04


#define  NET_TCP_CONN_CFG_ALL                           (NET_TCP_CONN_CFG_NONE             | \
                                                         NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL | \
                                                         NET_TCP_CONN_CFG_WIN_SIZE_ALL     | \
                                                         NET_TCP_CONN_CFG_TX_RTT_RTO       )


/*
*********************************************************************************************************
*                               TCP CONNECTION CLOSE/FREE CODE DEFINES
*
* Note(s) : (1) (a) TCP connection close codes used as arguments for various NetTCP_ConnClose() functions.
*
*               (b) TCP connection close codes bit-field flags logically OR'd.
*
*           (2) Available TCP connection free codes are identical to TCP connection close codes.
*********************************************************************************************************
*/

#define  NET_TCP_CONN_CLOSE_NONE                         DEF_BIT_NONE


#define  NET_TCP_CONN_CLOSE_CONN_NONE                    DEF_BIT_NONE
#define  NET_TCP_CONN_CLOSE_CONN_TX_RESET                DEF_BIT_00
#define  NET_TCP_CONN_CLOSE_CONN_ALL                    (NET_TCP_CONN_CLOSE_CONN_NONE    | \
                                                         NET_TCP_CONN_CLOSE_CONN_TX_RESET)

#define  NET_TCP_CONN_CLOSE_CONN_MASK                    NET_TCP_CONN_CLOSE_CONN_ALL


#define  NET_TCP_CONN_CLOSE_TMR_NONE                     DEF_BIT_NONE
#define  NET_TCP_CONN_CLOSE_TMR_TIMEOUT                  DEF_BIT_04
#define  NET_TCP_CONN_CLOSE_TMR_TX_IDLE                  DEF_BIT_05
#define  NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN             DEF_BIT_06
#define  NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN              DEF_BIT_07
#define  NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY               DEF_BIT_08
#define  NET_TCP_CONN_CLOSE_TMR_RE_TX                    DEF_BIT_09

#define  NET_TCP_CONN_CLOSE_TMR_ALL                     (NET_TCP_CONN_CLOSE_TMR_NONE          | \
                                                         NET_TCP_CONN_CLOSE_TMR_TIMEOUT       | \
                                                         NET_TCP_CONN_CLOSE_TMR_TX_IDLE       | \
                                                         NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN  | \
                                                         NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN   | \
                                                         NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY    | \
                                                         NET_TCP_CONN_CLOSE_TMR_RE_TX         )

#define  NET_TCP_CONN_CLOSE_TMR_MASK                     NET_TCP_CONN_CLOSE_TMR_ALL


#define  NET_TCP_CONN_CLOSE_ALL                         (NET_TCP_CONN_CLOSE_NONE     | \
                                                         NET_TCP_CONN_CLOSE_CONN_ALL | \
                                                         NET_TCP_CONN_CLOSE_TMR_ALL  )


#define  NET_TCP_CONN_FREE_NONE                          NET_TCP_CONN_CLOSE_NONE

#define  NET_TCP_CONN_FREE_TMR_NONE                      NET_TCP_CONN_CLOSE_TMR_NONE
#define  NET_TCP_CONN_FREE_TMR_TIMEOUT                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT
#define  NET_TCP_CONN_FREE_TMR_TX_IDLE                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE
#define  NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN              NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN
#define  NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN               NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN
#define  NET_TCP_CONN_FREE_TMR_TX_ACK_DLY                NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY
#define  NET_TCP_CONN_FREE_TMR_RE_TX                     NET_TCP_CONN_CLOSE_TMR_RE_TX
#define  NET_TCP_CONN_FREE_TMR_ALL                       NET_TCP_CONN_CLOSE_TMR_ALL
#define  NET_TCP_CONN_FREE_TMR_MASK                      NET_TCP_CONN_CLOSE_TMR_MASK

#define  NET_TCP_CONN_FREE_ALL                           NET_TCP_CONN_CLOSE_ALL


/*
*********************************************************************************************************
*********************************************************************************************************
*                                          LOCAL DATA TYPES
*********************************************************************************************************
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                     TCP SEQUENCE CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT08U          NET_TCP_SEQ_CODE;


/*
*********************************************************************************************************
*                                 TCP ACKNOWLEDGEMENT CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT08U          NET_TCP_ACK_CODE;


/*
*********************************************************************************************************
*                                 TCP CONNECTION RESET CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT08U          NET_TCP_RESET_CODE;


/*
*********************************************************************************************************
*                                      TCP WINDOW CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT08U          NET_TCP_WIN_CODE;


/*
*********************************************************************************************************
*                                   TCP CALCULATION CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT08U          NET_TCP_CALC_CODE;


/*
*********************************************************************************************************
*                                  TCP CONFIGURATION CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT08U          NET_TCP_CFG_CODE;


/*
*********************************************************************************************************
*                                      TCP CLOSE CODE DATA TYPE
*********************************************************************************************************
*/

typedef  CPU_INT16U          NET_TCP_CLOSE_CODE;


/*
*********************************************************************************************************
*                                       TCP FREE CODE DATA TYPE
*********************************************************************************************************
*/

typedef  NET_TCP_CLOSE_CODE  NET_TCP_FREE_CODE;


/*
*********************************************************************************************************
*********************************************************************************************************
*                                       LOCAL GLOBAL VARIABLES
*********************************************************************************************************
*********************************************************************************************************
*/

static  NET_TCP_SEQ_NBR   NetTCP_TxSeqNbrCtr;                   /* Global tx seq nbr ctr.                               */

#ifdef  NET_TCP_CFG_RANDOM_ISN_GEN
static  NET_MD5_CONTEXT   NetTCP_ISN_MD5_Handle;
                                                                /* 128-bit secret obtained at start-up (See RFC #6528). */
static  CPU_INT32U        NetTCP_ISN_SecretKey[NET_TCP_SECRET_KEY_SIZE];

typedef struct            net_tcp_isn_five_tuple {
        CPU_INT08U        Local_IP [NET_CONN_ADDR_LEN_MAX];
        CPU_INT08U        Remote_IP[NET_CONN_ADDR_LEN_MAX];
        CPU_INT16U        Local_Port;
        CPU_INT16U        Remote_Port;
        CPU_INT32U        Secret[NET_TCP_SECRET_KEY_SIZE];
} NET_TCP_ISN_FIVE_TUPLE;
#endif


/*
*********************************************************************************************************
*********************************************************************************************************
*                                      LOCAL FUNCTION PROTOTYPES
*
* Note(s) : (1) NetTCP_RxPktConnHandlerState&&&() abbreviated to NetTCP_RxPktConnHandler&&&() to enforce
*               ANSI-compliance of 31-character symbol length uniqueness.
*********************************************************************************************************
*********************************************************************************************************
*/

                                                                /* --------------------- RX FNCTS --------------------- */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
static  void                NetTCP_RxPktValidateBuf               (NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);
#endif

static  void                NetTCP_RxPktValidate                  (NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_HDR           *p_tcp_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktValidateOpt               (NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_HDR           *p_tcp_hdr,
                                                                   CPU_INT08U             tcp_hdr_len_size,
                                                                   NET_ERR               *p_err);

static  CPU_BOOLEAN         NetTCP_RxPktValidateOptMaxSegSize     (NET_BUF_HDR           *p_buf_hdr,
                                                                   CPU_INT08U            *p_opt,
                                                                   CPU_INT08U            *p_opt_len,
                                                                   NET_ERR               *p_err);



static  void                NetTCP_RxPktDemuxSeg                  (NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);



static  void                NetTCP_RxPktConnHandler               (NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

                                                                /* See Note #1.                                         */
static  void                NetTCP_RxPktConnHandlerListen         (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerSyncRxd        (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerSyncTxd        (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerConn           (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerFinWait1       (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerFinWait2       (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerClosing        (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerTimeWait       (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerCloseWait      (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerLastAck        (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_RxPktConnHandlerSeg            (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_ACK_CODE       ack_code,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);



static  void                NetTCP_RxPktConnHandlerCfgConn        (NET_TCP_CONN          *p_conn);



static  void                NetTCP_RxPktConnHandlerRxQ_Sync       (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerRxQ_Conn       (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerRxQ_AppData    (NET_TCP_CONN          *p_conn,
                                                                   NET_ERR               *p_err);



static  void                NetTCP_RxPktConnHandlerTxWinRemote    (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_ACK_CODE       ack_code,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_RxPktConnHandlerReTxQ          (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_ACK_CODE       ack_code,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);



static  CPU_BOOLEAN         NetTCP_RxPktConnHandlerListenQ_IsAvail(NET_TCP_CONN          *p_conn,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_RxPktConnHandlerSignalConn     (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_CONN_STATE     state,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_RxPktConnHandlerSignalClose    (NET_TCP_CONN          *p_conn,
                                                                   CPU_BOOLEAN            data_avail,
                                                                   NET_ERR               *p_err);



static  NET_TCP_SEQ_CODE    NetTCP_RxPktConnIsValidSeq            (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  NET_TCP_ACK_CODE    NetTCP_RxPktConnIsValidAck            (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);

static  NET_TCP_RESET_CODE  NetTCP_RxPktConnIsValidReset          (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_ERR               *p_err);



static  NET_BUF_QTY         NetTCP_RxPktFree                      (NET_BUF               *p_buf_q);

static  void                NetTCP_RxPktDiscard                   (NET_BUF               *p_buf,
                                                                   NET_ERR               *p_err);



static  void                NetTCP_RxConnWinSizeCfg               (NET_TCP_CONN          *p_conn);


static  void                NetTCP_RxConnWinSizeHandler           (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   CPU_INT16U             nbr_buf,
                                                                   NET_TCP_WIN_CODE       win_update_code);



                                                                /* --------------------- TX FNCTS --------------------- */

static  void                NetTCP_TxConnWinSizeCfg               (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnWinSizeCfgCongCtrl       (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnWinSizeCfgMinTh          (NET_TCP_CONN          *p_conn);


static  void                NetTCP_TxConnWinSizeHandlerCfgd       (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_WIN_SIZE       win_update_size,
                                                                   NET_TCP_WIN_CODE       win_update_code,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxConnWinSizeHandlerCongCtrl   (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_ACK_CODE       ack_code,
                                                                   NET_TCP_WIN_SIZE       win_update_size,
                                                                   NET_TCP_WIN_CODE       win_update_code,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnWinSizeCalcSlowStartTh   (NET_TCP_CONN          *p_conn);


static  void                NetTCP_TxConnWinSizeCongSet           (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_WIN_CODE       win_inc_code);

static  void                NetTCP_TxConnWinSizeCongInc           (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_WIN_SIZE       win_update_size,
                                                                   NET_TCP_WIN_CODE       win_inc_code);


static  void                NetTCP_TxConnWinSizeUpdateAvail       (NET_TCP_CONN          *p_conn);


static  void                NetTCP_TxConnWinSizeDupAckCtrlReset   (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnWinSizeDupAckCtrlUpdate  (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   CPU_BOOLEAN            reset_ctr);


static  void                NetTCP_TxConnWinSizeZeroWinHandler    (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_WIN_CODE       win_update_code,
                                                                   NET_TCP_CLOSE_CODE     close_code);

static  void                NetTCP_TxConnWinSizeZeroWinTimeout    (void                  *p_conn_timeout);



static  void                NetTCP_TxConnSync                     (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_CONN_STATE     state,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxConnClose                    (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_CONN_STATE     state,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnAck                      (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_ACK_CODE       tx_ack_code,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxConnAckDlyReset              (NET_TCP_CONN          *p_conn,
                                                                   CPU_BOOLEAN            tmr_free);

static  void                NetTCP_TxConnAckDlyTimeout            (void                  *p_conn_timeout);


static  void                NetTCP_TxConnReset                    (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_RESET_CODE     tx_reset_code,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnProbe                    (NET_TCP_CONN          *p_conn,
                                                                   CPU_BOOLEAN            tx_probe_data_octet,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnKeepAlive                (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxConnKeepAliveReset           (NET_TCP_CONN          *p_conn);



static  void                NetTCP_TxConnTxQ                      (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_ACK_CODE       tx_ack_code,
                                                                   CPU_BOOLEAN            tx_q_timeout,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   CPU_BOOLEAN            tx_suspend_en,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnTxQ_TimeoutIdle          (void                  *p_conn_timeout);

static  void                NetTCP_TxConnTxQ_TimeoutIdleSet       (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnTxQ_TimeoutIdleClr       (NET_TCP_CONN          *p_conn);


static  void                NetTCP_TxConnTxQ_TimeoutSillyWin      (void                  *p_conn_timeout);



static  void                NetTCP_TxConnReTxQ                    (NET_TCP_CONN          *p_conn,
                                                                   CPU_BOOLEAN            re_tx_q_timeout,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnReTxQ_Timeout            (void                  *p_conn_timeout);

static  void                NetTCP_TxConnReTxQ_TimeoutSet         (NET_TCP_CONN          *p_conn,
                                                                   CPU_BOOLEAN            re_tx_q_timeout,
                                                                   NET_TCP_CLOSE_CODE     close_code,
                                                                   NET_ERR               *p_err);



static  void                NetTCP_TxConnPrepareSegAddrs          (NET_TCP_CONN          *p_conn,
                                                                   CPU_INT08U            *p_src_addr,
                                                                   CPU_INT08U            *p_src_port,
                                                                   CPU_INT16U             src_addr_len,
                                                                   CPU_INT16U             src_port_len,
                                                                   CPU_INT08U            *p_dest_addr,
                                                                   CPU_INT08U            *p_dest_port,
                                                                   CPU_INT16U             dest_addr_len,
                                                                   CPU_INT16U             dest_port_len,
                                                                   NET_ERR               *p_err);


static  void                NetTCP_TxConnRTT_Init                 (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTT_Reset                (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTT_CalcUpdate           (NET_TCP_CONN          *p_conn);


static  void                NetTCP_TxConnRTO_Init                 (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTO_CfgMaxTimeout        (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTO_CalcUpdate           (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTO_CalcUpdate_ms        (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTO_CalcUpdate_ms_scaled (NET_TCP_CONN          *p_conn);

static  NET_TCP_TIMEOUT_MS  NetTCP_TxConnRTO_CalcBackOff          (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_TIMEOUT_MS     rto_ms);


static  void                NetTCP_TxConnRTT_RTO_Init             (NET_TCP_CONN          *p_conn);

static  void                NetTCP_TxConnRTT_RTO_Calc             (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_CALC_CODE      calc_code,
                                                                   NET_TCP_TX_RTT_TS_MS   rtt_ts_txd_ms,
                                                                   NET_TCP_TX_RTT_TS_MS   rtt_ts_rxd_ms);


#ifdef  NET_IPv4_MODULE_EN
static  void                NetTCP_TxPktHandlerIPv4               (NET_BUF               *p_buf,
                                                                   NET_IPv4_ADDR          src_addr,
                                                                   NET_TCP_PORT_NBR       src_port,
                                                                   NET_IPv4_ADDR          dest_addr,
                                                                   NET_TCP_PORT_NBR       dest_port,
                                                                   NET_TCP_SEQ_NBR        seq_nbr,
                                                                   NET_TCP_SEQ_NBR        ack_nbr,
                                                                   NET_TCP_WIN_SIZE       win_size,
                                                                   NET_IPv4_TOS           TOS,
                                                                   NET_IPv4_TTL           TTL,
                                                                   NET_TCP_FLAGS          flags_tcp,
                                                                   NET_IPv4_FLAGS         flags_ip,
                                                                   void                  *p_opts_tcp,
                                                                   void                  *p_opts_ip,
                                                                   NET_ERR               *p_err);
#endif

#ifdef  NET_IPv6_MODULE_EN
static  void                NetTCP_TxPktHandlerIPv6               (NET_BUF                 *p_buf,
                                                                   NET_IPv6_ADDR           *p_src_addr,
                                                                   NET_TCP_PORT_NBR         src_port,
                                                                   NET_IPv6_ADDR           *p_dest_addr,
                                                                   NET_TCP_PORT_NBR         dest_port,
                                                                   NET_TCP_SEQ_NBR          seq_nbr,
                                                                   NET_TCP_SEQ_NBR          ack_nbr,
                                                                   NET_TCP_WIN_SIZE         win_size,
                                                                   NET_IPv6_TRAFFIC_CLASS   traffic_class,
                                                                   NET_IPv6_FLOW_LABEL      flow_label,
                                                                   NET_IPv6_HOP_LIM         hop_lim,
                                                                   NET_TCP_FLAGS            flags_tcp,
                                                                   void                    *p_opts_tcp,
                                                                   NET_ERR                 *p_err);
#endif

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
static  void                NetTCP_TxPktValidate                  (NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_TCP_PORT_NBR       src_port,
                                                                   NET_TCP_PORT_NBR       dest_port,
                                                                   NET_TCP_SEQ_NBR        seq_nbr,
                                                                   NET_TCP_SEQ_NBR        ack_nbr,
                                                                   NET_TCP_WIN_SIZE       win_size,
                                                                   NET_TCP_FLAGS          flags_tcp,
                                                                   void                  *p_opts_tcp,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxPktValidateOpt               (void                  *p_opts_tcp,
                                                                   NET_TCP_FLAGS          flags_tcp,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxPktValidateOptMaxSegSize     (void                  *p_opt_tcp,
                                                                   CPU_INT08U            *p_opt_len,
                                                                   void                 **p_opt_next,
                                                                   NET_TCP_FLAGS          flags_tcp,
                                                                   NET_ERR               *p_err);
#endif



#ifdef  NET_IPv4_MODULE_EN
static  void                NetTCP_TxPktIPv4                      (NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   NET_IPv4_ADDR          src_addr,
                                                                   NET_TCP_PORT_NBR       src_port,
                                                                   NET_IPv4_ADDR          dest_addr,
                                                                   NET_TCP_PORT_NBR       dest_port,
                                                                   NET_TCP_SEQ_NBR        seq_nbr,
                                                                   NET_TCP_SEQ_NBR        ack_nbr,
                                                                   NET_TCP_WIN_SIZE       win_size,
                                                                   NET_IPv4_TOS           TOS,
                                                                   NET_IPv4_TTL           TTL,
                                                                   NET_TCP_FLAGS          flags_tcp,
                                                                   NET_IPv4_FLAGS         flags_ip,
                                                                   void                  *p_opts_tcp,
                                                                   void                  *p_opts_ip,
                                                                   NET_ERR               *p_err);
#endif

#ifdef  NET_IPv6_MODULE_EN
static  void                NetTCP_TxPktIPv6                      (NET_BUF                 *p_buf,
                                                                   NET_BUF_HDR             *p_buf_hdr,
                                                                   NET_IPv6_ADDR           *p_src_addr,
                                                                   NET_TCP_PORT_NBR         src_port,
                                                                   NET_IPv6_ADDR           *p_dest_addr,
                                                                   NET_TCP_PORT_NBR         dest_port,
                                                                   NET_TCP_SEQ_NBR          seq_nbr,
                                                                   NET_TCP_SEQ_NBR          ack_nbr,
                                                                   NET_TCP_WIN_SIZE         win_size,
                                                                   NET_IPv6_TRAFFIC_CLASS   traffic_class,
                                                                   NET_IPv6_FLOW_LABEL      flow_label,
                                                                   NET_IPv6_HOP_LIM         hop_lim,
                                                                   NET_TCP_FLAGS            flags_tcp,
                                                                   void                    *p_opts_tcp,
                                                                   NET_ERR                 *p_err);
#endif

static  CPU_INT08U          NetTCP_TxPktPrepareOpt                (void                  *p_opts_tcp,
                                                                   CPU_INT08U            *p_opt_hdr,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxPktPrepareOptMaxSegSize      (void                  *p_opts_tcp,
                                                                   CPU_INT08U            *p_opt_hdr,
                                                                   CPU_INT08U            *p_opt_len,
                                                                   void                 **p_opt_next,
                                                                   NET_ERR               *p_err);

static  void                NetTCP_TxPktPrepareHdr                (NET_BUF               *p_buf,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   CPU_INT16U             tcp_hdr_len_tot,
                                                                   CPU_INT08U             tcp_opt_len_tot,
                                                                   CPU_INT16U             addr_size,
                                                                   void                  *p_src_addr,
                                                                   NET_TCP_PORT_NBR       src_port,
                                                                   void                  *p_dest_addr,
                                                                   NET_TCP_PORT_NBR       dest_port,
                                                                   NET_TCP_SEQ_NBR        seq_nbr,
                                                                   NET_TCP_SEQ_NBR        ack_nbr,
                                                                   NET_TCP_WIN_SIZE       win_size,
                                                                   NET_TCP_FLAGS          flags_tcp,
                                                                   CPU_INT32U            *p_tcp_hdr_opts,
                                                                   NET_ERR               *p_err);



static  NET_BUF_QTY         NetTCP_TxPktFree                      (NET_BUF               *p_buf_q);

static  void                NetTCP_TxPktDiscard                   (NET_BUF               *p_buf,
                                                                   NET_ERR               *p_err);




                                                                /* ------------------ TCP CONN FNCTS ------------------ */

static  void                NetTCP_ConnCfg                        (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_CFG_CODE       cfg_code);

static  void                NetTCP_ConnCfgMaxSegSize              (NET_TCP_CONN          *p_conn);



static  void                NetTCP_ConnIdleTimeout                (void                  *p_conn_timeout);


static  void                NetTCP_ConnClose                      (NET_TCP_CONN          *p_conn,
                                                                   NET_BUF_HDR           *p_buf_hdr,
                                                                   CPU_BOOLEAN            close_conn_app,
                                                                   NET_TCP_CLOSE_CODE     close_code);

static  void                NetTCP_ConnCloseHandler               (NET_TCP_CONN          *p_conn,
                                                                   CPU_BOOLEAN            close_conn_app,
                                                                   NET_TCP_CLOSE_CODE     close_code);

static  void                NetTCP_ConnClosingTimeoutDataAvail    (void                  *p_conn_timeout);



static  void                NetTCP_ConnFreeHandler                (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_FREE_CODE      free_code);

static  void                NetTCP_ConnFreeTmr                    (NET_TCP_CONN          *p_conn,
                                                                   NET_TCP_FREE_CODE      free_code);

static  void                NetTCP_ConnFreeBufQ                   (NET_BUF              **p_buf_q_head,
                                                                   NET_BUF              **p_buf_q_tail);



static  void                NetTCP_ConnClr                        (NET_TCP_CONN          *p_conn);

static  void                NetTCP_ConnCopy                       (NET_TCP_CONN          *p_conn_dest,
                                                                   NET_TCP_CONN          *p_conn_src);


static  void                NetTCP_ConnDiscard                    (NET_TCP_CONN          *p_conn);

static  void                NetTCP_GetTxDataIx                    (NET_IF_NBR             if_nbr,
                                                                   NET_PROTOCOL_TYPE      protocol,
                                                                   CPU_INT16U             additial_hdr_size,
                                                                   CPU_INT16U             data_len,
                                                                   NET_TCP_CONN          *p_conn,
                                                                   CPU_INT16U            *p_ix,
                                                                   NET_ERR               *p_err);


/*
*********************************************************************************************************
*                                            NetTCP_Init()
*
* Description : (1) Initialize Transmission Control Protocol Layer :
*
*                   (a) Perform TCP Module/OS  initialization
*                   (b) Perform TCP Module/BSP initialization
*                   (c) Initialize TCP connection pool
*                   (d) Initialize TCP connection table
*
*
* Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP layer successfully initialized.
*                               NET_ERR_FAULT_MEM_ALLOC         Error in memory allocation of a semaphore.
*                               NET_TCP_ERR_INIT_RX_Q_FAULT     Rx Q not successfully initialized.
*                               NET_TCP_ERR_INIT_TX_Q_FAULT     Tx Q not successfully initialized.
*
* Return(s)   : none.
*
* Caller(s)   : Net_Init().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (2) The following TCP initialization MUST be sequenced as follows :
*
*                   (a) TCP connection pool MUST be initialized PRIOR to initializing the pool with pointers
*                           to TCP connections
*********************************************************************************************************
*/

void  NetTCP_Init (NET_ERR  *p_err)
{
    NET_TCP_CONN      *p_conn;
    NET_TCP_CONN_QTY   i;
    KAL_ERR            err_kal;
    NET_ERR            err;

                                                                /* --------------- PERFORM TCP/BSP INIT --------------- */
    NetTCP_TxSeqNbrCtr = NetUtil_InitSeqNbrGet();               /* Init tx seq nbr ctr. User must increment every 4 uS. */

#ifdef  NET_TCP_CFG_RANDOM_ISN_GEN                              /* Populate secret key. (See RFC #6528).                */
    for (int i = 0; i < (sizeof(NetTCP_ISN_SecretKey) / sizeof(CPU_INT32U)); i++) {
         NetTCP_ISN_SecretKey[i] = NetUtil_RandomRangeGet(0u, DEF_INT_32U_MAX_VAL);
    }
#endif

                                                                /* ------------- INIT TCP CONN POOL/STATS ------------- */
    NetTCP_ConnPoolPtr = DEF_NULL;                              /* Init-clr TCP conn pool (see Note #2b).               */

    NetStat_PoolInit((NET_STAT_POOL   *)&NetTCP_ConnPoolStat,
                     (NET_STAT_POOL_QTY) NET_TCP_NBR_CONN,
                     (NET_ERR         *)&err);


                                                                /* ---------------- INIT TCP CONN TBL ----------------- */
    p_conn = &NetTCP_ConnTbl[0];
    for (i = 0; i < (NET_TCP_CONN_QTY)NET_TCP_NBR_CONN; i++) {
        p_conn->ID        = (NET_TCP_CONN_ID)i;

        p_conn->ConnState =  NET_TCP_CONN_STATE_FREE;           /* Init each TCP conn as free/NOT used.                 */
        p_conn->Flags     =  NET_TCP_FLAG_NONE;

                                                                /* Initialize TCP connection receive queue.             */
                                                                /* Create     TCP connection receive queue signals ...  */
                                                                /* ... with NO pending signal.                          */
        p_conn->RxQ_SignalObj = KAL_SemCreate((const CPU_CHAR *)&NET_TCP_RX_Q_NAME,
                                                                 DEF_NULL,
                                                                &err_kal);
        switch (err_kal) {
            case KAL_ERR_NONE:
                 break;

            case KAL_ERR_MEM_ALLOC:
                *p_err = NET_ERR_FAULT_MEM_ALLOC;
                 goto exit;

            case KAL_ERR_INVALID_ARG:
            case KAL_ERR_ISR:
            case KAL_ERR_CREATE:
            default:
                 *p_err = NET_TCP_ERR_INIT_RX_Q_FAULT;
                  goto exit;

        }

                                                                /* Initialize TCP connection receive queue timeout values.*/
        NetTCP_RxQ_TimeoutDflt(i, p_err);
        if (*p_err != NET_TCP_ERR_NONE) {
             goto exit;
        }


                                                                /* Initialize TCP connection transmit queue.            */
                                                                /* Create     TCP connection transmit queue signals ... */
                                                                /* ... with NO pending signal.                          */
        p_conn->TxQ_SignalObj = KAL_SemCreate((const CPU_CHAR *)&NET_TCP_TX_Q_NAME,
                                                                 DEF_NULL,
                                                                &err_kal);
        switch (err_kal) {
            case KAL_ERR_NONE:
                 break;

            case KAL_ERR_MEM_ALLOC:
                *p_err = NET_ERR_FAULT_MEM_ALLOC;
                 goto exit;

            case KAL_ERR_INVALID_ARG:
            case KAL_ERR_ISR:
            case KAL_ERR_CREATE:
            default:
                 *p_err = NET_TCP_ERR_INIT_TX_Q_FAULT;
                  goto exit;

        }
                                                                /* Initialize TCP connection transmit queue timeout values.*/
        NetTCP_TxQ_TimeoutDflt(i, p_err);
        if (*p_err != NET_TCP_ERR_NONE) {
             goto exit;
        }



#if (NET_DBG_CFG_MEM_CLR_EN == DEF_ENABLED)
        NetTCP_ConnClr(p_conn);
#endif
                                                                /* Free each TCP conn to TCP conn pool (see Note #2).   */
        p_conn->NextPtr    = NetTCP_ConnPoolPtr;
        NetTCP_ConnPoolPtr = p_conn;

        p_conn++;
    }


   *p_err = NET_TCP_ERR_NONE;

exit:
   return;
}


/*
*********************************************************************************************************
*                                           NetTCP_RxQ_Clr()
*
* Description : Clear TCP connection receive queue signal.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to clear receive queue signal.
*               -----------     Argument validated in NetTCP_RxAppData(),
*                                                     NetTCP_RxPktConnHandlerRxQ_AppData(),
*                                                     NetTCP_ConnFreeHandler().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive queue signal
*                                                                   successfully cleared.
*                               NET_TCP_ERR_RX_Q_SIGNAL_CLR     TCP connection receive queue signal
*                                                                   NOT          cleared.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxAppData(),
*               NetTCP_RxPktConnHandlerRxQ_AppData(),
*               NetTCP_ConnFreeHandler().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_RxQ_Clr (NET_TCP_CONN_ID   conn_id_tcp,
                      NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    KAL_ERR        err_kal;


    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    KAL_SemSet(p_conn->RxQ_SignalObj, 0u, &err_kal);            /* Clear TCP connection receive queue signal.           */
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;


        case KAL_ERR_NULL_PTR:
        case KAL_ERR_INVALID_ARG:
        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_RX_Q_SIGNAL_CLR;
             break;
    }
}

/*
*********************************************************************************************************
*                                           NetTCP_RxQ_Wait()
*
* Description : Wait on TCP connection receive queue.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to wait on receive queue.
*               -----------     Argument checked in NetTCP_RxAppData().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive queue   non-empty.
*                               NET_TCP_ERR_RX_Q_EMPTY          TCP connection receive queue still empty by
*                                                                   timeout.
*                               NET_TCP_ERR_RX_Q_SIGNAL_ABORT   TCP connection receive queue signal aborted;
*                                                                   TCP connection closed/aborted.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT   TCP connection receive queue signal fault.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxAppData().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (1) (a) If timeouts NOT desired, wait on TCP connection receive queue forever
*                       (i.e. do NOT exit).
*
*                   (b) If timeout      desired, return NET_TCP_ERR_RX_Q_EMPTY error on TCP connection
*                       receive queue timeout.  Implement timeout with OS-dependent functionality.
*********************************************************************************************************
*/

void  NetTCP_RxQ_Wait (NET_TCP_CONN_ID   conn_id_tcp,
                       NET_ERR          *p_err)
{
    CPU_INT32U     timeout_ms;
    NET_TCP_CONN  *p_conn;
    KAL_ERR        err_kal;
    CPU_SR_ALLOC();

    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    CPU_CRITICAL_ENTER();
    timeout_ms = p_conn->RxQ_SignalTimeout_ms;
    CPU_CRITICAL_EXIT();

                                                                /* Wait on TCP connection receive queue ...             */
                                                                /* ... with configured timeout.                         */
    KAL_SemPend(p_conn->RxQ_SignalObj, KAL_OPT_PEND_NONE, timeout_ms, &err_kal);
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;


        case KAL_ERR_TIMEOUT:
            *p_err = NET_TCP_ERR_RX_Q_EMPTY;                    /* See Note #1b.                                        */
             break;


        case KAL_ERR_ABORT:
            *p_err = NET_TCP_ERR_RX_Q_SIGNAL_ABORT;
             break;


        case KAL_ERR_ISR:
        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_RX_Q_SIGNAL_FAULT;
             break;
    }
}


/*
*********************************************************************************************************
*                                        NetTCP_RxQ_Signal()
*
* Description : Signal TCP connection receive queue.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to signal receive queue.
*               -----------     Argument validated in NetTCP_RxAppData(),
*                                                     NetTCP_RxPktConnHandlerRxQ_AppData().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive queue successfully
*                                                                   signaled.
*                               NET_TCP_ERR_RX_Q_FULL           TCP connection receive queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT   TCP connection receive queue signal fault.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxAppData(),
*               NetTCP_RxPktConnHandlerRxQ_AppData().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_RxQ_Signal (NET_TCP_CONN_ID   conn_id_tcp,
                         NET_ERR          *p_err)
{
    NET_CONN      *p_net_conn;
    NET_TCP_CONN  *p_tcp_conn;
    KAL_ERR        err_kal;


    p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

                                                                /* Signal TCP connection receive queue.                 */
    KAL_SemPost(p_tcp_conn->RxQ_SignalObj, KAL_OPT_PEND_NONE, &err_kal);
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;

        case KAL_ERR_OVF:
            *p_err = NET_TCP_ERR_RX_Q_FULL;
             break;

        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_RX_Q_SIGNAL_FAULT;
             break;
    }

    p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
    if (p_net_conn->ID_App != NET_CONN_ID_NONE) {
        p_tcp_conn->FnctAppPostRx(p_net_conn->ID_App);

    } else if (p_net_conn->ID_AppClone != NET_CONN_ID_NONE) {
        p_tcp_conn->FnctAppPostRx(p_net_conn->ID_AppClone);
    } else {
                                                                /* Empty Else Statement                                 */
    }
}


/*
*********************************************************************************************************
*                                         NetTCP_RxQ_Abort()
*
* Description : Abort wait on TCP connection receive queue.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to abort wait on socket receive queue.
*               -----------     Argument validated in NetTCP_ConnFreeHandler().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                Wait on TCP connection receive queue
*                                                                   successfully aborted.
*                               NET_TCP_ERR_RX_Q_ABORT          TCP connection receive queue abort failed.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnFreeHandler().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_RxQ_Abort (NET_TCP_CONN_ID   conn_id_tcp,
                        NET_ERR          *p_err)
{
    NET_CONN      *p_net_conn;
    NET_TCP_CONN  *p_tcp_conn;
    NET_CONN_ID    net_conn_id;
    KAL_ERR        err_kal;


    p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

                                                                /* Abort wait on TCP connection receive queue ...       */
                                                                /* ... for ALL waiting tasks.                           */
    KAL_SemPendAbort(p_tcp_conn->RxQ_SignalObj, &err_kal);
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;


        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_RX_Q_ABORT;
             break;
    }

    net_conn_id = p_tcp_conn->ID_Conn;
    if (net_conn_id != NET_CONN_ID_NONE) {
        p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
        p_tcp_conn->FnctAppPostRx(p_net_conn->ID_App);
    }
}


/*
*********************************************************************************************************
*                                       NetTCP_RxQ_TimeoutDflt()
*
* Description : Set TCP connection receive queue to configured-default timeout value.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to set receive queue configured-default
*   `           -----------         timeout.
*
*                               Argument checked in NetSock_CfgTimeoutRxQ_Dflt(),
*                                                   NetTCP_ConnClr(),
*                                                   NetTCP_Init().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive queue configured-
*                                                                   default timeout successfully set.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_CfgTimeoutRxQ_Dflt(),
*               NetTCP_ConnClr(),
*               NetTCP_Init().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).  See 'net_sock.c  NetSock_CfgTimeoutRxQ_Dflt()'.
*
* Note(s)     : (1) NetTCP_RxQ_TimeoutDflt() is called by network protocol suite function(s) &
*                   may be called either with OR without the global network lock already acquired.
*
*                   See also 'net_sock.c  NetSock_CfgTimeoutRxQ_Dflt()  Note #2'.
*********************************************************************************************************
*/

#ifdef  NET_TCP_MODULE_EN
void  NetTCP_RxQ_TimeoutDflt (NET_TCP_CONN_ID   conn_id_tcp,
                              NET_ERR          *p_err)
{
    CPU_INT32U  timeout_ms;
                                                                /* Set TCP connection receive queue timeout ...         */
                                                                /* ... to configured-default        timeout value.      */
    timeout_ms = NET_TCP_DFLT_TIMEOUT_CONN_RX_Q_MS;

    NetTCP_RxQ_TimeoutSet(conn_id_tcp, timeout_ms, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }

   *p_err = NET_TCP_ERR_NONE;
}
#endif


/*
*********************************************************************************************************
*                                      NetTCP_RxQ_TimeoutSet()
*
* Description : Set TCP connection receive queue timeout value.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to set receive queue timeout.
*               -----------     Argument checked in NetSock_CfgTimeoutRxQ_Set(),
*                                                   NetTCP_RxQ_TimeoutDflt().
*
*               timeout_ms      Timeout value :
*
*                                   NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value desired.
*
*                                   In number of milliseconds, otherwise.
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive queue timeout
*                                                                   successfully set.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_CfgTimeoutRxQ_Set(),
*               NetTCP_RxQ_TimeoutDflt().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).  See 'net_sock.c  NetSock_CfgTimeoutRxQ_Set()'.
*
* Note(s)     : (1) NetTCP_RxQ_TimeoutSet() is called by network protocol suite function(s) & may be
*                   called either with OR without the global network lock already acquired.
*
*                   See also 'net_sock.c  NetSock_CfgTimeoutRxQ_Set()  Note #2'.
*
*               (2) 'NetTCP_RxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
*                    critical sections.
*********************************************************************************************************
*/

void  NetTCP_RxQ_TimeoutSet (NET_TCP_CONN_ID   conn_id_tcp,
                             CPU_INT32U        timeout_ms,
                             NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_SR_ALLOC();



    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    CPU_CRITICAL_ENTER();
                                                                /* Set TCP connection receive queue timeout value.      */
    p_conn->RxQ_SignalTimeout_ms = timeout_ms;
    CPU_CRITICAL_EXIT();

   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                    NetTCP_RxQ_TimeoutGet_ms()
*
* Description : Get TCP connection receive queue timeout value.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to get receive queue timeout.
*               -----------     Argument checked in NetSock_CfgTimeoutRxQ_Get_ms().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive queue timeout
*                                                                   successfully returned.
*
* Return(s)   : TCP connection receive queue network timeout value :
*
*                   NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value configured.
*
*                   In number of milliseconds, otherwise.
*
* Caller(s)   : NetSock_CfgTimeoutRxQ_Get_ms().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).  See 'net_sock.c  NetSock_CfgTimeoutRxQ_Get_ms()'.
*
* Note(s)     : (1) NetTCP_RxQ_TimeoutGet_ms() is called by network protocol suite function(s) & may
*                   be called either with OR without the global network lock already acquired.
*
*                   See also 'net_sock.c  NetSock_CfgTimeoutRxQ_Get_ms()  Note #3'.
*
*               (2) 'NetTCP_RxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
*                    critical sections.
*********************************************************************************************************
*/

CPU_INT32U  NetTCP_RxQ_TimeoutGet_ms (NET_TCP_CONN_ID   conn_id_tcp,
                                      NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_INT32U     timeout_ms;
    CPU_SR_ALLOC();


    p_conn = &NetTCP_ConnTbl[conn_id_tcp];
    CPU_CRITICAL_ENTER();

                                                                /* Get TCP connection receive queue timeout value ...   */
                                                                /* ... (in OS ticks).                                   */
    timeout_ms = p_conn->RxQ_SignalTimeout_ms;
    CPU_CRITICAL_EXIT();

   *p_err = NET_TCP_ERR_NONE;

    return (timeout_ms);
}

/*
*********************************************************************************************************
*                                          NetTCP_TxQ_Clr()
*
* Description : Clear TCP connection transmit queue signal.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to clear transmit queue signal.
*               -----------     Argument validated in NetTCP_TxConnAppData(),
*                                                     NetTCP_ConnFreeHandler().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit queue signal
*                                                                   successfully cleared.
*                               NET_TCP_ERR_TX_Q_SIGNAL_CLR     TCP connection transmit queue signal
*                                                                   NOT          cleared.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnAppData(),
*               NetTCP_ConnFreeHandler().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_TxQ_Clr (NET_TCP_CONN_ID   conn_id_tcp,
                      NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    KAL_ERR        err_kal;


    p_conn = &NetTCP_ConnTbl[conn_id_tcp];


    KAL_SemSet(p_conn->TxQ_SignalObj, 0u, &err_kal);            /* Clear TCP connection transmit queue signal.          */
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;

        case KAL_ERR_NULL_PTR:
        case KAL_ERR_INVALID_ARG:
        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_TX_Q_SIGNAL_CLR;
             break;
    }
}


/*
*********************************************************************************************************
*                                         NetTCP_TxQ_Wait()
*
* Description : Wait on TCP connection transmit queue.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to wait on transmit queue.
*               -----------     Argument checked in NetTCP_TxConnAppData().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit queue NOT full.
*                               NET_TCP_ERR_TX_Q_FULL           TCP connection transmit queue still full
*                                                                   after timeout.
*                               NET_TCP_ERR_TX_Q_SIGNAL_ABORT   TCP connection transmit queue signal aborted;
*                                                                   TCP connection closed/aborted.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT   TCP connection transmit queue signal fault.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnAppData().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (1) (a) If timeouts NOT desired, wait on TCP connection transmit queue forever
*                       (i.e. do NOT exit).
*
*                   (b) If timeout      desired, return NET_TCP_ERR_TX_Q_FULL error on TCP connection
*                       transmit queue timeout.  Implement timeout with OS-dependent functionality.
*********************************************************************************************************
*/

void  NetTCP_TxQ_Wait (NET_TCP_CONN_ID   conn_id_tcp,
                       NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_INT32U     timeout_ms;
    KAL_ERR        err_kal;
    CPU_SR_ALLOC();


    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    CPU_CRITICAL_ENTER();
    timeout_ms = p_conn->TxQ_SignalTimeout_ms;
    CPU_CRITICAL_EXIT();
                                                                /* Wait on TCP connection transmit queue ...            */
                                                                /* ... with configured timeout (see Note #1b).          */
    KAL_SemPend(p_conn->TxQ_SignalObj, KAL_OPT_PEND_NONE, timeout_ms, &err_kal);
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;


        case KAL_ERR_TIMEOUT:
            *p_err = NET_TCP_ERR_TX_Q_FULL;                     /* See Note #1b.                                        */
             break;


        case KAL_ERR_ABORT:
            *p_err = NET_TCP_ERR_TX_Q_SIGNAL_ABORT;
             break;


        case KAL_ERR_ISR:
        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_TX_Q_SIGNAL_FAULT;
             break;
    }
}


/*
*********************************************************************************************************
*                                        NetTCP_TxQ_Signal()
*
* Description : Signal TCP connection transmit queue.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to signal transmit queue.
*               -----------     Argument validated in NetTCP_TxConnWinSizeHandlerCfgd().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit queue successfully
*                                                                   signaled.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT   TCP connection transmit queue signal fault.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeHandlerCfgd().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_TxQ_Signal (NET_TCP_CONN_ID   conn_id_tcp,
                         NET_ERR          *p_err)
{
    NET_CONN      *p_net_conn;
    NET_TCP_CONN  *p_tcp_conn;
    KAL_ERR        err_kal;


    p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];


                                                                /* Signal TCP connection transmit queue.                */
    KAL_SemPost(p_tcp_conn->TxQ_SignalObj, KAL_OPT_PEND_NONE, &err_kal);
    switch (err_kal) {
        case KAL_ERR_NONE:
            *p_err = NET_TCP_ERR_NONE;
             break;


        case KAL_ERR_OVF:
        case KAL_ERR_OS:
        default:
            *p_err = NET_TCP_ERR_TX_Q_SIGNAL_FAULT;
             break;
    }

    p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
    p_tcp_conn->FnctAppPostTx(p_net_conn->ID_App);
}


/*
*********************************************************************************************************
*                                         NetTCP_TxQ_Abort()
*
* Description : Abort wait on TCP connection transmit queue.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to abort wait on socket transmit queue.
*               -----------     Argument validated in NetTCP_ConnFreeHandler().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                Wait on TCP connection transmit queue
*                                                                   successfully aborted.
*                               NET_TCP_ERR_TX_Q_ABORT          TCP connection transmit queue abort failed.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnFreeHandler().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_TxQ_Abort (NET_TCP_CONN_ID   conn_id_tcp,
                        NET_ERR          *p_err)
{
    NET_CONN      *p_net_conn;
    NET_TCP_CONN  *p_tcp_conn;
    NET_CONN_ID    net_conn_id;
    KAL_ERR        err_kal;


    p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

                                                                /* Abort wait on TCP connection transmit queue ...      */
                                                                /* ... for ALL waiting tasks.                           */
   KAL_SemPendAbort(p_tcp_conn->TxQ_SignalObj, &err_kal);
   switch (err_kal) {
       case KAL_ERR_NONE:
           *p_err = NET_TCP_ERR_NONE;
            break;


       case KAL_ERR_OS:
       default:
           *p_err = NET_TCP_ERR_TX_Q_ABORT;
            break;
   }

   net_conn_id = p_tcp_conn->ID_Conn;
   if (net_conn_id != NET_CONN_ID_NONE) {
       p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
       p_tcp_conn->FnctAppPostRx(p_net_conn->ID_App);
   }
}


/*
*********************************************************************************************************
*                                      NetTCP_TxQ_TimeoutDflt()
*
* Description : Set TCP connection transmit queue to configured-default timeout value.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to set transmit queue configured-default
*   `           -----------         timeout.
*
*                               Argument checked in NetSock_CfgTimeoutTxQ_Dflt(),
*                                                   NetTCP_ConnClr(),
*                                                   NetTCP_Init().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit queue configured-
*                                                                   default timeout successfully set.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_CfgTimeoutTxQ_Dflt(),
*               NetTCP_ConnClr(),
*               NetTCP_Init().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).  See 'net_sock.c  NetSock_CfgTimeoutTxQ_Dflt()'.
*
* Note(s)     : (1) NetTCP_TxQ_TimeoutDflt() is called by network protocol suite function(s) &
*                   may be called either with OR without the global network lock already acquired.
*
*                   See also 'net_sock.c  NetSock_CfgTimeoutTxQ_Dflt()  Note #3'.
*********************************************************************************************************
*/

void  NetTCP_TxQ_TimeoutDflt (NET_TCP_CONN_ID   conn_id_tcp,
                              NET_ERR          *p_err)
{
    CPU_INT32U  timeout_ms;
                                                                /* Set TCP connection transmit queue timeout ...        */
                                                                /* ... to configured-default         timeout value.     */
    timeout_ms = NET_TCP_DFLT_TIMEOUT_CONN_TX_Q_MS;

    NetTCP_TxQ_TimeoutSet(conn_id_tcp, timeout_ms, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }

   *p_err = NET_TCP_ERR_NONE;
}

/*
*********************************************************************************************************
*                                      NetTCP_TxQ_TimeoutSet()
*
* Description : Set TCP connection transmit queue timeout value.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to set transmit queue timeout.
*               -----------     Argument checked in NetSock_CfgTimeoutTxQ_Set(),
*                                                   NetTCP_TxQ_TimeoutDflt().
*
*               timeout_ms      Timeout value :
*
*                                   NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value desired.
*
*                                   In number of milliseconds, otherwise.
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit queue timeout
*                                                                   successfully set.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_CfgTimeoutTxQ_Set(),
*               NetTCP_TxQ_TimeoutDflt().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).  See 'net_sock.c  NetSock_CfgTimeoutTxQ_Set()'.
*
* Note(s)     : (1) NetTCP_TxQ_TimeoutSet() is called by network protocol suite function(s) & may be
*                   called either with OR without the global network lock already acquired.
*
*                   See also 'net_sock.c  NetSock_CfgTimeoutTxQ_Set()  Note #3'.
*
*               (2) 'NetTCP_TxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
*                    critical sections.
*********************************************************************************************************
*/

void  NetTCP_TxQ_TimeoutSet (NET_TCP_CONN_ID   conn_id_tcp,
                             CPU_INT32U        timeout_ms,
                             NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_SR_ALLOC();


    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    CPU_CRITICAL_ENTER();
                                                                /* Set TCP connection transmit queue timeout value ...  */
                                                                /* ... (in OS ticks).                                   */
    p_conn->TxQ_SignalTimeout_ms = timeout_ms;
    CPU_CRITICAL_EXIT();

   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                     NetTCP_TxQ_TimeoutGet_ms()
*
* Description : Get TCP connection transmit queue timeout value.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to get transmit queue timeout.
*               -----------     Argument checked in NetSock_CfgTimeoutTxQ_Get_ms().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit queue timeout
*                                                                   successfully returned.
*
* Return(s)   : TCP connection transmit queue network timeout value :
*
*                   NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value configured.
*
*                   In number of milliseconds, otherwise.
*
* Caller(s)   : NetSock_CfgTimeoutTxQ_Get_ms().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).  See 'net_sock.c  NetSock_CfgTimeoutTxQ_Get_ms()'.
*
* Note(s)     : (1) NetTCP_TxQ_TimeoutGet_ms() is called by network protocol suite function(s) & may
*                   be called either with OR without the global network lock already acquired.
*
*                   See also 'net_sock.c  NetSock_CfgTimeoutTxQ_Get_ms()  Note #4'.
*
*               (2) 'NetTCP_TxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
*                    critical sections.
*********************************************************************************************************
*/

CPU_INT32U  NetTCP_TxQ_TimeoutGet_ms (NET_TCP_CONN_ID   conn_id_tcp,
                                      NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_INT32U     timeout_ms;
    CPU_SR_ALLOC();


    p_conn = &NetTCP_ConnTbl[conn_id_tcp];
    CPU_CRITICAL_ENTER();
                                                                /* Get TCP connection transmit queue timeout value ...  */
                                                                /* ... (in OS ticks).                                   */
    timeout_ms = p_conn->TxQ_SignalTimeout_ms;
    CPU_CRITICAL_EXIT();

   *p_err = NET_TCP_ERR_NONE;

    return (timeout_ms);
}


/*
*********************************************************************************************************
*                                             NetTCP_Rx()
*
* Description : (1) Process received segments & demultiplex to socket or application layer connection :
*
*                   (a) Validate    TCP packet
*                   (b) Demultiplex TCP packet to TCP connection
*                   (c) Handle/Process TCP segment
*                   (d) Return TCP error code(s)
*
*               (2) Although TCP data units are typically referred to as 'segments' (see RFC #793, Section 3.1),
*                   the term 'TCP packet' (see RFC #1983, 'packet') is used for TCP Receive until the packet is
*                   validated as a TCP segment.
*
*
* Argument(s) : p_buf        Pointer to network buffer that received TCP packet.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP segment successfully received & processed.
*
*                                                               ---- RETURNED BY NetTCP_RxPktDiscard() : -----
*                               NET_ERR_RX                      Receive error; packet discarded.
*
* Return(s)   : none.
*
* Caller(s)   : NetIP_RxPktDemuxDatagram().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (3) TCP receive statistics already updated in NetTCP_RxPktConnHandler(); do NOT re-update.
*
*                   (a) Network buffer already freed & error counter already incremented in previous
*                       function(s).
*
*                   See also 'NetTCP_RxPktConnHandler()  Note #2'.
*********************************************************************************************************
*/

void  NetTCP_Rx (NET_BUF  *p_buf,
                 NET_ERR  *p_err)
{
    NET_BUF_HDR  *p_buf_hdr;
    NET_TCP_HDR  *p_tcp_hdr;



#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------------- VALIDATE PTR ------------------- */
    if (p_buf == DEF_NULL) {
        NetTCP_RxPktDiscard(p_buf, p_err);
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }
#endif


    NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxPktCtr);


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
    p_buf_hdr = &p_buf->Hdr;
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NetTCP_RxPktValidateBuf(p_buf_hdr, p_err);                  /* Validate rx'd buf.                                   */
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
             break;


        case NET_ERR_INVALID_PROTOCOL:
        case NET_BUF_ERR_INVALID_TYPE:
        case NET_BUF_ERR_INVALID_IX:
        default:
             NetTCP_RxPktDiscard(p_buf, p_err);
             return;
    }
#endif
    p_tcp_hdr = (NET_TCP_HDR *)&p_buf->DataPtr[p_buf_hdr->TransportHdrIx];
    NetTCP_RxPktValidate(p_buf, p_buf_hdr, p_tcp_hdr, p_err);   /* Validate rx'd pkt.                                   */


                                                                /* -------------- DEMUX PKT TO TCP CONN --------------- */
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
             NetTCP_RxPktDemuxSeg(p_buf, p_buf_hdr, p_err);
             break;


        case NET_TCP_ERR_INVALID_PORT_NBR:
        case NET_TCP_ERR_INVALID_LEN_HDR:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_INVALID_LEN_DATA:
        case NET_TCP_ERR_INVALID_FLAG:
        case NET_TCP_ERR_INVALID_CHK_SUM:
        case NET_TCP_ERR_INVALID_OPT_LEN:
        case NET_TCP_ERR_INVALID_OPT_END:
        case NET_TCP_ERR_INVALID_OPT_NBR:
        default:
             NetTCP_RxPktDiscard(p_buf, p_err);
             return;
    }


                                                                /* --------------- HANDLE TCP PKT/CONN ---------------- */
    switch (*p_err) {                                           /* Chk err from NetTCP_RxPktDemuxSeg().                 */
        case NET_TCP_ERR_NONE:
             NetTCP_RxPktConnHandler(p_buf, p_buf_hdr, p_err);
             break;


        case NET_CONN_ERR_INVALID_FAMILY:
        case NET_CONN_ERR_INVALID_CONN:
        case NET_ERR_RX_DEST:
        default:
             NetTCP_RxPktDiscard(p_buf, p_err);
             return;
    }


                                                                /* ---------------- RTN TCP ERR CODES ----------------- */
    switch (*p_err) {                                           /* Chk err from NetTCP_RxPktConnHandler().              */
        case NET_TCP_ERR_NONE:
                                                                /* See Note #3.                                         */
             break;


        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_TCP_ERR_CONN_CLOSED:
        case NET_TCP_ERR_CONN_RESET_VALID:
            *p_err = NET_TCP_ERR_NONE;
             break;


        case NET_ERR_RX:
                                                                /* See Note #3a.                                        */
             return;


        case NET_INIT_ERR_NOT_COMPLETED:
        case NET_TCP_ERR_INVALID_CONN:
        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        default:
             NetTCP_RxPktDiscard(p_buf, p_err);
             return;
    }
}


/*
*********************************************************************************************************
*                                         NetTCP_RxAppData()
*
* Description : (1) Deframe application data from TCP connection's enqueued TCP segment(s) :
*
*                   (a) Wait on TCP connection application receive queue for packet buffer(s)
*                   (b) Deframe application data from enqueued TCP segment(s)
*                   (c) Update  TCP connection application receive queue
*                       (1) Free TCP packet buffer(s)
*                   (d) Update TCP connection receive window
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to receive application data.
*
*               pdata_buf       Pointer to application buffer to receive application data.
*               ---------       Argument validated in NetSock_RxDataHandlerStream().
*
*               data_buf_len    Size    of application receive buffer (in octets).
*               ------------    Argument validated in NetSock_RxDataHandlerStream().
*
*               flags           Flags to select receive options; bit-field flags logically OR'd :
*               -----
*                                   NET_TCP_FLAG_NONE               No      TCP receive flags selected.
*                                   NET_TCP_FLAG_RX_DATA_PEEK       Receive TCP application data without consuming
*                                                                       the data; i.e. data NOT removed from TCP
*                                                                       connection's application receive queue(s).
*                                   NET_TCP_FLAG_RX_BLOCK           Receive TCP application data with blocking,
*                                                                       if flag set; without blocking, if clear.
*
*                               Argument validated in NetSock_RxDataHandlerStream().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection application data successfully
*                                                                       deframed; check return value for number of
*                                                                       data octets received.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_CONN_DATA_INVALID       TCP connection application receive queue contains
*                                                                       invalid or improperly sequenced data.
*
*                               NET_TCP_ERR_RX_Q_CLOSED             TCP connection application receive queue closed
*                                                                       (see Note #2e3B).
*                               NET_TCP_ERR_RX_Q_EMPTY              TCP connection application receive queue empty
*                                                                       (see Note #2e2B).
*
*                                                                   ------- RETURNED BY NetTCP_ConnIsUsed() : -------
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
*                                                                   -------- RETURNED BY NetTCP_RxQ_Wait() : --------
*                               NET_TCP_ERR_RX_Q_SIGNAL_ABORT       TCP connection receive queue signal aborted;
*                                                                       TCP connection closed/aborted.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive queue signal fault.
*
*                                                                   ----- RETURNED BY Net_GlobalLockAcquire() : -----
*                               NET_ERR_FAULT_LOCK_ACQUIRE          Network access NOT acquired.
*
* Return(s)   : Total application data octets deframed into receive buffer, if NO error(s).
*
*               0,                                                          otherwise.
*
* Caller(s)   : NetSock_RxDataHandlerStream().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : RECEIVE Call' specifies how to handle receive
*                   data requests from the application layer :
*
*                   (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
*
*                   (b) (1) For the "LISTEN STATE, SYN-SENT STATE, SYN-RECEIVED STATE ... queue for processing
*                           after entering ESTABLISHED state".
*
*                       (2) The application layer may request to receive application data before the TCP
*                           connection enters the connected state.  Such requests will block or return
*                           no data.
*
*                           See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #1bA'
*                                  &  Note #4b2.
*
*                   (c) For the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE" :
*
*                       (1) "If insufficient incoming segments are queued to satisfy the request, queue
*                            the request."
*
*                       (2) "Reassemble queued incoming segments into receive buffer and return to user."
*
*                   (d) For the "CLOSE-WAIT STATE ... since the remote side has already sent FIN, RECEIVEs
*                       must be satisfied by the text already on hand, but not yet delivered to the user.
*                       If no text is awaiting delivery, the RECEIVE will get a 'error: connection closing'
*                       response.  Otherwise, any remaining text can be used to satisfy the RECEIVE".
*
*                   (e) (1) For the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE ... return 'error:
*                           connection closing'".
*
*                       (2) Typically, these states will have already received ALL remaining closing
*                           data from the closing remote host.
*
*                           (A) However, in case all receive data from the remote host has NOT yet been
*                               received, application layer receives from these states are permitted until
*                               the TCP connection's sequence receive state is closed & the TCP connection's
*                               application receive queue is empty.
*
*                           (B) If all receive data from the remote host has NOT yet been received but the
*                               application receive queue is currently empty, return application receive
*                               queue empty error(s).
*
*                       (3) Once a TCP connection has closed & ALL receive data has been received by the
*                           application layer :
*
*                           (A) Close the TCP connection;
*                           (B) Return application receive queue closed error.
*               (3) (a) RFC #793, Section 3.3 states that :
*
*                       (1) "Every octet of data sent over a TCP connection has a sequence number."
*                       (2) In addition, "SYN and FIN ... control information ... [is] implicitly assign[ed]
*                           sequence numbers ... [but] is not physically carried in the segment data space".
*
*                           (A) "For sequence number purposes, the SYN is considered to occur before the
*                                first actual data octet of the segment in which it occurs," ...
*                           (B) "While the FIN is considered to occur after the last actual data octet in
*                                a segment in which it occurs."
*
*                       (3) "The segment length (SEG.LEN) includes both data and sequence space occupying
*                            controls.
*
*
*                                   -----          -----------------------        Synchronization
*                                     ^            |  Initial SEQ #(SYN) |  <---  Sequence Number
*                                     |            -----------------------        (see Note #3a2A)
*                                     |            |    Data Octet #1    |  ---
*                                     |            |    Data Octet #2    |   ^
*                                                  |    Data Octet #3    |   |
*                               TCP Connection     |          .          |   |       Data Octet
*                                 Sequences        |          .          |   |   Sequence Number(s)
*                               (see Note #3a)     |          .          |   |    (see Note #3a1)
*                                                  | Data Octet #(N - 2) |   |
*                                     |            | Data Octet #(N - 1) |   v
*                                     |            | Data Octet #   N    |  ---       Closing
*                                     |            -----------------------        Sequence Number
*                                     v            |   Close SEQ #(FIN)  |  <---  (see Note #3a2B)
*                                   -----          -----------------------
*
*
*                       See also 'NetTCP_TxConnSync()   Note #3'
*                              & 'NetTCP_TxConnClose()  Note #2'.
*
*                   (b) Therefore, since TCP synchronization or close sequence numbers are NOT actual data
*                       sequences or octets that are transmitted or received; segments which include these
*                       TCP control sequence numbers MUST adjust TCP data sequence numbers & TCP segment
*                       lengths by these TCP control sequence numbers.
*
*                       (1) A TCP data segment MUST adjust its data index by the possible synchronization
*                           control sequence.
*
*                           (A) On a received TCP segment's first data read, the segment's base data index
*                               is NOT offset -- even though for a synchronization segment, this base data
*                               index starts on the sequence number following the synchronization control
*                               sequence.
*
*                           (B) On any additional received TCP segment data reads, the segment's base data
*                               index MUST be offset by possible synchronization control sequence.
*
*                       (2) TCP connections & TCP data segments MUST advance their sequence numbers & adjust
*                           their segment lengths by possible TCP control sequences.
*
*                           (A) A TCP connection MUST advance its sequence numbers by :
*
*                               (1) Possible synchronization sequence; but only on the first, initial access
*                                   to a TCP synchronization segment; ...
*                               (2) All accessed data sequence(s);    ...
*                               (3) Possible closing         sequence; which SHOULD only occur once on the
*                                   last access to a TCP closing segment.
*
*                           (B) (1) A received TCP segment MUST advance its sequence numbers by :
*
*                                   (a) Possible synchronization sequence; but only on the first, initial
*                                       access to a TCP synchronization segment; ...
*                                   (b) All accessed data sequence(s).
*
*                               (2) (a) A received TCP segment MUST adjust its total segment length by :
*
*                                       (1) Possible synchronization sequence; but only on the first, initial
*                                           access to a TCP synchronization segment; ...
*                                       (2) All accessed data sequence(s).
*
*                                       (3) Possible closing         sequence adjustment MAY be ignored since
*                                           all effective segment data handling occurs prior to accessing any
*                                           trailing closing sequence.
*
*                                   (b) A received TCP segment MUST adjust its data  segment length ONLY by :
*
*                                       (b) All accessed data sequence(s).
*               (4) (a) Stream-type connections receive all data octets in one or more non-distinct packets.
*                       In other words, the application data is NOT bounded by any specific packet(s); rather,
*                       it is contiguous & sequenced from one packet to the next.
*
*                   (b) Therefore, the TCP connection receive queue is signaled ONLY when data is received for
*                       a connection where data was previously unavailable.
*
*                   (c) Consequently, it is typical -- but NOT absolutely required -- that a single application
*                       task only receive or request to receive application data from a TCP connection.
*
*                   See also 'net_sock.c  NetSock_RxDataHandlerStream()  Note #2'.
*
*               (5) Since pointer arithmetic is based on the specific pointer data type & inherent pointer
*                   data type size, pointer arithmetic operands :
*
*                   (a) MUST be in terms of the specific pointer data type & data type size; ...
*                   (b) SHOULD NOT & in some cases MUST NOT be cast to other data types or data type sizes.
*
*               (6) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that "the window
*                   sent in each segment indicates the range of sequence numbers the sender of the window
*                   (the data receiver) is currently prepared to accept.  There is an assumption that this
*                   is related to the currently available data buffer space available for this connection
*                   ... One strategy would be to ... [update the] information when the window is larger".
*
*                   See also 'NetTCP_RxPktConnHandlerRxQ_Sync()  Note #5',
*                            'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #6',
*                          & 'NetTCP_RxConnWinSizeHandler()      Note #2a'.
*
*               (7) (a) Since segments enqueued to a TCP connection's application receive queue have
*                       already been acknowledged to the remote host & since no mechanism exists for a TCP
*                       connection to re-request previously acknowledged segments, any TCP connection whose
*                       application receive queue becomes corrupted MUST be closed to prevent the application
*                       layer from receiving the corrupted data.
*
*                   (b) For any internal errors where the TCP connection's application receive queue is NOT
*                       corrupted, the TCP connection is NOT closed.  Thus the application layer may try to
*                       re-receive the application data.
*
*                       However, a TCP connection may deadlock due to persistent internal errors -- i.e. the
*                       internal errors prevent the TCP connection from deframing application data from the
*                       application receive queue which also prevents the TCP connection from receiving
*                       additional application data.  Thus exception handling code in the application layer
*                       SHOULD eventually detect & close any TCP connection deadlocked due to internal errors.
*********************************************************************************************************
*/

CPU_INT16U  NetTCP_RxAppData (NET_TCP_CONN_ID   conn_id_tcp,
                              void             *pdata_buf,
                              CPU_INT16U        data_buf_len,
                              NET_TCP_FLAGS     flags,
                              NET_ERR          *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_SEG_SIZE   seg_len_close      = 0u;
    NET_TCP_SEQ_NBR    seq_nbr_cur        = 0u;
#endif
    CPU_BOOLEAN        block              = DEF_NO;
    CPU_BOOLEAN        q_closed           = DEF_NO;
    CPU_BOOLEAN        q_closed_empty     = DEF_NO;
    CPU_BOOLEAN        q_prevly_empty     = DEF_NO;
    CPU_BOOLEAN        peek               = DEF_NO;
    CPU_BOOLEAN        frag_adv           = DEF_NO;
    NET_TCP_CONN      *p_conn             = DEF_NULL;
    NET_BUF           *p_buf_head         = DEF_NULL;
    NET_BUF           *p_buf_seg          = DEF_NULL;
    NET_BUF           *p_buf_seg_prev     = DEF_NULL;
    NET_BUF           *p_buf_seg_next     = DEF_NULL;
    NET_BUF           *p_buf_frag         = DEF_NULL;
    NET_BUF           *p_buf_frag_next    = DEF_NULL;
    NET_BUF_HDR       *p_buf_seg_hdr      = DEF_NULL;
    NET_BUF_HDR       *p_buf_seg_prev_hdr = DEF_NULL;
    NET_BUF_HDR       *p_buf_seg_next_hdr = DEF_NULL;
    NET_BUF_HDR       *p_buf_frag_hdr     = DEF_NULL;
    CPU_INT08U        *p_data             = DEF_NULL;
    NET_BUF_SIZE       data_ix_frag       = 0u;
    NET_BUF_SIZE       data_ix_pkt        = 0u;
    NET_BUF_SIZE       data_len_pkt       = 0u;
    CPU_INT16U         data_len_buf_rem   = 0u;
    CPU_INT16U         data_len_tot       = 0u;
    NET_TCP_SEG_SIZE   seg_len_avail      = 0u;
    NET_TCP_SEG_SIZE   seg_len_data       = 0u;
    NET_TCP_SEG_SIZE   seg_len_data_rem   = 0u;
    NET_TCP_SEG_SIZE   seg_len_data_tot   = 0u;
    NET_TCP_SEG_SIZE   seg_len_sync       = 0u;
    NET_TCP_SEG_SIZE   seg_len_sync_init  = 0u;
    NET_TCP_SEQ_NBR    seq_nbr_init       = 0u;
    NET_TCP_SEQ_NBR    seq_nbr_ix         = 0u;
    NET_BUF_QTY        buf_nbr_freed      = 0u;
    NET_ERR            err                = NET_ERR_NONE;



#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return (0u);
    }
#endif

                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    p_conn    = &NetTCP_ConnTbl[conn_id_tcp];
    q_closed =  DEF_NO;

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (0u);


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #2a.                                        */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (0u);


        case NET_TCP_CONN_STATE_LISTEN:                         /* See Note #2b.                                        */
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:                           /* See Note #2c.                                        */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
             break;


        case NET_TCP_CONN_STATE_CLOSE_WAIT:                     /* See Note #2d.                                        */
        case NET_TCP_CONN_STATE_CLOSING:                        /* See Note #2e.                                        */
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:             /* See Note #2e3.                                       */
             if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED) {
                 q_closed = DEF_YES;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (0u);
    }



                                                                /* ------------ WAIT ON TCP CONN APP RX Q ------------- */
    if (p_conn->RxQ_App_Head == DEF_NULL) {                     /* If no rx'd data pkts;                           ...  */
        if (q_closed != DEF_NO) {                               /* ... & rx q closed             (see Note #2e3),  ...  */
            if (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL) {
                                                                /* ... close data-avail TCP conn (see Note #2e3A)  ...  */
                NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            }

           *p_err =  NET_TCP_ERR_RX_Q_CLOSED;                   /* ... & rtn rx Q closed err     (see Note #2e3B); ...  */
            return (0u);
        }

        block = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_RX_BLOCK);
        if (block != DEF_YES) {                                 /* ... & non-blocking rx,                          ...  */
           *p_err =  NET_TCP_ERR_RX_Q_EMPTY;                    /* ... rtn rx Q empty err.                              */
            return (0u);
        }

        Net_GlobalLockRelease();
        NetTCP_RxQ_Wait(conn_id_tcp, p_err);
        Net_GlobalLockAcquire((void *)&NetTCP_RxAppData, &err);
        if (err != NET_ERR_NONE) {
            *p_err  = err;                                      /* Rtn err from Net_GlobalLockAcquire().                */
             return (0u);
        }

        if (*p_err != NET_TCP_ERR_NONE) {
             return (0u);                                       /* Rtn err from NetTCP_RxQ_Wait().                      */
        }

        if (p_conn->RxQ_App_Head == DEF_NULL) {                 /* If still NO rx'd data pkts, ...                      */
           *p_err =  NET_TCP_ERR_RX_Q_EMPTY;                    /* ... rtn rx Q empty err.                              */
            return (0u);
        }

        q_prevly_empty = DEF_YES;

    } else {
        NetTCP_RxQ_Clr(conn_id_tcp, &err);                      /* Clr any possible async rx Q signal.                  */
        q_prevly_empty = DEF_NO;
    }



                                                                /* ----------- DEFRAME TCP CONN RX APP DATA ----------- */
    p_buf_head         = (NET_BUF       *)p_conn->RxQ_App_Head;
    p_buf_seg          = (NET_BUF       *)p_buf_head;
    p_buf_seg_prev     = (NET_BUF       *)0;
    p_data            = (CPU_INT08U    *)pdata_buf;
    data_len_buf_rem  = (CPU_INT16U     )data_buf_len;
    data_len_tot      = (CPU_INT16U     )0u;
    p_buf_seg_next     = (NET_BUF       *)0;
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    p_buf_seg_hdr      = (NET_BUF_HDR   *)&p_buf_seg->Hdr;
    seq_nbr_cur       = (NET_TCP_SEQ_NBR) p_buf_seg_hdr->TCP_SeqNbr;
#endif

    while ((p_buf_seg != DEF_NULL) &&                           /* Copy app rx data from TCP conn q'd seg(s).           */
           (data_len_buf_rem     > 0)) {

        p_buf_seg_hdr  = &p_buf_seg->Hdr;
        p_buf_seg_next =  p_buf_seg_hdr->NextPrimListPtr;
        p_buf_frag     =  p_buf_seg;

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        if (seq_nbr_cur != p_buf_seg_hdr->TCP_SeqNbr) {         /* If next q'd seg's seq nbr NOT consecutive, ...       */
                                                                /* ... close TCP conn (see Note #7a).                   */
            NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                             (NET_BUF_HDR      *)0,
                             (CPU_BOOLEAN       )DEF_YES,
                             (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
           *p_err =  NET_TCP_ERR_CONN_DATA_INVALID;
            return (0u);
        }
#endif
                                                                /* Init seg lens.                                       */
        seg_len_data      = p_buf_seg_hdr->TCP_SegLenData;
        seg_len_data_rem  = seg_len_data;
        seg_len_data_tot  = 0u;

        seg_len_sync      = 0u;
        seg_len_sync_init = 0u;
        if (p_buf_seg_hdr->TCP_SegSync  == DEF_YES) {
            seg_len_sync  = NET_TCP_SEG_LEN_SYNC;
        }
                                                                /* If still init seg len, cfg init sync seg len.        */
        if (p_buf_seg_hdr->TCP_SegLen == p_buf_seg_hdr->TCP_SegLenInit) {
            seg_len_sync_init = seg_len_sync;
        }

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        seg_len_close     = 0u;
        if (p_buf_seg_hdr->TCP_SegClose == DEF_YES) {
            seg_len_close = NET_TCP_SEG_LEN_CLOSE;
        }
#endif
                                                                /* Calc start seq nbr ix into seg data (see Note #3b1). */
        seq_nbr_init = (NET_TCP_SEQ_NBR)(p_buf_seg_hdr->TCP_SeqNbrInit + seg_len_sync - seg_len_sync_init);
        seq_nbr_ix   = (NET_TCP_SEQ_NBR)(p_buf_seg_hdr->TCP_SeqNbr     - seq_nbr_init);
        data_ix_frag = (NET_BUF_SIZE   ) seq_nbr_ix;

        frag_adv     =  DEF_YES;

        while ((p_buf_frag != DEF_NULL) &&
               (frag_adv   == DEF_YES )) {

            p_buf_frag_hdr  = &p_buf_frag->Hdr;
                                                                /* While seg's frag data ix >= cur frag data len ...    */
            if (data_ix_frag >= p_buf_frag_hdr->DataLen) {
                data_ix_frag   -= p_buf_frag_hdr->DataLen;
                p_buf_frag_next = p_buf_frag_hdr->NextBufPtr;
                p_buf_frag      = p_buf_frag_next;              /* ... adv to next seg frag.                            */

            } else {
                frag_adv       =  DEF_NO;
            }
        }


        while ((p_buf_frag       != DEF_NULL) &&                /* Copy app rx data from avail seg pkt buf(s).          */
               (data_len_buf_rem  > 0)        &&
               (seg_len_data_rem  > 0)       ) {

            p_buf_frag_hdr  = &p_buf_frag->Hdr;
            p_buf_frag_next =  p_buf_frag_hdr->NextBufPtr;

            seg_len_avail  = (NET_TCP_SEG_SIZE)(p_buf_frag_hdr->DataLen - data_ix_frag);
            if (seg_len_avail > seg_len_data_rem) {             /* If seg frag pkt data len > rem seg len, ...          */
                seg_len_avail = seg_len_data_rem;               /* ... lim copy to rem seg len.                         */
            }

            data_len_pkt =  DEF_MIN((NET_BUF_SIZE)data_len_buf_rem, /* Lim copy to min of rem'ing data buf len ...      */
                                    (NET_BUF_SIZE)seg_len_avail); /* ... or avail seg len.                              */
                                                                /* Calc ix into seg frag's data.                        */
            data_ix_pkt  = (NET_BUF_SIZE)p_buf_frag_hdr->DataIx + data_ix_frag;
            data_ix_frag =  0u;

            NetBuf_DataRd((NET_BUF    *) p_buf_frag,
                          (NET_BUF_SIZE) data_ix_pkt,
                          (NET_BUF_SIZE) data_len_pkt,
                          (CPU_INT08U *) p_data,
                          (NET_ERR    *)&err);
            if ( err != NET_BUF_ERR_NONE) {                     /* See Note #6b.                                        */
               *p_err  = NET_TCP_ERR_CONN_FAIL;
                return (0u);
            }
                                                                /* Update data ptr & lens.                              */
            p_data           +=             data_len_pkt;       /* MUST NOT cast ptr operand (see Note #5b).            */
            data_len_tot     += (CPU_INT16U)data_len_pkt;
            data_len_buf_rem -= (CPU_INT16U)data_len_pkt;
            seg_len_data_tot += (CPU_INT16U)data_len_pkt;
            seg_len_data_rem -= (CPU_INT16U)data_len_pkt;

            p_buf_frag         =  p_buf_frag_next;
        }

        if (data_len_buf_rem > 0) {                             /* If rem data buf len > 0, ...                         */
            p_buf_seg_prev = p_buf_seg;
            p_buf_seg      = p_buf_seg_next;                    /* ... adv to next q'd seg.                             */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
            if (seg_len_data_tot != seg_len_data) {             /* If calc'd seg data len != actual seg data len, ...   */
                                                                /* ... close TCP conn (see Note #7a).                   */
                NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                 (NET_BUF_HDR      *)0,
                                 (CPU_BOOLEAN       )DEF_YES,
                                 (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
               *p_err =  NET_TCP_ERR_CONN_DATA_INVALID;
                return (0u);
            }
                                                                /* Adv seq nbr by cur seg's :                ...        */
            seq_nbr_cur += (NET_TCP_SEQ_NBR)seg_len_sync_init;  /* ... init sync  seg len (see Note #3b2A1), ...        */
            seq_nbr_cur += (NET_TCP_SEQ_NBR)seg_len_data;       /* ...      data  seg len (see Note #3b2A2), ...        */
            seq_nbr_cur += (NET_TCP_SEQ_NBR)seg_len_close;      /* ...    & close seg len (see Note #3b2A3).            */
#endif
        }
    }

    q_closed_empty = ((q_closed != DEF_NO) &&                   /* Chk rx q closed ...                                  */
                      (data_len_tot < 1)) ? DEF_YES : DEF_NO;   /* ... & empty (i.e. no rx'd data).                     */



                                                                /* ------------- UPDATE TCP CONN APP RX Q ------------- */
    peek = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_RX_DATA_PEEK);
    if (peek == DEF_YES) {                                      /* If peek opt req'd                      ...           */
        if (q_prevly_empty == DEF_YES) {                        /* ... & TCP conn app rx Q prev'ly empty, ...           */
            NetTCP_RxQ_Signal(conn_id_tcp, &err);               /* ...     signal app rx Q                ...           */
                                                                /* ... to negate non-consuming peek (see Note #4b).     */
            if (err != NET_TCP_ERR_NONE) {                      /* If app rx Q signal failed, ...                       */
                peek = DEF_NO;                                  /* ... consume pkt buf(s).                              */
            }
        }
    }

    if ((peek != DEF_YES) ||                                    /* If peek opt NOT req'd                         ..     */
        (q_closed_empty != DEF_NO)) {                           /* .. or rx q closed & empty, unlink ALL seg pkt ..     */
                                                                /* .. buf(s) whose data was entirely consumed.          */


        if (p_buf_seg != DEF_NULL) {                            /* If TCP conn app rx Q NOT empty after data rd(s)      */
            if (seg_len_data_rem > 0) {                         /* .. & cur seg's rem data len > 0;              ..     */
                p_buf_seg_hdr->PrevPrimListPtr = DEF_NULL;      /* ..   unlink from prev q'd seg(s),             ..     */
                p_conn->RxQ_App_Head           = p_buf_seg;     /* ..   set new TCP conn app rx Q head,          ..     */
                                                                /* .. & update seg's seq nbr  (see Note #3b2B1)  ..     */
                p_buf_seg_hdr->TCP_SeqNbr     += (seg_len_data_tot + seg_len_sync_init);
                                                                /* ..        & seg's seg lens (see Note #3b2B2).        */
                p_buf_seg_hdr->TCP_SegLen     -= (seg_len_data_tot + seg_len_sync_init);
                p_buf_seg_hdr->TCP_SegLenData -=  seg_len_data_tot;

                if (p_buf_seg_prev != DEF_NULL) {               /* If prev q'd seg(s) avail, ...                        */
                                                                /* ... unlink from app rx Q  ...                        */
                    p_buf_seg_prev_hdr                  = &p_buf_seg_prev->Hdr;
                    p_buf_seg_prev_hdr->NextPrimListPtr = DEF_NULL;
                    buf_nbr_freed += NetTCP_RxPktFree(p_buf_head); /* ... & free ALL rd seg pkt buf(s).                 */
                }

            } else {                                            /* Else if cur seg's rem data len = 0     ...           */
                if (p_buf_seg_next != DEF_NULL) {               /* ... &    rem rx q'd seg(s) avail,      ...           */
                                                                /* ... unlink cur seg from rem q'd seg(s) ...           */
                    p_buf_seg_next_hdr                  = &p_buf_seg_next->Hdr;
                    p_buf_seg_next_hdr->PrevPrimListPtr = DEF_NULL;
                    p_buf_seg_hdr->NextPrimListPtr      = DEF_NULL;
                                                                /* ... set new TCP conn app rx Q head;    ...           */
                    p_conn->RxQ_App_Head                = p_buf_seg_next;


                } else {                                        /* ... & NO rem rx q'd seg(s) avail,      ...           */
                                                                /* ... unlink  ALL q'd seg(s);            ...           */
                    p_conn->RxQ_App_Head                = DEF_NULL;
                    p_conn->RxQ_App_Tail                = DEF_NULL;
                }

                buf_nbr_freed += NetTCP_RxPktFree(p_buf_head);  /* ... & free rd  seg pkt buf(s) from app rx Q.         */
            }

        } else {                                                /* Else clr app rx Q ...                                */
            p_conn->RxQ_App_Head = DEF_NULL;
            p_conn->RxQ_App_Tail = DEF_NULL;

            buf_nbr_freed += NetTCP_RxPktFree(p_buf_head);      /* ... & free ALL seg pkt buf(s) from app rx Q.         */
        }

                                                                /* ----------- UPDATE TCP CONN RX WIN SIZE ------------ */
                                                                /* Inc TCP conn's rx win size (see Note #6).            */
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
        NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, data_len_tot, NET_TCP_CONN_RX_WIN_INC);
#else
        NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, buf_nbr_freed, NET_TCP_CONN_RX_WIN_INC);
#endif
    }


    if (q_closed_empty != DEF_NO) {                             /* If rx q closed & empty,                       ..     */
        if (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL) {
                                                                /* .. close data-avail TCP conn (see Note #2e3A) ..     */
            NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        }

       *p_err =  NET_TCP_ERR_RX_Q_CLOSED;                       /* .. & rtn rx Q closed err     (see Note #2e3B).       */
        return (0u);
    }


#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
    (void)&buf_nbr_freed;
#endif


   *p_err =  NET_TCP_ERR_NONE;

    return (data_len_tot);
}


/*
*********************************************************************************************************
*                                         NetTCP_TxConnReq()
*
* Description : (1) Transmit TCP connection request :
*
*                   (a) Update   TCP connection state
*                   (b) Transmit TCP connection request
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to transmit connection request.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   ---- RETURNED BY NetTCP_ConnIsUsed() : -----
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
*                                                                   ---- RETURNED BY NetTCP_TxConnSync() : -----
*                               NET_TCP_ERR_NONE                    TCP connection request successfully
*                                                                       transmitted.
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_TX                              Transmit        error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN                Network  interface link state down (i.e.
*                                                                       NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_ConnHandlerStream().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).
*
* Note(s)     : (2) On ANY error(s), return error to TCP connection caller & allow caller to retry or close
*                   connection(s) but do NOT close TCP connection.
*********************************************************************************************************
*/

void  NetTCP_TxConnReq (NET_TCP_CONN_ID   conn_id_tcp,
                        NET_ERR          *p_err)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CONN_STATE   state;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
#endif

    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_CONN_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
#endif


                                                                /* -------------- UPDATE TCP CONN STATE --------------- */
    state             = p_conn->ConnState;
    p_conn->ConnState = NET_TCP_CONN_STATE_SYNC_TXD;


                                                                /* ----------------- TX TCP CONN REQ ------------------ */
    NetTCP_TxConnSync((NET_TCP_CONN     *)p_conn,
                      (NET_BUF_HDR      *)0,
                      (NET_TCP_CONN_STATE)state,
                      (NET_ERR          *)p_err);
    if (*p_err != NET_TCP_ERR_NONE) {                           /* See Note #2.                                         */
         return;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                       NetTCP_TxConnReqClose()
*
* Description : (1) Transmit TCP connection close :
*
*                   (a) Handle TCP connection close                             See Note #2a
*                   (b) Update TCP connection timer                             See Note #2b
*
*
* Argument(s) : conn_id_tcp         Handle identifier of TCP connection to transmit connection close.
*
*               conn_close_code     Indicate whether to close transport connection :
*
*                                       NET_CONN_CLOSE_FULL         Close TCP connection but do NOT allow
*                                                                       closing receive data to be available.
*                                       NET_CONN_CLOSE_HALF         Close TCP connection but        allow
*                                                                       closing receive data to be available.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection close successfully transmitted
*                                                                       or queued for transmit.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid network connection handle identifier.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   ------ RETURNED BY NetTCP_ConnIsUsed() : -------
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
*                                                                   ------ RETURNED BY NetTCP_TxConnClose() : ------
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_ACK_NONE           TCP connection acknowledgement NOT requested.
*                               NET_TCP_ERR_CONN_ACK_DLYD           TCP connection acknowledgement transmit delayed.
*                               NET_TCP_ERR_CONN_ACK_PREVLY_TXD     TCP connection acknowledgement previously
*                                                                       transmitted for segment.
*                               NET_TCP_ERR_CONN_ACK_INVALID        TCP connection acknowledgement NOT valid for
*                                                                       current TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_CloseHandlerStream().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).
*
* Note(s)     : (2) (a) RFC #793, Section 3.9 'Event Processing : CLOSE Call' specifies how to handle
*                       close requests from the application layer :
*
*                       (1) For the "CLOSED STATE ... return 'error: connection does not exist'".
*
*                       (2) For the "LISTEN STATE ... any outstanding RECEIVEs are returned with 'error:
*                           closing' responses.  Delete TCB [and] enter CLOSED state".
*
*                       (3) For the "SYN-SENT STATE ... Delete the TCB and return 'error: closing'
*                           responses to any queued SENDs, or RECEIVEs".
*
*                       (4) For the "SYN-RECEIVED STATE" :
*
*                           (A) "If no SENDs have been issued and there is no pending data to send," ...
*                               (1) "then form a FIN segment and send it,"                           ...
*                               (2) "and enter FIN-WAIT-1 state;"                                    ...
*
*                           (B) "Otherwise queue for processing after entering ESTABLISHED state."
*
*                       (5) For the "ESTABLISHED STATE" :
*
*                           (A) "Queue this until all preceding SENDs have been segmentized," ...
*                           (B) "then form a FIN segment and send it"                         ...
*                           (C) "In any case, enter FIN-WAIT-1 state."
*
*                       (6) For the "FIN-WAIT-1 STATE, FIN-WAIT-2 STATE" :
*
*                           (A) "Strictly speaking, this is an error and should receive a 'error: connection
*                                closing' response."
*
*                           (B) "An 'ok' response would be acceptable, too, as long as a second FIN is not
*                                emitted (the first FIN may be retransmitted though)."
*
*                       (7) For the "CLOSE-WAIT STATE" :
*
*                           (A) "Queue this request until all preceding SENDs have been segmentized;" ...
*                           (B) "then send a FIN segment,"                                            ...
*                           (C) (1) "Enter CLOSING state."
*                               (2) RFC #1122, Section 4.2.2.20.(a) amends the state transition to "enter
*                                   LAST-ACK state, not CLOSING".
*
*                       (8) For the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE ... respond with 'error:
*                           connection closing'".
*
*                   (b) RFC #793, Section 3.9 'Event Processing : CLOSE Call' does NOT specify which timeout
*                       values to set for each state transition to closing state(s).
*
*                       #### Therefore, the following timeout values will be used for the following close
*                       state transitions :
*
*                       (1) SYN-RECEIVED STATE  ->  FIN-WAIT-1 STATE                TCP Connection timeout
*                           See also 'NetTCP_RxPktConnHandlerSyncRxd()  Note #3'.
*
*                       (2) ESTABLISHED  STATE  ->  FIN-WAIT-1 STATE                TCP Connection timeout
*                           See also 'NetTCP_RxPktConnHandlerConn()     Note #3'.
*
*                       (3) CLOSE-WAIT   STATE  ->  LAST-ACK   STATE                TCP Time-Wait / Two TCP Maximum
*                                                                                       Segment Lifetimes timeout
*                           See also 'NetTCP_RxPktConnHandlerLastAck()  Note #3'.
*
*                   (c) RFC #1122, Section 4.2.2.13 states that "a TCP connection may terminate in two ways" :
*
*                       (1) "The normal TCP close sequence using a FIN handshake."
*                       (2) "An 'abort' in which one or more RST segments are sent and the connection state
*                            is immediately discarded."
*
*               (3) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the user's
*                       CLOSE can be acknowledged".
*
*                   (b) However, TCP connection should signal the application layer that "the user's close
*                       [is] acknowledged" whenever its re-transmit queue becomes &/or is empty :
*
*                       (1) Transition from LISTEN   to CLOSED
*                       (2) Transition from SYN-SENT to CLOSED
*
*                   See also 'NetTCP_RxPktConnHandlerSignalClose()  Note #1'.
*
*               (4) On ANY error(s), network resources MUST be appropriately freed :
*
*                   (a) Close the TCP connection.
*********************************************************************************************************
*/

void  NetTCP_TxConnReqClose (NET_TCP_CONN_ID   conn_id_tcp,
                             CPU_INT08U        conn_close_code,
                             NET_ERR          *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    CPU_BOOLEAN          used;
    NET_CONN_ID          conn_id;
    NET_CONN_ID          conn_id_transport;
#endif
    NET_TCP_CONN        *p_conn;
    NET_TCP_CONN_STATE   state;
    NET_TMR_TICK         timeout_tick;
    NET_ERR              err;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
#endif

    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* VALIDATE CONN IDs                                    */
    conn_id = p_conn->ID_Conn;
    used    = NetConn_IsUsed(conn_id, &err);
    if (used != DEF_YES) {
       *p_err = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }

    conn_id_transport =  NetConn_ID_TransportGet(conn_id, &err);
    if (conn_id_tcp  != (NET_TCP_CONN_ID)conn_id_transport) {
       *p_err = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }
#endif


                                                                /* -------------- HANDLE TCP CONN CLOSE --------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #2a1.                                       */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_LISTEN:                         /* See Note #2a2.                                       */
        case NET_TCP_CONN_STATE_SYNC_TXD:                       /* See Note #2a3.                                       */
                                                                /* Signal app conn close (see Note #3b) ...             */
             NetTCP_RxPktConnHandlerSignalClose(p_conn, DEF_NO, &err);
                                                                /* ... & close TCP conn.                                */
             NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_NONE;
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Note #2a4.                                       */
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_CONN:                           /* See Note #2a5.                                       */
                                                                /* Enter fin-wait-1 state  (see Note #2a5C),        ... */
             state                = p_conn->ConnState;
             p_conn->ConnState     = NET_TCP_CONN_STATE_FIN_WAIT_1;
             p_conn->TxQ_State     = NET_TCP_TX_Q_STATE_CLOSING;
             p_conn->ConnCloseCode = conn_close_code;
             timeout_tick         = p_conn->TimeoutConn_tick;   /* ... reset conn tmr      (see Notes #2b1 & #2b2), ... */

             NetTCP_TxConnClose(p_conn, state, p_err);          /* ... & tx TCP conn close (see Note #2a5B).            */
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;


        case NET_TCP_CONN_STATE_CLOSE_WAIT:                     /* See Note #2a7.                                       */
                                                                /* Enter last-ack state    (see Note #2a7C2), ...       */
             state                 = p_conn->ConnState;
             p_conn->ConnState     = NET_TCP_CONN_STATE_LAST_ACK;
             p_conn->TxQ_State     = NET_TCP_TX_Q_STATE_CLOSING;
             p_conn->ConnCloseCode = conn_close_code;
                                                                /* ... start time-wait tmr (see Note #2b3),   ...       */
             timeout_tick          = p_conn->TimeoutConn_tick;

             NetTCP_TxConnClose(p_conn, state, p_err);          /* ... & tx TCP conn close (see Note #2a7B).            */
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;


        case NET_TCP_CONN_STATE_FIN_WAIT_1:                     /* See Note #2a6.                                       */
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:                      /* See Note #2a8.                                       */
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


                                                                /* -------------------- UPDATE TMR -------------------- */
    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if (err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                         (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_TCP_ERR_CONN_FAIL;
        return;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                       NetTCP_TxConnAppData()
*
* Description : (1) Prepare & transmit data from Application layer(s) via TCP connection :
*
*                   (a) Validate application data
*
*                   (b) Transmit application data via TCP Transmit :
*                       (1) Validate TCP connection
*                       (2) Wait on  TCP connection transmit queue
*                       (3) Prepare  TCP data segment(s) :
*                           (A) TCP segment addresses
*                           (B) Prepare application data :
*                               (1) Get buffer(s) for application data
*                               (2) Copy application data into TCP packet buffer(s)
*                               (3) Update TCP segment data controls
*                               (4) Update application data controls
*                       (4) Update TCP connection transmit window
*
*                   (c) Update TCP connection :
*                       (1) Append TCP transmit segment(s) to TCP connection transmit queue
*                       (2) Update TCP connection sequence number(s)
*
*                   (d) Transmit TCP data segment(s) via TCP Transmit
*
*
* Argument(s) : conn_id_tcp     Handle identifier of connection to transmit application data.
*
*               p_data          Pointer to application data.
*               ------          Argument validated in NetSock_TxDataHandlerStream().
*
*               data_len        Length  of application data (in octets) [see Note #4].
*               --------        Argument validated in NetSock_TxDataHandlerStream().
*
*               flags           Flags to select transmit options; bit-field flags logically OR'd :
*               -----
*                                   NET_TCP_FLAG_NONE               No       TCP transmit flags selected.
*                                   NET_TCP_FLAG_TX_BLOCK           Transmit TCP application data with blocking,
*                                                                       if flag set; without blocking, if clear.
*
*                               Argument validated in NetSock_TxDataHandlerStream().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Application data successfully prepared &
*                                                                       transmitted via TCP layer.
*                               NET_ERR_FAULT_NULL_PTR                Argument 'p_data'   passed a NULL pointer.
*                               NET_TCP_ERR_INVALID_DATA_SIZE       Argument 'data_len' passed an invalid size.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_CONN_DATA_INVALID       TCP connection application transmit queue contains
*                                                                       invalid or improperly sequenced data.
*                               NET_TCP_ERR_TX_Q_FULL               TCP connection transmit queue full.
*                               NET_TCP_ERR_TX_Q_SUSPEND            TCP connection transmit queue temporarily suspended.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   -------- RETURNED BY NetTCP_ConnIsUsed() : ---------
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
*                                                                   ---------- RETURNED BY NetTCP_TxQ_Wait() : ---------
*                               NET_TCP_ERR_TX_Q_SIGNAL_ABORT       TCP connection transmit queue signal aborted;
*                                                                       TCP connection closed/aborted.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*
*                                                                   -------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_ACK_NONE           TCP connection acknowledgement NOT requested.
*                               NET_TCP_ERR_CONN_ACK_DLYD           TCP connection acknowledgement transmit delayed.
*                               NET_TCP_ERR_CONN_ACK_PREVLY_TXD     TCP connection acknowledgement previously
*                                                                       transmitted for segment.
*                               NET_TCP_ERR_CONN_ACK_INVALID        TCP connection acknowledgement NOT valid for
*                                                                       current TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_TX                              Transmit        error.
*
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN                Network  interface link state down (i.e.
*                                                                       NOT available for receive or transmit).
*
*                                                                   ------- RETURNED BY Net_GlobalLockAcquire() : ------
*                               NET_ERR_FAULT_LOCK_ACQUIRE          Network access NOT acquired.
*
* Return(s)   : Number of data octets transmitted, if NO error(s).
*
*               0,                                 otherwise.
*
* Caller(s)   : NetSock_TxDataHandlerStream().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : SEND Call' specifies how to handle transmit
*                   data requests from the application layer :
*
*                   (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
*
*                   (b) For the "LISTEN STATE" :
*
*                           (A) TCP Listen state transmit NOT yet implemented;
*                               see also 'net_sock.c  NetSock_TxDataHandlerStream()  Note #2aA'.
*                               #### NET-815
*
*                       (1) "If the foreign socket is specified, then" :
*
*                           (A) "Change the connection from passive to active," ...
*                           (B) "Select an ISS"                                 ...
*                           (C) "Send a SYN segment,"                           ...
*                           (D) "Set" :
*                               (1) "SND.UNA to ISS," ...
*                               (2) "SND.NXT to ISS+1."
*                           (E) "Enter SYN-SENT state."
*                           (F) "Data associated with SEND may be" ...
*                               (1) "sent with SYN segment"        ...
*                               (2) (a) "or queued for transmission after entering ESTABLISHED state."
*                                   (b) "If there is no room to queue the request, respond with 'error:
*                                        insufficient resources'."
*
*                       (2) "If Foreign [sic] socket was not specified, then return 'error: foreign socket
*                            unspecified'."
*
*                   (c) For the "SYN-SENT STATE, SYN-RECEIVED STATE" :
*
*                       (1) "Queue the data for transmission after entering ESTABLISHED state."
*                       (2) "If no space to queue, respond with 'error: insufficient resources'."
*
*                   (d) For the "ESTABLISHED STATE, CLOSE-WAIT STATE" :
*
*                       (1) (A) "Segmentize the buffer"                         ...
*                           (B) "and send it with a piggybacked acknowledgment" ...
*                               (1) "(acknowledgment value = RCV.NXT)"
*                       (2) "If there is no insufficient space to remember this buffer, simply return
*                           'error: insufficient resources'."
*
*                   (e) For the "FIN-WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSING STATE, LAST-ACK STATE,
*                       TIME-WAIT STATE" :
*
*                       (1) "Return 'error: connection closing'" ...
*                       (2) "and do not service request."
*               (3) TCP segments with transmit data are sequenced into the TCP connection's transmit
*                   queue to await transmission at the appropriate time(s) [see 'NetTCP_TxConnTxQ()
*                   Note #1b'].
*
*                   (a) Transmit TCP segments are inserted into a doubly-linked Transmit Queue, ordered
*                       consecutively by sequence number(s) [see also Note #3b1].
*
*                       In the diagram below, ... :
*
*                       (1) (A) TCP connections' 'TxQ_Head' points to the head of a TCP connections'
*                                   Transmit Queue;
*                           (B) TCP connections' 'TxQ_Tail' points to the tail of a TCP connections'
*                                   Transmit Queue.
*
*                       (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr' doubly-link each
*                           segment to form the Transmit Queue.
*
*                   (b) (1) Transmit data is packetized into TCP segments in sequence-order.  Therefore,
*                           new transmit segments are sequenced after previously packetized segments
*                           starting at the tail of the Transmit Queue.
*
*                       (2) Segments at the head of the Transmit Queue are available & ready to be
*                           transmitted via the Internet Transmit Layer.
*
*
*                                      |                                               |
*                                      |<------- TCP Connection Transmit Queue ------->|
*                                      |                (see Note #3)                  |
*
*                                  Segments Ready                           Segments Sequenced
*                                   to Transmit                             into Transmit Queue
*                                  start at head                             starting at tail
*                                 (see Note #3b2)                            (see Note #3b1)
*
*                                         |             NextPrimListPtr             |
*                                         |             (see Note #3a2)             |
*                                         v                    |                    v
*                                                              |
*                       Head of        -------       -------   v   -------       -------  (see Note #3a1B)
*                       Transmit  ---->|     |------>|     |------>|     |------>|     |
*                        Queue         |     |       |     |       |     |       |     |       Tail of
*                                      |     |<------|     |<------|     |<------|     |<----  Transmit
*                  (see Note #3a1A)    |     |       |     |   ^   |     |       |     |        Queue
*                                      |     |       |     |   |   |     |       |     |
*                                      -------       -------   |   -------       -------
*                                                              |
*                                                       PrevPrimListPtr
*                                                       (see Note #3a2)
*
*               (4) 'data_len' of 0 octets NOT allowed.
*
*               (5) Certain network connections MUST periodically suspend network transmit(s) to handle
*                   network receive packet(s).  To protect TCP connections from transmit corruption while
*                   suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
*                   suspended connections until the connection is no longer suspended.
*
*                   See also 'NetTCP_TxConnTxQ()  Note #12b2A2'.
*
*               (6) (a) RFC #793, Section 3.8 'Interfaces : User/TCP Interface : TCP User Commands : Send'
*                       states that :
*
*                       (1) "If the PUSH flag is set, the data must be transmitted promptly to the receiver,
*                            and the PUSH bit will be set in the last TCP segment created from the buffer."
*
*                       (2) "If the PUSH flag is not set, the data may be combined with data from subsequent
*                            SENDs for transmission efficiency."
*
*                   (b) RFC #1122, Section 4.2.2.2 states that :
*
*                       (1) "When an application issues a series of SEND calls without setting the PUSH
*                            flag, the TCP MAY aggregate the data internally without sending it."
*
*                       (2) "The PSH bit is not a record marker and is independent of segment boundaries.
*                            The transmitter SHOULD collapse successive PSH bits when it packetizes data,
*                            to send the largest possible segment.
*
*                       (3) (A) "A TCP MAY implement PUSH flags on SEND calls."
*
*                           (B) (1) "If PUSH flags are not implemented, then the sending TCP : ...
*
*                                   (a) must not buffer data indefinitely, and ...
*                                   (b) MUST set the PSH bit in the last buffered segment (i.e., when
*                                       there is no more queued data to be sent)."
*
*                                       (1) However, NO RFC specifies whether the PUSH bit should be
*                                           set ONLY in the last buffered segment.  Therefore, is is
*                                           assumed that the PUSH bit MAY be set in the last buffered
*                                           segment of each call to SEND.
*
*                               (2) "When the PUSH flag is not implemented on SEND calls, i.e., when
*                                    the application/TCP interface uses a pure streaming model,
*                                    responsibility for aggregating any tiny data fragments to form
*                                    reasonable sized segments is partially borne by the application
*                                    layer."
*
*                       (4) (A) "An application program is logically required to set the PUSH flag in a
*                                SEND call whenever it needs to force delivery of the data to avoid a
*                                communication deadlock.  However, a TCP SHOULD send a maximum-sized
*                                segment whenever possible, to improve performance."
*
*                           (B) "Generally, an interactive application protocol must set the PUSH flag
*                                at least in the last SEND call in each command or response sequence."
*
*               (7) Since pointer arithmetic is based on the specific pointer data type & inherent pointer
*                   data type size, pointer arithmetic operands :
*
*                   (a) MUST be in terms of the specific pointer data type & data type size; ...
*                   (b) SHOULD NOT & in some cases MUST NOT be cast to other data types or data type sizes.
*
*               (8) Network buffers allocated for TCP connection transmit SHOULD be fully used even if
*                   the TCP connection's configured transmit window is zero.
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCfgd()  Note #2'.
*
*               (9) Network buffers' reference counters MUST be incremented to include the queued TCP
*                   segments as new  references to the network buffers.  However, these additional references
*                   are handled when the TCP segments are enqueued to the TCP connection's re-transmit queue
*                   (see 'NetTCP_TxConnTxQ()  Note #10').
*
*              (10) (a) Since segments enqueued to a TCP connection's transmit queue have already been
*                       reported as transmitted to the application & since no mechanism exists for a TCP
*                       connection to re-request previously transmitted data, any TCP connection whose
*                       transmit queue becomes corrupted MUST be closed to force the application layer to
*                       abort &/or recover from the corrupted data.
*
*                   (b) For any internal errors where the TCP connection's transmit queue is NOT corrupted,
*                       the TCP connection is NOT closed.  Thus the application layer may try to re-transmit
*                       the application data.
*
*                   (c) On ANY transmit error, any remaining application data transmit is immediately aborted.
*
*                   See also 'NetTCP_TxConnTxQ()    Note #14'.
*                          & 'NetTCP_TxConnReTxQ()  Note #11'.
*********************************************************************************************************
*/

CPU_INT16U  NetTCP_TxConnAppData (NET_TCP_CONN_ID   conn_id_tcp,
                                  void             *p_data,
                                  CPU_INT16U        data_len,
                                  NET_TCP_FLAGS     flags,
                                  NET_ERR          *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR        src_addrv4             = NET_IPv4_ADDR_NONE;
    NET_IPv4_ADDR        dest_addrv4            = NET_IPv4_ADDR_NONE;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR        src_addrv6             = NET_IPv6_ADDR_NONE;
    NET_IPv6_ADDR        dest_addrv6            = NET_IPv6_ADDR_NONE;
#endif
    NET_TCP_CONN        *p_conn                 = DEF_NULL;
    NET_TCP_PORT_NBR     src_port               = NET_PORT_NBR_NONE;
    NET_TCP_PORT_NBR     dest_port              = NET_PORT_NBR_NONE;
    NET_TCP_TX_Q_STATE   wait_state             = NET_TCP_TX_Q_STATE_NONE;
    NET_CONN_ID          conn_id                = NET_CONN_ID_NONE;
    NET_CONN            *p_net_conn             = DEF_NULL;
    NET_IF_NBR           if_nbr                 = NET_IF_NBR_NONE;
    NET_BUF             *p_buf                  = DEF_NULL;
    NET_BUF             *p_buf_head             = DEF_NULL;
    NET_BUF             *p_buf_tail             = DEF_NULL;
    NET_BUF             *p_buf_q_tail           = DEF_NULL;
    NET_BUF_HDR         *p_buf_hdr              = DEF_NULL;
    NET_BUF_HDR         *p_buf_hdr_head         = DEF_NULL;
    NET_BUF_HDR         *p_buf_hdr_tail         = DEF_NULL;
    NET_BUF_HDR         *p_buf_hdr_q_tail       = DEF_NULL;
    NET_BUF_SIZE         buf_size_max           = 0u;
    NET_BUF_SIZE         buf_size_max_data;
    NET_BUF_SIZE         buf_size_max_tail      = 0u;
    NET_BUF_SIZE         buf_size_max_tail_data = 0u;
    NET_BUF_SIZE         data_ix_pkt            = 0u;
    NET_BUF_SIZE         data_ix_pkt_offset     = 0u;
    NET_BUF_SIZE         data_ix_pkt_tail       = 0u;
    NET_BUF_SIZE         data_len_pkt_tail      = 0u;
    NET_BUF_SIZE         data_len_pkt           = 0u;
    NET_BUF_SIZE         data_len_pkt_rem       = 0u;
    NET_BUF_SIZE         data_len_rem_min       = 0u;
    NET_BUF_SIZE         data_len_mss           = 0u;
    CPU_INT16U           data_len_rem           = 0u;
    CPU_INT16U           data_len_tot           = 0u;
    CPU_INT08U          *p_data_pkt;
    CPU_BOOLEAN          tx_q_append            = DEF_NO;
    CPU_BOOLEAN          tx_data                = DEF_NO;
    CPU_BOOLEAN          tx_err                 = DEF_NO;
    CPU_BOOLEAN          block                  = DEF_NO;
    NET_TCP_SEQ_NBR      seq_nbr                = 0u;
    NET_PROTOCOL_TYPE    proto_type             = NET_PROTOCOL_TYPE_NONE;
    NET_ERR              err                    = NET_ERR_NONE;



#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
                                                                /* ---------------- VALIDATE APP DATA ----------------- */
    if (p_data == DEF_NULL) {
       *p_err =  NET_ERR_FAULT_NULL_PTR;
        return (0u);
    }
    if (data_len < 1) {                                         /* Validate data len (see Note #4).                     */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxInvalidSizeCtr);
       *p_err =  NET_TCP_ERR_INVALID_DATA_SIZE;
        return (0u);
    }

                                                                /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return (0u);
    }
#endif


                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {                                /* Validate conn state.                                 */
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (0u);


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #2a.                                        */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (0u);


        case NET_TCP_CONN_STATE_LISTEN:                         /* See Note #2b.                                        */
                                                                /* NOT yet implemented (see Note #2bA).                 */
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (0u);


        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Note #2c.                                        */
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             tx_data = DEF_NO;
             break;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #2d.                                        */
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
             tx_data = DEF_YES;
             break;


        case NET_TCP_CONN_STATE_FIN_WAIT_1:                     /* See Note #2e.                                        */
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (0u);


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (0u);
    }


    switch (p_conn->TxQ_State) {                                /* Validate tx Q state.                                 */
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_CLOSING:
             block = DEF_NO;
             break;


        case NET_TCP_TX_Q_STATE_SUSPEND:                        /* See Note #5.                                         */
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
             block = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_TX_BLOCK);
             if (block != DEF_NO) {
                 wait_state = p_conn->TxQ_State;
             } else {
                *p_err =  NET_TCP_ERR_TX_Q_SUSPEND;
                 return (0u);
             }
             break;


        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        default:
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (0u);
    }


    if (block != DEF_NO) {
        while (p_conn->TxQ_State == wait_state) {
            Net_GlobalLockRelease();
            NetTCP_TxQ_Wait(conn_id_tcp, p_err);
            Net_GlobalLockAcquire((void *)&NetTCP_TxConnAppData, &err);
        }
    }


                                                                /* -------------- WAIT ON TCP CONN TX Q --------------- */
    if (tx_data == DEF_YES) {                                   /* If tx rdy,                    ...                    */
        if (data_len < 1) {                                     /* ... but  NO tx data avail,    ...                    */
                                                                /* ... tx q'd data OR immed ack; ...                    */
            NetTCP_TxConnTxQ(p_conn, 0, NET_TCP_CONN_TX_ACK_IMMED, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES,  p_err);
            return (0u);
        }
                                                                /* ... Else if tx data avail,    ...                    */
        if ((p_conn->TxWinSizeCfgdRem < 1) ||                   /* ... but tx Q full             ...                    */
            (p_conn->MaxSegSizeConn   < 1)   ) {
            block = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_TX_BLOCK);
            if (block != DEF_YES) {                             /* ... & non-blocking tx,        ...                    */
               *p_err =  NET_TCP_ERR_TX_Q_FULL;                 /* ... rtn tx Q full err.                               */
                return (0u);
            }

            Net_GlobalLockRelease();
            NetTCP_TxQ_Wait(conn_id_tcp, p_err);
            Net_GlobalLockAcquire((void *)&NetTCP_TxConnAppData, &err);
            if (err != NET_ERR_NONE) {
                *p_err  = err;                                  /* Rtn err from Net_GlobalLockAcquire().                */
                 return (0u);
            }

            if (*p_err != NET_TCP_ERR_NONE) {
                 return (0u);                                   /* Rtn err from NetTCP_TxQ_Wait().                      */
            }

            if (p_conn->TxWinSizeCfgdRem < 1) {                 /* If tx Q still full, ...                              */
               *p_err =  NET_TCP_ERR_TX_Q_FULL;                 /* ... rtn tx Q full err.                               */
                return (0u);
            }
        } else {
            NetTCP_TxQ_Clr(conn_id_tcp, &err);                  /* Clr any possible async tx Q signal.                  */
        }
    }


                                                                /* ------- PREPARE APP TX DATA INTO TCP SEG(S) -------- */
                                                                /* Prepare seg addrs.                                   */
    conn_id    =  p_conn->ID_Conn;
    p_net_conn = &NetConn_Tbl[conn_id];

    if (p_net_conn->Family == NET_SOCK_FAMILY_IP_V4) {
#ifdef  NET_IPv4_MODULE_EN
        NetTCP_TxConnPrepareSegAddrs(p_conn,
                      (CPU_INT08U *)&src_addrv4,
                      (CPU_INT08U *)&src_port,
                                     sizeof(src_addrv4),
                                     sizeof(src_port),
                      (CPU_INT08U *)&dest_addrv4,
                      (CPU_INT08U *)&dest_port,
                                     sizeof(dest_addrv4),
                                     sizeof(dest_port),
                                    &err);
#endif
    } else if (p_net_conn->Family == NET_SOCK_FAMILY_IP_V6) {
#ifdef  NET_IPv6_MODULE_EN
        NetTCP_TxConnPrepareSegAddrs(p_conn,
                      (CPU_INT08U *)&src_addrv6,
                      (CPU_INT08U *)&src_port,
                                     sizeof(src_addrv6),
                                     sizeof(src_port),
                      (CPU_INT08U *)&dest_addrv6,
                      (CPU_INT08U *)&dest_port,
                                     sizeof(dest_addrv6),
                                     sizeof(dest_port),
                                    &err);
#endif
    } else {
                                                                /* Empty Else Statement                                 */
    }

    if (err != NET_TCP_ERR_NONE) {
       *p_err = NET_TCP_ERR_CONN_FAULT;
        return (0u);
    }


    conn_id = p_conn->ID_Conn;
    if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
    if (err != NET_CONN_ERR_NONE) {
        NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_TCP_ERR_CONN_FAULT;
        return (0u);
    }

    p_buf_head   =  DEF_NULL;
    p_buf_tail   =  DEF_NULL;
    p_data_pkt   = (CPU_INT08U *)p_data;
    tx_q_append  =  DEF_YES;

    data_len_mss =  p_conn->MaxSegSizeConn;
    data_len_rem =  data_len;
    data_len_tot =  0u;
                                                                /* Prepare TCP tx seg hdr ctrls.                        */
    seq_nbr      =  p_conn->TxSeqNbrNextQ;

    if (data_len_mss <= 0) {
       *p_err = NET_TCP_ERR_NONE;
        return (0u);
    }

    if (p_conn->TxQ_Tail != DEF_NULL) {                         /* If tx Q NOT empty;                            ...    */
        p_buf                  =  p_conn->TxQ_Tail;
        p_buf_hdr              = &p_buf->Hdr;

        data_ix_pkt_tail       =  p_buf_hdr->DataIx;
        data_len_pkt_tail      =  p_buf_hdr->TCP_SegLenData;
                                                                /* ... calc tail seg's max data size,            ...    */
        buf_size_max_tail      =  NetBuf_GetMaxSize(if_nbr, NET_TRANSACTION_TX, p_buf, data_ix_pkt_tail);

        buf_size_max_tail_data =  DEF_MIN(buf_size_max_tail, data_len_mss);

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        if (data_len_pkt_tail > buf_size_max_tail_data) {       /* If seg len > max data size, tx Q data seg invalid,   */
                                                                /* ... close TCP conn (see Note #10a).                  */
            NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
           *p_err =  NET_TCP_ERR_CONN_DATA_INVALID;
            return (0u);
        }
#endif

        if (data_len_pkt_tail < buf_size_max_tail_data) {       /* ... & if avail data space on tx Q's tail seg, ...    */
                                                                /* ... append data on tx Q tail seg (see Note #6b1).    */
            data_ix_pkt      = data_ix_pkt_tail       + data_len_pkt_tail;
            data_len_pkt_rem = buf_size_max_tail_data - data_len_pkt_tail;
                                                                /* Lim pkt data len to min of rem'ing data len, ...     */
                                                                /* ... pkt data len or cfg'd tx win size.               */
            data_len_rem_min = DEF_MIN(data_len_pkt_rem, data_len_rem);
            data_len_pkt     = DEF_MIN(data_len_rem_min, p_conn->TxWinSizeCfgdRem);

                                                                /* Wr app data into TCP tx buf.                         */
            NetBuf_DataWr(p_buf, data_ix_pkt, data_len_pkt, p_data_pkt, &err);
            if ( err != NET_BUF_ERR_NONE) {                     /* If wr err, tx Q data corrupted; ...                  */
                                                                /* ... close TCP conn (see Note #10a).                  */
                NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
               *p_err  = NET_TCP_ERR_CONN_FAULT;
                return (0u);
            }

                                                                /* Update TCP seg tx buf ctrls.                         */
            p_buf_hdr->DataLen        += data_len_pkt;
            p_buf_hdr->TotLen         += data_len_pkt;

            p_buf_hdr->TCP_SegLenInit += data_len_pkt;
            p_buf_hdr->TCP_SegLen     += data_len_pkt;
            p_buf_hdr->TCP_SegLenData += data_len_pkt;


            p_buf_head    = p_buf;                              /* Set tx Q tail as first seg in tx app data chain.     */
            p_buf_tail    = p_buf;
            tx_q_append   = DEF_NO;

                                                                /* Update data ptr & lens.                              */
            p_data_pkt   += data_len_pkt;                       /* MUST NOT cast ptr operand (see Note #7b).            */
            data_len_tot += data_len_pkt;
            data_len_rem -= data_len_pkt;

            seq_nbr      += data_len_pkt;
                                                                /* Dec TCP conn's tx win size (see Note #8).            */
            NetTCP_TxConnWinSizeHandlerCfgd(p_conn, data_len_pkt, NET_TCP_CONN_TX_WIN_DEC, &err);
            if ( err != NET_TCP_ERR_NONE) {
               *p_err  = NET_TCP_ERR_CONN_FAULT;
                return (0u);
            }
        }
    }


                                                                /* Calc max data size.                                  */
#if 0
    data_ix_pkt       = NET_BUF_DATA_IX_TX;
#else
    switch (p_net_conn->Family) {
        case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
             proto_type = NET_PROTOCOL_TYPE_TCP_V4;
             break;


        case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
             proto_type = NET_PROTOCOL_TYPE_TCP_V6;
             break;


        default:
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return (0u);
    }

    data_ix_pkt = 0u;

    NetTCP_GetTxDataIx(if_nbr,
                       proto_type,
                       0u,
                       data_len,
                       p_conn,
                      &data_ix_pkt,
                       p_err);
#endif
    buf_size_max      = NetBuf_GetMaxSize(if_nbr, NET_TRANSACTION_TX, DEF_NULL, data_ix_pkt);
    buf_size_max_data = DEF_MIN(buf_size_max, data_len_mss);

    while ((data_len_rem             > 0) &&                    /* Prepare TCP seg(s) for ALL app data ...              */
           (p_conn->TxWinSizeCfgdRem > 0) &&                    /* ... as net rsrc(s)/err(s) permit.                    */
           (tx_err == DEF_NO)) {
                                                                /* Reinit data_ix_pkt.                                  */
        data_ix_pkt = 0u;
        NetTCP_GetTxDataIx( if_nbr,
                            proto_type,
                            0u,
                            data_len,
                            p_conn,
                           &data_ix_pkt,
                            p_err);
                                                                /* Lim pkt data len to min of max buf data size or ...  */
                                                                /* ... rem'ing data len or cfg'd tx win size.           */
        data_len_rem_min = DEF_MIN(buf_size_max_data, data_len_rem);
        data_len_pkt     = DEF_MIN(data_len_rem_min,  p_conn->TxWinSizeCfgdRem);
                                                                /* Get app data tx buf.                                 */
        p_buf = NetBuf_Get(if_nbr,
                           NET_TRANSACTION_TX,
                           data_len_pkt,
                           data_ix_pkt,
                          &data_ix_pkt_offset,
                           NET_BUF_FLAG_NONE,
                          &err);
        if (err == NET_BUF_ERR_NONE) {
            data_ix_pkt += data_ix_pkt_offset;
        } else {
            tx_err       = DEF_YES;
        }


        if (tx_err == DEF_NO) {                                 /* Wr app data into TCP tx buf.                         */
            NetBuf_DataWr(p_buf, data_ix_pkt, data_len_pkt, p_data_pkt, &err);
            if (err != NET_BUF_ERR_NONE) {
                NetTCP_TxPktDiscard(p_buf, &err);
                tx_err = DEF_YES;
            }
        }


        if (tx_err == DEF_NO) {
                                                                /* Init TCP seg(s) tx buf ctrls.                        */
            p_buf_hdr                  = &p_buf->Hdr;
            p_buf_hdr->DataIx          =  data_ix_pkt;
            p_buf_hdr->DataLen         =  data_len_pkt;
            p_buf_hdr->TotLen          =  p_buf_hdr->DataLen;
            p_buf_hdr->ProtocolHdrType =  NET_PROTOCOL_TYPE_APP;

            switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
                case NET_SOCK_FAMILY_IP_V4:
                     p_buf_hdr->IP_AddrSrc  = src_addrv4;
                     p_buf_hdr->IP_AddrDest = dest_addrv4;
                     break;
#endif

                case NET_SOCK_FAMILY_IP_V6:
#ifdef  NET_IPv6_MODULE_EN
                     p_buf_hdr->IPv6_AddrSrc  = src_addrv6;
                     p_buf_hdr->IPv6_AddrDest = dest_addrv6;
                     break;
#endif
                default:
                     break;
            }

            p_buf_hdr->TransportPortSrc  = src_port;
            p_buf_hdr->TransportPortDest = dest_port;

            p_buf_hdr->TCP_SegLenInit    = data_len_pkt;
            p_buf_hdr->TCP_SegLen        = p_buf_hdr->TCP_SegLenInit;
            p_buf_hdr->TCP_SegLenData    = p_buf_hdr->TCP_SegLenInit;
            p_buf_hdr->TCP_SegSync       = DEF_NO;
            p_buf_hdr->TCP_SegClose      = DEF_NO;
            p_buf_hdr->TCP_SegAck        = DEF_YES;
            p_buf_hdr->TCP_SegReset      = DEF_NO;

            p_buf_hdr->TCP_SeqNbrInit    = seq_nbr;
            p_buf_hdr->TCP_SeqNbr        = p_buf_hdr->TCP_SeqNbrInit;

            p_buf_hdr->TCP_Flags         = NET_TCP_FLAG_NONE  |
                                           NET_TCP_FLAG_TX_ACK;

            if (p_buf_tail != DEF_NULL) {                       /* If tx app data chain NOT empty, ...                  */
                                                                /* ... append seg(s) @ Q tail (see Note #3b1).          */
                p_buf_hdr_tail                  = &p_buf_tail->Hdr;
                p_buf_hdr_tail->NextPrimListPtr =  p_buf;
                p_buf_hdr->PrevPrimListPtr      =  p_buf_tail;
                p_buf_tail                      =  p_buf;

            } else {                                            /* Else add seg as first seg in tx app data chain.      */
                p_buf_head                      =  p_buf;
                p_buf_tail                      =  p_buf;
            }

                                                                /* Update data ptr & lens.                              */
            p_data_pkt   += data_len_pkt;                       /* MUST NOT cast ptr operand (see Note #7b).            */
            data_len_tot += data_len_pkt;
            data_len_rem -= data_len_pkt;

            seq_nbr      += data_len_pkt;

                                                                /* Dec TCP conn's tx win size (see Note #8).            */
            NetTCP_TxConnWinSizeHandlerCfgd(p_conn, data_len_pkt,  NET_TCP_CONN_TX_WIN_DEC, &err);
            if (err != NET_TCP_ERR_NONE) {
               *p_err = NET_TCP_ERR_CONN_FAULT;
                return (0u);
            }
        }
    }


    if (p_buf_head == DEF_NULL) {                               /* If NO data seg'd, rtn no rsrc(s) err ...             */
       *p_err = NET_TCP_ERR_NONE_AVAIL;                         /* ... (see Notes #2b1F2b, #2c2, & #2d2).               */
        return (0u);
    }

    DEF_BIT_SET(p_buf_hdr->TCP_Flags, NET_TCP_FLAG_TX_PUSH);    /* Set PUSH flag in last q'd tx seg (see Note #6b3B1b). */




                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    if (p_conn->TxQ_Tail != DEF_NULL) {                         /* If tx Q NOT empty                            ...     */
        if (tx_q_append == DEF_YES) {                           /* ... & tx app data chain NOT already on tx Q, ...     */
                                                                /* ... append seg(s) @ Q tail (see Note #3b1).          */
            p_buf_q_tail                      =  p_conn->TxQ_Tail;
            p_buf_hdr_q_tail                  = &p_buf_q_tail->Hdr;
            p_buf_hdr_q_tail->NextPrimListPtr =  p_buf_head;

            p_buf_hdr_head                    = &p_buf_head->Hdr;
            p_buf_hdr_head->PrevPrimListPtr   =  p_buf_q_tail;
        }

        p_conn->TxQ_Tail = p_buf_tail;

    } else {                                                    /* Else add seg(s) to empty tx Q.                       */
        p_conn->TxQ_Head = p_buf_head;
        p_conn->TxQ_Tail = p_buf_tail;
    }

                                                                /* Update TCP conn tx seq nbr(s).                       */
    p_conn->TxSeqNbrNextQ = seq_nbr;



                                                                /* ---------------- TX TCP DATA SEG(S) ---------------- */
    if (tx_data == DEF_YES) {
        NetTCP_TxConnTxQ(p_conn, 0, NET_TCP_CONN_TX_ACK_NONE, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES, p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
            case NET_ERR_TX:                                    /* Ignore transitory tx err(s).                         */
            case NET_ERR_IF_LINK_DOWN:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_CLOSE:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_CONN_FAIL:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            case NET_TCP_ERR_TX_PKT:
            case NET_ERR_IF_LOOPBACK_DIS:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_ADDR:
            case NET_CONN_ERR_INVALID_ADDR_LEN:
            default:
                 return (0u);
        }
    }


   *p_err =  NET_TCP_ERR_NONE;

    return (data_len_tot);
}


/*
*********************************************************************************************************
*                                       NetTCP_ConnIsAvailRx()
*
* Description : (1) Check TCP connection for available receive operation(s) :
*
*                   (a) Application receive data
*                   (b) Receive connection closed
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to check for available receive operation(s).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection successfully checked for
*                                                                       available receive operation(s); check
*                                                                       return value for receive availability.
*
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   --- RETURNED BY NetTCP_ConnIsUsed() : ----
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
* Return(s)   : DEF_YES, if TCP connection has any available receive operation(s).
*
*               DEF_NO,  otherwise.
*
* Caller(s)   : NetSock_IsAvailRxStream().
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : RECEIVE Call' specifies how to handle receive
*                   data requests from the application layer :
*
*                   (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
*
*                   (b) (1) For the "LISTEN STATE, SYN-SENT STATE, SYN-RECEIVED STATE ... queue for processing
*                           after entering ESTABLISHED state".
*
*                       (2) The application layer may request to receive application data before the TCP
*                           connection enters the connected state.  Such requests will block or return
*                           no data.
*
*                   (c) For the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE" :
*
*                       (1) "If insufficient incoming segments are queued to satisfy the request, queue
*                            the request."
*
*                       (2) "Reassemble queued incoming segments into receive buffer and return to user."
*
*                   (d) For the "CLOSE-WAIT STATE ... since the remote side has already sent FIN, RECEIVEs
*                       must be satisfied by the text already on hand, but not yet delivered to the user.
*                       If no text is awaiting delivery, the RECEIVE will get a 'error: connection closing'
*                       response.  Otherwise, any remaining text can be used to satisfy the RECEIVE".
*
*                   (e) (1) For the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE ... return 'error:
*                           connection closing'".
*
*                       (2) Typically, these states will have already received ALL remaining closing
*                           data from the closing remote host.
*
*                           (A) However, in case all receive data from the remote host has NOT yet been
*                               received, application layer receives from these states are permitted until
*                               the TCP connection's sequence receive state is closed & the TCP connection's
*                               application receive queue is empty.
*
*                   See also 'NetTCP_RxAppData()  Note #2'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnIsAvailRx (NET_TCP_CONN_ID   conn_id_tcp,
                                   NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_BOOLEAN    rx_avail;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return (DEF_NO);
    }
#endif

                                                                /* -------------- CHK TCP CONN RX AVAIL --------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (DEF_NO);


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #2a.                                        */
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (DEF_NO);


        case NET_TCP_CONN_STATE_LISTEN:                         /* See Note #2b.                                        */
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             rx_avail = DEF_NO;                                 /* See Note #2b2.                                       */
             break;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #2c.                                        */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
                                                                /* Chk TCP conn rx data avail (see Note #2c).           */
             rx_avail =  (p_conn->RxQ_App_Head != DEF_NULL) ? DEF_YES : DEF_NO;
             break;


        case NET_TCP_CONN_STATE_CLOSE_WAIT:                     /* See Note #2d.                                        */
        case NET_TCP_CONN_STATE_CLOSING:                        /* See Note #2e.                                        */
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
                                                                /* Chk TCP conn rx data avail (see Note #2d) OR ...     */
             rx_avail = ((p_conn->RxQ_App_Head != DEF_NULL) ||
                                                                /* ... TCP conn rx q closed   (see Note #2e2A).         */
                        ((p_conn->RxQ_App_Head == DEF_NULL) &&
                         (p_conn->RxQ_State    ==  NET_TCP_RX_Q_STATE_CLOSED))) ? DEF_YES : DEF_NO;
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (DEF_NO);
    }


   *p_err =  NET_TCP_ERR_NONE;

    return (rx_avail);
}


/*
*********************************************************************************************************
*                                        NetTCP_ConnIsRdyTx()
*
* Description : Check if TCP connection ready to transmit.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to check if ready to transmit.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection successfully checked if
*                                                                       ready for transmit; check return
*                                                                       value for transmit ready availability.
*
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   --- RETURNED BY NetTCP_ConnIsUsed() : ----
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
* Return(s)   : DEF_YES, if TCP connection is ready to transmit.
*
*               DEF_NO,  otherwise.
*
* Caller(s)   : NetSock_IsRdyTxStream().
*
* Note(s)     : (1) RFC #793, Section 3.9 'Event Processing : SEND Call' specifies how to handle transmit
*                   data requests from the application layer :
*
*                   (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
*
*                   (b) For the "LISTEN STATE" :
*
*                           (A)TCP Listen state transmit NOT yet implemented. #### NET-815
*
*                       (1) "If the foreign socket is specified, then" :
*
*                           (F) "Data associated with SEND may be" ...
*                               (1) "sent with SYN segment"        ...
*                               (2) (a) "or queued for transmission after entering ESTABLISHED state."
*
*                   (c) For the "SYN-SENT STATE, SYN-RECEIVED STATE" :
*
*                       (1) "Queue the data for transmission after entering ESTABLISHED state."
*
*                   (d) For the "ESTABLISHED STATE, CLOSE-WAIT STATE" :
*
*                       (1) (A) "Segmentize the buffer" ...
*                           (B) "and send it with a piggybacked acknowledgment."
*
*                   (e) For the "FIN-WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSING STATE, LAST-ACK STATE,
*                       TIME-WAIT STATE" :
*
*                       (1) "Return 'error: connection closing'" ...
*                       (2) "and do not service request."
*
*                   See also 'NetTCP_TxConnAppData()  Note #2'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnIsRdyTx (NET_TCP_CONN_ID   conn_id_tcp,
                                 NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_BOOLEAN    tx_rdy;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return (DEF_NO);
    }
#endif

                                                                /* --------------- CHK TCP CONN TX RDY ---------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (DEF_NO);


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #1a.                                        */
        case NET_TCP_CONN_STATE_LISTEN:                         /* NOT yet implemented (see Note #1bA).                 */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:                     /* See Note #1e.                                        */
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (DEF_NO);


        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Note #1c.                                        */
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             tx_rdy = DEF_NO;
             break;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1d.                                        */
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
                                                                /* Chk TCP conn tx data rdy status.                     */
             tx_rdy = ((p_conn->TxWinSizeCfgdRem > 0) && (p_conn->MaxSegSizeConn > 0)) ? DEF_YES : DEF_NO;
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (DEF_NO);
    }


   *p_err =  NET_TCP_ERR_NONE;

    return (tx_rdy);
}


/*
*********************************************************************************************************
*                                          NetTCP_ConnGet()
*
* Description : (1) Allocate & initialize a TCP connection :
*
*                   (a) Get      a TCP connection
*                   (b) Validate   TCP connection
*                   (c) Initialize TCP connection
*                   (d) Update     TCP connection pool statistics
*                   (e) Return TCP connection handle identifier
*                         OR
*                       Null identifier & error code, on failure
*
*               (2) The TCP connection pool is implemented as a stack :
*
*                   (a) 'NetTCP_ConnPoolPtr' points to the head of the TCP connection pool.
*
*                   (b) TCP connections' 'NextPtr's link each TCP connection to form the TCP connection pool stack.
*
*                   (c) TCP connections are inserted & removed at the head of        the TCP connection pool stack.
*
*
*                                    TCP connections are
*                                    inserted & removed
*                                        at the head
*                                      (see Note #2c)
*
*                                             |                 NextPtr
*                                             |             (see Note #2b)
*                                             v                    |
*                                                                  |
*                                          -------       -------   v   -------       -------
*                     TCP Connection  ---->|     |------>|     |------>|     |------>|     |
*                      Pool Pointer        |     |       |     |       |     |       |     |
*                                          |     |       |     |       |     |       |     |
*                     (see Note #2a)       -------       -------       -------       -------
*
*                                          |                                               |
*                                          |<------- Pool of Free TCP Connections -------->|
*                                          |                (see Note #2)                  |
*
*
* Argument(s) : p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection successfully allocated &
*                                                                       initialized.
*                               NET_TCP_ERR_NONE_AVAIL              NO available TCP connections to allocate.
*                               NET_TCP_ERR_INVALID_CONN_TYPE       TCP connection is NOT a valid type.
*
* Return(s)   : TCP connection handle identifier, if NO error(s).
*
*               NET_TCP_CONN_ID_NONE,             otherwise.
*
* Caller(s)   : various.
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (3) (a) TCP connection pool is accessed by 'NetTCP_ConnPoolPtr' during execution of
*
*                       (1) NetTCP_Init()
*                       (2) NetTCP_ConnGet()
*                       (3) NetTCP_ConnFree()
*
*                   (b) Since the primary tasks of the network protocol suite are prevented from running
*                       concurrently (see 'net.h  Note #3'), it is NOT necessary to protect the shared
*                       resources of the connection pool since no asynchronous access from other network
*                       tasks is possible.
*********************************************************************************************************
*/

NET_TCP_CONN_ID  NetTCP_ConnGet (NET_TCP_APP_POST_FNCT  fnct_app_post_rx,
                                 NET_TCP_APP_POST_FNCT  fnct_app_post_tx,
                                 NET_ERR               *p_err)
{
    NET_TCP_CONN     *p_conn;
    NET_TCP_CONN_ID   conn_id_tcp;
    NET_ERR           err;

                                                                /* ------------------- GET TCP CONN ------------------- */
    if (NetTCP_ConnPoolPtr != DEF_NULL) {                       /* If TCP conn pool NOT empty, get TCP conn from pool.  */
        p_conn               = (NET_TCP_CONN *)NetTCP_ConnPoolPtr;
        NetTCP_ConnPoolPtr  = (NET_TCP_CONN *)p_conn->NextPtr;

    } else {                                                    /* If none avail, rtn err.                              */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NoneAvailCtr);
       *p_err =  NET_TCP_ERR_NONE_AVAIL;
        return (NET_TCP_CONN_ID_NONE);
    }

                                                                /* ------------------ INIT TCP CONN ------------------- */
    NetTCP_ConnClr(p_conn);
    DEF_BIT_SET(p_conn->Flags, NET_TCP_FLAG_USED);              /* Set TCP conn as used.                                */
    p_conn->ConnState   = NET_TCP_CONN_STATE_CLOSED;

    p_conn->FnctAppPostRx = fnct_app_post_rx;
    p_conn->FnctAppPostTx = fnct_app_post_tx;

                                                                /* ------------ UPDATE TCP CONN POOL STATS ------------ */
    NetStat_PoolEntryUsedInc(&NetTCP_ConnPoolStat, &err);

                                                                /* ----------------- RTN TCP CONN ID ------------------ */
    conn_id_tcp = p_conn->ID;
   *p_err        = NET_TCP_ERR_NONE;

    return (conn_id_tcp);
}


/*
*********************************************************************************************************
*                                          NetTCP_ConnFree()
*
* Description : Free a TCP connection.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to free.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_Listen(),
*               NetSock_GetConnTransport().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (1) #### To prevent freeing a TCP connection already freed via previous TCP connection
*                   free, NetTCP_ConnFree() checks if the TCP connection is used BEFORE freeing the
*                   TCP connection.
*
*                   This prevention is only best-effort since any invalid duplicate TCP connection frees
*                   MAY be asynchronous to potentially valid TCP connection gets.  Thus the invalid TCP
*                   connection free(s) MAY corrupt the TCP connection's valid operation(s).
*
*                   However, since the primary tasks of the network protocol suite are prevented from
*                   running concurrently (see 'net.h  Note #3'), it is NOT necessary to protect TCP
*                   connection resources from possible corruption since no asynchronous access from
*                   other network tasks is possible.
*********************************************************************************************************
*/

void  NetTCP_ConnFree (NET_TCP_CONN_ID  conn_id_tcp)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_ERR        err;
#endif
    NET_TCP_CONN  *p_conn;

                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    if (conn_id_tcp == NET_TCP_CONN_ID_NONE) {
        return;
    }

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, &err);
    if (err != NET_TCP_ERR_NONE) {                              /* If TCP conn NOT used, ...                            */
        return;                                                 /* ... rtn but do NOT free (see Note #1).               */
    }
#endif

                                                                /* ------------------ FREE TCP CONN ------------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];
    NetTCP_ConnFreeHandler(p_conn, NET_TCP_CONN_FREE_ALL);
}


/*
*********************************************************************************************************
*                                     NetTCP_ConnCloseFromConn()
*
* Description : Close a TCP connection via a network connection.
*
*               (1) When a network connection closes a TCP connection, the TCP connection :
*
*                   (a) (1) Closes NO other network connection(s),
*                       (2) MUST NOT recursively re-close other network connection(s);
*
*                   (b) SHOULD clear network connection(s)' handle identifiers.
*
*                   See also 'net_sock.c  NetSock_CloseFromConn()       Note #1',
*                          & 'net_conn.c  NetConn_CloseFromTransport()  Note #1b'.
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to close.
*
* Return(s)   : none.
*
* Caller(s)   : NetConn_CloseTransport().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : (2) #### To prevent closing a TCP connection already closed via previous TCP connection
*                   close, NetTCP_ConnCloseFromConn() checks if the TCP connection is used BEFORE closing
*                   the TCP connection.
*
*                   This prevention is only best-effort since any invalid duplicate TCP connection closes
*                   MAY be asynchronous to potentially valid TCP connection gets.  Thus the invalid TCP
*                   connection closes(s) MAY corrupt the TCP connection's valid operation(s).
*
*                   However, since the primary tasks of the network protocol suite are prevented from
*                   running concurrently (see 'net.h  Note #3'), it is NOT necessary to protect TCP
*                   connection resources from possible corruption since no asynchronous access from
*                   other network tasks is possible.
*********************************************************************************************************
*/

void  NetTCP_ConnCloseFromConn (NET_TCP_CONN_ID  conn_id_tcp)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_ERR        err;
#endif
    NET_TCP_CONN  *p_conn;

                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    if (conn_id_tcp == NET_TCP_CONN_ID_NONE) {
        return;
    }

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, &err);
    if (err != NET_TCP_ERR_NONE) {                              /* If TCP conn NOT used, ...                            */
        return;                                                 /* ... rtn but do NOT close (see Note #2).              */
    }
#endif

                                                                /* ------------------ CLOSE TCP CONN ------------------ */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];
    NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                     (NET_BUF_HDR      *)0,
                     (CPU_BOOLEAN       )DEF_NO,                /* See Note #1.                                         */
                     (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
}


/*
*********************************************************************************************************
*                                       NetTCP_ConnSetID_Conn()
*
* Description : Set a TCP connection's network connection handle identifier.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to set.
*
*               conn_id         Handle identifier of network connection.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection's network connection handle
*                                                                   identifier successfully set.
*                               NET_TCP_ERR_INVALID_CONN_ID     Invalid network connection handle identifier.
*
*                                                               ----- RETURNED BY NetTCP_ConnIsUsed() : -----
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ------ RETURNED BY NetConn_IsUsed() : -------
*                               NET_CONN_ERR_INVALID_CONN       Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED           Network connection NOT currently used.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_GetConnTransport().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_ConnSetID_Conn (NET_TCP_CONN_ID   conn_id_tcp,
                             NET_CONN_ID       conn_id,
                             NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
                                                                /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }

                                                                /* --------------- VALIDATE NET CONN ID --------------- */
    if (conn_id != NET_CONN_ID_NONE) {
       (void)NetConn_IsUsed(conn_id, p_err);
        if (*p_err != NET_CONN_ERR_NONE) {
             return;
        }
    }
#endif


    p_conn          = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->ID_Conn =  conn_id;                                 /* Set TCP conn's conn id.                              */


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                     NetTCP_ConnSetStateListen()
*
* Description : Set TCP connection to LISTEN state.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to set LISTEN state.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection state successfully set to LISTEN.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid network connection handle identifier.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   ------ RETURNED BY NetTCP_ConnIsUsed() : -------
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*
* Return(s)   : none.
*
* Caller(s)   : NetSock_Listen().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s).
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  NetTCP_ConnSetStateListen (NET_TCP_CONN_ID                      conn_id_tcp,
                                 NET_TCP_APP_LISTEN_Q_IS_AVAIL_FNCT   tcp_app_listen_is_avail_fnct,
                                 NET_ERR                             *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    CPU_BOOLEAN    used;
    NET_CONN_ID    conn_id;
    NET_CONN_ID    conn_id_transport;
    NET_ERR        err;
#endif
    NET_TCP_CONN  *p_conn;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
#endif

    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* VALIDATE CONN IDs                                    */
    conn_id = p_conn->ID_Conn;
    used    = NetConn_IsUsed(conn_id, &err);
    if (used != DEF_YES) {
       *p_err  = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }

    conn_id_transport =  NetConn_ID_TransportGet(conn_id, &err);
    if (conn_id_tcp  != (NET_TCP_CONN_ID)conn_id_transport) {
       *p_err = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }
#endif


    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_CLOSED:
             p_conn->FnctAppListenQ_IsAvail = tcp_app_listen_is_avail_fnct;
             p_conn->ConnState              = NET_TCP_CONN_STATE_LISTEN;
             break;


        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                    NetTCP_ConnAppAcceptRdySignal()
*
* Description : Signal the TCP connection that the connection has been accepted by the application layer.
*               The Receive window can be configured to let the remote host send data on this connection.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection.
*
*               p_err           Pointer to variable that will receive the return error code from this function :
*
*                                   NET_TCP_ERR_NONE                No error*
*                                   NET_TCP_ERR_INVALID_CONN_ID     Invalid connection id.
*
* Return(s)   : None.
*
* Caller(s)   : NetSock_Accept().
*
* Note(s)     : none.
*********************************************************************************************************
*/
#ifndef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
void  NetTCP_ConnAppAcceptRdySignal (NET_CONN_ID       conn_id_parent,
                                     NET_TCP_CONN_ID   conn_id_tcp,
                                     NET_ERR          *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    CPU_BOOLEAN    used;
    NET_CONN_ID    conn_id;
    NET_CONN_ID    conn_id_transport;
    NET_ERR        err;
#endif
    NET_CONN      *p_conn_parent;
    NET_TCP_CONN  *p_conn_tcp_parent;
    NET_TCP_CONN  *p_conn_tcp;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
#endif

    p_conn_tcp = &NetTCP_ConnTbl[conn_id_tcp];

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* VALIDATE CONN IDs                                    */
    conn_id = p_conn_tcp->ID_Conn;
    used    = NetConn_IsUsed(conn_id, &err);
    if (used != DEF_YES) {
       *p_err  = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }

    conn_id_transport =  NetConn_ID_TransportGet(conn_id, &err);
    if (conn_id_tcp  != (NET_TCP_CONN_ID)conn_id_transport) {
       *p_err = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }
#endif

    p_conn_parent = &NetConn_Tbl[conn_id_parent];

    if (p_conn_parent->ID_Transport == NET_TCP_CONN_ID_NONE) {

        NetTCP_RxConnWinSizeHandler(p_conn_tcp, DEF_NULL, NET_TCP_DFLT_RX_WIN_SIZE_OCTET, NET_TCP_CONN_RX_WIN_INIT);

    } else {

        p_conn_tcp_parent = &NetTCP_ConnTbl[p_conn_parent->ID_Transport];

        if (p_conn_tcp_parent->RxWinSizeCfgd != 0) {
            NetTCP_RxConnWinSizeHandler(p_conn_tcp, DEF_NULL, p_conn_tcp_parent->RxWinSizeCfgd, NET_TCP_CONN_RX_WIN_INIT);
        } else {
            NetTCP_RxConnWinSizeHandler(p_conn_tcp, DEF_NULL, NET_TCP_DFLT_RX_WIN_SIZE_OCTET, NET_TCP_CONN_RX_WIN_INIT);
        }
    }

   *p_err = NET_TCP_ERR_NONE;

}
#endif


/*
*********************************************************************************************************
*                                     NetTCP_ConnCfgIdleTimeout()
*
* Description : (1) Configure TCP connection's   idle timeout :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection idle timeout
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure connection idle timeout.
*
*               timeout_sec     Desired value for TCP connection idle timeout (in seconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgIdleTimeoutHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection idle timeout successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid idle timeout.
*
*                                                               -------- RETURNED BY NetTCP_ConnIsUsed() : ---------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ------- RETURNED BY Net_GlobalLockAcquire() : ------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection idle timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgIdleTimeout() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgIdleTimeoutHandler()  Note #2'.
*
*               (3) Configured timeout does NOT reschedule any current idle timeout in progress but
*                   becomes effective the next time a TCP connection sets its idle timeout.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgIdleTimeout (NET_TCP_CONN_ID       conn_id_tcp,
                                        NET_TCP_TIMEOUT_SEC   timeout_sec,
                                        NET_ERR              *p_err)
{
   CPU_BOOLEAN  cfg_valid;

                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgIdleTimeout, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ----------- CFG TCP CONN TX IDLE TIMEOUT ----------- */
   cfg_valid = NetTCP_ConnCfgIdleTimeoutHandler(conn_id_tcp, timeout_sec, p_err);
   goto exit_release;


exit_lock_fault:
    cfg_valid = DEF_FAIL;
    goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                 NetTCP_ConnCfgIdleTimeoutHandler()
*
* Description : (1) Configure TCP connection's   idle timeout :
*
*                   (a) Validate  TCP connection idle timeout configuration
*                   (b) Configure TCP connection idle timeout
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure connection idle timeout.
*               -----------     Argument checked in NetTCP_ConnCfgIdleTimeout().
*
*               timeout_sec     Desired value for TCP connection idle timeout (in seconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection idle timeout
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid idle timeout.
*
* Return(s)   : DEF_OK,   TCP connection idle timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgIdleTimeout().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgIdleTimeoutHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgIdleTimeout()  Note #2'.
*
*               (3) Configured timeout does NOT reschedule any current idle timeout in progress but
*                   becomes effective the next time a TCP connection sets its idle timeout.
*
*               (4) Configured timeout converted to 'NET_TMR_TICK' ticks to avoid run-time conversion.
*
*               (5) TCP connections' 'TimeoutConn' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgIdleTimeoutHandler (NET_TCP_CONN_ID       conn_id_tcp,
                                               NET_TCP_TIMEOUT_SEC   timeout_sec,
                                               NET_ERR              *p_err)
{
    NET_TCP_CONN  *p_conn;
    NET_ERR        err;


                                                                /* ---------- VALIDATE TCP CONN IDLE TIMEOUT ---------- */
#if (NET_TCP_CONN_TIMEOUT_IDLE_MIN_SEC > 0)
    if (timeout_sec < NET_TCP_CONN_TIMEOUT_IDLE_MIN_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if ((NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                               || \
    ((NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC > DEF_INT_16U_MAX_VAL)))
    if (timeout_sec > NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* ----------- CFG TCP CONN TX IDLE TIMEOUT ----------- */
    p_conn                   = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TimeoutConn_sec  =  timeout_sec;
    p_conn->TimeoutConn_tick =  timeout_sec * NET_TMR_TIME_TICK_PER_SEC;


    NetTmr_Set( p_conn->TimeoutTmr,                             /* Set inactivity tmr.                                  */
               &NetTCP_ConnIdleTimeout,
                p_conn->TimeoutConn_tick,
               &err);

    if (err != NET_TMR_ERR_NONE) {
       *p_err = err;
        return (DEF_FAIL);
    }

   *p_err = NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                   NetTCP_ConnCfgMaxSegSizeLocal()
*
* Description : (1) Configure TCP connection's   local maximum segment size :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection local maximum segment size                 See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure local maximum segment size.
*
*               max_seg_size    Desired maximum segment size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgMaxSegSizeLocalHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection local maximum segment size
*                                                                   successfully configured.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE  Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP     Invalid TCP connection operation.
*                               NET_TCP_ERR_INVALID_ARG         Invalid local maximum segment size.
*
*                                                               ---------- RETURNED BY NetTCP_ConnIsUsed() : -----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               -------- RETURNED BY Net_GlobalLockAcquire() : ---------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection local maximum segment size successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgMaxSegSizeLocal() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgMaxSegSizeLocalHandler()  Note #2'.
*
*               (3) RFC #793, Section 3.1 'Header Format : Options : Maximum Segment Size' states that
*                   a TCP connection advertises its "maximum receive segment size ... only ... in the
*                   initial connection request (i.e., in segments with the SYN control bit set)".
*
*                   Thus any configuration of the local receive maximum segment size MUST be performed
*                   by the application layer PRIOR to any TCP connection request/synchronization either
*                   from a :
*
*                   (a) Actively- connected TCP connection
*                   (b) Passively-connected TCP connection, which is cloned from its previously-
*                           configured LISTEN-state TCP connection
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgMaxSegSizeLocal (NET_TCP_CONN_ID    conn_id_tcp,
                                            NET_TCP_SEG_SIZE   max_seg_size,
                                            NET_ERR           *p_err)
{
   CPU_BOOLEAN  cfg_valid;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgMaxSegSizeLocal, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* --------- CFG TCP CONN LOCAL MAX SEG SIZE ---------- */
   cfg_valid = NetTCP_ConnCfgMaxSegSizeLocalHandler(conn_id_tcp, max_seg_size, p_err);

   goto exit_release;


exit_lock_fault:
    cfg_valid = DEF_FAIL;
    goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
    Net_GlobalLockRelease();

exit:
    return (cfg_valid);
}


/*
*********************************************************************************************************
*                               NetTCP_ConnCfgMaxSegSizeLocalHandler()
*
* Description : (1) Configure TCP connection's   local maximum segment size :
*
*                   (a) Validate  TCP connection local maximum segment size configuration
*                   (b) Configure TCP connection local maximum segment size                 See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure local maximum segment size.
*               -----------     Argument checked by NetTCP_ConnCfgMaxSegSizeLocal().
*
*               max_seg_size    Desired maximum segment size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection local maximum segment size
*                                                                   successfully configured.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE  Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP     Invalid TCP connection operation.
*                               NET_TCP_ERR_INVALID_ARG         Invalid local maximum segment size.
*
* Return(s)   : DEF_OK,   TCP connection local maximum segment size successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgMaxSegSizeLocal().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgMaxSegSizeLocalHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgMaxSegSizeLocal()  Note #2'.
*
*               (3) RFC #793, Section 3.1 'Header Format : Options : Maximum Segment Size' states that
*                   a TCP connection advertises its "maximum receive segment size ... only ... in the
*                   initial connection request (i.e., in segments with the SYN control bit set)".
*
*                   Thus any configuration of the local receive maximum segment size MUST be performed
*                   by the application layer PRIOR to any TCP connection request/synchronization either
*                   from a :
*
*                   (a) Actively- connected TCP connection
*                   (b) Passively-connected TCP connection, which is cloned from its previously-
*                           configured LISTEN-state TCP connection
*
*               (4) TCP connections' 'MaxSegSizeLocal' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgMaxSegSizeLocalHandler (NET_TCP_CONN_ID    conn_id_tcp,
                                                   NET_TCP_SEG_SIZE   max_seg_size,
                                                   NET_ERR           *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* -------------- VALIDATE MAX SEG SIZE --------------- */
#if (NET_TCP_MAX_SEG_SIZE_MIN > 0)
    if (max_seg_size < NET_TCP_MAX_SEG_SIZE_MIN) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif

#if ((NET_TCP_MAX_SEG_SIZE_MAX < DEF_INT_08U_MAX_VAL)                                                      || \
    ((NET_TCP_MAX_SEG_SIZE_MAX < DEF_INT_16U_MAX_VAL) && (NET_TCP_MAX_SEG_SIZE_MAX > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_MAX_SEG_SIZE_MAX < DEF_INT_32U_MAX_VAL) && (NET_TCP_MAX_SEG_SIZE_MAX > DEF_INT_16U_MAX_VAL)))
    if (max_seg_size > NET_TCP_MAX_SEG_SIZE_MAX) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif

                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (DEF_FAIL);


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (DEF_FAIL);


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_CONN_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (DEF_FAIL);
    }


                                                                /* --------- CFG TCP CONN LOCAL MAX SEG SIZE ---------- */
    p_conn->MaxSegSizeLocalCfgd = max_seg_size;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnCfgRxWinSize()
*
* Description : (1) Configure TCP connection's   receive window size :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection receive window size                        See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure receive window size.
*
*               win_size        Desired receive window size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgRxWinSizeHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection receive window size successfully
*                                                                   configured.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE  Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP     Invalid TCP connection operation.
*                               NET_TCP_ERR_INVALID_ARG         Invalid receive window size.
*
*                                                               ------- RETURNED BY NetTCP_ConnIsUsed() : --------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ----- RETURNED BY Net_GlobalLockAcquire() : ------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection receive window size successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgRxWinSize() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgRxWinSizeHandler()  Note #2'.
*
*               (3) A TCP connection's receive window size SHOULD NOT be updated after the TCP
*                   connection is connected (see 'NetTCP_RxConnWinSizeHandler()  Notes #2b & #5').
*                   Thus any configuration of the local receive window size MUST be performed
*                   by the application layer PRIOR to any TCP connection request/synchronization
*                   either from a :
*
*                   (a) Actively- connected TCP connection
*                   (b) Passively-connected TCP connection, which is cloned from its previously-
*                           configured LISTEN-state TCP connection
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgRxWinSize (NET_TCP_CONN_ID    conn_id_tcp,
                                      NET_TCP_WIN_SIZE   win_size,
                                      NET_ERR           *p_err)
{
   CPU_BOOLEAN  cfg_valid;


#if(NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgRxWinSize, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ------------- CFG TCP CONN RX WIN SIZE ------------- */
   cfg_valid = NetTCP_ConnCfgRxWinSizeHandler(conn_id_tcp, win_size, p_err);
   goto exit_release;


exit_lock_fault:
    cfg_valid = DEF_FAIL;
    goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                  NetTCP_ConnCfgRxWinSizeHandler()
*
* Description : (1) Configure TCP connection's   receive window size :
*
*                   (a) Validate  TCP connection receive window size configuration
*                   (b) Configure TCP connection receive window size                        See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure receive window size.
*               -----------     Argument checked by NetTCP_ConnCfgRxWinSize(),
*                                                   NetSock_CfgRxQ_Size().
*
*               win_size        Desired receive window size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection receive window size
*                                                                   successfully configured.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE  Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP     Invalid TCP connection operation.
*                               NET_TCP_ERR_INVALID_ARG         Invalid receive window size.
*
* Return(s)   : DEF_OK,   TCP connection receive window size successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgRxWinSize(),
*               NetSock_CfgRxQ_Size().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgRxWinSizeHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgRxWinSize()  Note #2'.
*
*               (3) A TCP connection's receive window size SHOULD NOT be updated after the TCP
*                   connection is connected (see 'NetTCP_RxConnWinSizeHandler()  Notes #2b & #5').
*                   Thus any configuration of the local receive window size MUST be performed
*                   by the application layer PRIOR to any TCP connection request/synchronization
*                   either from a :
*
*                   (a) Actively- connected TCP connection
*                   (b) Passively-connected TCP connection, which is cloned from its previously-
*                           configured LISTEN-state TCP connection
*
*               (4) TCP connections' 'RxWinSizeCfgd' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgRxWinSizeHandler (NET_TCP_CONN_ID    conn_id_tcp,
                                             NET_TCP_WIN_SIZE   win_size,
                                             NET_ERR           *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* --------------- VALIDATE RX WIN SIZE --------------- */
#if (NET_TCP_WIN_SIZE_MIN > 0)
    if (win_size < NET_TCP_WIN_SIZE_MIN) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif

#if ((NET_TCP_WIN_SIZE_MAX < DEF_INT_08U_MAX_VAL)                                                  || \
    ((NET_TCP_WIN_SIZE_MAX < DEF_INT_16U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_WIN_SIZE_MAX < DEF_INT_32U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_16U_MAX_VAL)))
    if (win_size > NET_TCP_WIN_SIZE_MAX) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (DEF_FAIL);


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (DEF_FAIL);


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_CONN_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (DEF_FAIL);
    }


                                                                /* ------------- CFG TCP CONN RX WIN SIZE ------------- */
    p_conn->RxWinSizeCfgd = win_size;                           /* Cfg rx win size.                                     */
    NetTCP_RxConnWinSizeCfg(p_conn);                            /* Cfg rx win ctrls.                                    */


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnCfgTxWinSize()
*
* Description : (1) Configure TCP connection's   transmit window size :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection transmit window size                       See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit window size.
*
*               win_size        Desired transmit window size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgTxWinSizeHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection transmit window size successfully
*                                                                   configured.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE  Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP     Invalid TCP connection operation.
*                               NET_TCP_ERR_INVALID_ARG         Invalid transmit window size.
*
*                                                               ------- RETURNED BY NetTCP_ConnIsUsed() : --------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ------ RETURNED BY Net_GlobalLockAcquire() : -----
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit window size successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxWinSize() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgTxWinSizeHandler()  Note #2'.
*
*               (3) A TCP connection's transmit window size SHOULD NOT be updated after the TCP connection is
*                   connected.  Thus any configuration of the local transmit window size MUST be performed by
*                   the application layer PRIOR to any TCP connection request/synchronization either from a :
*
*                   (a) Actively- connected TCP connection
*                   (b) Passively-connected TCP connection, which is cloned from its previously-
*                           configured LISTEN-state TCP connection
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCfgd()  Note #3'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxWinSize (NET_TCP_CONN_ID    conn_id_tcp,
                                      NET_TCP_WIN_SIZE   win_size,
                                      NET_ERR           *p_err)
{
   CPU_BOOLEAN  cfg_valid;

                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxWinSize, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ------------- CFG TCP CONN TX WIN SIZE ------------- */
   cfg_valid = NetTCP_ConnCfgTxWinSizeHandler(conn_id_tcp, win_size, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                  NetTCP_ConnCfgTxWinSizeHandler()
*
* Description : (1) Configure TCP connection's   transmit window size :
*
*                   (a) Validate  TCP connection transmit window size configuration
*                   (b) Configure TCP connection transmit window size                       See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit window size.
*               -----------     Argument checked by NetTCP_ConnCfgTxWinSize(),
*                                                   NetSock_CfgTxQ_Size().
*
*               win_size        Desired transmit window size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit window size
*                                                                   successfully configured.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE  Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP     Invalid TCP connection operation.
*                               NET_TCP_ERR_INVALID_ARG         Invalid transmit window size.
*
* Return(s)   : DEF_OK,   TCP connection transmit window size successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgTxWinSize(),
*               NetSock_CfgTxQ_Size().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxWinSizeHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgTxWinSize()  Note #2'.
*
*               (3) A TCP connection's transmit window size SHOULD NOT be updated after the TCP connection is
*                   connected.  Thus any configuration of the local transmit window size MUST be performed by
*                   the application layer PRIOR to any TCP connection request/synchronization either from a :
*
*                   (a) Actively- connected TCP connection
*                   (b) Passively-connected TCP connection, which is cloned from its previously-
*                           configured LISTEN-state TCP connection
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCfgd()  Note #3'.
*
*               (4) TCP connections' 'TxWinSizeCfgd' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxWinSizeHandler (NET_TCP_CONN_ID    conn_id_tcp,
                                             NET_TCP_WIN_SIZE   win_size,
                                             NET_ERR           *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* --------------- VALIDATE TX WIN SIZE --------------- */
#if (NET_TCP_WIN_SIZE_MIN > 0)
    if (win_size < NET_TCP_WIN_SIZE_MIN) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif

#if ((NET_TCP_WIN_SIZE_MAX < DEF_INT_08U_MAX_VAL)                                                  || \
    ((NET_TCP_WIN_SIZE_MAX < DEF_INT_16U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_WIN_SIZE_MAX < DEF_INT_32U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_16U_MAX_VAL)))
    if (win_size > NET_TCP_WIN_SIZE_MAX) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif

                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (DEF_FAIL);


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (DEF_FAIL);


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_CONN_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (DEF_FAIL);
    }


                                                                /* ------------- CFG TCP CONN TX WIN SIZE ------------- */
    p_conn->TxWinSizeCfgd = win_size;                           /* Cfg tx win size.                                     */
    NetTCP_TxConnWinSizeCfg(p_conn);                            /* Cfg tx win ctrls.                                    */


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnCfgTxNagleEn()
*
* Description : (1) Configure TCP connection's   transmit Nagle algorithm enable :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection transmit Nagle algorithm enable            See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit Nagle enable.
*
*               nagle_en        Desired value for TCP connection transmit Nagle enable :
*
*                                   DEF_ENABLED             TCP connections delay transmitting next data
*                                                               segment(s) until all unacknowledged data
*                                                               is acknowledged OR an MSS-sized segment
*                                                               can be transmitted.
*
*                                   DEF_DISABLED            TCP connections transmit all data segment(s)
*                                                               when permitted by local & remote hosts'
*                                                               congestion controls.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgTxNagleEnHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection transmit Nagle enable successfully
*                                                                   configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid enable/disable configuration.
*
*                                                               ------- RETURNED BY NetTCP_ConnIsUsed() : --------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ------ RETURNED BY Net_GlobalLockAcquire() : -----
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit Nagle enable successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxNagleEn() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgTxNagleEnHandler()  Note #2'.
*
*               (3) RFC #1122, Section 4.2.3.4 also states that "a TCP SHOULD implement the Nagle
*                   Algorithm ... However, there MUST be a way for an application to disable the
*                   Nagle algorithm on an individual connection".
*
*                   See also 'NetTCP_TxConnTxQ()  Note #6'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxNagleEn (NET_TCP_CONN_ID   conn_id_tcp,
                                      CPU_BOOLEAN       nagle_en,
                                      NET_ERR          *p_err)
{
   CPU_BOOLEAN  cfg_valid;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxNagleEn, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ------------- CFG TCP CONN TX NAGLE EN ------------- */
   cfg_valid = NetTCP_ConnCfgTxNagleEnHandler(conn_id_tcp, nagle_en, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                  NetTCP_ConnCfgTxNagleEnHandler()
*
* Description : (1) Configure TCP connection's   transmit Nagle algorithm enable :
*
*                   (a) Validate  TCP connection transmit Nagle algorithm enable configuration
*                   (b) Configure TCP connection transmit Nagle algorithm enable                See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit Nagle enable.
*               -----------     Argument checked in NetTCP_ConnCfgTxNagleEn().
*
*               nagle_en        Desired value for TCP connection transmit Nagle enable :
*
*                                   DEF_ENABLED             TCP connections delay transmitting next data
*                                                               segment(s) until all unacknowledged data
*                                                               is acknowledged OR an MSS-sized segment
*                                                               can be transmitted.
*
*                                   DEF_DISABLED            TCP connections transmit all data segment(s)
*                                                               when permitted by local & remote hosts'
*                                                               congestion controls.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit Nagle enable
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid enable/disable configuration.
*
* Return(s)   : DEF_OK,   TCP connection transmit Nagle enable successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgTxNagleEn().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxNagleEnHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgTxNagleEn()  Note #2'.
*
*               (3) RFC #1122, Section 4.2.3.4 also states that "a TCP SHOULD implement the Nagle
*                   Algorithm ... However, there MUST be a way for an application to disable the
*                   Nagle algorithm on an individual connection".
*
*                   See also 'NetTCP_TxConnTxQ()  Note #6'.
*
*               (4) TCP connections' 'TxWinSizeNagleEn' variables MUST ALWAYS be accessed with the
*                   global network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxNagleEnHandler (NET_TCP_CONN_ID   conn_id_tcp,
                                             CPU_BOOLEAN       nagle_en,
                                             NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* ---------------- VALIDATE NAGLE EN ----------------- */
    switch (nagle_en) {
        case DEF_ENABLED:
        case DEF_DISABLED:
             break;


        default:
            *p_err =  NET_TCP_ERR_INVALID_ARG;
             return (DEF_FAIL);
    }


                                                                /* ------------- CFG TCP CONN TX NAGLE EN ------------- */
    p_conn                   = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxWinSizeNagleEn =  nagle_en;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                 NetTCP_ConnCfgTxAckImmedRxdPushEn()
*
* Description : (1) Configure TCP connection's   transmit immediate acknowledgement for received & pushed
*                       TCP segments enable :
*
*                   (a) Validate  TCP connection transmit immediate acknowledgement enable configuration
*                   (b) Acquire   network lock
*                   (c) Validate  TCP connection used
*                   (d) Configure TCP connection transmit immediate acknowledgement enable      See Note #3
*                   (e) Release   network lock
*
*
* Argument(s) : conn_id_tcp         Handle identifier of TCP connection to configure transmit immediate
*                                       acknowledgement for received & pushed TCP segments enable.
*
*               tx_immed_ack_en     Desired value for TCP connection transmit immediate acknowledgement
*                                       for received & pushed TCP segments enable :
*
*                                       DEF_ENABLED             TCP connection acknowledgements
*                                                                   immediately transmitted for any
*                                                                   pushed TCP segments received.
*
*                                       DEF_DISABLED            TCP connection acknowledgements NOT
*                                                                   immediately transmitted for any
*                                                                   pushed TCP segments received.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit immediate
*                                                                   acknowledgement successfully configured.
*
*                               NET_TCP_ERR_INVALID_ARG         Invalid enable/disable configuration.
*
*                                                               ---- RETURNED BY NetTCP_ConnIsUsed() : -----
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               --- RETURNED BY Net_GlobalLockAcquire() : --
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit immediate acknowledgement for received & pushed TCP
*                             segments enable successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxAckImmedRxdPushEn() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*               (3) RFC #813, Section 5 states that "the receiver of data will refrain from sending an
*                   acknowledgement under certain circumstances ... The most obvious event on which to
*                   depend is the arrival of another segment.  So, if a segment arrives, postpone sending
*                   an acknowledgement if ... the push bit is not set in the segment, since it is a
*                   reasonable assumption that there is more data coming in a subsequent segment."
*
*                   See also 'NetTCP_TxConnAck()  Note #4a4'.
*
*               (4) TCP connections' 'TxAckImmedRxdPushEn' variables MUST ALWAYS be accessed with the
*                   global network lock already acquired (see Note #2b).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxAckImmedRxdPushEn (NET_TCP_CONN_ID   conn_id_tcp,
                                                CPU_BOOLEAN       tx_immed_ack_en,
                                                NET_ERR          *p_err)
{
   NET_TCP_CONN  *p_conn;
   CPU_BOOLEAN    rtn_val;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ------------- VALIDATE TX IMMED ACK EN ------------- */
   switch (tx_immed_ack_en) {
       case DEF_ENABLED:
       case DEF_DISABLED:
            break;


       default:
           *p_err =  NET_TCP_ERR_INVALID_ARG;
            return (DEF_FAIL);
   }


                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxAckImmedRxdPushEn, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif


                                                                /* ----------- CFG TCP CONN TX IMMED ACK EN ----------- */
   p_conn                      = &NetTCP_ConnTbl[conn_id_tcp];
   p_conn->TxAckImmedRxdPushEn =  tx_immed_ack_en;


   rtn_val = DEF_OK;
  *p_err =  NET_TCP_ERR_NONE;
   goto exit_release;


exit_lock_fault:
   rtn_val = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   rtn_val = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (rtn_val);
}


/*
*********************************************************************************************************
*                                   NetTCP_ConnCfgTxAckDlyTimeout()
*
* Description : (1) Configure TCP connection's   transmit acknowledgement delay timeout :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection transmit acknowledgement delay timeout     See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit acknowledgement
*                                   delay timeout.
*
*               timeout_ms      Desired value for TCP connection transmit acknowledgement delay timeout
*                                   (in milliseconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgTxAckDlyTimeoutHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection transmit acknowledgement delay timeout
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid acknowledgement delay timeout.
*
*                                                               ---------- RETURNED BY NetTCP_ConnIsUsed() : -----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               --------- RETURNED BY Net_GlobalLockAcquire() : --------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit acknowledgement delay timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxAckDlyTimeout() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgTxAckDlyTimeoutHandler()  Note #2'.
*
*               (3) (a) RFC #1122, Section 4.2.3.2 states that "an ACK should not be excessively delayed;
*                       in particular, the delay MUST be less than 0.5 seconds".
*
*                   (b) RFC #2581, Section 4.2 reiterates that "an ACK ... MUST be generated within 500 ms
*                       of the arrival of the first unacknowledged packet".
*
*                   See also 'NetTCP_TxConnAck()  Note #6a2'.
*
*               (4) Configured timeout does NOT reschedule any current acknowledgement delay timeout in
*                   progress but becomes effective the next time a TCP connection sets an acknowledgement
*                   delay timeout.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxAckDlyTimeout (NET_TCP_CONN_ID      conn_id_tcp,
                                            NET_TCP_TIMEOUT_MS   timeout_ms,
                                            NET_ERR             *p_err)
{
    CPU_BOOLEAN  cfg_valid;

                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
    Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxAckDlyTimeout, p_err);
    if (*p_err != NET_ERR_NONE) {
         goto exit_lock_fault;
    }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         goto exit_fail;
    }
#endif

                                                                /* --------- CFG TCP CONN TX ACK DLY TIMEOUT ---------- */
    cfg_valid = NetTCP_ConnCfgTxAckDlyTimeoutHandler(conn_id_tcp, timeout_ms, p_err);
    goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                               NetTCP_ConnCfgTxAckDlyTimeoutHandler()
*
* Description : (1) Configure TCP connection's   transmit acknowledgement delay timeout :
*
*                   (a) Validate  TCP connection transmit acknowledgement delay timeout configuration
*                   (b) Configure TCP connection transmit acknowledgement delay timeout         See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit acknowledgement
*               -----------         delay timeout.
*
*                               Argument checked   in NetTCP_ConnCfgTxAckDlyTimeout();
*                                        validated in NetTCP_ConnClr().
*
*               timeout_ms      Desired value for TCP connection transmit acknowledgement delay timeout
*                                   (in milliseconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit acknowledgement
*                                                                   delay timeout successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid acknowledgement delay timeout.
*
* Return(s)   : DEF_OK,   TCP connection transmit acknowledgement delay timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgTxAckDlyTimeout(),
*               NetTCP_ConnClr().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxAckDlyTimeoutHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgTxAckDlyTimeout()  Note #2'.
*
*               (3) (a) (1) RFC #1122, Section 4.2.3.2 states that "an ACK should not be excessively
*                               delayed; in particular, the delay MUST be less than 0.5 seconds".
*
*                       (2) RFC #2581, Section 4.2 reiterates that "an ACK ... MUST be generated
*                           within 500 ms of the arrival of the first unacknowledged packet".
*
*                   (b) If the acknowledgement delay timeout is configured with a non-zero value,
*                       at least one timer tick MUST be set to ensure that the non-zero timeout
*                       is implemented.
*
*                   See also 'NetTCP_TxConnAck()  Note #6a2'.
*
*               (4) Configured timeout does NOT reschedule any current acknowledgement delay timeout in
*                   progress but becomes effective the next time a TCP connection sets an acknowledgement
*                   delay timeout.
*
*               (5) Configured timeout converted to 'NET_TMR_TICK' ticks to avoid run-time conversion.
*
*               (6) TCP connections' 'TxAckDlyTimeout' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxAckDlyTimeoutHandler (NET_TCP_CONN_ID      conn_id_tcp,
                                                   NET_TCP_TIMEOUT_MS   timeout_ms,
                                                   NET_ERR             *p_err)
{
    NET_TCP_CONN  *p_conn;
    NET_TMR_TICK   timeout_tick;


                                                                /* ----------- VALIDATE TX ACK DLY TIMEOUT ------------ */
#if (NET_TCP_ACK_DLY_TIME_MIN_MS > 0)
    if (timeout_ms < NET_TCP_ACK_DLY_TIME_MIN_MS) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if ((NET_TCP_ACK_DLY_TIME_MAX_MS < DEF_INT_08U_MAX_VAL)                                                         || \
    ((NET_TCP_ACK_DLY_TIME_MAX_MS < DEF_INT_16U_MAX_VAL) && (NET_TCP_ACK_DLY_TIME_MAX_MS > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_ACK_DLY_TIME_MAX_MS < DEF_INT_32U_MAX_VAL) && (NET_TCP_ACK_DLY_TIME_MAX_MS > DEF_INT_16U_MAX_VAL)))
    if (timeout_ms > NET_TCP_ACK_DLY_TIME_MAX_MS) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* --------- CFG TCP CONN TX ACK DLY TIMEOUT ---------- */
    timeout_tick = (timeout_ms * NET_TMR_TIME_TICK_PER_SEC) / DEF_TIME_NBR_mS_PER_SEC;
    if (timeout_tick < 1) {                                     /* If < 1 tick, ...                                     */
        timeout_tick = 1u;                                      /* ... set at least 1 tick (see Note #3b).              */
    }

    p_conn                       = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxAckDlyTimeout_ms   =  timeout_ms;
    p_conn->TxAckDlyTimeout_tick =  timeout_tick;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                    NetTCP_ConnCfgTxKeepAliveEn()
*
* Description : (1) Configure TCP connection's   transmit keep-alive algorithm enable :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection transmit keep-alive algorithm enable       See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive enable.
*
*               keep_alive_en   Desired value for TCP connection transmit keep-alive enable :
*
*                                   DEF_ENABLED             TCP connections transmit periodic keep-alive
*                                                               segments if NO data segments have been
*                                                               received within the keep-alive timeout.
*
*                                   DEF_DISABLED            TCP connections transmit a reset segment &
*                                                               close    if NO data segments have been
*                                                               received within the keep-alive timeout.
*
*                               See also 'NetTCP_ConnCfgIdleTimeoutHandler()  Note #1'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgTxKeepAliveEnHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection transmit keep-alive enable successfully
*                                                                   configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid enable/disable configuration.
*
*                                                               --------- RETURNED BY NetTCP_ConnIsUsed() : ----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               -------- RETURNED BY Net_GlobalLockAcquire() : -------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit keep-alive enable successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxKeepAliveEn() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgTxKeepAliveEnHandler()  Note #2'.
*
*               (3) RFC #1122, Section 4.2.3.6 states that "if keep-alives are included, the application
*                   MUST be able to turn them on or off for each TCP connection".
*
*                   See also 'NetTCP_TxConnKeepAlive()  Note #2a'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxKeepAliveEn (NET_TCP_CONN_ID   conn_id_tcp,
                                          CPU_BOOLEAN       keep_alive_en,
                                          NET_ERR          *p_err)
{
   CPU_BOOLEAN  cfg_valid;

                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxKeepAliveEn, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }
#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ---------- CFG TCP CONN TX KEEP-ALIVE EN ----------- */
   cfg_valid = NetTCP_ConnCfgTxKeepAliveEnHandler(conn_id_tcp, keep_alive_en, p_err);

   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                NetTCP_ConnCfgTxKeepAliveEnHandler()
*
* Description : (1) Configure TCP connection's   transmit keep-alive algorithm enable :
*
*                   (a) Validate  TCP connection transmit keep-alive algorithm enable configuration
*                   (b) Configure TCP connection transmit keep-alive algorithm enable           See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive enable.
*               -----------     Argument checked in NetTCP_ConnCfgTxKeepAliveEn().
*
*               keep_alive_en   Desired value for TCP connection transmit keep-alive enable :
*
*                                   DEF_ENABLED             TCP connections transmit periodic keep-alive
*                                                               segments if NO data segments have been
*                                                               received within the keep-alive timeout.
*
*                                   DEF_DISABLED            TCP connections transmit a reset segment &
*                                                               close    if NO data segments have been
*                                                               received within the keep-alive timeout.
*
*                               See also 'NetTCP_ConnCfgIdleTimeoutHandler()  Note #1'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit keep-alive
*                                                                   enable successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid enable/disable configuration.
*
* Return(s)   : DEF_OK,   TCP connection transmit keep-alive enable successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgTxKeepAliveEn().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxKeepAliveEnHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgTxKeepAliveEn()  Note #2'.
*
*               (3) RFC #1122, Section 4.2.3.6 states that "if keep-alives are included, the application
*                   MUST be able to turn them on or off for each TCP connection".
*
*                   See also 'NetTCP_TxConnKeepAlive()  Note #2a'.
*
*               (4) TCP connections' 'TxKeepAliveEn' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxKeepAliveEnHandler (NET_TCP_CONN_ID   conn_id_tcp,
                                                 CPU_BOOLEAN       keep_alive_en,
                                                 NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* ------------ VALIDATE TX KEEP-ALIVE EN ------------- */
    switch (keep_alive_en) {
        case DEF_ENABLED:
        case DEF_DISABLED:
             break;


        default:
            *p_err =  NET_TCP_ERR_INVALID_ARG;
             return (DEF_FAIL);
    }


                                                                /* ---------- CFG TCP CONN TX KEEP-ALIVE EN ----------- */
    p_conn                = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxKeepAliveEn =  keep_alive_en;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                    NetTCP_ConnCfgTxKeepAliveTh()
*
* Description : (1) Configure TCP connection's maximum number of consecutive keep-alives to transmit :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection transmit keep-alive threshold              See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp             Handle identifier of TCP connection to configure transmit
*                                           keep-alive threshold.
*
*               nbr_max_keep_alive      Desired maximum number of consecutive keep-alives to transmit.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgTxKeepAliveThHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection transmit keep-alive threshold
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid maximum number of keep-alives.
*
*                                                               --------- RETURNED BY NetTCP_ConnIsUsed() : ----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               -------- RETURNED BY Net_GlobalLockAcquire() : -------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit keep-alive threshold successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxKeepAliveTh() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgTxKeepAliveThHandler()  Note #2'.
*
*               (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other End Crashes',
*                   Pages 334-335 states "that the [remote host] ... send[s] ... [N] keepalive probes ...
*                   before declaring the connection dead".
*
*                   See also 'NetTCP_TxConnKeepAlive()  Note #2c3'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxKeepAliveTh (NET_TCP_CONN_ID   conn_id_tcp,
                                          NET_PKT_CTR       nbr_max_keep_alive,
                                          NET_ERR          *p_err)
{
   CPU_BOOLEAN  cfg_valid;

                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxKeepAliveTh, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ---------- CFG TCP CONN TX KEEP-ALIVE TH ----------- */
   cfg_valid = NetTCP_ConnCfgTxKeepAliveThHandler(conn_id_tcp, nbr_max_keep_alive, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                NetTCP_ConnCfgTxKeepAliveThHandler()
*
* Description : (1) Configure TCP connection's maximum number of consecutive keep-alives to transmit :
*
*                   (a) Validate  TCP connection transmit keep-alive threshold configuration
*                   (b) Configure TCP connection transmit keep-alive threshold                  See Note #3
*
*
* Argument(s) : conn_id_tcp             Handle identifier of TCP connection to configure transmit
*               -----------                 keep-alive threshold.
*
*                                       Argument checked in NetTCP_ConnCfgTxKeepAliveTh().
*
*               nbr_max_keep_alive      Desired maximum number of consecutive keep-alives to transmit.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit keep-alive
*                                                                   threshold successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid maximum number of keep-alives.
*
* Return(s)   : DEF_OK,   TCP connection transmit keep-alive threshold successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgTxKeepAliveTh().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxKeepAliveThHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgTxKeepAliveTh()  Note #2'.
*
*               (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other End Crashes',
*                   Pages 334-335 states "that the [remote host] ... send[s] ... [N] keepalive probes ...
*                   before declaring the connection dead".
*
*                   See also 'NetTCP_TxConnKeepAlive()  Note #2c3'.
*
*               (4) TCP connections' 'TxKeepAliveTh' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxKeepAliveThHandler (NET_TCP_CONN_ID   conn_id_tcp,
                                                 NET_PKT_CTR       nbr_max_keep_alive,
                                                 NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* ------------ VALIDATE TX KEEP-ALIVE TH ------------- */
#if (NET_TCP_TX_KA_TH_MIN  > NET_PKT_CTR_MIN)
    if (nbr_max_keep_alive < NET_TCP_TX_KA_TH_MIN) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if (NET_TCP_TX_KA_TH_MAX  < NET_PKT_CTR_MAX)
    if (nbr_max_keep_alive > NET_TCP_TX_KA_TH_MAX) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* ---------- CFG TCP CONN TX KEEP-ALIVE TH ----------- */
    p_conn                = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxKeepAliveTh =  nbr_max_keep_alive;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                               NetTCP_ConnCfgTxKeepAliveRetryTimeout()
*
* Description : (1) Configure TCP connection's   transmit keep-alive retry timeout :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection transmit keep-alive retry timeout
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive retry
*                                   timeout.
*
*               timeout_sec     Desired value for TCP connection transmit keep-alive retry timeout (in seconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgTxKeepAliveRetryHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection transmit keep-alive retry timeout
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid keep-alive retry timeout.
*
*                                                               ----------- RETURNED BY NetTCP_ConnIsUsed() : -----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               --------- RETURNED BY Net_GlobalLockAcquire() : ---------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection transmit keep-alive retry timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxKeepAliveRetryTimeout() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgTxKeepAliveRetryHandler()  Note #2'.
*
*               (3) Configured timeout does NOT reschedule any current keep-alive retry timeout in progress
*                   but becomes effective the next time a TCP connection sets its keep-alive retry timeout.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxKeepAliveRetryTimeout (NET_TCP_CONN_ID       conn_id_tcp,
                                                    NET_TCP_TIMEOUT_SEC   timeout_sec,
                                                    NET_ERR              *p_err)
{
   CPU_BOOLEAN  cfg_valid;

                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgTxKeepAliveRetryTimeout, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ----- CFG TCP CONN TX KEEP-ALIVE RETRY TIMEOUT ----- */
   cfg_valid = NetTCP_ConnCfgTxKeepAliveRetryHandler(conn_id_tcp, timeout_sec, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                               NetTCP_ConnCfgTxKeepAliveRetryHandler()
*
* Description : (1) Configure TCP connection's   transmit keep-alive retry timeout :
*
*                   (a) Validate  TCP connection transmit keep-alive retry timeout configuration
*                   (b) Configure TCP connection transmit keep-alive retry timeout
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive retry
*               -----------         timeout.
*
*                               Argument checked in NetTCP_ConnCfgTxKeepAliveRetryTimeout().
*
*               timeout_sec     Desired value for TCP connection transmit keep-alive retry timeout (in seconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection transmit keep-alive retry
*                                                                   timeout successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid keep-alive retry timeout.
*
* Return(s)   : DEF_OK,   TCP connection transmit keep-alive retry timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgTxKeepAliveRetryTimeout().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgTxKeepAliveRetryHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgTxKeepAliveRetryTimeout()  Note #2'.
*
*               (3) NetTCP_ConnCfgTxKeepAliveRetryTimeoutHandler() abbreviated to
*                   NetTCP_ConnCfgTxKeepAliveRetryHandler() to enforce ANSI-compliance of 31-character
*                   symbol length uniqueness.
*
*               (4) Configured timeout does NOT reschedule any current keep-alive retry timeout in progress
*                   but becomes effective the next time a TCP connection sets its keep-alive retry timeout.
*
*               (5) TCP connections' 'TxKeepAliveRetryTimeout_sec' variables MUST ALWAYS be accessed with
*                   the global network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgTxKeepAliveRetryHandler (NET_TCP_CONN_ID       conn_id_tcp,
                                                    NET_TCP_TIMEOUT_SEC   timeout_sec,
                                                    NET_ERR              *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* ------- VALIDATE TX KEEP-ALIVE RETRY TIMEOUT ------- */
#if (NET_TCP_TX_KA_RETRY_TIMEOUT_MIN_SEC > 0)
    if (timeout_sec < NET_TCP_TX_KA_RETRY_TIMEOUT_MIN_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if ((NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                 || \
    ((NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC > DEF_INT_16U_MAX_VAL)))
    if (timeout_sec > NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* ----- CFG TCP CONN TX KEEP-ALIVE RETRY TIMEOUT ----- */
    p_conn                              = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxKeepAliveRetryTimeout_sec =  timeout_sec;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnCfgReTxMaxTh()
*
* Description : (1) Configure TCP connection's   maximum number of same segment retransmissions :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection maximum number retransmissions             See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure maximum number of
*                                   same segment retransmissions.
*
*               nbr_max_re_tx   Desired maximum number of same segment retransmissions.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgReTxMaxThHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection maximum number of retransmissions
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid maximum number of retransmissions.
*
*                                                               ------- RETURNED BY NetTCP_ConnIsUsed() : --------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ----- RETURNED BY Net_GlobalLockAcquire() : ------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection maximum number of same segment retransmissions successfully
*                             configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgReTxMaxTh() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgReTxMaxThHandler()  Note #2'.
*
*               (3) RFC #1122, Section 4.2.3.5 states that "when the number of transmissions of the
*                   same segment reaches a threshold ... close the connection".
*
*                   See also 'NetTCP_TxConnReTxQ()  Note #3'.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgReTxMaxTh (NET_TCP_CONN_ID   conn_id_tcp,
                                      NET_PKT_CTR       nbr_max_re_tx,
                                      NET_ERR          *p_err)
{
   CPU_BOOLEAN  cfg_valid;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgReTxMaxTh, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* -------------- CFG TCP CONN RE-TX TH --------------- */
   cfg_valid = NetTCP_ConnCfgReTxMaxThHandler(conn_id_tcp, nbr_max_re_tx, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                  NetTCP_ConnCfgReTxMaxThHandler()
*
* Description : (1) Configure TCP connection's   maximum number of same segment retransmissions :
*
*                   (a) Validate  TCP connection maximum number retransmissions configuration
*                   (b) Configure TCP connection maximum number retransmissions                 See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure maximum number of
*               -----------         same segment retransmissions.
*
*                               Argument checked in NetTCP_ConnCfgReTxMaxTh().
*
*               nbr_max_re_tx   Desired maximum number of same segment retransmissions.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection maximum number of
*                                                                   retransmissions successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid maximum number of retransmissions.
*
* Return(s)   : DEF_OK,   TCP connection maximum number of same segment retransmissions successfully
*                             configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgReTxMaxTh().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgReTxMaxThHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgReTxMaxTh()  Note #2'.
*
*               (3) RFC #1122, Section 4.2.3.5 states that "when the number of transmissions of the
*                   same segment reaches a threshold ... close the connection".
*
*                   See also 'NetTCP_TxConnReTxQ()  Note #3'.
*
*               (4) TCP connections' 'TxSegReTxTh' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgReTxMaxThHandler (NET_TCP_CONN_ID   conn_id_tcp,
                                             NET_PKT_CTR       nbr_max_re_tx,
                                             NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;


                                                                /* ---------------- VALIDATE RE-TX TH ----------------- */
#if (NET_TCP_RE_TX_TH_MIN > NET_PKT_CTR_MIN)
    if (nbr_max_re_tx < NET_TCP_RE_TX_TH_MIN) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if (NET_TCP_RE_TX_TH_MAX < NET_PKT_CTR_MAX)
    if (nbr_max_re_tx > NET_TCP_RE_TX_TH_MAX) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* -------------- CFG TCP CONN RE-TX TH --------------- */
    p_conn              = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxSegReTxTh =  nbr_max_re_tx;


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                   NetTCP_ConnCfgReTxMaxTimeout()
*
* Description : (1) Configure TCP connection's   maximum retransmission timeout :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection maximum retransmission timeout             See Note #3
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure maximum retransmission
*                                   timeout value.
*
*               timeout_sec     Desired value for TCP connection maximum retransmission timeout (in seconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgReTxMaxTimeoutHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection maximum retransmission timeout
*                                                                   successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid maximum retransmission timeout.
*
*                                                               ---------- RETURNED BY NetTCP_ConnIsUsed() : ----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               -------- RETURNED BY Net_GlobalLockAcquire() : --------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection maximum retransmission timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgReTxMaxTimeout() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgReTxMaxTimeoutHandler()  Note #2'.
*
*               (3) (a) RFC #2988, Section 2.4 states that "a maximum value MAY be placed on RTO provided
*                       it is at least 60 seconds".
*
*                   (b) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper bound
*                       should be 2*MSL".
*
*                   (c) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299 states
*                       that "the timeout value ... [has] an upper limit of 64 seconds".
*
*               (4) Configured timeout does NOT reschedule any current retransmission timeout in progress
*                   but becomes effective the next time a TCP connection sets its retransmission timeout.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgReTxMaxTimeout (NET_TCP_CONN_ID       conn_id_tcp,
                                           NET_TCP_TIMEOUT_SEC   timeout_sec,
                                           NET_ERR              *p_err)
{
   CPU_BOOLEAN  cfg_valid;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgReTxMaxTimeout, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* --------------- CFG TCP CONN RTO MAX --------------- */
   cfg_valid = NetTCP_ConnCfgReTxMaxTimeoutHandler(conn_id_tcp, timeout_sec, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                NetTCP_ConnCfgReTxMaxTimeoutHandler()
*
* Description : (1) Configure TCP connection's   maximum retransmission timeout :
*
*                   (a) Validate  TCP connection maximum retransmission timeout configuration
*                   (b) Configure TCP connection maximum retransmission timeout                 See Note #3
*
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to configure maximum retransmission
*               -----------         timeout value.
*
*                               Argument checked in NetTCP_ConnCfgReTxMaxTimeout().
*
*               timeout_sec     Desired value for TCP connection maximum retransmission timeout (in seconds).
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection maximum retransmission
*                                                                   timeout successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid maximum retransmission timeout.
*
* Return(s)   : DEF_OK,   TCP connection maximum retransmission timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgReTxMaxTimeout().
*
*               This function is an INTERNAL network protocol suite function & MUST NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgReTxMaxTimeoutHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgReTxMaxTimeout()  Note #2'.
*
*               (3) (a) RFC #2988, Section 2.4 states that "a maximum value MAY be placed on RTO provided
*                       it is at least 60 seconds".
*
*                   (b) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper bound
*                       should be 2*MSL".
*
*                   (c) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299 states
*                       that "the timeout value ... [has] an upper limit of 64 seconds".
*
*               (4) Configured timeout does NOT reschedule any current retransmission timeout in progress
*                   but becomes effective the next time a TCP connection sets its retransmission timeout.
*
*               (5) TCP connections' 'TxRTT_RTO_Max_sec' variables MUST ALWAYS be accessed with the global
*                   network lock already acquired (see Note #2).
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnCfgReTxMaxTimeoutHandler (NET_TCP_CONN_ID       conn_id_tcp,
                                                  NET_TCP_TIMEOUT_SEC   timeout_sec,
                                                  NET_ERR              *p_err)
{
    NET_TCP_CONN  *p_conn;

                                                                /* ----------------- VALIDATE RTO MAX ----------------- */
                                                                /* See Note #3.                                         */
#if (NET_TCP_TX_RTO_MAX_TIMEOUT_MIN_SEC > 0)
    if (timeout_sec < NET_TCP_TX_RTO_MAX_TIMEOUT_MIN_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if ((NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                || \
    ((NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC > DEF_INT_16U_MAX_VAL)))
    if (timeout_sec > NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif


                                                                /* --------------- CFG TCP CONN RTO MAX --------------- */
    p_conn                    = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TxRTT_RTO_Max_sec =  timeout_sec;

    NetTCP_TxConnRTO_CfgMaxTimeout(p_conn);                     /* Cfg RTO ctrls.                                       */


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                   NetTCP_ConnCfgMSL_Timeout()
*
* Description : (1) Configure TCP connection's maximum segment lifetime (MSL) timeout :
*
*                   (a) Acquire   network lock
*                   (b) Validate  TCP connection used
*                   (c) Configure TCP connection MSL
*                   (d) Release   network lock
*
*
* Argument(s) : conn_id_tcp         Handle identifier of TCP connection to configure MSL value.
*
*               msl_timeout_sec     Desired value for TCP connection MSL timeout (in seconds).
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                                                               - RETURNED BY NetTCP_ConnCfgReTxMaxTimeoutHandler() : -
*                               NET_TCP_ERR_NONE                TCP connection MSL successfully configured.
*                               NET_TCP_ERR_INVALID_ARG         Invalid MSL timeout.
*
*                                                              ---------- RETURNED BY NetTCP_ConnIsUsed() : ----------
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
*                                                               ------- RETURNED BY Net_GlobalLockAcquire() : --------
*                               NET_ERR_FAULT_LOCK_ACQUIRE      Network access NOT acquired.
*
* Return(s)   : DEF_OK,   TCP connection MSL timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgMSL_Timeout() is called by application function(s) & ... :
*
*                   (a) MUST NOT be called with the global network lock already acquired; ...
*                   (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
*                       network lock (see 'net.h  Note #3').
*
*                   This is required since an application's network protocol suite API function access
*                   is asynchronous to other network protocol tasks.
*
*                   See also 'NetTCP_ConnCfgMSL_TimeoutHandler()  Note #2'.
*
*********************************************************************************************************
*/

CPU_BOOLEAN NetTCP_ConnCfgMSL_Timeout(NET_TCP_CONN_ID      conn_id_tcp,
                                      NET_TCP_TIMEOUT_SEC  msl_timeout_sec,
                                      NET_ERR             *p_err)
{
   CPU_BOOLEAN  cfg_valid;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
   if (p_err == (NET_ERR *)0) {
       CPU_SW_EXCEPTION(DEF_FAIL);
   }
#endif
                                                                /* ----------------- ACQUIRE NET LOCK ----------------- */
                                                                /* See Note #2b.                                        */
   Net_GlobalLockAcquire((void *)&NetTCP_ConnCfgMSL_Timeout, p_err);
   if (*p_err != NET_ERR_NONE) {
        goto exit_lock_fault;
   }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
  (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
   if (*p_err != NET_TCP_ERR_NONE) {
        goto exit_fail;
   }
#endif

                                                                /* ----------------- CFG TCP CONN MSL ----------------- */
   cfg_valid = NetTCP_ConnCfgMSL_TimeoutHandler(conn_id_tcp, msl_timeout_sec, p_err);
   goto exit_release;


exit_lock_fault:
   cfg_valid = DEF_FAIL;
   goto exit;

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
exit_fail:
   cfg_valid = DEF_FAIL;
#endif

exit_release:
                                                                /* ----------------- RELEASE NET LOCK ----------------- */
   Net_GlobalLockRelease();

exit:
   return (cfg_valid);
}


/*
*********************************************************************************************************
*                                NetTCP_ConnCfgMSL_TimeoutHandler()
*
* Description : (1) Configure TCP connection's   maximum segment lifetime (MSL):
*
*                   (a) Validate  TCP connection MSL configuration
*                   (b) Configure TCP connection MSL
*
*
* Argument(s) : conn_id_tcp         Handle identifier of TCP connection to configure MSL.
*
*                                   Argument checked in NetTCP_ConnCfgMSL_Timeout().
*
*               msl_timeout_sec     Desired value for TCP MSL timeout (in seconds).
*
*               p_err                Pointer to variable that will receive the return error code from this function :
*
*                                   NET_TCP_ERR_NONE                TCP connection MSL successfully configured.
*                                   NET_TCP_ERR_INVALID_ARG         Invalid MSL timeout.
*
* Return(s)   : DEF_OK,   TCP connection maximum retransmission timeout successfully configured.
*
*               DEF_FAIL, otherwise.
*
* Caller(s)   : NetTCP_ConnCfgMSL_Timeout().
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s) [see also Note #2].
*
* Note(s)     : (2) NetTCP_ConnCfgMSL_TimeoutHandler() is called by network protocol suite function(s)
*                   & MUST be called with the global network lock already acquired.
*
*                   See also 'NetTCP_ConnCfgMSL_Timeout()  Note #2'.
*
*********************************************************************************************************
*/

CPU_BOOLEAN NetTCP_ConnCfgMSL_TimeoutHandler(NET_TCP_CONN_ID      conn_id_tcp,
                                             NET_TCP_TIMEOUT_SEC  msl_timeout_sec,
                                             NET_ERR             *p_err)
{
    NET_TCP_CONN  *p_conn;

                                                                /* ------------------- VALIDATE MLS ------------------- */
#if (NET_TCP_CONN_TIMEOUT_MAX_SEG_MIN_SEC > 0)
    if (msl_timeout_sec < NET_TCP_CONN_TIMEOUT_MAX_SEG_MIN_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif
#if ((NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                  || \
    ((NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC > DEF_INT_08U_MAX_VAL)) || \
    ((NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC > DEF_INT_16U_MAX_VAL)))
    if (msl_timeout_sec > NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC) {
       *p_err =  NET_TCP_ERR_INVALID_ARG;
        return (DEF_FAIL);
    }
#endif

                                                                /* ----------------- CFG TCP CONN MSL ----------------- */
    p_conn                            = &NetTCP_ConnTbl[conn_id_tcp];
    p_conn->TimeoutMaxSeg_sec         =  msl_timeout_sec;
    p_conn->TimeoutMaxSeg_tick_scaled = (NET_TMR_TICK)p_conn->TimeoutMaxSeg_sec * NET_TMR_TIME_TICK_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;

   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_OK);
}


/*
*********************************************************************************************************
*                                         NetTCP_ConnIsUsed()
*
* Description : Validate TCP connection in use.
*
* Argument(s) : conn_id_tcp     Handle identifier of TCP connection to validate.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP connection successfully validated as
*                                                                   in use.
*                               NET_INIT_ERR_NOT_COMPLETED         Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN        Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED       TCP connection NOT currently used.
*
* Return(s)   : DEF_YES, TCP connection   valid &      in use.
*
*               DEF_NO,  TCP connection invalid or NOT in use.
*
* Caller(s)   : various.
*
*               This function is an INTERNAL network protocol suite function & SHOULD NOT be called by
*               application function(s) [see also Note #1].
*
* Note(s)     : (1) NetTCP_ConnIsUsed() blocked until network initialization completes.
*
*               (2) NetTCP_ConnIsUsed() MUST be called with the global network lock already acquired.
*********************************************************************************************************
*/

CPU_BOOLEAN  NetTCP_ConnIsUsed (NET_TCP_CONN_ID   conn_id_tcp,
                                NET_ERR          *p_err)
{
    NET_TCP_CONN  *p_conn;
    CPU_BOOLEAN    used;


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (Net_InitDone != DEF_YES) {                              /* If init NOT complete, exit (see Note #1).            */
       *p_err =  NET_INIT_ERR_NOT_COMPLETED;
        return (DEF_NO);
    }
#endif

                                                                /* --------------- VALIDATE TCP CONN ID --------------- */
    if (conn_id_tcp < NET_TCP_CONN_ID_MIN) {
       *p_err =  NET_TCP_ERR_INVALID_CONN;
        return (DEF_NO);
    }
    if (conn_id_tcp > (NET_TCP_CONN_QTY)NET_TCP_CONN_ID_MAX) {
       *p_err =  NET_TCP_ERR_INVALID_CONN;
        return (DEF_NO);
    }

                                                                /* -------------- VALIDATE TCP CONN USED -------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];
    used  =  DEF_BIT_IS_SET(p_conn->Flags, NET_TCP_FLAG_USED);
    if (used != DEF_YES) {
       *p_err =  NET_TCP_ERR_CONN_NOT_USED;
        return (DEF_NO);
    }


   *p_err =  NET_TCP_ERR_NONE;

    return (DEF_YES);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnPoolStatGet()
*
* Description : Get TCP connection statistics pool.
*
* Argument(s) : none.
*
* Return(s)   : TCP connection statistics pool, if NO error(s).
*
*               NULL           statistics pool, otherwise.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s).
*
* Note(s)     : (1) NetTCP_ConnPoolStatGet() blocked until network initialization completes; return NULL
*                   statistics pool.
*********************************************************************************************************
*/

NET_STAT_POOL  NetTCP_ConnPoolStatGet (void)
{
#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    NET_ERR        err;
#endif
    NET_STAT_POOL  stat_pool;
    CPU_SR_ALLOC();


#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (Net_InitDone != DEF_YES) {                              /* If init NOT complete, ...                            */
        NetStat_PoolClr(&stat_pool, &err);
        return (stat_pool);                                     /* ... rtn NULL stat pool (see Note #1).                */
    }
#endif


    CPU_CRITICAL_ENTER();
    stat_pool = NetTCP_ConnPoolStat;
    CPU_CRITICAL_EXIT();

    return (stat_pool);
}


/*
*********************************************************************************************************
*                                  NetTCP_ConnPoolStatResetMaxUsed()
*
* Description : Reset TCP connection's statistics pool's maximum number of entries used.
*
* Argument(s) : none.
*
* Return(s)   : none.
*
* Caller(s)   : Application.
*
*               This function is a network protocol suite application programming interface (API) function
*               & MAY be called by application function(s).
*
* Note(s)     : (1) NetTCP_ConnPoolStatResetMaxUsed() blocked until network initialization completes.
*
*                   (a) However, since 'NetTCP_ConnPoolStat' is reset when network initialization
*                       completes; NO error is returned.
*********************************************************************************************************
*/

void  NetTCP_ConnPoolStatResetMaxUsed (void)
{
    NET_ERR  err;


                                                                /* Acquire net lock.                                    */
    Net_GlobalLockAcquire((void *)&NetTCP_ConnPoolStatResetMaxUsed, &err);
    if (err != NET_ERR_NONE) {
        return;
    }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (Net_InitDone != DEF_YES) {                              /* If init NOT complete, ...                            */
        Net_GlobalLockRelease();
        return;                                                 /* ... rtn w/o err (see Note #1a).                      */
    }
#endif


    NetStat_PoolResetUsedMax(&NetTCP_ConnPoolStat, &err);       /* Reset TCP conn stat pool.                            */

    Net_GlobalLockRelease();                                    /* Release net lock.                                    */
}


/*
*********************************************************************************************************
*                                         NetTCP_ConnStateGet()
*
* Description : Retrieve the TCP Connection State.
*
* Argument(s) : conn_id     TCP Connection ID number.
*
* Return(s)   : TCP Connection State.
*
* Caller(s)   : Application.
*
* Note(s)     : none.
*********************************************************************************************************
*/

NET_TCP_CONN_STATE  NetTCP_ConnStateGet (NET_TCP_CONN_ID  conn_id)
{
    NET_TCP_CONN        *p_conn_tcp;
    NET_TCP_CONN_STATE   state;
    NET_ERR              err;


                                                                /* Acquire net lock.                                    */
    Net_GlobalLockAcquire((void *)&NetTCP_ConnStateGet, &err);
    if (err != NET_ERR_NONE) {
        return (NET_TCP_CONN_STATE_NONE);
    }

#if (NET_ERR_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (Net_InitDone != DEF_YES) {                              /* If init NOT complete, return                         */
        Net_GlobalLockRelease();
        return (NET_TCP_CONN_STATE_NONE);
    }
#endif

    p_conn_tcp  = &NetTCP_ConnTbl[conn_id];
    state       =  p_conn_tcp->ConnState;                       /* Get TCP Connection State.                            */


    Net_GlobalLockRelease();                                    /* Release net lock.                                    */

    return (state);
}

/*
*********************************************************************************************************
*********************************************************************************************************
*                                           LOCAL FUNCTIONS
*********************************************************************************************************
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                      NetTCP_RxPktValidateBuf()
*
* Description : Validate received buffer header as TCP protocol.
*
* Argument(s) : p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                Received buffer's TCP header validated.
*                               NET_ERR_INVALID_PROTOCOL        Buffer's protocol type is NOT TCP.
*                               NET_BUF_ERR_INVALID_TYPE        Invalid network buffer type.
*                               NET_BUF_ERR_INVALID_IX          Invalid buffer  index.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_Rx().
*
* Note(s)     : none.
*********************************************************************************************************
*/

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
static  void  NetTCP_RxPktValidateBuf (NET_BUF_HDR  *p_buf_hdr,
                                       NET_ERR      *p_err)
{
    NET_IF_NBR   if_nbr;
    CPU_BOOLEAN  valid;
    NET_ERR      err;

                                                                /* -------------- VALIDATE NET BUF TYPE --------------- */
    switch (p_buf_hdr->Type) {
        case NET_BUF_TYPE_RX_LARGE:
             break;


        case NET_BUF_TYPE_NONE:
        case NET_BUF_TYPE_BUF:
        case NET_BUF_TYPE_TX_LARGE:
        case NET_BUF_TYPE_TX_SMALL:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.Buf.InvTypeCtr);
            *p_err = NET_BUF_ERR_INVALID_TYPE;
             return;
    }

                                                                /* --------------- VALIDATE TCP BUF HDR --------------- */
    if (!((p_buf_hdr->ProtocolHdrType == NET_PROTOCOL_TYPE_TCP_V4) ||
          (p_buf_hdr->ProtocolHdrType == NET_PROTOCOL_TYPE_TCP_V6))) {
        if_nbr = p_buf_hdr->IF_Nbr;
        valid  = NetIF_IsValidHandler(if_nbr, &err);
        if (valid == DEF_YES) {
            NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxInvalidProtocolCtr);
        }
       *p_err = NET_ERR_INVALID_PROTOCOL;
        return;
    }

    if (p_buf_hdr->TransportHdrIx == NET_BUF_IX_NONE) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxInvalidBufIxCtr);
       *p_err = NET_BUF_ERR_INVALID_IX;
        return;
    }

   *p_err = NET_TCP_ERR_NONE;
}
#endif


/*
*********************************************************************************************************
*                                       NetTCP_RxPktValidate()
*
* Description : (1) Validate received TCP packet :
*
*                   (a) Get TCP packet RTT timestamp received               See 'NetTCP_TxConnRTT_RTO_Calc()
*                                                                                   Note #2a2A2'
*
*                   (b) (1) Validate the received packet's following TCP header fields :
*
*                           (A) Source      Port
*                           (B) Destination Port
*                           (C) Header  Length
*                           (D) Segment Length                              See Note #4
*                           (E) Flags
*                           (F) Check-Sum                                   See Note #5
*                           (G) Options
*
*                       (2) Validation ignores the following TCP header fields :
*
*                           (A) Sequence        Number
*                           (B) Acknowledgement Number
*                           (C) Window Advertisement
*                           (D) Urgent Pointer                              See 'net_tcp.c  Note #1b'
*
*                   (c) Convert the following TCP header fields from network-order to host-order :
*
*                       (1) Source      Port                                See Note #1cB1
*                       (2) Destination Port                                See Note #1cB2
*                       (3) Sequence        Number                          See Note #1cB3
*                       (4) Acknowledgement Number                          See Note #1cB4
*                       (5) Header Length/Flags                             See Note #1cB5
*                       (6) Window Advertisement                            See Note #1cB6
*                       (7) Check-Sum                                       See Note #4f
*                       (8) Urgent Pointer                                  See 'net_tcp.c  Note #1b'
*
*                           (A) These fields are NOT converted directly in the received packet buffer's
*                               data area but are converted in local or network buffer variables ONLY.
*
*                           (B) The following TCP header fields are converted & stored in network buffer
*                               variables :
*
*                               (1) Source      Port
*                               (2) Destination Port
*                               (3) Sequence        Number
*                               (4) Acknowledgement Number
*                               (5) Header Length/Flags
*                               (6) Window Advertisement
*
*                   (d) Update network buffer's protocol controls
*
*
* Argument(s) : p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_tcp_hdr    Pointer to received packet's TCP header.
*               --------    Argument validated in NetTCP_Rx()/NetTCP_RxPktValidateBuf().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                Received packet validated.
*                               NET_TCP_ERR_INVALID_PORT_NBR    Invalid TCP port number.
*                               NET_TCP_ERR_INVALID_LEN_HDR     Invalid TCP header  length.
*                               NET_TCP_ERR_INVALID_LEN_SEG     Invalid TCP segment length.
*                               NET_TCP_ERR_INVALID_LEN_DATA    Invalid TCP data    length.
*                               NET_TCP_ERR_INVALID_FLAG        Invalid TCP flags.
*                               NET_TCP_ERR_INVALID_CHK_SUM     Invalid TCP check-sum.
*
*                                                               - RETURNED BY NetTCP_RxPktValidateOpt() : -
*                               NET_TCP_ERR_INVALID_OPT_LEN     Invalid TCP option length.
*                               NET_TCP_ERR_INVALID_OPT_END     Invalid TCP option list ending.
*                               NET_TCP_ERR_INVALID_OPT_NBR     Invalid TCP option number of same option.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_Rx().
*
* Note(s)     : (2) See 'net_tcp.h  TCP HEADER' for TCP header format.
*
*               (3) The following TCP header fields MUST be decoded &/or converted from network-order to host-
*                   order BEFORE any TCP Reset Segments are transmitted (see 'NetTCP_TxConnReset()  Note #2') :
*
*                   (a) Sequence        Number
*                   (b) Acknowledgement Number
*                   (c) Segment Length
*
*               (4) Since TCP segment headers do NOT contain a segment length field, the TCP Segment Length
*                   is assumed to be the remaining IP Datagram Length.
*
*               (5) (a) TCP header Check-Sum field MUST be validated BEFORE (or AFTER) any multi-octet words
*                       are converted from network-order to host-order since "the sum of 16-bit integers can
*                       be computed in either byte order" [RFC #1071, Section 2.(B)].
*
*                       In other words, the TCP Segment Check-Sum CANNOT be validated AFTER SOME but NOT ALL
*                       multi-octet words have been converted from network-order to host-order.
*
*                   (b) However, ALL received packets' multi-octet words are converted in local or network
*                       buffer variables ONLY (see Note #1cA).  Therefore, TCP Segment Check-Sum may be
*                       validated at any point.
*
*                   (c) The TCP Segment Check-Sum MUST be validated AFTER the TCP segment length has been
*                       validated so that the total TCP Segment Length (in octets) will already be calculated
*                       for the TCP Check-Sum calculation.
*
*                       For efficiency, the TCP Segment Check-Sum is validated AFTER all other TCP header
*                       fields have been validated.  Thus the iteration-intensive TCP Segment Check-Sum is
*                       calculated only after all other TCP header fields have been quickly validated.
*
*                   (d) (1) In addition to the TCP segment header & data, the TCP Check-Sum calculation
*                           includes "a 96-bit pseudo header conceptually prefixed to the TCP header ...
*                           [which] contains the Source Address, the Destination Address, the Protocol,
*                           and TCP length" (see RFC #793, Section 3.1 'Header Format : Checksum').
*
*                       (2) Since network check-sum functions REQUIRE that 16-bit one's-complement check-
*                           sum calculations be performed on headers & data arranged in network-order (see
*                           'net_util.c  NetUtil_16BitOnesCplChkSumDataVerify()  Note #4'), TCP pseudo-header
*                           values MUST be set or converted to network-order.
*
*                   (e) RFC #793, Section 3.1 'Header Format : Checksum' specifies that "if a segment contains
*                       an odd number of header and text octets ... the last octet is padded ... with zeros to
*                       form a 16-bit word for checksum purposes".
*
*                       See also 'net_util.c  NetUtil_16BitSumDataCalc()  Note #8'.
*
*                   (f) After the TCP Segment Check-Sum is validated, it is NOT necessary to convert the Check-
*                       Sum from network-order to host-order since    it is NOT required for further processing.
*
*               (6) (a) Since the minimum network buffer size MUST be configured such that the entire TCP
*                       header MUST be received in a single packet (see 'net_buf.h  NETWORK BUFFER INDEX &
*                       SIZE DEFINES  Note #1c'), after the TCP header size is decremented from the first
*                       packet buffer's remaining number of data octets, any remaining octets MUST be user
*                       &/or application data octets.
*
*                       (1) Note that the 'Data' index is updated regardless of a null-size data length.
*
*                   (b) If additional packet buffers exist, the remaining IP datagram 'Data' MUST be user
*                       &/or application data.  Therefore, the 'Data' length does NOT need to be adjusted
*                       but the 'Data' index MUST be updated.
*
*                   (c) #### Total TCP Segment Length & Data Length is duplicated in ALL fragmented packet
*                       buffers (may NOT be necessary; remove if unnecessary).
*
*               (7) (a) RFC #1122, Section 4.2.2.5 states that "[a] TCP MUST be prepared to handle an
*                       illegal option length (e.g., zero) without crashing; a suggested procedure is
*                       to reset the connection".  However, NO RFC specifies how TCP should handle
*                       received segments with any other invalid TCP option fields.
*
*                       Therefore, it seems reasonable & is assumed that ALL TCP segments with ANY
*                       invalid TCP option fields SHOULD transmit a TCP reset segment.
*
*                   (b) RFC #1122, Sections 3.2.1 & 3.2.2 require that IP & ICMP packets with certain
*                       invalid header fields be "silently discarded".  However, NO RFC specifies how
*                       TCP should handle received segments with invalid header fields.
*
*                       Therefore, it seems reasonable & is assumed that ALL TCP segments with ANY
*                       invalid header fields [other than invalid TCP option fields (see Note #7a)]
*                       SHOULD be silently discarded.
*
*               (8) (a) RFC #1122, Section 3.2.1.8 states that "all IP options ... received in datagrams
*                       MUST be passed to the transport layer ... [which] MUST ... interpret those IP
*                       options that they understand and silently ignore the others".
*
*                   (b) RFC #1122, Section 4.2.3.8 reiterates that "when received options are passed up
*                       to TCP from the IP layer, TCP MUST ignore options that it does not understand".
*
*                       NOT currently implemented. #### NET-814
*********************************************************************************************************
*/

static  void  NetTCP_RxPktValidate (NET_BUF      *p_buf,
                                    NET_BUF_HDR  *p_buf_hdr,
                                    NET_TCP_HDR  *p_tcp_hdr,
                                    NET_ERR      *p_err)
{
#if (( defined(NET_IPv4_MODULE_EN)) && \
     (!defined(NET_TCP_CHK_SUM_OFFLOAD_RX)))
    NET_TCP_PSEUDO_HDR   tcp_pseudo_hdrv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_PSEUDO_HDR  tcp_pseudo_hdrv6;
#endif
    CPU_INT08U           tcp_hdr_len_tot;
    CPU_INT16U           tcp_hdr_len;
    CPU_INT16U           tcp_tot_len;
    CPU_INT16U           tcp_data_len;
    NET_TCP_HDR_FLAGS    tcp_flags;
    CPU_BOOLEAN          tcp_flags_reserved;
    CPU_BOOLEAN          tcp_chk_sum_valid;
    CPU_BOOLEAN          tcp_chk_sum_ipv6;
    NET_BUF             *p_buf_next;
    NET_BUF_HDR         *p_buf_next_hdr;
    NET_ERR              err;



                                                                /* ---------------- GET TCP RTT RX TS ----------------- */
    p_buf_hdr->TCP_RTT_TS_Rxd_ms = (NET_TCP_TX_RTT_TS_MS)NetUtil_TS_Get_ms();



                                                                /* ---------------- VALIDATE TCP PORTS ---------------- */
    NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TransportPortSrc,  &p_tcp_hdr->PortSrc);
    if (p_buf_hdr->TransportPortSrc  == NET_TCP_PORT_NBR_RESERVED) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrPortSrcCtr);
       *p_err = NET_TCP_ERR_INVALID_PORT_NBR;
        return;
    }

    NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TransportPortDest, &p_tcp_hdr->PortDest);
    if (p_buf_hdr->TransportPortDest == NET_TCP_PORT_NBR_RESERVED) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrPortDestCtr);
       *p_err = NET_TCP_ERR_INVALID_PORT_NBR;
        return;
    }


                                                                /* --------------- VALIDATE TCP HDR LEN --------------- */
                                                                /* See 'net_tcp.h  TCP HEADER  Note #2'.                */
    NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TCP_HdrLen_Flags, &p_tcp_hdr->HdrLen_Flags);
    tcp_hdr_len    = (CPU_INT16U)(p_buf_hdr->TCP_HdrLen_Flags & NET_TCP_HDR_LEN_MASK);
    tcp_hdr_len  >>=  NET_TCP_HDR_LEN_SHIFT;
    if (tcp_hdr_len < NET_TCP_HDR_LEN_MIN) {                    /* If hdr len < min hdr len, rtn err.                   */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_HDR;
        return;
    }
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (tcp_hdr_len > NET_TCP_HDR_LEN_MAX) {                    /* If hdr len > max hdr len, rtn err.                   */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_HDR;
        return;
    }
#endif

    tcp_hdr_len_tot = (CPU_INT08U)(tcp_hdr_len * NET_TCP_HDR_LEN_WORD_SIZE);



                                                                /* ------------- VALIDATE TCP SEG TOT LEN ------------- */
    tcp_tot_len                = p_buf_hdr->IP_DatagramLen;     /* See Note #4.                                         */
    p_buf_hdr->TransportTotLen = tcp_tot_len;
    if (p_buf_hdr->TransportTotLen < NET_TCP_TOT_LEN_MIN) {     /* If seg tot len < min tot len, rtn err.               */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrSegLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_SEG;
        return;
    }
    if (p_buf_hdr->TransportTotLen > NET_TCP_TOT_LEN_MAX) {     /* If seg tot len > max tot len, rtn err.               */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrSegLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_SEG;
        return;
    }


                                                                /* ---------------- VALIDATE TCP FLAGS ---------------- */
                                                                /* See 'net_tcp.h  TCP HEADER  Note #2'.                */
#if 1                                                           /* Allow invalid reserved flags for rx'd segs.          */
    tcp_flags          = p_buf_hdr->TCP_HdrLen_Flags  & NET_TCP_HDR_FLAG_MASK;
    tcp_flags_reserved = DEF_BIT_IS_SET_ANY(tcp_flags, NET_TCP_HDR_FLAG_RESERVED);
    if (tcp_flags_reserved != DEF_NO) {                         /* If reserved flag bits set, rtn err.                  */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagsCtr);
       *p_err = NET_TCP_ERR_INVALID_FLAG;
        return;
    }
#endif

    p_buf_hdr->TCP_SegSync  = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_SYNC );
    p_buf_hdr->TCP_SegClose = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_CLOSE);
    p_buf_hdr->TCP_SegAck   = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_ACK  );
    p_buf_hdr->TCP_SegReset = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_RESET);


                                                                /* --------------- VALIDATE TCP CHK SUM --------------- */
                                                                /* See Note #5.                                         */

    tcp_chk_sum_ipv6 = DEF_BIT_IS_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
    if (tcp_chk_sum_ipv6 == DEF_NO) {
#ifdef NET_IPv4_MODULE_EN
#ifdef NET_TCP_CHK_SUM_OFFLOAD_RX
        tcp_chk_sum_valid = DEF_YES;
#else
                                                                /* Prepare TCP chk sum pseudo-hdr (see Note #5d).       */
        tcp_pseudo_hdrv4.AddrSrc  = (NET_IPv4_ADDR)NET_UTIL_HOST_TO_NET_32(p_buf_hdr->IP_AddrSrc);
        tcp_pseudo_hdrv4.AddrDest = (NET_IPv4_ADDR)NET_UTIL_HOST_TO_NET_32(p_buf_hdr->IP_AddrDest);
        tcp_pseudo_hdrv4.Zero     = (CPU_INT08U )0x00u;
        tcp_pseudo_hdrv4.Protocol = (CPU_INT08U )NET_IP_HDR_PROTOCOL_TCP;
        tcp_pseudo_hdrv4.TotLen   = (CPU_INT16U )NET_UTIL_HOST_TO_NET_16(p_buf_hdr->TransportTotLen);

        tcp_chk_sum_valid         =  NetUtil_16BitOnesCplChkSumDataVerify((void     *) p_buf,
                                                                          (void     *)&tcp_pseudo_hdrv4,
                                                                          (CPU_INT16U) NET_TCP_PSEUDO_HDR_SIZE,
                                                                          (NET_ERR  *) p_err);
#endif
#else
        tcp_chk_sum_valid = DEF_FAIL;
#endif

    } else {
#ifdef NET_IPv6_MODULE_EN
#ifdef NET_TCP_CHK_SUM_OFFLOAD_RX
        tcp_chk_sum_valid = DEF_YES;
#else
        tcp_pseudo_hdrv6.AddrSrc          = p_buf_hdr->IPv6_AddrSrc;
        tcp_pseudo_hdrv6.AddrDest         = p_buf_hdr->IPv6_AddrDest;
        tcp_pseudo_hdrv6.UpperLayerPktLen = (CPU_INT32U)NET_UTIL_HOST_TO_NET_32(p_buf_hdr->TransportTotLen);
        tcp_pseudo_hdrv6.Zero             = (CPU_INT16U)0x00u;
        tcp_pseudo_hdrv6.NextHdr          = (CPU_INT16U)NET_UTIL_NET_TO_HOST_16(NET_IP_HDR_PROTOCOL_TCP);
        tcp_chk_sum_valid                 = NetUtil_16BitOnesCplChkSumDataVerify((void     *) p_buf,
                                                                                 (void     *)&tcp_pseudo_hdrv6,
                                                                                 (CPU_INT16U) NET_IPv6_PSEUDO_HDR_SIZE,
                                                                                 (NET_ERR  *) p_err);
#endif
#else
        tcp_chk_sum_valid = DEF_FAIL;
#endif
    }

    if (tcp_chk_sum_valid != DEF_OK) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrChkSumCtr);
       *p_err = NET_TCP_ERR_INVALID_CHK_SUM;
        return;
    }
#if 0                                                           /* See Note #5f.                                        */
   (void)NET_UTIL_VAL_GET_NET_16(&p_tcp_hdr->ChkSum);
#endif


                                                                /* ---------------- UDPATE TCP FIELDS ----------------- */
                                                                /* See Notes #1c & #3.                                  */
    NET_UTIL_VAL_COPY_GET_NET_32(&p_buf_hdr->TCP_SeqNbr,  &p_tcp_hdr->SeqNbr);
    NET_UTIL_VAL_COPY_GET_NET_32(&p_buf_hdr->TCP_AckNbr,  &p_tcp_hdr->AckNbr);
    NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TCP_WinSize, &p_tcp_hdr->WinSize);

    p_buf_hdr->TransportHdrLen  = tcp_hdr_len_tot;
    tcp_data_len                = tcp_tot_len - p_buf_hdr->TransportHdrLen;
    p_buf_hdr->TransportDataLen = tcp_data_len;
    p_buf_hdr->TCP_SegLenInit   = p_buf_hdr->TransportDataLen;
    p_buf_hdr->TCP_SegLen       = p_buf_hdr->TCP_SegLenInit;


                                                                /* ---------------- VALIDATE TCP OPTS ----------------- */
    if (tcp_hdr_len_tot > NET_TCP_HDR_SIZE_MIN) {               /* If hdr len > min, validate/process TCP opts.         */
        NetTCP_RxPktValidateOpt(p_buf_hdr, p_tcp_hdr, tcp_hdr_len_tot, p_err);
        if (*p_err != NET_TCP_ERR_NONE) {                       /* If any TCP opt err(s), ...                           */
             NetTCP_TxConnReset((NET_TCP_CONN     *) 0,         /* ... tx TCP conn reset (see Note #7a).                */
                                (NET_BUF_HDR      *) p_buf_hdr,
                                (NET_TCP_RESET_CODE) NET_TCP_CONN_TX_RESET,
                                (NET_TCP_CLOSE_CODE) NET_TCP_CONN_CLOSE_ALL,
                                (NET_ERR          *)&err);
             return;
        }
    }


                                                                /* ----------------- UPDATE BUF CTRLS ----------------- */
                                                                /* Calc TCP data len/ix (see Note #6a).                 */
#if 0                                                           /* See Note #3c.                                        */
    p_buf_hdr->TransportHdrLen = tcp_hdr_len_tot;
#endif
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (p_buf_hdr->TransportHdrLen > tcp_tot_len) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrDataLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_DATA;
        return;
    }
    if (p_buf_hdr->TransportHdrLen > p_buf_hdr->DataLen) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrDataLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_DATA;
        return;
    }
#endif
#if 0                                                           /* See Note #3c.                                        */
    tcp_data_len               =  tcp_tot_len - p_buf_hdr->TransportHdrLen;
    p_buf_hdr->TransportDataLen =  tcp_data_len;
    p_buf_hdr->TCP_SegLenInit   =  p_buf_hdr->TransportDataLen;
    p_buf_hdr->TCP_SegLen       =  p_buf_hdr->TCP_SegLenInit;
#endif
    p_buf_hdr->TCP_SegLenData   =  p_buf_hdr->TCP_SegLenInit;
    p_buf_hdr->TCP_SeqNbrInit   =  p_buf_hdr->TCP_SeqNbr;

    p_buf_hdr->DataLen         -= (NET_BUF_SIZE) p_buf_hdr->TransportHdrLen;
    p_buf_hdr->DataIx           = (CPU_INT16U  )(p_buf_hdr->TransportHdrIx + p_buf_hdr->TransportHdrLen);
    p_buf_hdr->ProtocolHdrType  =  NET_PROTOCOL_TYPE_APP;

    p_buf_next = p_buf_hdr->NextBufPtr;
    while (p_buf_next != DEF_NULL) {                            /* Calc ALL pkt bufs' data len/ix    (see Note #6b).    */
        p_buf_next_hdr                   = &p_buf_next->Hdr;
        p_buf_next_hdr->DataIx           =  p_buf_next_hdr->TransportHdrIx;
        p_buf_next_hdr->TransportHdrLen  =  0u;                 /* NULL TCP hdr  len in each pkt buf.                   */
        p_buf_next_hdr->TransportTotLen  =  tcp_tot_len;        /* Dup  TCP tot  len & ...                              */
        p_buf_next_hdr->TransportDataLen =  tcp_data_len;       /* ...      data len in each pkt buf (see Note #6c).    */
        p_buf_next_hdr->TCP_SegLenInit   =  p_buf_next_hdr->TransportDataLen;
        p_buf_next_hdr->TCP_SegLen       =  p_buf_next_hdr->TCP_SegLenInit;
        p_buf_next_hdr->TCP_SegLenData   =  p_buf_next_hdr->TCP_SegLenInit;
        p_buf_hdr->ProtocolHdrType       =  NET_PROTOCOL_TYPE_APP;
        p_buf_next                       =  p_buf_next_hdr->NextBufPtr;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                      NetTCP_RxPktValidateOpt()
*
* Description : Validate & process received packet's TCP options.
*
* Argument(s) : p_buf_hdr            Pointer to network buffer header that received TCP packet.
*               --------            Argument validated in NetTCP_Rx().
*
*               p_tcp_hdr            Pointer to received packet's TCP header.
*               --------            Argument validated in NetTCP_Rx()/NetTCP_RxPktValidateBuf().
*
*               tcp_hdr_len_size    Length  of received packet's TCP header.
*               ----------------    Argument validated in NetTCP_RxPktValidate().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP options validated & processed.
*                               NET_TCP_ERR_INVALID_OPT_LEN     Invalid TCP option length.
*                               NET_TCP_ERR_INVALID_OPT_END     Invalid TCP option list ending.
*                               NET_TCP_ERR_INVALID_OPT_NBR     Invalid TCP option number of same option.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktValidate().
*
* Note(s)     : (1) (a) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES' for   supported TCP options' summary.
*
*                   (b) See 'net_tcp.c  Note #1c'                   for unsupported TCP options.
*
*                       See also Note #2b3.
*
*               (2) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
*                       in length" and "may begin on any octet boundary".
*
*                       (1) Since TCP options are NOT required or guaranteed to align multi-octet words on
*                           appropriate word boundaries, ALL TCP options are decoded & processed a single
*                           octet at a time.
*
*                   (b) RFC #1122, Section 4.2.2.5 states that :
*
*                       (1) "A TCP MUST be able to receive a TCP option in any segment."
*
*                       (2) "A TCP MUST ignore without error any TCP option it does not implement, assuming
*                            that the option has a field length" ...
*
*                       (3) "All TCP options defined in the future will have length fields."
*
*                       See also 'net_tcp.h  TCP HEADER OPTIONS DEFINES  Note #2b'.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktValidateOpt (NET_BUF_HDR  *p_buf_hdr,
                                       NET_TCP_HDR  *p_tcp_hdr,
                                       CPU_INT08U    tcp_hdr_len_size,
                                       NET_ERR      *p_err)
{
    CPU_INT08U   *p_opts;
    CPU_INT08U    opt_list_len_size;
    CPU_INT08U    opt_list_len_rem;
    CPU_INT08U    opt_len;
    CPU_INT08U    opt_nbr_max_seg_size;
    CPU_BOOLEAN   opt_err;
    CPU_BOOLEAN   opt_list_end;


    opt_list_len_size = tcp_hdr_len_size - NET_TCP_HDR_SIZE_MIN;/* Calc opt list len size.                              */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------- VALIDATE TCP HDR OPT LIST SIZE ---------- */
    if (opt_list_len_size > NET_TCP_HDR_OPT_SIZE_MAX) {         /* If tot opt len > max opt size, ...                   */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
       *p_err = NET_TCP_ERR_INVALID_OPT_LEN;                    /* ... rtn err.                                         */
        return;
    }

    if ((opt_list_len_size % NET_TCP_HDR_OPT_SIZE_WORD) != 0u) {/* If tot opt len NOT multiple of opt size, ...         */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
       *p_err = NET_TCP_ERR_INVALID_OPT_LEN;                    /* ... rtn err.                                         */
        return;
    }
#endif


                                                                /* ------------- DECODE/VALIDATE TCP OPTS ------------- */
    opt_err              =  DEF_NO;
    opt_list_end         =  DEF_NO;
    opt_nbr_max_seg_size =  0u;

    p_opts                = (CPU_INT08U *)&p_tcp_hdr->Opts[0];
    opt_list_len_rem     =  opt_list_len_size;

    while (opt_list_len_rem > 0) {                              /* Process each opt in list (see Notes #1 & #2).        */
        switch (*p_opts) {
            case NET_TCP_HDR_OPT_END_LIST:                      /* ------------------- END OPT LIST ------------------- */
                 opt_list_end = DEF_YES;                        /* Mark end of opt list.                                */
                 opt_len      = NET_TCP_HDR_OPT_LEN_END_LIST;
                 break;


            case NET_TCP_HDR_OPT_NOP:                           /* --------------------- NOP OPT ---------------------- */
#if 1                                                           /* NOP's invalid after END.                             */
                 if (opt_list_end != DEF_NO) {                  /* If opt found AFTER end of opt list, rtn err.         */
                     NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
                    *p_err = NET_TCP_ERR_INVALID_OPT_END;
                     return;
                 }
#endif
                 opt_len = NET_TCP_HDR_OPT_LEN_NOP;
                 break;


            case NET_TCP_HDR_OPT_MAX_SEG_SIZE:                  /* ----------------- MAX SEG SIZE OPT ----------------- */
                 if (opt_list_end != DEF_NO) {                  /* If opt found AFTER end of opt list, rtn err.         */
                     NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
                    *p_err = NET_TCP_ERR_INVALID_OPT_END;
                     return;
                 }
                 if (opt_nbr_max_seg_size > 0) {                /* If > 1 max seg size opt,            rtn err.         */
                     NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
                    *p_err = NET_TCP_ERR_INVALID_OPT_NBR;
                     return;
                 }
                 opt_nbr_max_seg_size++;

                 opt_err = NetTCP_RxPktValidateOptMaxSegSize(p_buf_hdr, p_opts, &opt_len, p_err);
                 break;
                                                                /* --------------- UNSUPPORTED TCP OPTS --------------- */
                                                                /* See Notes #1b & #2b2.                                */
            case NET_TCP_HDR_OPT_WIN_SCALE:
            case NET_TCP_HDR_OPT_SACK_PERMIT:
            case NET_TCP_HDR_OPT_SACK:
            case NET_TCP_HDR_OPT_ECHO_REQ:
            case NET_TCP_HDR_OPT_ECHO_REPLY:
            case NET_TCP_HDR_OPT_TS:
            default:                                            /* ----------------- INVALID TCP OPTS ----------------- */
                 opt_len = *(p_opts + 1);                       /* Ignore unknown opts      (see Note #2b2).            */
                 if (opt_len < NET_TCP_HDR_OPT_LEN_MIN_LEN) {   /* If opt len < min opt len (see Note #2b3), rtn err.   */
                     NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
                    *p_err = NET_TCP_ERR_INVALID_OPT_LEN;
                     return;
                 }
                 break;
        }

        if (opt_err != DEF_NO) {                                /* If ANY opt errs,               rtn err.              */
            return;
        }

        if (opt_len > opt_list_len_rem) {                       /* If opt len > rem opt list len, rtn err.              */
            NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
           *p_err = NET_TCP_ERR_INVALID_OPT_LEN;
            return;
        }

        opt_list_len_rem -= opt_len;
        p_opts            += opt_len;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                 NetTCP_RxPktValidateOptMaxSegSize()
*
* Description : Validate & process received TCP Maximum Segment Size option.
*
* Argument(s) : p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_opt        Pointer to Maximum Segment Size option.
*               ----        Argument validated in NetTCP_RxPktValidateOpt().
*
*               p_opt_len    Pointer to variable that will receive the TCP option length (in octets).
*               --------    Argument validated in NetTCP_RxPktValidateOpt().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP option validated & processed.
*                               NET_TCP_ERR_INVALID_OPT_LEN     Invalid TCP option length.
*
* Return(s)   : DEF_NO,  NO Maximum Segment Size option error.
*
*               DEF_YES, otherwise.
*
* Caller(s)   : NetTCP_RxPktValidateOpt().
*
* Note(s)     : (1) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES  Note #2b1' for TCP Maximum Segment Size
*                   option summary.
*
*               (2) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
*                       in length" and "may begin on any octet boundary".
*
*                   (b) Since TCP options are NOT required or guaranteed to align multi-octet words on
*                       appropriate word boundaries, ALL TCP options are decoded & processed a single
*                       octet at a time.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  NetTCP_RxPktValidateOptMaxSegSize (NET_BUF_HDR  *p_buf_hdr,
                                                        CPU_INT08U   *p_opt,
                                                        CPU_INT08U   *p_opt_len,
                                                        NET_ERR      *p_err)
{
    NET_TCP_SEG_SIZE  max_seg_size;


   *p_opt_len = NET_TCP_HDR_OPT_LEN_MAX_SEG_SIZE;

    p_opt++;
    if (*p_opt != *p_opt_len) {                                 /* If opt len != max seg size opt len, rtn err.         */
         NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
        *p_err  = NET_TCP_ERR_INVALID_OPT_LEN;
         return (DEF_YES);
    }

                                                                /* Calc max seg size (see Note #2b).                    */
    p_opt++;
    max_seg_size   = *p_opt;
    max_seg_size <<=  DEF_OCTET_NBR_BITS;
    p_opt++;
    max_seg_size  += *p_opt;

    if (max_seg_size > NET_TCP_MAX_SEG_SIZE_MAX) {              /* If max seg size > max, rtn err.                      */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
       *p_err =  NET_TCP_ERR_INVALID_OPT_LEN;
        return (DEF_YES);
    }

    p_buf_hdr->TCP_MaxSegSize = max_seg_size;

   *p_err                     = NET_TCP_ERR_NONE;

    return (DEF_NO);
}


/*
*********************************************************************************************************
*                                       NetTCP_RxPktDemuxSeg()
*
* Description : (1) Demultiplex received packet to appropriate TCP connection :
*
*                   (a) Search connection list for connection whose local &/or remote addresses are
*                       identical to the received packet's destination & source addresses.
*
*                   (b) Update network buffer's connection controls.
*
*
* Argument(s) : p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                Received packet successfully demultiplexed
*                                                                   to appropriate TCP connection.
*                               NET_CONN_ERR_INVALID_FAMILY     Invalid network connection family.
*                               NET_CONN_ERR_INVALID_CONN       Invalid network connection number(s).
*                               NET_ERR_RX_DEST                 Invalid destination; no connection available
*                                                                   for received packet.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_Rx().
*
* Note(s)     : (2) The 'SRCH CONN LIST FOR PKT/CONN ADDR(S)' pre-processor 'else'-conditional code will
*                   never be compiled/linked since 'net_conn.h' ensures that the family type configuration
*                   constant (NET_CONN_CFG_FAMILY) is configured with an appropriate family type value
*                   (see 'net_conn.h  CONFIGURATION ERRORS').  The 'else'-conditional code is included for
*                   completeness & as an extra precaution in case 'net_conn.h' is incorrectly modified.
*
*               (3) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED [State]' states
*                       that "an incoming segment ... causes a RST to be sent in response".
*
*                   (b) RFC #792, Section 'Destination Unreachable Message : Description' states that
*                       "if, in the destination host, the IP module cannot deliver the datagram because
*                       the indicated ... process port is not active, the destination host may send a
*                       destination unreachable message to the source host".
*********************************************************************************************************
*/

static  void  NetTCP_RxPktDemuxSeg (NET_BUF      *p_buf,
                                    NET_BUF_HDR  *p_buf_hdr,
                                    NET_ERR      *p_err)
{
    CPU_INT08U             addr_local[NET_CONN_ADDR_LEN_MAX];
    CPU_INT08U             addr_remote[NET_CONN_ADDR_LEN_MAX];
    NET_CONN_ADDR_LEN      addr_len          = 0;
    NET_CONN_PROTOCOL_IX   protocol_ix       = NET_CONN_PROTOCOL_IX_NONE;
    NET_CONN_FAMILY        family            = NET_CONN_FAMILY_NONE;
    NET_CONN_ID            conn_id           = NET_CONN_ID_NONE;
    NET_CONN_ID            conn_id_transport = NET_CONN_ID_NONE;
    NET_CONN_ID            conn_id_app       = NET_CONN_ID_NONE;
    NET_ERR                err;

                                                                /* ------- SRCH CONN LIST FOR PKT/CONN ADDR(S) -------- */
#ifdef  NET_IP_MODULE_EN
    p_buf_hdr = &p_buf->Hdr;

    Mem_Clr((void     *)&addr_local,
            (CPU_SIZE_T) NET_CONN_ADDR_LEN_MAX);

    Mem_Clr((void     *)&addr_remote,
            (CPU_SIZE_T) NET_CONN_ADDR_LEN_MAX);

    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        family      = NET_CONN_FAMILY_IP_V4_SOCK;
        protocol_ix = NET_CONN_PROTOCOL_IX_IP_V4_TCP;
                                                                /* Cfg srch local  addr as pkt dest addr.               */
        NET_UTIL_VAL_COPY_SET_NET_16(&addr_local [NET_CONN_ADDR_IP_IX_PORT],    &p_buf_hdr->TransportPortDest);
        NET_UTIL_VAL_COPY_SET_NET_32(&addr_local [NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrDest);
                                                                /* Cfg srch remote addr as pkt src  addr.               */
        NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT],    &p_buf_hdr->TransportPortSrc);
        NET_UTIL_VAL_COPY_SET_NET_32(&addr_remote[NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrSrc);

        addr_len = NET_SOCK_ADDR_LEN_IP_V4;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        family      = NET_CONN_FAMILY_IP_V6_SOCK;
        protocol_ix = NET_CONN_PROTOCOL_IX_IP_V6_TCP;
                                                                /* Cfg srch local  addr as pkt dest addr.               */
        NET_UTIL_VAL_COPY_SET_NET_16(&addr_local [NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
        Mem_Copy(&addr_local [NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrDest, NET_IPv6_ADDR_SIZE);
                                                                /* Cfg srch remote addr as pkt src  addr.               */
        NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
        Mem_Copy(&addr_remote[NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrSrc, NET_IPv6_ADDR_SIZE);

        addr_len = NET_SOCK_ADDR_LEN_IP_V6;
#endif
    }
#else                                                           /* See Note #2.                                         */
   *p_err = NET_CONN_ERR_INVALID_FAMILY;
    return;
#endif


    conn_id = NetConn_Srch(family,                              /* Srch for TCP conn.                                   */
                           protocol_ix,
                          &addr_local[0],
                          &addr_remote[0],
                           addr_len,
                          &conn_id_transport,
                          &conn_id_app,
                          &err);
    switch (err) {
        case NET_CONN_ERR_CONN_FULL:                            /* Complete TCP conn found.                             */
             p_buf_hdr->ConnType = NET_CONN_TYPE_CONN_FULL;
             break;


        case NET_CONN_ERR_CONN_HALF:                            /* Half     TCP conn found.                             */
        case NET_CONN_ERR_CONN_HALF_WILDCARD:
             p_buf_hdr->ConnType = NET_CONN_TYPE_CONN_HALF;
             break;


        case NET_CONN_ERR_CONN_NONE:                            /* If NO    TCP conn found;                 ...         */
        case NET_CONN_ERR_CONN_FULL_WILDCARD:
        case NET_CONN_ERR_INVALID_FAMILY:
        case NET_CONN_ERR_INVALID_PROTOCOL_IX:
        case NET_CONN_ERR_INVALID_ADDR:
        case NET_CONN_ERR_INVALID_ADDR_LEN:
        default:
             NetTCP_TxConnReset(DEF_NULL,                       /* ... tx TCP  conn reset   (see Note #3a), ...         */
                                p_buf_hdr,
                                NET_TCP_CONN_TX_RESET,
                                NET_TCP_CONN_CLOSE_ALL,
                               &err);
             if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_ICMPv4_MODULE_EN
                 NetICMPv4_TxMsgErr(p_buf,                      /* ... tx ICMP port unreach (see Note #3b), ...         */
                                    NET_ICMPv4_MSG_TYPE_DEST_UNREACH,
                                    NET_ICMPv4_MSG_CODE_DEST_PORT,
                                    NET_ICMPv4_MSG_PTR_NONE,
                                   &err);
#endif
             } else {
#ifdef  NET_IPCMPv6_MODULE_EN
                 NetICMPv6_TxMsgErr(p_buf,                      /* ... tx ICMP port unreach (see Note #3b), ...         */
                                    NET_ICMPv6_MSG_TYPE_DEST_UNREACH,
                                    NET_ICMPv6_MSG_CODE_DEST_PORT_UNREACHABLE,
                                    NET_ICMPv6_MSG_PTR_NONE,
                                   &err);
#endif
             }
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDestCtr);
            *p_err = NET_ERR_RX_DEST;                           /* ... & rtn dest err.                                  */
             return;
    }


                                                                /* -------------- UPDATE BUF CONN CTRLS --------------- */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (conn_id           == NET_CONN_ID_NONE) {
       *p_err = NET_CONN_ERR_INVALID_CONN;
        return;
    }
    if (conn_id_transport == NET_CONN_ID_NONE) {
       *p_err = NET_CONN_ERR_INVALID_CONN;
        return;
    }
#endif

    p_buf_hdr->Conn_ID           = conn_id;
    p_buf_hdr->Conn_ID_Transport = conn_id_transport;
    p_buf_hdr->Conn_ID_App       = conn_id_app;


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                      NetTCP_RxPktConnHandler()
*
* Description : (1) Handle received TCP packets for its TCP connection :
*
*                   (a) Demultiplex  TCP packet to appropriate TCP connection state handler
*                   (b) Free/Discard TCP packet
*                   (c) Update receive statistics                                           See Note #2
*
*
* Argument(s) : p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for later processing.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received reset segment successfully handled;
*                                                                       i.e. the TCP connection was reset.
*                               NET_TCP_ERR_CONN_CLOSED             TCP connection successfully closed.
*
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*
*                                                                   ---- RETURNED BY NetTCP_ConnIsUsed() : -----
*                               NET_INIT_ERR_NOT_COMPLETED             Network initialization NOT complete.
*                               NET_TCP_ERR_INVALID_CONN            Invalid TCP connection number.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*
*                                                                   --- RETURNED BY NetTCP_RxPktDiscard() : ----
*                               NET_ERR_RX                          Receive error; packet discarded.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_Rx().
*
* Note(s)     : (2) (a) SOME   TCP receive statistics already updated in NetTCP_RxPktDiscard(); do NOT
*                       re-update.
*
*                   (b) Update TCP receive statistics even if any transitory transmit error(s) occur in
*                       TCP connection state handler functions.
*
*               (3) RFC #1122, Section 4.2.2.13 states that "a host MAY implement a 'half-duplex' TCP
*                   close sequence ... i.e., closed in only one direction, and a host is permitted to
*                   continue sending data in the open direction on a half-closed connection".
*
*                   (a) "A host ... that has called CLOSE cannot continue to read data from the
*                        connection.  If such a host issues a CLOSE call while received data is
*                        still pending ... its TCP SHOULD send a RST to show that data was lost."
*
*                       However, since it does NOT seem reasonable to allow a half-closed connection
*                       "to continue sending data in the open direction" (i.e. from the host that did
*                       NOT issue a CLOSE call) but prevent the receiving host (i.e. the host that DID
*                       issue the CLOSE call) from receiving the transmitted data; it is assumed that
*                       the host that issued the CLOSE call MUST be allowed to receive data transmitted
*                       from the other host that has NOT yet issued its CLOSE.
*
*                   (b) However, "if such a host issues a CLOSE call ... [and] new data is received
*                       after CLOSE is called, its TCP SHOULD send a RST to show that data was lost".
*
*                       In other words, since a TCP connection in the connection-closing-data-available
*                       state is closed to further TCP data or controls, a TCP reset segment is
*                       transmitted as for the CLOSED state.
*
*                   (c) "Some systems have not implemented half-closed connections."
*
*               (4) Network buffer already freed by lower layer/handler function(s).
*
*               (5) Stevens' UNIX Network Programming Volume 1, Second Edition, Section 6.6 states that if
*                   shutdown() is invoked with SHUT_RD as the second argument, then "The read-half of the
*                   connection is closed" and "The process can no longer issue any of the read functions
*                   on the socket. Any data received after this call for a TCP socket is acknowledged and
*                   silently discarded.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandler (NET_BUF      *p_buf,
                                       NET_BUF_HDR  *p_buf_hdr,
                                       NET_ERR      *p_err)
{
    NET_TCP_CONN_ID   conn_id_tcp;
    NET_TCP_CONN     *p_conn;
    NET_SOCK         *p_sock;
    NET_ERR           err;


    conn_id_tcp = (NET_TCP_CONN_ID)p_buf_hdr->Conn_ID_Transport;

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* -------------- VALIDATE TCP CONN USED -------------- */
   (void)NetTCP_ConnIsUsed(conn_id_tcp, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
#endif

                                                                /* ------------ DEMUX TCP PKT TO TCP CONN ------------- */
    p_conn = &NetTCP_ConnTbl[conn_id_tcp];

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_LISTEN:
             NetTCP_RxPktConnHandlerListen(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_TX_PKT:
                 case NET_ERR_TX:
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf,&err);
                     *p_err = NET_ERR_RX;
                      return;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_FIN_INVALID:
                 case NET_TCP_ERR_CONN_LISTEN_Q_MAX:
                 case NET_TCP_ERR_INVALID_CONN_ID:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_CONN_ERR_NOT_USED:
                 case NET_CONN_ERR_INVALID_CONN:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
             NetTCP_RxPktConnHandlerSyncRxd(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_CLOSE:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_SYNC_TXD:
             NetTCP_RxPktConnHandlerSyncTxd(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_CLOSE:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_FIN_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CONN:
             p_sock = NetSock_GetObj(NetConn_Tbl[p_conn->ID_Conn].ID_App);
             NetTCP_RxPktConnHandlerConn(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      if ( (p_sock               != DEF_NULL                   )   &&
                          ((p_sock->ShutdownMode == NET_SOCK_SHUTDOWN_MODE_RD  )   ||
                           (p_sock->ShutdownMode == NET_SOCK_SHUTDOWN_MODE_RDWR))) {

                                                                /* If corresp. socket is on RD or RDWR shutdown mode... */
                                                                /* ...& rx'd buf has payload, discard pkt. See Note (5).*/
                          if (p_buf_hdr->DataLen > 0u) {
                              if (*p_err == NET_TCP_ERR_CONN_DATA_VALID) {
                                  NetTCP_RxPktDiscard(p_buf, p_err);
                              }                                 /* Upper layers should NOT have the NET_ERR_RX from ...  */
                                                                /* ...NetTCP_RxPktDiscard() be returned by this fnct...  */
                                                                /* ...when valid pkt is discarded due to a SHUT_RD/RDWR. */
                                                                /* Therefore, 'p_err' must be intentionally masked here. */
                             *p_err = NET_TCP_ERR_CONN_DATA_NONE;
                              return;
                          }
                      }
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_CLOSE:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_FIN_WAIT_1:
             NetTCP_RxPktConnHandlerFinWait1(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_CLOSE:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_ID:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 case NET_CONN_ERR_INVALID_CONN:
                 case NET_CONN_ERR_NOT_USED:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_FIN_WAIT_2:
             NetTCP_RxPktConnHandlerFinWait2(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CLOSING:
             NetTCP_RxPktConnHandlerClosing(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_ID:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 case NET_CONN_ERR_INVALID_CONN:
                 case NET_CONN_ERR_NOT_USED:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_TIME_WAIT:
             NetTCP_RxPktConnHandlerTimeWait(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CLOSE_WAIT:
             NetTCP_RxPktConnHandlerCloseWait(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_LAST_ACK:
             NetTCP_RxPktConnHandlerLastAck(p_conn, p_buf, p_buf_hdr, p_err);

             switch (*p_err) {
                 case NET_TCP_ERR_CONN_RESET_VALID:
                 case NET_TCP_ERR_CONN_DATA_NONE:
                 case NET_TCP_ERR_CONN_CLOSED:
                      NetTCP_RxPktFree(p_buf);
                                                                /* 'break' intentionally omitted; MUST execute the ...  */
                                                                /* ... following case : 'NET_TCP_ERR_CONN_DATA_VALID'.  */

                 case NET_TCP_ERR_CONN_DATA_VALID:
                      NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
                      break;


                 case NET_TCP_ERR_NONE_AVAIL:
                 case NET_TCP_ERR_RX_Q_FULL:
                 case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_TX:                               /* Ignore transitory err(s)?                            */
                 case NET_ERR_IF_LINK_DOWN:
                 case NET_ERR_IF_LOOPBACK_DIS:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                     *p_err = NET_ERR_RX;
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_SEQ_SYNC_INVALID:
                 case NET_TCP_ERR_CONN_SEQ_INVALID:
                 case NET_TCP_ERR_CONN_ACK_NONE:
                 case NET_TCP_ERR_CONN_ACK_INVALID:
                 case NET_TCP_ERR_CONN_RESET_INVALID:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_CONN_DATA_DUP:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 case NET_CONN_ERR_INVALID_FAMILY:
                 case NET_CONN_ERR_INVALID_ADDR:
                 case NET_CONN_ERR_INVALID_ADDR_LEN:
                 default:
                      NetTCP_RxPktDiscard(p_buf, p_err);
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NetTCP_TxConnReset((NET_TCP_CONN     *) 0,         /* Tx TCP conn reset (see Note #3b).                    */
                                (NET_BUF_HDR      *) p_buf_hdr,
                                (NET_TCP_RESET_CODE) NET_TCP_CONN_TX_RESET,
                                (NET_TCP_CLOSE_CODE) NET_TCP_CONN_CLOSE_ALL,
                                (NET_ERR          *)&err);

             NetTCP_RxPktDiscard(p_buf, p_err);
             return;


        case NET_TCP_CONN_STATE_NONE:
        case NET_TCP_CONN_STATE_CLOSED:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
}


/*
*********************************************************************************************************
*                                   NetTCP_RxPktConnHandlerListen()
*
* Description : (1) Handle TCP connection in LISTEN state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Reset           (RST)                                           See Note #2a
*                       (2) Acknowledgement (ACK)                                           See Note #2b
*                       (3) Synchronization (SYN)                                           See Note #2c
*
*                   (b) Check if TCP connection listen queue is available                   See Note #3
*
*                   (c) Prepare/configure TCP connection :
*
*                       (1) Clone new TCP connection from current TCP listen connection,    See Note #5a
*                               if half-connection :
*
*                           (A) Get  connections
*                           (B) Set  connection  identification handles
*                           (C) Set  connection  addresses
*                           (D) Add  connection  into connection list
*                           (E) Copy connection  from half-connection
*
*                       (2) Reconfigure current TCP listen connection,                      See Note #5b
*                               if full-connection
*
*                   (d) Update TCP connection :
*                       (1) Handle received TCP segment                                     See Note #2c2
*                       (2) Configure TCP connection remote host maximum segment size       See Note #7
*                       (3) Update    TCP connection state                                  See Note #2c
*
*                   (e) Transmit TCP connection synchronization for valid received          See Note #2c3
*                           TCP connection requests
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_FIN_INVALID    Received segment's finish/close flag is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset        flag is
*                                                                       NOT valid for current TCP connection.
*
*                               NET_TCP_ERR_CONN_LISTEN_Q_MAX       TCP connection listen queue is NOT available
*                                                                       queue a new connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid application connection.
*
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid network connection family.
*
*                                                                   ------ RETURNED BY NetTCP_RxPktConnIsValidReset() : ------
*                                                                   ------- RETURNED BY NetTCP_RxPktConnIsValidAck() : -------
*                                                                   ------- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -------
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   - RETURNED BY NetTCP_RxPktConnHandlerListenQ_IsAvail() : -
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_CONN_ERR_INVALID_CONN           Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED               Network connection NOT currently used.
*
*                                                                   ----------- RETURNED BY NetTCP_TxConnSync() : ------------
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_TX                              Transmit        error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN                Network  interface link state down (i.e.
*                                                                       NOT available for receive or transmit).
*
*                                                                   ------- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -------
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for later processing (see Note #2c2).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]' states that :
*
*                   (a) "An incoming RST should be ignored."
*
*                   (b) "Any acknowledgment is bad if it arrives on a connection still in the LISTEN state.
*                        An acceptable reset segment should be formed for any arriving ACK-bearing segment."
*
*                   (c) "If the SYN bit is set ... the connection state should be changed to SYN-RECEIVED" :
*
*                       (1) "Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ ..."
*                           (A) See Note #2c3
*
*                       (2) "And any other control or text should be queued for processing later."
*
*                           (A) If any control or text is queued for later processing, the next sequence octet to
*                               receive (RCV.NXT) MUST include the length of this received segment (SEG.LEN) :
*
*                               (1) RCV.NXT = SEG.SEQ + SEG.LEN + 1
*
*                       (3) "ISS should be selected and a SYN segment sent."
*
*                   (d) "Any other control or text-bearing segment (not containing SYN) must have an ACK and
*                        thus would be discarded by the ACK processing ... So you are unlikely to get here,
*                        but if you do, drop the segment, and return."
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states to
*                       "not process the FIN if the state is CLOSED, LISTEN or SYN-SENT since the SEG.SEQ cannot
*                       be validated; drop the segment".
*
*               (3) (a) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 257-258 states
*                       that :
*
*                       (1) "Each listening end point has a fixed length queue of connections that have been
*                            accepted by TCP (i.e., the three-way handshake is complete), but not yet accepted
*                            by the application."
*
*                       (3) "When a connection request arrives (i.e., the SYN segment), ... the current number
*                            of connections already queued for this listening end point [is checked] to see
*                            whether to accept the connection or not."
*
*                       (4) "If there is room on this listening end point's queue for this new connection, ...
*                            the TCP module ACKs the SYN and completes the connection."
*
*                       (5) "If there is not room on the queue for the new connection" :
*
*                           (A) "TCP just ignores the received SYN."
*                           (B) "Nothing is sent back (i.e., no RST segment)."
*
*                   (b) (A) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 15.9, Page 455
*                           reiterates that :
*
*                           (2) A "listen ... socket ... limit[s] ... the number of connections that can be
*                               queued on the socket," ...
*
*                           (5) "after which the socket layer refuses to queue additional connection requests.
*                                When this occurs, TCP ignores incoming connection requests."
*
*                       (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 28.2, Page 930
*                           also states that :
*
*                           (5) (A) "By silently dropping the segment" ...
*                               (B) "and not replying with an RST,"    ...
*                               (C) "The client's connection request should time out, causing the client to
*                                    retransmit the SYN."
*
*                       (C) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 259-260
*                           summarizes that :
*
*                           (5) (A) "TCP ignores the incoming SYN when the queue is full," ...
*                               (B) "and doesn't respond with an RST,"                     ...
*
*                               (C) (1) "because ... this condition could change in a short while ... [and] by
*                                        ignoring the SYN, the server forces the client TCP to re-transmit the
*                                        SYN later, hoping that the queue will then have room for the new
*                                        connection".
*
*                                   (2) Whereas page 259-260 counters that "if the server's TCP responded with
*                                       a reset, the client's active open would abort".
*
*                   See also 'NetTCP_RxPktConnHandlerListenQ_IsAvail()  Note #1'.
*
*               (4) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
*                   since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
*                   is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
*                   The 'else'-conditional code is included for completeness & as an extra precaution in case
*                   'net_conn.h' is incorrectly modified.
*
*               (5) (a) (1) If any received TCP connection request to a LISTEN-state connection is a half-connection
*                           -- i.e. a connection with ONLY the local address specified/configured -- then a new
*                           connection is cloned from the LISTEN-state connection to handle each unique connection
*                           request.
*
*                       (2) The following connection parameters are cloned/copied from the LISTEN-state connection :
*
*                           (A) Application connection handle identifier
*                               (1) When the cloned connection is fully connected/established, it is queued to the
*                                   LISTEN-state connection's application connection as a cloned network connection
*                                   until the connection is accepted & a new application connection is created.
*
*                                   See also 'net_sock.c  NetSock_Accept()  Notes #1d & #1e'.
*
*                           (B) (1) TCP connection receive  parameters
*                               (2) TCP connection transmit parameters
*                               (3) TCP connection timeout  values
*
*                               See also 'NetTCP_ConnCopy()  Note #1a'.
*
*                   (b) If any received TCP connection request to a LISTEN-state connection is a full-connection --
*                       i.e. a connection with BOTH the local & remote addresses specified/configured -- then the
*                       LISTEN-state connection is reconfigured to handle the received connection request.
*
*               (6) On ANY TCP LISTEN-connection preparation error(s), network resources MUST be appropriately freed :
*
*                   (a) If NO TCP     connections available, NO           resources  need be freed.
*                   (b) If NO network connections available, ONLY the TCP connection need be closed.
*                   (c) If    network connection preparation fails, the TCP & network connection MUST both
*                          be closed.  However, the TCP connection need NOT close application connection(s).
*
*                       See also 'NetTCP_ConnCloseHandler()  Note #2b1C1'.
*
*                   (d) If any remaining TCP connection preparation fails, the TCP & network connection MUST
*                       both be closed.  The application connection(s) SHOULD NOT be closed since it is cloned
*                       from the LISTEN-state connection (see Note #4), but network connections MAY need to be
*                       de-referenced from the application connection(s).
*
*                       See also 'NetTCP_ConnCloseHandler()  Note #2b';
*                              & 'net_conn.c  NetConn_CloseApp()          Note #1'
*                              & 'net_sock.c  NetSock_FreeConnFromSock()  Note #2'.
*
*               (7) RFC #1122, Section 4.2.2.6 states that :
*
*                   (a) A "TCP SHOULD send an MSS (Maximum Segment Size) option in every SYN segment".
*
*                   (b) "If an MSS option is not received at connection setup, TCP MUST assume a default
*                        send MSS of 536."
*
*               (8) TCP connection timeout for LISTEN state is implemented by TCP connection retransmission
*                   function(s) (see 'NetTCP_TxConnReTxQ()  Note #3c').
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerListen (NET_TCP_CONN  *p_conn,
                                             NET_BUF       *p_buf,
                                             NET_BUF_HDR   *p_buf_hdr,
                                             NET_ERR       *p_err)
{
    CPU_INT08U             addr_local[NET_CONN_ADDR_LEN_MAX];
    CPU_INT08U             addr_remote[NET_CONN_ADDR_LEN_MAX];
    CPU_BOOLEAN            q_avail           = DEF_NO;
    NET_TCP_SEG_SIZE       mss_dflt_tx       = 0u;
    NET_TCP_SEQ_CODE       seq_code          = 0u;
    NET_TCP_ACK_CODE       ack_code          = 0u;
    NET_TCP_RESET_CODE     reset_code        = 0u;
    NET_IF_NBR             if_nbr            = NET_IF_NBR_NONE;
    NET_CONN_FAMILY        conn_family       = NET_CONN_FAMILY_NONE;
    NET_CONN_PROTOCOL_IX   conn_protocol_ix  = NET_CONN_PROTOCOL_IX_NONE;
    NET_CONN_ID            conn_id           = NET_CONN_ID_NONE;
    NET_CONN_ID            conn_id_clone     = NET_CONN_ID_NONE;
    NET_CONN_ID            conn_id_clone_app = NET_CONN_ID_NONE;
    NET_TCP_CONN_ID        conn_id_clone_tcp = NET_CONN_ID_NONE;
    NET_TCP_CONN          *p_conn_clone      = DEF_NULL;
    NET_TCP_CONN          *p_conn_tx_sync    = DEF_NULL;
    NET_TCP_CONN_STATE     state             = NET_TCP_CONN_STATE_NONE;
    NET_ERR                err               = NET_ERR_NONE;
    NET_ERR                err_rtn           = NET_TCP_ERR_NONE;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose != DEF_NO) {                    /* If invalid   fin/close rx'd, ...                     */
       *p_err = NET_TCP_ERR_CONN_SEQ_FIN_INVALID;
        return;                                                 /* ... ignore TCP pkt    (see Note #2e).                */
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    if (reset_code != NET_TCP_CONN_RX_RESET_NONE) {             /* If reset    rx'd, ...                                */
       *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
        return;                                                 /* ... ignore TCP pkt    (see Note #2a).                */
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    if (ack_code != NET_TCP_CONN_RX_ACK_NONE) {                 /* If ack      rx'd, ...                                */
                                                                /* ... tx TCP conn reset (see Note #2b).                */
        NetTCP_TxConnReset(p_conn, p_buf_hdr, NET_TCP_CONN_TX_RESET, NET_TCP_CONN_CLOSE_ALL, &err);
       *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
        return;
    }

                                                                /* Chk     rx'd seq nbr.                                */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    if (seq_code != NET_TCP_CONN_RX_SEQ_SYNC) {                 /* If sync NOT rx'd, ...                                */
       *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
        return;                                                 /* ... ignore TCP pkt    (see Note #2d).                */
    }
                                                                /* Else sync avail, update seg lens.                    */
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_SYNC;
    p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_SYNC;



                                                                /* -------------- CHK TCP CONN LISTEN Q --------------- */
    q_avail = NetTCP_RxPktConnHandlerListenQ_IsAvail(p_conn, p_err); /* Chk TCP listen Q     avail.                     */
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }

    if (q_avail != DEF_YES) {                                   /* If  TCP listen Q NOT avail (see Note #3a5),          */
       *p_err = NET_TCP_ERR_CONN_LISTEN_Q_MAX;
        return;                                                 /* ... ignore TCP pkt         (see Note #3a5A).         */
    }



                                                                /* ----------------- PREPARE TCP CONN ----------------- */
    if (p_buf_hdr->ConnType != NET_CONN_TYPE_CONN_FULL) {       /* If pkt demux'd to half-conn, clone new conn          */
                                                                /* .. from LISTEN    half-conn (see Note #5a).          */
                                                                /* -------------------- GET CONNS --------------------- */

        conn_id_clone_tcp =  NetTCP_ConnGet(p_conn->FnctAppPostRx,
                                            p_conn->FnctAppPostTx,
                                           &err);
        if ( err != NET_TCP_ERR_NONE) {                         /* See Note #6a.                                        */
           *p_err  = NET_TCP_ERR_NONE_AVAIL;
            return;
        }
        p_conn_clone = &NetTCP_ConnTbl[conn_id_clone_tcp];


#ifdef  NET_IP_MODULE_EN
        if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
            conn_family      =  NET_CONN_FAMILY_IP_V4_SOCK;
            conn_protocol_ix =  NET_CONN_PROTOCOL_IX_IP_V4_TCP;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            conn_family      =  NET_CONN_FAMILY_IP_V6_SOCK;
            conn_protocol_ix =  NET_CONN_PROTOCOL_IX_IP_V6_TCP;
#endif
        }
#else                                                           /* See Notes #4 & #6d.                                  */
        NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_CONN_ERR_INVALID_FAMILY;
        return;
#endif

        conn_id_clone = NetConn_Get(conn_family, conn_protocol_ix, &err);
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6b.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_NONE_AVAIL;
            return;
        }


                                                                /* SET CONN IDs                                         */
        p_conn_clone->ID_Conn = conn_id_clone;
        NetConn_ID_TransportSet((NET_CONN_ID) conn_id_clone,
                                (NET_CONN_ID) conn_id_clone_tcp,
                                (NET_ERR   *)&err);
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6c.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }


        conn_id           = p_conn->ID_Conn;
        conn_id_clone_app = NetConn_ID_AppGet((NET_CONN_ID) conn_id, /* Get half-conn's app conn id & ...               */
                                              (NET_ERR   *)&err);
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6c.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }
        if (conn_id_clone_app == NET_CONN_ID_NONE) {
           *p_err  = NET_TCP_ERR_INVALID_CONN_ID;
            return;
        }

        NetConn_ID_AppCloneSet((NET_CONN_ID) conn_id_clone,     /* ... set as cloned conn's      ...                    */
                               (NET_CONN_ID) conn_id_clone_app, /* ... app conn clone id (see Note #5a2A1).             */
                               (NET_ERR   *)&err);
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6c.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }


                                                                /* ------------------ CFG CONN ADDRS ------------------ */
#ifdef  NET_IP_MODULE_EN

        Mem_Clr((void     *)&addr_local,
                (CPU_SIZE_T) NET_CONN_ADDR_LEN_MAX);

        Mem_Clr((void     *)&addr_remote,
                (CPU_SIZE_T) NET_CONN_ADDR_LEN_MAX);

        if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
                                                                /* Cfg local  addr as pkt dest addr.                    */
            NET_UTIL_VAL_COPY_SET_NET_16(&addr_local [NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
            NET_UTIL_VAL_COPY_SET_NET_32(&addr_local [NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrDest);
                                                                /* Cfg remote addr as pkt src  addr.                    */
            NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
            NET_UTIL_VAL_COPY_SET_NET_32(&addr_remote[NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrSrc);
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
                                                                /* Cfg local  addr as pkt dest addr.                    */
            NET_UTIL_VAL_COPY_SET_NET_16(&addr_local [NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
            Mem_Copy(&addr_local [NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrDest, NET_IPv6_ADDR_SIZE);
                                                                /* Cfg remote addr as pkt src  addr.                    */
            NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
            Mem_Copy(&addr_remote [NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrSrc, NET_IPv6_ADDR_SIZE);
#endif
        }

#else                                                           /* See Notes #4 & #6d.                                  */
        NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_CONN_ERR_INVALID_FAMILY;
        return;
#endif

        if_nbr = p_buf_hdr->IF_Nbr;
        NetConn_AddrLocalSet(conn_id_clone,
                             if_nbr,
                            &addr_local[0],
                             NET_CONN_ADDR_LEN_MAX,
                             DEF_NO,
                            &err);
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6c.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }

        NetConn_AddrRemoteSet(conn_id_clone,
                             &addr_remote[0],
                              NET_CONN_ADDR_LEN_MAX,
                              DEF_NO,
                             &err);
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6c.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }


        NetConn_ListAdd(conn_id_clone, &err);                   /* Add conn into conn list.                             */
        if ( err != NET_CONN_ERR_NONE) {                        /* See Note #6c.                                        */
            NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }


                                                                /* Copy half-conn state to full conn.                   */
        NetTCP_ConnCopy(p_conn_clone, p_conn);


#ifndef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
        NetTCP_RxConnWinSizeHandler(p_conn_clone, DEF_NULL, 0, NET_TCP_CONN_RX_WIN_ZERO);
#endif
        p_conn_tx_sync = p_conn_clone;


    } else {                                                    /* Else conn to listen TCP conn (see Note #5b).         */
        p_conn_tx_sync = p_conn;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn_tx_sync, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        default:                                                /* See Note #6d.                                        */
             NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }


                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* Cfg remote max seg size as advertised ...            */
                                                                /* ... by remote host (see Note #7).                    */
    if (DEF_BIT_IS_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME) == DEF_YES) {
#ifdef  NET_IPv6_MODULE_EN
        mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V6;
#else
       *p_err = NET_ERR_FAULT_FEATURE_DIS;
        NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        return;
#endif
    } else {
#ifdef  NET_IPv4_MODULE_EN
        mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V4;

#else
       *p_err = NET_ERR_FAULT_FEATURE_DIS;
        NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        return;
#endif
    }

    p_conn_tx_sync->MaxSegSizeRemote = (p_buf_hdr->TCP_MaxSegSize != NET_TCP_MAX_SEG_SIZE_NONE)
                                     ?  p_buf_hdr->TCP_MaxSegSize
                                     :  mss_dflt_tx;

    state                     = p_conn_tx_sync->ConnState;
    p_conn_tx_sync->ConnState = NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE;


                                                                /* ----------------- TX TCP CONN SYNC ----------------- */
    NetTCP_TxConnSync(p_conn_tx_sync, p_buf_hdr, state, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {                           /* See Note #6d.                                        */
         NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
         return;
    }
    NetSock_ConnChildAdd(conn_id_clone_app, conn_id_clone, p_err);
    if (*p_err != NET_SOCK_ERR_NONE) {
         NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
         return;
    }


   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerSyncRxd()
*
* Description : (1) Handle TCP connection in SYN-RECEIVED state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                       See Note  #2a
*                       (2) Reset           (RST)                                       See Note  #2b
*                       (3) Synchronization (SYN)                                       See Note  #2c
*                       (4) Acknowledgement (ACK)                                       See Note  #2d
*                       (5) Finish/Close    (FIN)                                       See Note  #2e
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                                 See Note  #2d2A1
*                       (2) Update    TCP connection state                              See Notes #2d2A1a & #2e4
*                       (3) Update    TCP connection timer
*
*                   (c) Acknowledge   TCP connection
*                       (1) Signal    TCP/application connection complete
*                       (2) Handle    TCP connection  received data                     See Note  #2d2A1
*                       (3) Transmit  TCP connection  data                              See Notes #2d2A2  & #2e3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data processed (see Note #2d2A1).
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the SYN-RECEIVED state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2C.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit :
*                               SYN-RECEIVED STATE' states that "if the RST bit is set" and ...
*
*                               (1) "If this connection was initiated with a passive OPEN (i.e., came from
*                                    the LISTEN state), then return this connection to the LISTEN state."
*
*                               (2) "If this connection was initiated with an active OPEN (i.e., came from
*                                    the SYN-SENT state) then the connection was refused, signal the user
*                                   'connection refused' ... enter the CLOSED state."
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
*                               reiterates that "if the receiver ... of a RST ... was in SYN-RECEIVED state
*                               and had previously been in the LISTEN state, then the receiver returns to
*                               the LISTEN state, otherwise the receiver aborts the connection and goes to
*                               the CLOSED state".
*
*                           (C) However, since TCP connections opened from the LISTEN state are cloned from
*                               the original LISTEN-state TCP connection, it is NOT necessary to return ANY
*                               reset TCP connection from the SYN-RECEIVED state back to the LISTEN state.
*
*                           See also 'NetTCP_RxPktConnIsValidReset()  Note #2a4B'.
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of
*                               a segment with the RST when in a synchronized state" to "provide some
*                               protection against ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
*                               amendment applies only to the "handling of a ... RST ... when in a synchronized
*                               state", it is assumed that this should also apply to the SYN-RECEIVED state.
*
*                               See also 'NetTCP_RxPktConnIsValidReset()  Note #2a5B'.
*
*                           (C) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) (A) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                               of a segment with the SYN bit set in the synchronized state ... [by] handling
*                               ... the SYN bit" as follows :
*
*                               (a) "If the SYN bit is set and the sequence number is outside the
*                                    expected window, send an ACK back to the peer."
*
*                               (b) "If the SYN bit is set and the sequence number is an exact
*                                    match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                    then send an ACK segment ... but ... subtract one from
*                                    value being acknowledged."
*
*                               (c) "If the SYN bit is set and the sequence number is acceptable,
*                                    i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                    ACK segment."
*
*                           (B) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
*                               amendment applies only to the "handling of a ... SYN ... in a synchronized
*                               state", it is assumed that this should also apply to the SYN-RECEIVED state.
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field' states
*                       that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on [and in the] SYN-RECEIVED STATE" :
*
*                           (A) (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
*
*                                   (a) "Enter the ESTABLISHED state" ...
*                                   (b) "and continue processing."
*
*                               (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT
*                                   [State]' states to "send ... [any] data or controls which were queued
*                                   for transmission" when the SYN-SENT state transitions to the ESTABLISHED
*                                   state.
*
*                                   Although this section is the only section to state that any data or
*                                   controls should be sent when transitioning from the SYN-SENT state
*                                   to the ESTABLISHED state, it is assumed that any data or controls
*                                   should also be sent for the transition from the SYN-RECEIVED state
*                                   to the ESTABLISHED state.
*
*                           (B) "If the segment acknowledgment is not acceptable, form a reset segment ...
*                                and send it."
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) And the "SYN-RECEIVED STATE enter[s] the CLOSE-WAIT state".
*
*               (3) (a) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                           "for any state if the user timeout expires, flush all queues, signal the user
*                           'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                       (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                           Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                           or control segment should reset its connection timer.
*
*                   (b) (1) Once a TCP connection enters the connected state, most of its TCP connection timers
*                           should be reset.
*
*                       (2) However, the following timers MAY already have been allocated & initialized, & MUST
*                           NOT be reset :
*
*                           (A)    Transmit Idle timer              'TxQ_IdleTmr'
*                           (B) Re-transmit      timer              'ReTxQ_Tmr'
*
*               (4) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerSyncRxd (NET_TCP_CONN  *p_conn,
                                              NET_BUF       *p_buf,
                                              NET_BUF_HDR   *p_buf_hdr,
                                              NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    NET_TCP_FREE_CODE   free_code;
    NET_TCP_CONN_STATE  state;
    NET_TMR_TICK        timeout_tick;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2C).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b2Ab).               */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt    (see Note #2d1).               */
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
        default:
                                                                /* ... tx TCP conn reset (see Note #2d2B).              */
             NetTCP_TxConnReset(p_conn, p_buf_hdr, NET_TCP_CONN_TX_RESET, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s) [see Note #4].           */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_TX_PKT:
        case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_RE_TX_SEG_TH:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    state = p_conn->ConnState;
    if (p_buf_hdr->TCP_SegClose != DEF_YES) {                   /* If fin/close NOT rx'd, ...                           */
        p_conn->ConnState = NET_TCP_CONN_STATE_CONN;            /* ...  chng to conn'd     state (see Note #2d2A1a).    */
    } else {                                                    /* Else chng to close-wait state (see Note #2e4).       */
        p_conn->ConnState = NET_TCP_CONN_STATE_CLOSE_WAIT;
    }

    p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CONN;


                                                                /* UPDATE TMR's                                         */
    free_code = NET_TCP_CONN_FREE_TMR_ALL;                      /* See Note #3c1.                                       */
    DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_TX_IDLE);      /* See Note #3c2A.                                      */
    DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_RE_TX);        /* See Note #3c2B.                                      */

    NetTCP_ConnFreeTmr(p_conn, free_code);                      /* Free TCP conn tmr(s) [see Note #3b].                 */


                                                                /* Get  TCP conn tmr.                                   */
    timeout_tick       = p_conn->TimeoutConn_tick;              /* Start    conn tmr    (see Note #3a2).                */
    p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                    (void        *) p_conn,
                                    (NET_TMR_TICK ) timeout_tick,
                                    (NET_ERR     *)&err);
    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_NONE_AVAIL;
        return;
    }



                                                                /* ------------------- ACK TCP CONN ------------------- */
    NetTCP_RxPktConnHandlerSignalConn(p_conn, state, &err);     /* Signal app conn (see Note #1c1).                     */
    if ( err != NET_TCP_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }

    NetTCP_RxPktConnHandlerRxQ_AppData(p_conn, &err);           /* Handle TCP conn rx'd data (see Note #2d2A1).         */
    if (err != NET_TCP_ERR_NONE) {
       *p_err = NET_TCP_ERR_CONN_FAIL;
        return;
    }

    if (p_conn->ConnState == NET_TCP_CONN_STATE_CONN) {         /* If conn'd, tx any tx data (see Note #1c3).           */
        NetTCP_TxConnTxQ(p_conn,
                         p_buf_hdr,
                         NET_TCP_CONN_TX_ACK_NONE,
                         DEF_NO,
                         NET_TCP_CONN_CLOSE_ALL,
                         DEF_NO,
                         p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
            case NET_ERR_TX:                                    /* Ignore transitory tx err(s).                         */
            case NET_ERR_IF_LINK_DOWN:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_CLOSE:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_CONN_FAIL:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            case NET_TCP_ERR_TX_PKT:
            case NET_ERR_IF_LOOPBACK_DIS:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_ADDR:
            case NET_CONN_ERR_INVALID_ADDR_LEN:
            default:
                 return;
        }

    } else {                                                    /* Else tx TCP conn ack (see Note #2e3).                */
        NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_IMMED, NET_TCP_CONN_CLOSE_ALL, p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            default:
                 return;
        }
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerSyncTxd()
*
* Description : (1) Handle TCP connection in SYN-SENT state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Acknowledgement (ACK)                                           See Note  #2a
*                       (2) Reset           (RST)                                           See Note  #2b
*                       (3) Synchronization (SYN)                                           See Note  #2c
*
*                   (b) Update TCP connection :
*                       (1) Configure TCP connection remote host maximum segment size       See Note  #3
*                       (2) Handle received TCP segment                                     See Note  #2c
*                       (3) Update    TCP connection state                                  See Notes #2c3A1 & #2c3B1
*                       (4) Update    TCP connection timer
*
*                   (c) Acknowledge   TCP connection
*                       (1) Signal    TCP/application connection complete
*                       (2) Handle    TCP connection  received data                         See Note  #2c3A3
*                       (3) Transmit  TCP connection  acknowledgement & data                See Note  #2c3A2
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_FIN_INVALID    Received segment's finish/close flag is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled &
*                                                                       valid data queued for processing
*                                                                       (see Notes #2c3A3 & #2c3B3).
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State]' states to :
*
*                   (a) "First check the ACK bit[;] if the ACK bit is set" :
*
*                       (1) "If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless the RST bit is
*                            set) ... and discard the segment."
*
*                       (2) "If SND.UNA < SEG.ACK =< SND.NXT then the ACK is acceptable."
*
*                       See also 'NetTCP_RxPktConnIsValidAck()  Note #1c1A'.
*
*                   (b) "Second check the RST bit[;] if the RST bit is set [and] if the ACK was acceptable
*                        then signal the user 'error: connection reset', drop the segment, [and] enter
*                        CLOSED state."
*
*                        See also 'NetTCP_RxPktConnIsValidReset()  Notes #2a3 & #2a5C'.
*
*                   (c) "Fourth check the SYN bit[;] if the SYN bit is on and ... acceptable then" :
*
*                       (1) "RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ."
*                           (A) See also Note #2c3B3a
*
*                       (2) (A) "SND.UNA should be advanced to equal SEG.ACK (if there is an ACK)" ...
*
*                           (B) "and any segments on the retransmission queue which are thereby acknowledged
*                                should be removed."
*
*                       (3) (A) "If SND.UNA > ISS (our SYN has been ACKed)" :
*
*                               (1) "Change the connection state to ESTABLISHED" :
*
*                               (2) (a) "Form an ACK segment ... and send it."
*
*                                   (b) "Data or controls which were queued for transmission may be included."
*
*                               (3) "If there are other controls or text in the segment then continue processing."
*
*                               (4) RFC #1122, Section 4.2.2.20.(c) adds that "when the connection enters
*                                   ESTABLISHED state, the following variables must be set" :
*
*                                   (a) SND.WND <- SEG.WND
*                                   (b) SND.WL1 <- SEG.SEQ
*                                   (c) SND.WL2 <- SEG.ACK
*
*                           (B) "Otherwise" :
*
*                               (1) "Enter SYN-RECEIVED," ...
*
*                               (2) "Form an SYN,ACK segment ... and send it."
*
*                               (3) "If there are other controls or text in the segment, queue them for later
*                                    processing after the ESTABLISHED state has been reached."
*
*                                   (a) If any control or text is queued for later processing, the next sequence
*                                       octet to receive (RCV.NXT) MUST include the length of this received
*                                       segment (SEG.LEN) :
*
*                                       (1) RCV.NXT = SEG.SEQ + SEG.LEN + 1
*
*                   (d) "Fifth, if neither of the SYN or RST bits is set then drop the segment."
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       to "not process the FIN if the state is CLOSED, LISTEN or SYN-SENT since the SEG.SEQ
*                       cannot be validated; drop the segment".
*
*               (3) RFC #1122, Section 4.2.2.6 states that :
*
*                   (a) A "TCP SHOULD send an MSS (Maximum Segment Size) option in every SYN segment".
*
*                   (b) "If an MSS option is not received at connection setup, TCP MUST assume a default
*                        send MSS of 536."
*
*               (4) (a) TCP connection timeout for SYN-SENT state is implemented by TCP connection retransmission
*                       function(s) (see 'NetTCP_TxConnReTxQ()  Note #3c').
*
*                   (b) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                           "for any state if the user timeout expires, flush all queues, signal the user
*                           'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                       (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                           Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                           or control segment should reset its connection timer.
*
*                   (c) (1) Once a TCP connection enters the connected state, most of its TCP connection
*                           timers should be reset.
*
*                       (2) However, the following timers MAY already have been allocated & initialized,
*                           & MUST NOT be reset :
*
*                           (A)    Transmit Idle timer              'TxQ_IdleTmr'
*                           (B) Re-transmit      timer              'ReTxQ_Tmr'
*
*               (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerSyncTxd (NET_TCP_CONN  *p_conn,
                                              NET_BUF       *p_buf,
                                              NET_BUF_HDR   *p_buf_hdr,
                                              NET_ERR       *p_err)
{
    NET_TCP_SEG_SIZE    mss_dflt_tx;
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    NET_TCP_FREE_CODE   free_code;
    NET_TCP_CONN_STATE  state;
    NET_TMR_TICK        timeout_tick;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose != DEF_NO) {                    /* If invalid   fin/close rx'd, ...                     */
       *p_err = NET_TCP_ERR_CONN_SEQ_FIN_INVALID;
        return;                                                 /* ... ignore TCP pkt (see Note #2e).                   */
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    if (ack_code == NET_TCP_CONN_RX_ACK_INVALID) {              /* If invalid ack rx'd, ...                             */
                                                                /* ... tx TCP conn reset (see Note #2a1).               */
        NetTCP_TxConnReset(p_conn, p_buf_hdr, NET_TCP_CONN_TX_RESET, NET_TCP_CONN_CLOSE_ALL, &err);
       *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
        return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If valid reset rx'd, close TCP conn (see Note #2b).  */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:
        default:
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    if (seq_code != NET_TCP_CONN_RX_SEQ_SYNC) {                 /* If sync NOT rx'd, ...                                */
       *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
        return;                                                 /* ... ignore TCP pkt (see Note #2d).                   */
    }
                                                                /* Else sync avail, update seg lens.                    */
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_SYNC;
    p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_SYNC;



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* Cfg remote max seg size ...                          */
                                                                /* ... as advertised by remote host (see Note #3).      */
    if (DEF_BIT_IS_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME) == DEF_YES) {
#ifdef  NET_IPv6_MODULE_EN
        mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V6;
#else
       *p_err = NET_ERR_FAULT_FEATURE_DIS;
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        return;
#endif
    } else {
#ifdef  NET_IPv4_MODULE_EN
        mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V4;
#else
       *p_err = NET_ERR_FAULT_FEATURE_DIS;
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        return;
#endif
    }

    p_conn->MaxSegSizeRemote = (p_buf_hdr->TCP_MaxSegSize != NET_TCP_MAX_SEG_SIZE_NONE)
                             ?  p_buf_hdr->TCP_MaxSegSize
                             :  mss_dflt_tx;


                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s) [see Note #5].           */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_TX_PKT:
        case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_RE_TX_SEG_TH:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    state = p_conn->ConnState;
    if (ack_code == NET_TCP_CONN_RX_ACK_VALID) {                /* If valid ack rx'd        (see Note #2a1), ...        */
        p_conn->ConnState = NET_TCP_CONN_STATE_CONN;            /* ... chng to conn'd state (see Note #2c3A1).          */
        p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CONN;

    } else {                                                    /* Else chng to sync rx'd state (see Note #2c3B1).      */
        p_conn->ConnState = NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE;
    }


                                                                /* UPDATE TMR's                                         */
    free_code = NET_TCP_CONN_FREE_TMR_ALL;                      /* See Note #4c1.                                       */
    DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_TX_IDLE);      /* See Note #4c2A.                                      */
    DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_RE_TX);        /* See Note #4c2B.                                      */

    NetTCP_ConnFreeTmr(p_conn, free_code);                      /* Free TCP conn tmr(s) [see Note #4c].                 */


    if (p_conn->ConnState == NET_TCP_CONN_STATE_CONN) {         /* If conn'd, get TCP conn tmr.                         */
        timeout_tick       = p_conn->TimeoutConn_tick;          /* Start conn tmr (see Note #4b2).                      */
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
        if ( err != NET_TMR_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
           *p_err = NET_TCP_ERR_NONE_AVAIL;
            return;
        }
    }



                                                                /* ------------------- ACK TCP CONN ------------------- */
    if (p_conn->ConnState == NET_TCP_CONN_STATE_CONN) {         /* If conn'd, ...                                       */
        NetTCP_RxPktConnHandlerSignalConn(p_conn, state, &err); /* ... signal app conn           (see Note #1c1);   ... */
        if ( err != NET_TCP_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
           *p_err = NET_TCP_ERR_CONN_FAIL;
            return;
        }

        NetTCP_RxPktConnHandlerRxQ_AppData(p_conn, &err);       /* ... handle TCP conn rx'd data (see Note #2d2A1); ... */
        if (err != NET_TCP_ERR_NONE) {
           *p_err = NET_TCP_ERR_CONN_FAIL;
            return;
        }
                                                                /* ... & tx ack & any tx data    (see Note #1c3).       */
        NetTCP_TxConnTxQ(p_conn,
                         p_buf_hdr,
                         NET_TCP_CONN_TX_ACK_IMMED,
                         DEF_NO,
                         NET_TCP_CONN_CLOSE_ALL,
                         DEF_NO,
                         p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
            case NET_ERR_TX:                                    /* Ignore transitory tx err(s).                         */
            case NET_ERR_IF_LINK_DOWN:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_CLOSE:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_CONN_FAIL:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            case NET_TCP_ERR_TX_PKT:
            case NET_ERR_IF_LOOPBACK_DIS:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_ADDR:
            case NET_CONN_ERR_INVALID_ADDR_LEN:
            default:
                 return;
        }

    } else {                                                    /* Else tx TCP conn sync/ack (see Note #2c3B2).         */
        NetTCP_TxConnSync(p_conn, p_buf_hdr, state, &err);
        if ( err != NET_TCP_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_CLOSE;
            return;
        }
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                    NetTCP_RxPktConnHandlerConn()
*
* Description : (1) Handle TCP connection in ESTABLISHED state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d & #2e
*                       (2) Update TCP connection state                             See Note  #2f5
*                       (3) Update TCP connection timer                             See Note  #3
*
*                   (c) Transmit TCP connection acknowledgement & data              See Notes #2e2A & #2f3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive  queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive  queue signal fault.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the ESTABLISHED state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
*                               that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
*                               RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
*                               responses.  All segment queues should be flushed.  Users should also receive an
*                               unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on [and in the] ESTABLISHED STATE" :
*
*                           (A) "If SND.UNA < SEG.ACK <= SND.NXT then" :
*
*                               (1) "Set SND.UNA <- SEG.ACK."
*
*                               (2) "Any segments on the retransmission queue which are thereby entirely
*                                    acknowledged are removed."
*
*                               (3) "The send window should be updated" :
*
*                                   (a) (1) (A) "If ((SND.WL1 <  SEG.SEQ) or" ...
*
*                                           (B) (1) "(SND.WL1  = SEG.SEQ and" ...
*                                               (2)  "SND.WL2 <= SEG.ACK)),"  ...
*
*                                       (2) (A) "Set SND.WND <- SEG.WND," ...
*                                           (B) "Set SND.WL1 <- SEG.SEQ," ...
*                                           (C) "Set SND.WL2 <- SEG.ACK."
*
*                                   (b) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
*                                        sequence number of the last segment used to update SND.WND, and that
*                                        SND.WL2 records the acknowledgment number of the last segment used to
*                                        update SND.WND.  The check here prevents using old segments to update
*                                        the window."
*
*                           (B) (1) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
*
*                               (2) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
*                                   for the segment's acknowledgement to include SND.UNA : "The window should
*                                   updated if SND.UNA <= SEG.ACK <= SND.NXT."
*
*                                   See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
*
*                           (C) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
*                                [and] drop the segment."
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                       states that for the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... it
*                       is possible to deliver segment text to user RECEIVE buffers" :
*
*                       (1) "If the segment ... carries [a] PUSH flag, then the user is informed [and] the
*                            buffer is returned."
*
*                       (2) (A) (1) "When the TCP takes responsibility for delivering the data to the user it
*                                    must also acknowledge the receipt of the data."
*
*                               (2) "This acknowledgment should be piggybacked on a segment being transmitted
*                                    if possible without incurring undue delay."
*
*                           (B) "Once the TCP takes responsibility for the data" :
*
*                               (1) "It advances RCV.NXT over the data accepted," ...
*
*                               (2) "Adjusts RCV.WND as appropriate to the current buffer availability" ...
*
*                               (3) (a) "The total of RCV.NXT and RCV.WND should not be reduced."
*
*                                   (b) RFC #793,  Section 3.7 'Data Communication : Managing the Window' &
*                                       RFC #1122, Section 4.2.2.16 confirm that "a TCP receiver SHOULD NOT
*                                       shrink the window"; i.e. "advertise a much smaller window without
*                                       having accepted that much data".
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) And the "ESTABLISHED STATE enter[s] the CLOSE-WAIT state".
*
*               (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                       "for any state if the user timeout expires, flush all queues, signal the user
*                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                   (b) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                       or control segment should reset its connection timer.
*
*               (4) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerConn (NET_TCP_CONN  *p_conn,
                                           NET_BUF       *p_buf,
                                           NET_BUF_HDR   *p_buf_hdr,
                                           NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    NET_TMR_TICK        timeout_tick;
    CPU_BOOLEAN         keep_alive_rx = DEF_NO;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;

        case NET_TCP_CONN_RX_SEQ_KEEP_ALIVE:
             keep_alive_rx = DEF_YES;
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;

        case NET_TCP_CONN_RX_ACK_OTW:
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_OTW, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;

        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2C).                */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }


    if (keep_alive_rx == DEF_NO) {
                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
        NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
        switch (err_rtn) {
            case NET_TCP_ERR_CONN_DATA_NONE:
            case NET_TCP_ERR_CONN_DATA_VALID:
            case NET_ERR_TX:                                    /* Ignore transitory tx err(s) [see Note #4].           */
            case NET_ERR_IF_LINK_DOWN:
                 break;


            case NET_TCP_ERR_CONN_DATA_DUP:
                *p_err = err_rtn;
                 return;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_FAIL:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_DATA_INVALID:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_RX_Q_FULL:
            case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
            case NET_TCP_ERR_TX_PKT:
            case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
            case NET_TCP_ERR_RE_TX_SEG_TH:
            case NET_ERR_IF_LOOPBACK_DIS:
            default:
                 NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
                *p_err = err_rtn;
                 return;
        }
    }

                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close rx'd, ...                               */
        p_conn->ConnState = NET_TCP_CONN_STATE_CLOSE_WAIT;      /* ... chng to close-wait state (see Note #2f5).        */
    }


                                                                /* -------------------- UPDATE TMR -------------------- */
    timeout_tick = p_conn->TimeoutConn_tick;                    /* Reset conn idle tmr (see Note #3b).                  */
    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }



                                                                /* --------------- TX TCP CONN ACK/DATA --------------- */
    ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED) ||
                (p_buf_hdr->TCP_SegClose        == DEF_YES))    /* See Note #2f3.                                       */
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;
                                                                /* Tx ack & any tx data (see Note #1c).                 */
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     ack_code,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_TCP_ERR_CONN_ACK_NONE:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_ACK_DLYD:
        case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s).                         */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_CLOSE:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_NONE_AVAIL:
        case NET_TCP_ERR_TX_PKT:
        case NET_ERR_IF_LOOPBACK_DIS:
        case NET_CONN_ERR_INVALID_FAMILY:
        case NET_CONN_ERR_INVALID_ADDR:
        case NET_CONN_ERR_INVALID_ADDR_LEN:
        default:
             return;
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerFinWait1()
*
* Description : (1) Handle TCP connection in FIN-WAIT-1 state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d   & #2e
*                       (2) Signal TCP/application connection close                 See Note  #2d2B2
*                       (3) Update TCP connection state :                           See Notes #2f5A1, #2f5A2b1, & #2f5B
*                           (A) Configure TCP connection timeout value
*                           (B) Configure TCP connection timeout function
*                       (4) Update TCP connection timer(s)                          See Notes #2f5A1, #2f5A2b2, & #3
*
*                   (c) Transmit TCP connection acknowledgement & data              See Notes #2e2A & #2f3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive  queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive  queue signal fault.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*
*                                                                   - RETURNED BY NetTCP_RxPktConnHandlerSignalClose() : -
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid application connection.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid network connection family.
*                               NET_CONN_ERR_INVALID_CONN           Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED               Network connection NOT currently used.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the FIN-WAIT-1 state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
*                               that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
*                               RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
*                               responses.  All segment queues should be flushed.  Users should also receive an
*                               unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on" :
*
*                           (A) And in the "ESTABLISHED STATE" :
*
*                               (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
*
*                                   (a) "Set SND.UNA <- SEG.ACK."
*
*                                   (b) "Any segments on the retransmission queue which are thereby entirely
*                                        acknowledged are removed."
*
*                                   (c) "The send window should be updated" :
*
*                                       (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
*
*                                               (2) (a) "(SND.WL1  = SEG.SEQ and" ...
*                                                   (b)  "SND.WL2 <= SEG.ACK)),"  ...
*
*                                           (B) (1) "Set SND.WND <- SEG.WND," ...
*                                               (2) "Set SND.WL1 <- SEG.SEQ," ...
*                                               (3) "Set SND.WL2 <- SEG.ACK."
*
*                                       (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
*                                            sequence number of the last segment used to update SND.WND, and that
*                                            SND.WL2 records the acknowledgment number of the last segment used to
*                                            update SND.WND.  The check here prevents using old segments to update
*                                            the window."
*
*                               (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
*
*                                   (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
*                                       for the segment's acknowledgement to include SND.UNA : "The window should
*                                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
*
*                                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
*
*                               (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
*                                    [and] drop the segment."
*
*                           (B) (1) For the "FIN-WAIT-1 STATE" :
*
*                                   (a) "In addition to the processing for the ESTABLISHED state" ...
*                                   (b) "If our FIN is now acknowledged then"                     ...
*                                       (1) "Enter FIN-WAIT-2 [state] and continue processing in that state."
*
*                               (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the user's
*                                       CLOSE can be acknowledged".
*
*                                   (b) However, a TCP connection transitions into the FIN-WAIT-2 state if & only if
*                                       the TCP connection's close request was previously acknowledged while in the
*                                       FIN-WAIT-1 state.  Thus the TCP connection's re-transmit queue should
*                                       already be empty prior to entering the FIN-WAIT-2 state.
*
*                                       Therefore, a TCP connection in the FIN-WAIT-1 state should :
*
*                                       (1) Signal the application layer that "the user's close [is] acknowledged"
*                                           whenever its re-transmit queue becomes empty.
*
*                                       (2) Close all unused timers (see also Note #2f5A1b).
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                       states that for the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... it
*                       is possible to deliver segment text to user RECEIVE buffers" :
*
*                       (1) "If the segment ... carries [a] PUSH flag, then the user is informed [and] the
*                            buffer is returned."
*
*                       (2) (A) (1) "When the TCP takes responsibility for delivering the data to the user it
*                                    must also acknowledge the receipt of the data."
*
*                               (2) "This acknowledgment should be piggybacked on a segment being transmitted
*                                    if possible without incurring undue delay."
*
*                           (B) "Once the TCP takes responsibility for the data" :
*
*                               (1) "It advances RCV.NXT over the data accepted," ...
*
*                               (2) "Adjusts RCV.WND as appropriate to the current buffer availability" ...
*
*                               (3) (a) "The total of RCV.NXT and RCV.WND should not be reduced."
*
*                                   (b) RFC #793,  Section 3.7 'Data Communication : Managing the Window' &
*                                       RFC #1122, Section 4.2.2.16 confirm that "a TCP receiver SHOULD NOT
*                                       shrink the window"; i.e. "advertise a much smaller window without
*                                       having accepted that much data".
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) For the "FIN-WAIT-1 STATE" :
*
*                           (A) "If our FIN has been ACKed (perhaps in this segment), then" :
*
*                               (1) "Enter TIME-WAIT [state]" ...
*                                   (a) "Start the time-wait timer,  ...
*                                       (1) A TCP connection should be closed WITHOUT fault following a TCP
*                                           connection TIME-WAIT timeout.
*
*                                   (b) "Turn off the other timers;" ...
*
*                               (2) However, it is possible that some closing received data from the remote
*                                   host is available but has NOT yet been received by the application layer.
*
*                                   (a) Therefore, if the application receive queue is closed, then enter the
*                                       TIME-WAIT state.
*
*                                   (b) (1) But if the application receive queue is NOT closed, then enter the
*                                           connection-closing-data-available state to allow the application
*                                           layer to receive the remaining receive data.
*
*                                       (2) (A) To satisfy the required time-wait timeout of two maximum segment
*                                               lifetimes (see Note #2f5A1a), the time-wait timeout is initially
*                                               used to provide the application layer sufficient time to receive
*                                               the closing received data.
*
*                                           (B) If after the time-wait timeout expires, the application receive
*                                               queue is still not empty, the user connection timeout is used
*                                               to provide the application layer additional time to receive the
*                                               closing received data.
*
*                                           See also Note #3a.
*
*                           (B) "Otherwise, enter the CLOSING state."
*
*               (3) (a) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                           "for any state if the user timeout expires, flush all queues, signal the user
*                           'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                       (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                           Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                           or control segment should reset its connection timer.
*
*                   (b) (1) (A) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.6 'FIN_WAIT_2
*                               State', Page 246 states that "in the FIN_WAIT_2 state we have sent our FIN and
*                               the other end has acknowledged it ... [and] we are waiting for the application
*                               on the other end to recognize that it has received an end-of-file notification
*                               and close its end of the connection, which sends us a FIN.  Only when the
*                               process at the other end does this will our end move from the FIN_WAIT_2 to
*                               the TIME_WAIT state.  This means our end of the connection can remain in this
*                               state forever.  The other end is still in the CLOSE_WAIT state, and can remain
*                               there forever, until the application decides to issue its close".
*
*                           (B) "Many Berkeley-derived implementations prevent this infinite wait in the
*                                FIN_WAIT_2 state" by :
*
*                                (1) "Mov[ing] the connection into the CLOSED state" ...
*                                (2) "if the connection is idle for 10 minutes plus 75 seconds."
*
*                       (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.1 'A FIN_WAIT_2
*                           timer', Page 818 states that "to avoid leaving a connection in the FIN_WAIT_2 state
*                           forever, if the other end never sends a FIN" :
*
*                           (A) (1) "When a connection moves from the FIN_WAIT_1 state to the FIN_WAIT_2 state" ...
*                               (2) "and the connection cannot receive any more data [implying the process called
*                                    close(), instead of ... half-close ... shutdown()]," ...
*
*                           (B) (1)  The TCP connection's "timer is set to 10 minutes ... [and] 75 seconds," ...
*                               (2) "and when it expires ... the connection is dropped".
*
*                       (3) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6 'FIN_WAIT_2
*                           and 2MSL Timers : FIN_WAIT_2 timer', Pages 825-827 adds that "terminating an idle
*                           connection after more than 10 minutes in the FIN_WAIT_2 state violates the protocol
*                           specification, but this is practical ... [since] all outstanding data on the connection
*                           has been sent and acknowledged, the other end has acknowledged the FIN, and TCP is
*                           waiting for the process at the other end of the connection to issue its close().  If
*                           the other process never closes its end of the connection, our end can remain in the
*                           FIN_WAIT_2 [state] forever".
*
*               (4) Since the mechanisms of TCP connection close are independent of the application layer
*                   close; any external application layer close error(s) are ignored.
*
*               (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerFinWait1 (NET_TCP_CONN  *p_conn,
                                               NET_BUF       *p_buf,
                                               NET_BUF_HDR   *p_buf_hdr,
                                               NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    CPU_BOOLEAN         data_avail;
    NET_TMR_TICK        timeout_tick;
    CPU_FNCT_PTR        timeout_fnct;
    NET_TCP_FREE_CODE   free_code;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2A3).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s) [see Note #5].           */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_RX_Q_FULL:
        case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_TX_PKT:
        case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_RE_TX_SEG_TH:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    timeout_fnct = (CPU_FNCT_PTR)0;
                                                                /* If local conn close ack'd (see Note #2f5A);      ... */
    if ((p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED        ) ||
        (p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED_SUSPEND)) {
                                                                /* Closing data avail for half-closed conns ONLY.       */
        data_avail = ((p_conn->ConnCloseCode !=  NET_CONN_CLOSE_HALF      ) ||
                     ((p_conn->RxQ_State     ==  NET_TCP_RX_Q_STATE_CLOSED) &&
                      (p_conn->RxQ_App_Head  == DEF_NULL))) ? DEF_NO : DEF_YES;

                                                                /* ... signal app conn close (see Note #2d2B2b1);   ... */
        NetTCP_RxPktConnHandlerSignalClose(p_conn, data_avail, &err);
        switch (err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_FAIL:                         /* Ignore any app conn close err(s) [see Note #4].      */
            case NET_TCP_ERR_INVALID_CONN_ID:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_CONN:
            case NET_CONN_ERR_NOT_USED:
            default:
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
                *p_err = err;
                 return;
        }

        if (p_buf_hdr->TCP_SegClose == DEF_YES) {               /* ... & if fin/close rx'd                          ... */

            if (data_avail != DEF_YES) {                        /* ... & NO app data avail,                         ... */
                                                                /* ... chng to time-wait state (see Note  #2f5A2a); ... */
                p_conn->ConnState                 =  NET_TCP_CONN_STATE_TIME_WAIT;
                p_conn->ConnCloseTimeoutFaultFlag =  DEF_NO;    /* ... clr close timeout fault (see Note  #2f5A1a1);... */
                timeout_fnct                      = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;

            } else {                                            /* ... else chng to conn-closing-data-avail state   ... */
                                                                /* ...                         (see Note  #2f5A2b1);... */
                p_conn->ConnState =  NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
                timeout_fnct      = (CPU_FNCT_PTR)&NetTCP_ConnClosingTimeoutDataAvail;
            }
                                                                /* ... & start time-wait tmr   (see Notes #2f5A1a & ... */
                                                                /* ...                                    #2f5A2b2A).   */
            timeout_tick = p_conn->TimeoutMaxSeg_tick_scaled;

        } else {
            p_conn->ConnState =  NET_TCP_CONN_STATE_FIN_WAIT_2; /* ... else chng to fin-wait-2 state (see Note #2d2B1b1)*/
                                                                /* ... & start      fin-wait-2 tmr   (see Note #3b).    */
            timeout_tick      =  NET_TCP_DFLT_TIMEOUT_CONN_FIN_WAIT_2_SEC * NET_TMR_TIME_TICK_PER_SEC;
            timeout_fnct      = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;


                                                                /* If conn is half-closed, and we transition from the...*/
                                                                /* ...FIN_WAIT_1 to the FIN_WAIT2 state, make sure we...*/
                                                                /* ...free the socket that was prevented from closing...*/
                                                                /* ...at the end of NetSock_CloseHandlerStream().       */
            if (p_conn->ConnCloseCode == NET_CONN_CLOSE_HALF) { /* See Note #5a2 in NetSock_CloseHandlerStream().       */
                p_conn->ConnCloseAppFlag = DEF_SET;
            }
        }


    } else {
        if (p_buf_hdr->TCP_SegClose == DEF_YES) {               /* Else if fin/close rx'd,                     ...      */
            p_conn->ConnState =  NET_TCP_CONN_STATE_CLOSING;    /* ... chng to closing state  (see Note #2f5B) ...      */
            timeout_tick      =  p_conn->TimeoutConn_tick;      /* ... & start conn close tmr (see Note #3a2).          */
            timeout_fnct      = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
        }
    }


                                                                /* UPDATE TMR's                                         */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_TIME_WAIT:                      /* If in time-wait            (see Note #2f5A1)    ...  */
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:             /* ... or closing state(s)    [see Note #2d2B2b2], ...  */
             free_code = NET_TCP_CONN_FREE_TMR_ALL;             /* ... free all TCP conn tmrs (see Note #2f5A1b).       */
             DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_TIMEOUT);
             NetTCP_ConnFreeTmr(p_conn, free_code);
             break;


        default:                                                /* 'default' case intentionally empty.                  */
             break;
    }


    if (timeout_fnct != (CPU_FNCT_PTR)0) {
        if (p_conn->TimeoutTmr != DEF_NULL) {
            NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                       (CPU_FNCT_PTR) timeout_fnct,
                       (NET_TMR_TICK) timeout_tick,
                       (NET_ERR    *)&err);
        } else {
            p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR ) timeout_fnct,
                                            (void        *) p_conn,
                                            (NET_TMR_TICK ) timeout_tick,
                                            (NET_ERR     *)&err);
        }

        if ( err != NET_TMR_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }
    }



                                                                /* --------------- TX TCP CONN ACK/DATA --------------- */
    ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED) ||
                (p_buf_hdr->TCP_SegClose        == DEF_YES))    /* See Note #2f3.                                       */
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;

    if ((p_conn->ConnState == NET_TCP_CONN_STATE_FIN_WAIT_1) || /* If TCP conn tx Q NOT closed, ...                     */
        (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING   )) { /* ... tx ack & any tx data (see Note #1c).             */
        NetTCP_TxConnTxQ(p_conn,
                         p_buf_hdr,
                         ack_code,
                         DEF_NO,
                         NET_TCP_CONN_CLOSE_ALL,
                         DEF_NO,
                         p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
            case NET_ERR_TX:                                    /* Ignore transitory tx err(s).                         */
            case NET_ERR_IF_LINK_DOWN:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_CLOSE:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_CONN_FAIL:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            case NET_TCP_ERR_TX_PKT:
            case NET_ERR_IF_LOOPBACK_DIS:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_ADDR:
            case NET_CONN_ERR_INVALID_ADDR_LEN:
            default:
                 return;
        }

    } else {                                                    /* Else tx TCP conn ack (see Note #2f3).                */
        NetTCP_TxConnAck(p_conn, p_buf_hdr, ack_code, NET_TCP_CONN_CLOSE_ALL, p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            default:
                 return;
        }
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerFinWait2()
*
* Description : (1) Handle TCP connection in FIN-WAIT-2 state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d   & #2e
*                       (2) Update TCP connection state :                           See Notes #2f5A & #2f5B2a
*                           (A) Configure TCP connection timeout value
*                           (B) Configure TCP connection timeout function
*                       (3) Update TCP connection timer(s)                          See Notes #2f5A,  #2f5B2b, & #3
*
*                   (c) Transmit TCP connection acknowledgement                     See Notes #2e2A & #2f3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnIsValidSeq() : --
*                                                                   -- RETURNED BY NetTCP_RxPktConnIsValidAck() : --
*                                                                   - RETURNED BY NetTCP_RxPktConnIsValidReset() : -
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnHandlerSeg() : --
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive queue signal fault.
*
*                                                                   ------- RETURNED BY NetTCP_TxConnAck() : -------
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the FIN-WAIT-2 state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
*                               that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
*                               RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
*                               responses.  All segment queues should be flushed.  Users should also receive an
*                               unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on" :
*
*                           (A) And in the "ESTABLISHED STATE" :
*
*                               (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
*
*                                   (a) "Set SND.UNA <- SEG.ACK."
*
*                                   (b) "Any segments on the retransmission queue which are thereby entirely
*                                        acknowledged are removed."
*
*                                   (c) "The send window should be updated" :
*
*                                       (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
*
*                                               (2) (a) "(SND.WL1  = SEG.SEQ and" ...
*                                                   (b)  "SND.WL2 <= SEG.ACK)),"  ...
*
*                                           (B) (1) "Set SND.WND <- SEG.WND," ...
*                                               (2) "Set SND.WL1 <- SEG.SEQ," ...
*                                               (3) "Set SND.WL2 <- SEG.ACK."
*
*                                       (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
*                                            sequence number of the last segment used to update SND.WND, and that
*                                            SND.WL2 records the acknowledgment number of the last segment used to
*                                            update SND.WND.  The check here prevents using old segments to update
*                                            the window."
*
*                               (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
*
*                                   (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
*                                       for the segment's acknowledgement to include SND.UNA : "The window should
*                                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
*
*                                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
*
*                               (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
*                                    [and] drop the segment."
*
*                           (B) For the "FIN-WAIT-2 STATE" :
*
*                               (1) "In addition to the processing for the ESTABLISHED state" ...
*                               (2) "If the retransmission queue is empty,"                   ...
*
*                                   (a) (1) "The user's CLOSE can be acknowledged."
*                                       (2) However, a TCP connection transitions into the FIN-WAIT-2 state if &
*                                           only if the TCP connection's close request was previously acknowledged
*                                           while in the FIN-WAIT-1 state.  Thus the TCP connection's re-transmit
*                                           queue should already be empty prior to entering the FIN-WAIT-2 state.
*
*                                           See also 'NetTCP_RxPktConnHandlerFinWait1()  Note #2d2B2'.
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                       states that for the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... it
*                       is possible to deliver segment text to user RECEIVE buffers" :
*
*                       (1) "If the segment ... carries [a] PUSH flag, then the user is informed [and] the
*                            buffer is returned."
*
*                       (2) (A) "When the TCP takes responsibility for delivering the data to the user it
*                                must also acknowledge the receipt of the data."
*
*                           (B) "Once the TCP takes responsibility for the data" :
*
*                               (1) "It advances RCV.NXT over the data accepted," ...
*
*                               (2) "Adjusts RCV.WND as appropriate to the current buffer availability" ...
*
*                               (3) (a) "The total of RCV.NXT and RCV.WND should not be reduced."
*
*                                   (b) RFC #793,  Section 3.7 'Data Communication : Managing the Window' &
*                                       RFC #1122, Section 4.2.2.16 confirm that "a TCP receiver SHOULD NOT
*                                       shrink the window"; i.e. "advertise a much smaller window without
*                                       having accepted that much data".
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) For the "FIN-WAIT-2 STATE" :
*
*                           (A) "Enter the TIME-WAIT state"      ...
*                               (1) "Start the time-wait timer," ...
*                                   (a) A TCP connection should be closed WITHOUT fault following a TCP
*                                       connection TIME-WAIT timeout.
*
*                               (2) "Turn off the other timers."
*
*                           (B) However, it is possible that some closing received data from the remote
*                               host is available but has NOT yet been received by the application layer.
*
*                               (1) Therefore, if the application receive queue is closed, then enter the
*                                   TIME-WAIT state.
*
*                               (2) (a) But if the application receive queue is NOT closed, then enter the
*                                       connection-closing-data-available state to allow the application
*                                       layer to receive the remaining receive data.
*
*                                   (b) (1) To satisfy the required time-wait timeout of two maximum segment
*                                           lifetimes (see Note #2f5A1a), the time-wait timeout is initially
*                                           used to provide the application layer sufficient time to receive
*                                           the closing received data.
*
*                                       (2) If after the time-wait timeout expires, the application receive
*                                           queue is still not empty, the user connection timeout is used
*                                           to provide the application layer additional time to receive the
*                                           closing received data.
*
*                                       See also Note #3a.
*
*               (3) (a) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                           "for any state if the user timeout expires, flush all queues, signal the user
*                           'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                       (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                           Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                           or control segment should reset its connection timer.
*
*                   (b) (1) (A) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.6 'FIN_WAIT_2
*                                   State', Page 246 states that "in the FIN_WAIT_2 state we have sent our FIN and
*                                   the other end has acknowledged it ... [and] we are waiting for the application
*                                   on the other end to recognize that it has received an end-of-file notification
*                                   and close its end of the connection, which sends us a FIN.  Only when the
*                                   process at the other end does this will our end move from the FIN_WAIT_2 to
*                                   the TIME_WAIT state.  This means our end of the connection can remain in this
*                                   state forever.  The other end is still in the CLOSE_WAIT state, and can remain
*                                   there forever, until the application decides to issue its close".
*
*                               (2) "Many Berkeley-derived implementations prevent this infinite wait in the
*                                    FIN_WAIT_2 state" by :
*
*                                    (a) "Mov[ing] the connection into the CLOSED state" ...
*                                    (b) "if the connection is idle for 10 minutes plus 75 seconds."
*
*                           (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.1 'A FIN_WAIT_2
*                               timer', Page 818 states that "to avoid leaving a connection in the FIN_WAIT_2 state
*                               forever, if the other end never sends a FIN" :
*
*                               (1) (a) "When a connection moves from the FIN_WAIT_1 state to the FIN_WAIT_2 state" ...
*                                   (b) "and the connection cannot receive any more data [implying the process called
*                                        close(), instead of ... half-close ... shutdown()]," ...
*
*                               (2) (a)  The TCP connection's "timer is set to 10 minutes ... [and] 75 seconds," ...
*                                   (b) "and when it expires ... the connection is dropped".
*
*                           (C) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6 'FIN_WAIT_2
*                               and 2MSL Timers : FIN_WAIT_2 timer', Pages 825-827 adds that "terminating an idle
*                               connection after more than 10 minutes in the FIN_WAIT_2 state violates the protocol
*                               specification, but this is practical ... [since] all outstanding data on the connection
*                               has been sent and acknowledged, the other end has acknowledged the FIN, and TCP is
*                               waiting for the process at the other end of the connection to issue its close().  If
*                               the other process never closes its end of the connection, our end can remain in the
*                               FIN_WAIT_2 [state] forever".
*
*                       (2) However, NO RFC or reference specifies or suggests any mechanism to handle/reset any
*                           FIN-WAIT-2 timeouts.
*
*                           Therefore, it is assumed that ANY TCP connection in  the FIN-WAIT-2 state that
*                           receives a valid TCP data or control segment should reset its FIN-WAIT-2 timer.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerFinWait2 (NET_TCP_CONN  *p_conn,
                                               NET_BUF       *p_buf,
                                               NET_BUF_HDR   *p_buf_hdr,
                                               NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    CPU_BOOLEAN         data_avail;
    NET_TMR_TICK        timeout_tick;
    CPU_FNCT_PTR        timeout_fnct;
    NET_TCP_FREE_CODE   free_code;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;


        case NET_TCP_CONN_RX_ACK_OTW:                           /* If out-of-window ack rx'd, ...                       */
                                                                /* ... tx TCP conn ack (see Note #2d2A3).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_OTW, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2A3).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_RX_Q_FULL:
        case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close rx'd,                               ... */
                                                                /* Closing data avail for half-closed conns ONLY.       */
        data_avail  = ((p_conn->ConnCloseCode !=  NET_CONN_CLOSE_HALF                     )   ||
                      ((p_conn->RxQ_State     ==  NET_TCP_RX_Q_STATE_CLOSED               )   &&
                       (p_conn->RxQ_App_Head  ==  DEF_NULL                                ))) ? DEF_NO : DEF_YES;

        data_avail &= (p_buf_hdr->DataLen > 0u);
        if (data_avail != DEF_YES) {                            /* ... & NO app data avail,                         ... */
                                                                /* ... chng to time-wait state (see Note  #2f5B1);  ... */
            p_conn->ConnState                 =  NET_TCP_CONN_STATE_TIME_WAIT;
            p_conn->ConnCloseTimeoutFaultFlag =  DEF_NO;        /* ... clr close timeout fault (see Note  #2f5A1a); ... */
            timeout_fnct                      = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;

        } else {                                                /* ... else chng to conn-closing-data-avail state   ... */
                                                                /* ...                         (see Note  #2f5B2a); ... */
            p_conn->ConnState =  NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
            timeout_fnct      = (CPU_FNCT_PTR)&NetTCP_ConnClosingTimeoutDataAvail;
        }
                                                                /* ... & start time-wait tmr   (see Notes #2f5A1 &  ... */
        timeout_tick = p_conn->TimeoutMaxSeg_tick_scaled;       /* ...                                    #2f5B2b1).    */

    } else {
                                                                /* Else reset fin-wait-2 tmr   (see Note #3b).          */
        timeout_tick =  NET_TCP_DFLT_TIMEOUT_CONN_FIN_WAIT_2_SEC * NET_TMR_TIME_TICK_PER_SEC;
        timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
    }


                                                                /* UPDATE TMR's                                         */
                                                                /* In time-wait or closing state(s) [see Note #2f5A],   */
    free_code = NET_TCP_CONN_FREE_TMR_ALL;                      /* ... free all TCP conn tmrs       (see Note #2f5A2).  */
    DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_TIMEOUT);
    NetTCP_ConnFreeTmr(p_conn, free_code);


    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR) timeout_fnct,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR ) timeout_fnct,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }


                                                                /* ----------------- TC TCP CONN ACK ------------------ */
                                                                /* Tx TCP conn ack (see Notes #1c).                     */
    NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_IMMED, NET_TCP_CONN_CLOSE_ALL, p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_TCP_ERR_CONN_ACK_NONE:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_ACK_DLYD:
        case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_NONE_AVAIL:
        default:
             return;
    }

   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerClosing()
*
* Description : (1) Handle TCP connection in CLOSING state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d    & #2e
*                       (2) Update TCP connection state :                           See Note  #2d2B2a1A
*                           (A) Configure TCP connection timeout value
*                           (B) Configure TCP connection timeout function
*                       (3) Update TCP connection timer(s)                          See Notes #2d2B2a1A, #2d2B2a1B2b,
*                                                                                                    & #3
*
*                   (c) Transmit TCP connection acknowledgement & data              See Notes #2d2B1 & #2f3
*
* Argument(s) : p_conn      Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf       Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr   Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive  queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive  queue signal fault.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*
*                                                                   - RETURNED BY NetTCP_RxPktConnHandlerSignalClose() : -
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid application connection.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid network connection family.
*                               NET_CONN_ERR_INVALID_CONN           Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED               Network connection NOT currently used.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the CLOSING state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                               states that in the "CLOSING, LAST-ACK, TIME-WAIT" states that "if the RST bit
*                               is set then, enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on" :
*
*                           (A) And in the "ESTABLISHED STATE" :
*
*                               (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
*
*                                   (a) "Set SND.UNA <- SEG.ACK."
*
*                                   (b) "Any segments on the retransmission queue which are thereby entirely
*                                        acknowledged are removed."
*
*                                   (c) "The send window should be updated" :
*
*                                       (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
*
*                                               (2) (a) "(SND.WL1  = SEG.SEQ and" ...
*                                                   (b)  "SND.WL2 <= SEG.ACK)),"  ...
*
*                                           (B) (1) "Set SND.WND <- SEG.WND," ...
*                                               (2) "Set SND.WL1 <- SEG.SEQ," ...
*                                               (3) "Set SND.WL2 <- SEG.ACK."
*
*                                       (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
*                                            sequence number of the last segment used to update SND.WND, and that
*                                            SND.WL2 records the acknowledgment number of the last segment used to
*                                            update SND.WND.  The check here prevents using old segments to update
*                                            the window."
*
*                               (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
*
*                                   (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
*                                       for the segment's acknowledgement to include SND.UNA : "The window should
*                                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
*
*                                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
*
*                               (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
*                                    [and] drop the segment."
*
*                           (B) For the "CLOSING STATE" :
*
*                               (1) "In addition to the processing for the ESTABLISHED state" ...
*
*                               (2) (a) "If the ACK acknowledges our FIN then" ...
*
*                                       (1) (A) "Enter the TIME-WAIT state," ...
*
*                                               (1) The following sections ... :
*
*                                                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES :
*                                                           Check FIN Bit : FIN-WAIT-1 STATE'
*                                                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES :
*                                                           Check FIN Bit : FIN-WAIT-2 STATE'
*
*                                               (2) ... generalize that when entering "the TIME-WAIT state" to ...
*
*                                                   (a) "Start the time-wait timer," ...
*                                                       (1) A TCP connection should be closed WITHOUT fault following
*                                                           a TCP connection TIME-WAIT timeout.
*
*                                                   (b) "Turn off the other timers."
*
*                                               (3) Although these sections are the only sections to state that these
*                                                   TCP connection timers should be updated when transitioning to the
*                                                   TIME-WAIT state, it is assumed that these timers should also be
*                                                   updated for the transition from the CLOSING state to the TIME-WAIT
*                                                   state.
*
*                                           (B) However, it is possible that some closing received data from the remote
*                                               host is available but has NOT yet been received by the application layer.
*
*                                               (1) Therefore, if the application receive queue is closed, then enter the
*                                                   TIME-WAIT state.
*
*                                               (2) (a) But if the application receive queue is NOT closed, then enter the
*                                                       connection-closing-data-available state to allow the application
*                                                       layer to receive the remaining receive data.
*
*                                                   (b) (1) To satisfy the required time-wait timeout of two maximum segment
*                                                           lifetimes (see Note #2f5A1a), the time-wait timeout is initially
*                                                           used to provide the application layer sufficient time to receive
*                                                           the closing received data.
*
*                                                       (2) If after the time-wait timeout expires, the application receive
*                                                           queue is still not empty, the user connection timeout is used
*                                                           to provide the application layer additional time to receive the
*                                                           closing received data.
*
*                                                       See also Note #3.
*
*                                       (2) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
*                                               ACK Field : FIN-WAIT-2 STATE' states that "if the retransmission
*                                               queue is empty, the user's CLOSE can be acknowledged".
*
*                                           (B) Although this section is the only section to state that the TCP
*                                               connection should acknowledge the user's close, it is assumed that
*                                               a TCP connection should signal the application layer that "the
*                                               user's close [is] acknowledged" whenever its re-transmit queue
*                                               becomes empty.
*
*                                   (b) (1) "Otherwise ignore the segment."
*
*                                       (2) However, it is possible that some but NOT all transmitted data has
*                                           been received by the remote host.  In other words, the remote host may
*                                           have received some but NOT ALL transmitted data preceding this host's
*                                           connection close request.
*
*                                           Therefore, acknowledgements validated by as within the transmit
*                                           window MUST be received & processed as in connected states.
*
*                                           See also 'NetTCP_RxPktConnIsValidAck()  Note #1d'.
*
*                                       See also Note #2e2.
*
*                   (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                           states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that "this should not occur, since a FIN has been received from the remote
*                           side.  Ignore the segment text."
*
*                       (2) (A) However, it is possible that some but NOT all data has been received from
*                               the remote host.  In other words, the remote host's  connection close request
*                               may have received but ALL receive data preceding the connection close request
*                               may NOT have been received.
*
*                               Therefore, receive data validated by sequence number as within the
*                               receive window MUST be received & processed as in connected states.
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
*                               Text' states that "once in the ESTABLISHED state, it is possible to deliver
*                               segment text to user RECEIVE buffers".
*
*                           See also Note #2d2B2b.
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) And the "CLOSING STATE ... remain[s] in the CLOSING state".
*
*               (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                       "for any state if the user timeout expires, flush all queues, signal the user
*                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                   (b) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                       or control segment should reset its connection timer.
*
*               (4) Since the mechanisms of TCP connection close are independent of the application layer
*                   close; any external application layer close error(s) are ignored.
*
*               (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerClosing (NET_TCP_CONN  *p_conn,
                                              NET_BUF       *p_buf,
                                              NET_BUF_HDR   *p_buf_hdr,
                                              NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    CPU_BOOLEAN         data_avail;
    NET_TMR_TICK        timeout_tick;
    CPU_FNCT_PTR        timeout_fnct;
    NET_TCP_FREE_CODE   free_code;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2A3).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s) [see Note #5].           */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_RX_Q_FULL:
        case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_TX_PKT:
        case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_RE_TX_SEG_TH:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* If local conn close ack'd (see Note #2d2B2a);     .. */
    if ((p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED        ) ||
        (p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED_SUSPEND)) {
                                                                /* Closing data avail for half-closed conns ONLY.       */
        data_avail = ((p_conn->ConnCloseCode !=  NET_CONN_CLOSE_HALF      ) ||
                     ((p_conn->RxQ_State     ==  NET_TCP_RX_Q_STATE_CLOSED) &&
                      (p_conn->RxQ_App_Head  == DEF_NULL))) ? DEF_NO : DEF_YES;

                                                                /* .. signal app conn close (see Note #2d2B2a2B),    .. */
        NetTCP_RxPktConnHandlerSignalClose(p_conn, data_avail, &err);
        switch (err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_FAIL:                         /* Ignore any app conn close err(s) [see Note #4].      */
            case NET_TCP_ERR_INVALID_CONN_ID:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_CONN:
            case NET_CONN_ERR_NOT_USED:
            default:
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
                *p_err = err;
                 return;
        }

        if (data_avail != DEF_YES) {                            /* .. & if NO app data avail,                        .. */
                                                                /* .. chng to time-wait state (see Note  #2d2B2a1B1),   */
            p_conn->ConnState                 =  NET_TCP_CONN_STATE_TIME_WAIT;
            p_conn->ConnCloseTimeoutFaultFlag =  DEF_NO;        /* .. clr close timeout fault (see Note  #2d2B2a1A2a1), */
            timeout_fnct                     = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;

        } else {                                                /* .. else chng to closing-data-avail state          .. */
                                                                /* ..                         (see Note  #2d2B2a1B2a),  */
            p_conn->ConnState =  NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
            timeout_fnct     = (CPU_FNCT_PTR)&NetTCP_ConnClosingTimeoutDataAvail;
        }
                                                                /* .. & start time-wait tmr   (see Notes #2d2B2a1A2a &  */
        timeout_tick =  p_conn->TimeoutMaxSeg_tick_scaled;      /* ..                                    #2d2B2a1B2b1). */


    } else {
        timeout_tick =  p_conn->TimeoutConn_tick;               /* Else start conn close tmr (see Note #3b).            */
        timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
    }



                                                                /* UPDATE TMR's                                         */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_TIME_WAIT:                      /* If in time-wait            (see Note #2d2B2a1A)  ... */
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:             /* ... or closing state(s)    [see Note #2d2B2a1B], ... */
             free_code = NET_TCP_CONN_FREE_TMR_ALL;             /* ... free all TCP conn tmrs (see Note #2d2B2a1A2b).   */
             DEF_BIT_CLR(free_code, NET_TCP_CONN_FREE_TMR_TIMEOUT);
             NetTCP_ConnFreeTmr(p_conn, free_code);
             break;


        default:                                                /* 'default' case intentionally empty.                  */
             break;
    }


    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR) timeout_fnct,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR ) timeout_fnct,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }



                                                                /* --------------- TX TCP CONN ACK/DATA --------------- */
    ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED) ||
                (p_buf_hdr->TCP_SegClose        == DEF_YES))    /* See Note #2f3.                                       */
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;

    if (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING) {      /* If conn still closing, ...                           */
                                                                /* ... tx ack & any tx data (see Note #1c).             */
        NetTCP_TxConnTxQ(p_conn,
                         p_buf_hdr,
                         ack_code,
                         DEF_NO,
                         NET_TCP_CONN_CLOSE_ALL,
                         DEF_NO,
                         p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
            case NET_ERR_TX:                                    /* Ignore transitory tx err(s).                         */
            case NET_ERR_IF_LINK_DOWN:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_CLOSE:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_CONN_FAIL:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            case NET_TCP_ERR_TX_PKT:
            case NET_ERR_IF_LOOPBACK_DIS:
            case NET_CONN_ERR_INVALID_FAMILY:
            case NET_CONN_ERR_INVALID_ADDR:
            case NET_CONN_ERR_INVALID_ADDR_LEN:
            default:
                 return;
        }

    } else {                                                    /* Else tx TCP conn ack (see Note #2f3).                */
        NetTCP_TxConnAck(p_conn, p_buf_hdr, ack_code, NET_TCP_CONN_CLOSE_ALL, p_err);
        switch (*p_err) {
            case NET_TCP_ERR_NONE:
            case NET_TCP_ERR_CONN_ACK_NONE:
            case NET_TCP_ERR_CONN_ACK_INVALID:
            case NET_TCP_ERR_CONN_ACK_DLYD:
            case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
                 break;


            case NET_TCP_ERR_CONN_NOT_USED:
            case NET_TCP_ERR_CONN_FAULT:
            case NET_TCP_ERR_INVALID_CONN_STATE:
            case NET_TCP_ERR_INVALID_CONN_OP:
            case NET_TCP_ERR_INVALID_LEN_SEG:
            case NET_TCP_ERR_NONE_AVAIL:
            default:
                 return;
        }
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerTimeWait()
*
* Description : (1) Handle TCP connection in TIME-WAIT state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d    & #2e
*                       (2) Update TCP connection timer                             See Notes #2d2C2
*
*                   (c) Transmit TCP connection acknowledgement                     See Notes #2d2C1 & #2f3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnIsValidSeq() : --
*                                                                   -- RETURNED BY NetTCP_RxPktConnIsValidAck() : --
*                                                                   - RETURNED BY NetTCP_RxPktConnIsValidReset() : -
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnHandlerSeg() : --
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive queue signal fault.
*
*                                                                   ------- RETURNED BY NetTCP_TxConnAck() : -------
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the TIME-WAIT state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                               states that in the "CLOSING, LAST-ACK, TIME-WAIT" states that "if the RST bit
*                               is set then, enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on" :
*
*                           (A) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
*
*                           (B) "If the ACK acks something not yet sent ... then send an ACK [and] drop the segment."
*
*                           (C) For the "TIME-WAIT STATE ... the only thing that can arrive in this state is a
*                               retransmission of the remote FIN" :
*
*                               (1) "Acknowledge it" ...
*                               (2) "Restart the 2 MSL timeout."
*
*                   (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                           states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that "this should not occur, since a FIN has been received from the remote
*                           side.  Ignore the segment text."
*
*                       (2) (A) However, it is possible that some but NOT all data has been received from
*                               the remote host.  In other words, the remote host's  connection close request
*                               may have received but ALL receive data preceding the connection close request
*                               may NOT have been received.
*
*                               Therefore, receive data validated by sequence number as within the
*                               receive window MUST be received & processed as in connected states.
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
*                               Text' states that "once in the ESTABLISHED state, it is possible to deliver
*                               segment text to user RECEIVE buffers".
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) For the "TIME-WAIT STATE" :
*
*                           (A) "Remain in the TIME-WAIT state" ...
*                           (B) "Restart the 2 MSL time-wait timeout."
*
*               (3) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : TIME-WAIT TIMEOUT' states
*                   that "if the time-wait timeout expires on a connection ... enter the CLOSED state".
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerTimeWait (NET_TCP_CONN  *p_conn,
                                               NET_BUF       *p_buf,
                                               NET_BUF_HDR   *p_buf_hdr,
                                               NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    NET_TMR_TICK        timeout_tick;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
   (void)&p_buf_hdr->TCP_SegClose;                              /* Ignore any rx'd fin (see Note #2f5A).                */

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2B).                */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_RX_Q_FULL:
        case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }

                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* -------------------- UPDATE TMR -------------------- */
    timeout_tick = p_conn->TimeoutMaxSeg_tick_scaled;           /* Reset time-wait tmr (see Note #2d2C2).               */
    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }


                                                                /* ----------------- TX TCP CONN ACK ------------------ */
                                                                /* Tx TCP conn ack (see Notes #1c).                     */
    NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_IMMED, NET_TCP_CONN_CLOSE_ALL, p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_TCP_ERR_CONN_ACK_NONE:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_ACK_DLYD:
        case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_NONE_AVAIL:
        default:
             return;
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                 NetTCP_RxPktConnHandlerCloseWait()
*
* Description : (1) Handle TCP connection in CLOSE-WAIT state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d   & #2e
*                       (2) Update TCP connection timer                             See Note  #3
*
*                   (c) Transmit TCP connection acknowledgement & data              See Notes #2d2B & #2f3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive  queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive  queue signal fault.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the CLOSE-WAIT state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
*                               that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
*                               RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
*                               responses.  All segment queues should be flushed.  Users should also receive an
*                               unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on" :
*
*                           (A) And in the "ESTABLISHED STATE" :
*
*                               (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
*
*                                   (a) "Set SND.UNA <- SEG.ACK."
*
*                                   (b) "Any segments on the retransmission queue which are thereby entirely
*                                        acknowledged are removed."
*
*                                   (c) "The send window should be updated" :
*
*                                       (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
*
*                                               (2) (a) "(SND.WL1  = SEG.SEQ and" ...
*                                                   (b)  "SND.WL2 <= SEG.ACK)),"  ...
*
*                                           (B) (1) "Set SND.WND <- SEG.WND," ...
*                                               (2) "Set SND.WL1 <- SEG.SEQ," ...
*                                               (3) "Set SND.WL2 <- SEG.ACK."
*
*                                       (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
*                                            sequence number of the last segment used to update SND.WND, and that
*                                            SND.WL2 records the acknowledgment number of the last segment used to
*                                            update SND.WND.  The check here prevents using old segments to update
*                                            the window."
*
*                               (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
*
*                                   (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
*                                       for the segment's acknowledgement to include SND.UNA : "The window should
*                                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
*
*                                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
*
*                               (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
*                                    [and] drop the segment."
*
*                           (B) For the "CLOSE-WAIT STATE ... do the same processing as for the ESTABLISHED state".
*
*                   (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                           states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that "this should not occur, since a FIN has been received from the remote
*                           side.  Ignore the segment text."
*
*                       (2) (A) However, it is possible that some but NOT all data has been received from the
*                               remote host.  In other words, the remote host's close request may have been
*                               received but ALL receive data preceding the close request may NOT have been
*                               received.
*
*                               Therefore, receive data validated by sequence number as within the receive
*                               window MUST be received & processed as in connected states.
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
*                               Text' states that "once in the ESTABLISHED state, it is possible to deliver
*                               segment text to user RECEIVE buffers".
*
*                           See also Note #2d2B.
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) And the "CLOSE-WAIT STATE ... remain[s] in the CLOSE-WAIT state".
*
*               (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                       "for any state if the user timeout expires, flush all queues, signal the user
*                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                   (b) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
*
*                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
*                       or control segment should reset its connection timer.
*
*               (4) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerCloseWait (NET_TCP_CONN  *p_conn,
                                                NET_BUF       *p_buf,
                                                NET_BUF_HDR   *p_buf_hdr,
                                                NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    NET_TMR_TICK        timeout_tick;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2A3).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s) [see Note #4].           */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_RX_Q_FULL:
        case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_TX_PKT:
        case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_RE_TX_SEG_TH:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }


                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* -------------------- UPDATE TMR -------------------- */
    timeout_tick = p_conn->TimeoutConn_tick;                    /* Reset conn idle/close tmr (see Note #3b).            */
    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if (err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }



                                                                /* --------------- TX TCP CONN ACK/DATA --------------- */
    ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED) ||
                (p_buf_hdr->TCP_SegClose        == DEF_YES))    /* See Note #2f3.                                       */
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;
                                                                /* Tx ack & any tx data (see Note #1c).                 */
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     ack_code,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_TCP_ERR_CONN_ACK_NONE:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_ACK_DLYD:
        case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s).                         */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_CLOSE:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_NONE_AVAIL:
        case NET_TCP_ERR_TX_PKT:
        case NET_ERR_IF_LOOPBACK_DIS:
        case NET_CONN_ERR_INVALID_FAMILY:
        case NET_CONN_ERR_INVALID_ADDR:
        case NET_CONN_ERR_INVALID_ADDR_LEN:
        default:
             return;
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerLastAck()
*
* Description : (1) Handle TCP connection in LAST-ACK state :
*
*                   (a) Validate received TCP packet for current TCP connection state :
*
*                       (1) Sequence Number (SEQ)                                   See Note  #2a
*                       (2) Reset           (RST)                                   See Note  #2b
*                       (3) Synchronization (SYN)                                   See Note  #2c
*                       (4) Acknowledgement (ACK)                                   See Note  #2d
*                       (5) Finish/Close    (FIN)                                   See Note  #2f
*
*                   (b) Update TCP connection :
*                       (1) Handle received TCP segment                             See Notes #2d       & #2e
*                       (2) Update TCP connection state :                           See Notes #2d2A1a   & #2d2A1b2A
*                           (A) Configure TCP connection timeout value
*                       (3) Update TCP connection timer                             See Notes #2d2A1b2B & #3
*
*                   (c) Transmit TCP connection acknowledgement & data              See Notes #2d2B     & #2f3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_SEQ_SYNC_INVALID   Received segment's synchronization        is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence        number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_ACK_NONE           Received segment's acknowledgement        is
*                                                                       NOT available.
*                               NET_TCP_ERR_CONN_ACK_INVALID        Received segment's acknowledgement number is
*                                                                       NOT valid for current TCP connection.
*                               NET_TCP_ERR_CONN_RESET_VALID        Received segment's reset flag is     valid
*                                                                       for current TCP connection; i.e. reset
*                                                                       the TCP connection.
*                               NET_TCP_ERR_CONN_RESET_INVALID      Received segment's reset flag is NOT valid
*                                                                       for current TCP connection.
*
*                               NET_TCP_ERR_CONN_CLOSED             TCP connection successfully closed.
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidSeq() : -----
*                                                                   ----- RETURNED BY NetTCP_RxPktConnIsValidAck() : -----
*                                                                   ---- RETURNED BY NetTCP_RxPktConnIsValidReset() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   ----- RETURNED BY NetTCP_RxPktConnHandlerSeg() : -----
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO
*                                                                       data to   queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid
*                                                                       data queued for processing.
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive  queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive  queue signal fault.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandler().
*
* Note(s)     : (2) TCP connections in the LAST-ACK state are handled as follows :
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
*                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) "If a segment's contents straddle the boundary between old and new, only the
*                            new parts should be processed."
*
*                       (4) (A) "If an incoming segment is not acceptable," ...
*
*                           (B) "an acknowledgment should be sent in reply" ...
*
*                           (C) "(unless the RST bit is set, if so drop the segment)".
*
*                               See also Notes #2b2Aa & #2b2B.
*
*                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
*
*                   (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
*                               that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
*                               RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
*                               responses.  All segment queues should be flushed.  Users should also receive an
*                               unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in any other state [other than LISTEN
*                               or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
*                               CLOSED state".
*
*                       (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                               ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected
*                                    window, silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset
*                                    the connection"; it is assumed that this should read "if the RST bit is
*                                    set and the sequence number is exactly the next expected sequence number,
*                                    reset the connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the  TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                               See also Note #2c2.
*
*                   (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                           states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                           FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that :
*
*                           (A) "If the SYN is in the window it is an error, send a reset, any outstanding
*                                RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
*                                should be flushed, the user should also receive an unsolicited general
*                               'connection reset' signal[, and] enter the CLOSED state."
*
*                           (B) But "if the SYN is not in the window this step would not have been reached
*                               and an ack would have been sent".
*
*                       (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
*                           of a segment with the SYN bit set in the synchronized state ... [by] handling
*                           ... the SYN bit" as follows :
*
*                           (a) "If the SYN bit is set and the sequence number is outside the
*                                expected window, send an ACK back to the peer."
*
*                           (b) "If the SYN bit is set and the sequence number is an exact
*                                match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                then send an ACK segment ... but ... subtract one from
*                                value being acknowledged."
*
*                           (c) "If the SYN bit is set and the sequence number is acceptable,
*                                i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                ACK segment."
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                       states that :
*
*                       (1) "If the ACK bit is off drop the segment."
*
*                       (2) "If the ACK bit is on [and in the] LAST-ACK STATE" :
*
*                           (A) "The only thing that can arrive in this state is an acknowledgement of our FIN."
*
*                               (1) "If our FIN is now acknowledged" ...
*
*                                   (a) "Enter the CLOSED state."
*
*                                   (b) However, it is possible that some closing received data from the remote
*                                       host is available but has NOT yet been received by the application layer.
*
*                                       (1) Therefore, if the application receive queue is closed, then close the
*                                           TCP connection &/or enter the CLOSED state.
*
*                                       (2) (A) But if the application receive queue is NOT closed, then enter the
*                                               connection-closing-data-available state to allow the application
*                                               layer to receive the remaining receive data.
*
*                                           (B) To provide the application layer sufficient time to receive the
*                                               closing received data, the user connection timeout is used as a
*                                               connection closing timeout.
*
*                                       See also Note #2e2.
*
*                               (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the
*                                       user's CLOSE can be acknowledged".
*
*                                   (b) However, TCP connection should signal the application layer that "the user's
*                                       close [is] acknowledged" whenever its re-transmit queue becomes &/or is
*                                       empty :
*
*                                       (1) Transition from LAST-ACK to CLOSED
*
*                                   See also 'NetTCP_RxPktConnHandlerSignalClose()  Note #1'.
*
*                           (B) However, it is possible that some but NOT all transmitted data has been received
*                               by the remote host.  In other words, the remote host may have received some but
*                               NOT ALL receive data preceding this host's close request.
*
*                               Therefore, acknowledgements validated as within the transmit window MUST be
*                               received & processed as in connected states.
*
*                               See also 'NetTCP_RxPktConnIsValidAck()  Note #1d'.
*
*                   (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
*                           states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                           STATE" that "this should not occur, since a FIN has been received from the remote
*                           side.  Ignore the segment text."
*
*                       (2) (A) However, it is possible that some but NOT all data has been received from
*                               the remote host.  In other words, the remote host's close request may have
*                               received but ALL receive data preceding the close request may NOT have been
*                               received.
*
*                               Therefore, receive data validated by sequence number as within the
*                               receive window MUST be received & processed as in connected states.
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
*                               Text' states that "once in the ESTABLISHED state, it is possible to deliver
*                               segment text to user RECEIVE buffers".
*
*                           See also Note #2d2A1b.
*
*                   (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                       that "if the FIN bit is set" :
*
*                       (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
*                            same message," ...
*
*                       (2) "Advance RCV.NXT over the FIN," ...
*
*                       (3) "Send an acknowledgment for the FIN" ...
*
*                       (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
*
*                       (5) And the "LAST-ACK STATE ... remain[s] in the LAST-ACK state".
*
*               (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                       "for any state if the user timeout expires, flush all queues, signal the user
*                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*
*                   (b) (1) However, a TCP connection enters the LAST-ACK state ONLY after the remote host
*                           has initiated an active close & enters the TIME-WAIT state, waiting for its
*                           time-wait timer to expire before closing its TCP connection.
*
*                       (2) Therefore, a TCP connection in the LAST-ACK state should NOT wait for its
*                           last acknowledgement from the remote host in the TIME-WAIT state longer than
*                           the remote host's time-wait timeout of two TCP maximum segment lifetimes.
*
*                       (3) Therefore, it is assumed that ANY TCP connection in the LAST-ACK state
*                           that receives a valid TCP data or control segment should reset its time-wait
*                           timer for two TCP maximum segment lifetimes.
*
*               (4) Since the mechanisms of TCP connection close are independent of the application layer
*                   close; any external application layer close error(s) are ignored.
*
*               (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerLastAck (NET_TCP_CONN  *p_conn,
                                              NET_BUF       *p_buf,
                                              NET_BUF_HDR   *p_buf_hdr,
                                              NET_ERR       *p_err)
{
    NET_TCP_SEQ_CODE    seq_code;
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_RESET_CODE  reset_code;
    CPU_BOOLEAN         data_avail;
    CPU_BOOLEAN         close_conn;
    NET_TMR_TICK        timeout_tick;
    NET_ERR             err;
    NET_ERR             err_rtn;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
                                                                /* Chk for rx'd fin/close.                              */
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   /* If fin/close avail, update seg lens.                 */
        p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
        p_buf_hdr->TCP_SegLen     += NET_TCP_SEG_LEN_CLOSE;
    }

                                                                /* Chk rx'd seq nbr.                                    */
    seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (seq_code) {
        case NET_TCP_CONN_RX_SEQ_VALID:
             break;


        case NET_TCP_CONN_RX_SEQ_SYNC:                          /* If invalid sync rx'd, ...                            */
        case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                                                /* ... tx TCP conn ack  (see Notes #2c2 & #2b2B).       */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_SEQ_SYNC_INVALID;
             return;


        case NET_TCP_CONN_RX_SEQ_NONE:
        case NET_TCP_CONN_RX_SEQ_INVALID:                       /* If invalid seq  rx'd (see Note #2a4A), ...           */
        default:
             if (p_buf_hdr->TCP_SegReset != DEF_YES) {          /* ... & reset NOT rx'd (see Note #2a4C), ...           */
                                                                /* ... tx TCP conn ack  (see Note #2a4B).               */
                 NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
             }
            *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
             return;
    }

                                                                /* Chk for rx'd reset.                                  */
    reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (reset_code) {
        case NET_TCP_CONN_RX_RESET_NONE:
             break;


        case NET_TCP_CONN_RX_RESET_VALID:                       /* If   valid reset rx'd, ...                           */
                                                                /* ...  close TCP conn (see Note #2b1A).                */
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_TCP_ERR_CONN_RESET_VALID;
             return;


        case NET_TCP_CONN_RX_RESET_INVALID:                     /* If invalid reset rx'd, ...                           */
        default:
                                                                /* ... tx TCP conn ack (see Note #2b2Ac).               */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
             return;
    }

                                                                /* Chk for rx'd ack.                                    */
    ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
    switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
        case NET_TCP_CONN_RX_ACK_DUP:
        case NET_TCP_CONN_RX_ACK_PREV:
             break;


        case NET_TCP_CONN_RX_ACK_NONE:                          /* If NO      ack rx'd, ...                             */
            *p_err = NET_TCP_ERR_CONN_ACK_NONE;                 /* ... ignore TCP pkt  (see Note #2d1).                 */
             return;


        case NET_TCP_CONN_RX_ACK_INVALID:                       /* If invalid ack rx'd, ...                             */
        default:
                                                                /* ... tx TCP conn ack (see Note #2d2B).                */
             NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
            *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
             return;
    }



                                                                /* ----------------- HANDLE RX'D SEG ------------------ */
    NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, &err_rtn);
    switch (err_rtn) {
        case NET_TCP_ERR_CONN_DATA_NONE:
        case NET_TCP_ERR_CONN_DATA_VALID:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s) [see Note #5].           */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_DATA_DUP:
            *p_err = err_rtn;
             return;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_DATA_INVALID:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_RX_Q_FULL:
        case NET_TCP_ERR_RX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_TX_Q_SIGNAL_FAULT:
        case NET_TCP_ERR_RE_TX_SEG_TH:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
            *p_err = err_rtn;
             return;
    }



                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    close_conn = DEF_NO;
    if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED) {       /* If    remote conn closed      (see Note #2e2A)  ...  */
                                                                /* ... & local  conn close ack'd (see Note #2d2A1) ...  */
        if ((p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED        ) ||
            (p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED_SUSPEND)) {
            close_conn = DEF_YES;
        }
    }

    if (close_conn == DEF_YES) {
                                                                /* Closing data avail for half-closed conns ONLY.       */
        data_avail = ((p_conn->ConnCloseCode !=  NET_CONN_CLOSE_HALF      ) ||
                     ((p_conn->RxQ_State     ==  NET_TCP_RX_Q_STATE_CLOSED) &&
                      (p_conn->RxQ_App_Head  == DEF_NULL))) ? DEF_NO : DEF_YES;
                                                                /* ... signal app conn close (see Note #2d2A2b1);  ...  */
                                                                /* Ignore any app conn close err(s) [see Note #4].      */
        NetTCP_RxPktConnHandlerSignalClose(p_conn, data_avail, &err);


        if (data_avail != DEF_YES) {                            /* ... & if NO app data avail,                     ...  */
                                                                /* ... close TCP conn (see Note #2d2A1b1);         ...  */
            NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
           *p_err = NET_TCP_ERR_CONN_CLOSED;
            return;
        }
                                                                /* ... else chng to closing-data-avail state       ...  */
                                                                /* ... (see Note #2d2A1b2A),                       ...  */
        p_conn->ConnState = NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
        timeout_tick     = p_conn->TimeoutUser_tick;            /* ... & set user tmr (see Note #2d2A1b2B).             */

    } else {                                                    /* Else start time-wait tmr (see Note #3b3).            */
        timeout_tick     = p_conn->TimeoutMaxSeg_tick_scaled;
    }


                                                                /* -------------------- UPDATE TMR -------------------- */
    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }



                                                                /* --------------- TX TCP CONN ACK/DATA --------------- */
    ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED) ||
                (p_buf_hdr->TCP_SegClose        == DEF_YES))    /* See Note #2f3.                                       */
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;
                                                                /* Tx ack & any tx data (see Note #1c).                 */
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     ack_code,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_TCP_ERR_CONN_ACK_NONE:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_ACK_DLYD:
        case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s).                         */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_CLOSE:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_NONE_AVAIL:
        case NET_TCP_ERR_TX_PKT:
        case NET_ERR_IF_LOOPBACK_DIS:
        case NET_CONN_ERR_INVALID_FAMILY:
        case NET_CONN_ERR_INVALID_ADDR:
        case NET_CONN_ERR_INVALID_ADDR_LEN:
        default:
             return;
    }



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                    NetTCP_RxPktConnHandlerSeg()
*
* Description : (1) Handle TCP connection's received segments :
*
*                   (a) Update TCP connection    transmit remote window                     See Note  #6
*                   (b) Update TCP connection controls on transition to connected state(s)
*                   (c) Handle TCP connection re-transmit queue                             See Notes #2b & #5
*                   (d) Update TCP connection    transmit congestion controls               See Note  #7
*                   (e) Handle TCP connection    receive  queue(s)                          See Note  #3
*                   (f) Handle TCP connection    receive  data                              See Notes #2a & #3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               ack_code    Indicates the received segment's acknowledgement condition :
*               --------
*                               NET_TCP_CONN_RX_ACK_NONE            NO received acknowledgement number.
*
*                               NET_TCP_CONN_RX_ACK_INVALID            Received acknowledgement number
*                                                                      is invalid for the TCP connection.
*
*                               NET_TCP_CONN_RX_ACK_VALID              Received acknowledgement number
*                                                                      is   valid for the TCP connection.
*
*                               NET_TCP_CONN_RX_ACK_DUP                Received acknowledgement number
*                                                                      is a          duplicate for the
*                                                                      TCP connection.
*
*                               NET_TCP_CONN_RX_ACK_PREV               Received acknowledgement number
*                                                                      is a previous duplicate for the
*                                                                      TCP connection.
*
*                           Argument validated in NetTCP_RxPktConnHandler() functions.
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_ACK_INVALID        Valid received segment acknowledgement NOT available.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnHandlerTxWinRemote() : -
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   ---- RETURNED BY NetTCP_RxPktConnHandlerReTxQ() : -----
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*
*                                                                   - RETURNED BY NetTCP_TxConnWinSizeHandlerCongCtrl() : -
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*
*                                                                   --- RETURNED BY NetTCP_RxPktConnHandlerRxQ_Sync() : ---
*                                                                   --- RETURNED BY NetTCP_RxPktConnHandlerRxQ_Conn() : ---
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but NO data
*                                                                       to  queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled & valid data
*                                                                       queued for application.
*
*                                                                   --- RETURNED BY NetTCP_RxPktConnHandlerRxQ_Conn() : ---
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment data;
*                                                                       NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment data;
*                                                                       NOT queued to receive queue(s).
*
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence number is NOT
*                                                                       valid for current TCP connection.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnHandlerRxQ_AppData() : -
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive queue signal fault.
*                               NET_TCP_ERR_RX_Q_SIGNAL_CLR         TCP connection receive queue clear  failed.
*
* Return(s)   : none.
*
* Caller(s)   : Various NetTCP_RxPktConnHandler() functions.
*
* Note(s)     : (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that "segments are processed in sequence ... processing is done in SEG.SEQ
*                       order" (see also Note #3).
*
*                   (b) The following sections generalize that for the SYN-SENT & ESTABLISHED states that
*                       "any segments on the retransmission queue which are ... acknowledged should be
*                       removed" :
*
*                       (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                               Check SYN Bit'
*                       (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                               ESTABLISHED STATE'
*
*               (3) TCP segments with receive data are sequenced into the appropriate TCP connection
*                   receive queue(s) to be made available & ready to be read by the application layer.
*
*                   See also 'NetTCP_RxPktConnHandlerRxQ_Conn()     Note #3'
*                          & 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #2'.
*
*               (4) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6 'Connection
*                   Establishment and Keepalive Timers', Page 828 states that "when a segment is received
*                   on a connection", TCP "resets the keepalive timer for that connection".
*
*                   See also 'NetTCP_TxConnKeepAliveReset()  Note #1'.
*
*               (5) A TCP connection's re-transmit queue SHOULD be updated ONLY by valid received
*                   acknowledgement segments.
*
*                   See also 'NetTCP_RxPktConnHandlerReTxQ()  Note #3'.
*
*               (6) RFC #1122, Section 4.2.2.20 generalizes that "when ... SND.UNA < SEG.ACK <= SND.NXT,
*                   the send window should be updated".
*
*                   See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1'.
*
*               (7) RFC #2581, Section 3.1 states that "the slow start and congestion avoidance algorithms
*                   ... [update] cwnd [TCP transmit congestion control window] for each ACK received that
*                   acknowledges new data".
*
*                   (a) A TCP connection's transmit window congestion controls SHOULD be updated :
*
*                       (1) After    any possible updating of the TCP connection re-transmit queue.
*                       (2) Prior to any possible queuing  of data segments into the TCP connection
*                               receive queue(s).
*
*               (8) Some  transitory errors were ignored &/or not returned from previous handler function(s).
*                   These transitory errors are included for completeness & as an extra precaution in case
*                   these transitory errors are returned by handler function(s).
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerSeg (NET_TCP_CONN      *p_conn,
                                          NET_TCP_ACK_CODE   ack_code,
                                          NET_BUF           *p_buf,
                                          NET_BUF_HDR       *p_buf_hdr,
                                          NET_ERR           *p_err)
{
    NET_ERR  err_rtn;



    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;



        case NET_TCP_CONN_STATE_LISTEN:
             NetTCP_RxPktConnHandlerRxQ_Sync(p_conn, p_buf, p_buf_hdr, &err_rtn);
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
             if (ack_code != NET_TCP_CONN_RX_ACK_VALID) {
                *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
                 return;
             }
#endif

             NetTCP_RxPktConnHandlerTxWinRemote(p_conn, ack_code, p_buf_hdr, p_err);
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }

             NetTCP_RxPktConnHandlerCfgConn(p_conn);

             NetTCP_RxPktConnHandlerReTxQ(p_conn, ack_code, p_buf_hdr, p_err);
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }

             NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0u, NET_TCP_CONN_TX_WIN_SEG_RXD, p_err);
             switch (*p_err) {
                 case NET_TCP_ERR_NONE:
                 case NET_ERR_TX:                               /* Ignore transitory tx err(s) [see Note #8].           */
                 case NET_ERR_IF_LINK_DOWN:
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 case NET_ERR_IF_LOOPBACK_DIS:
                 default:
                      return;
             }

             NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr, &err_rtn);
             break;



        case NET_TCP_CONN_STATE_SYNC_TXD:
             if (ack_code == NET_TCP_CONN_RX_ACK_VALID) {
                 NetTCP_RxPktConnHandlerTxWinRemote(p_conn, ack_code, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return;
                 }

                 NetTCP_RxPktConnHandlerCfgConn(p_conn);

                 NetTCP_RxPktConnHandlerReTxQ(p_conn, ack_code, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return;
                 }

                 NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0u, NET_TCP_CONN_TX_WIN_SEG_RXD, p_err);
                 switch (*p_err) {
                     case NET_TCP_ERR_NONE:
                     case NET_ERR_TX:                           /* Ignore transitory tx err(s) [see Note #8].           */
                     case NET_ERR_IF_LINK_DOWN:
                          break;


                     case NET_TCP_ERR_CONN_NOT_USED:
                     case NET_TCP_ERR_CONN_FAIL:
                     case NET_TCP_ERR_CONN_FAULT:
                     case NET_TCP_ERR_INVALID_CONN_STATE:
                     case NET_TCP_ERR_INVALID_CONN_OP:
                     case NET_TCP_ERR_TX_PKT:
                     case NET_TCP_ERR_RE_TX_SEG_TH:
                     default:
                          return;
                 }

                 NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr, &err_rtn);

             } else {
                 NetTCP_RxPktConnHandlerRxQ_Sync(p_conn, p_buf, p_buf_hdr, &err_rtn);
             }
             break;


        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
             switch (ack_code) {
                 case NET_TCP_CONN_RX_ACK_VALID:
                 case NET_TCP_CONN_RX_ACK_DUP:
                 case NET_TCP_CONN_RX_ACK_PREV:
                      break;


                 case NET_TCP_CONN_RX_ACK_NONE:
                 case NET_TCP_CONN_RX_ACK_INVALID:
                 default:
                     *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
                      return;
             }
#endif

             NetTCP_TxConnKeepAliveReset(p_conn);


             if ((p_buf_hdr->TCP_SegLenData  > 0u) &&           /* This check is added to avoid queuing data from       */
                 (p_conn->RxWinSizeActual   == 0u)) {           /* remote host when the receive windows is 0.           */
                                                                /* i.e. Remote stack doesn't respect RFCs.              */
                 *p_err = NET_TCP_ERR_RX_Q_FULL;
                  NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxPktQ_FullCtr);
                  return;
             }


             NetTCP_RxPktConnHandlerTxWinRemote(p_conn, ack_code, p_buf_hdr, p_err);
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }

             if (p_conn->MaxSegSizeConn <= 0) {                 /* Try set up again Conn if MSS was set to 0 in connect.*/
                 NetTCP_RxPktConnHandlerCfgConn(p_conn);
                 NetTCP_TxQ_Signal(p_conn->ID, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                       (NET_BUF_HDR      *)0,
                                       (CPU_BOOLEAN       )DEF_YES,
                                       (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
                      return;
                 }
             }

             switch (ack_code) {
                 case NET_TCP_CONN_RX_ACK_VALID:                /* If valid ack, update re-tx Q (see Note #5).          */
                 case NET_TCP_CONN_RX_ACK_DUP:
                      NetTCP_RxPktConnHandlerReTxQ(p_conn, ack_code, p_buf_hdr, p_err);
                      if (*p_err != NET_TCP_ERR_NONE) {
                           return;
                      }
                      break;


                 default:                                       /* 'default' case intentionally empty.                  */
                      break;
             }

             NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0u, NET_TCP_CONN_TX_WIN_SEG_RXD, p_err);
             switch (*p_err) {
                 case NET_TCP_ERR_NONE:
                 case NET_ERR_TX:                               /* Ignore transitory tx err(s) [see Note #8].           */
                 case NET_ERR_IF_LINK_DOWN:
                      break;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_FAIL:
                 case NET_TCP_ERR_CONN_FAULT:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_CONN_OP:
                 case NET_TCP_ERR_TX_PKT:
                 case NET_TCP_ERR_RE_TX_SEG_TH:
                 default:
                      return;
             }

             NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr, &err_rtn);
             switch (err_rtn) {
                 case NET_TCP_ERR_CONN_DATA_NONE:
                 case NET_TCP_ERR_CONN_DATA_VALID:
                      break;


                 case NET_TCP_ERR_CONN_DATA_DUP:
                     *p_err = err_rtn;
                      return;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 default:
                     *p_err = err_rtn;
                      return;
             }

             NetTCP_RxPktConnHandlerRxQ_AppData(p_conn, p_err);
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;


        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
             switch (ack_code) {
                 case NET_TCP_CONN_RX_ACK_VALID:
                 case NET_TCP_CONN_RX_ACK_DUP:
                      break;


                 case NET_TCP_CONN_RX_ACK_NONE:
                 case NET_TCP_CONN_RX_ACK_INVALID:
                 default:
                     *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
                      return;
             }
#endif

             NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr, &err_rtn);
             switch (err_rtn) {
                 case NET_TCP_ERR_CONN_DATA_NONE:
                 case NET_TCP_ERR_CONN_DATA_VALID:
                      break;


                 case NET_TCP_ERR_CONN_DATA_DUP:
                     *p_err = err_rtn;
                      return;


                 case NET_TCP_ERR_CONN_NOT_USED:
                 case NET_TCP_ERR_CONN_DATA_INVALID:
                 case NET_TCP_ERR_INVALID_CONN_STATE:
                 case NET_TCP_ERR_INVALID_LEN_SEG:
                 default:
                     *p_err = err_rtn;
                      return;
             }

             NetTCP_RxPktConnHandlerRxQ_AppData(p_conn, p_err);
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;



        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;



        case NET_TCP_CONN_STATE_NONE:
        case NET_TCP_CONN_STATE_CLOSED:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerCfgConn()
*
* Description : (1) Configure TCP connection's controls on transition to connected state(s) :
*
*                   (a) Configure TCP connection maximum segment size control(s)
*                   (b) Configure TCP connection window size controls
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg().
*
* Note(s)     : (2) During TCP connection initialization, some TCP connection controls were previously
*                   configured in NetTCP_ConnGet() when the TCP connection was allocated from the TCP
*                   connection pool.  These TCP connection controls do NOT need to be reconfigured
*                   but are shown for completeness.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerCfgConn (NET_TCP_CONN  *p_conn)
{
    NET_TCP_CFG_CODE  cfg_code;

                                                                /* Cfg conn (see Note #1).                              */
    cfg_code = NET_TCP_CONN_CFG_NONE              |
               NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN |
               NET_TCP_CONN_CFG_WIN_SIZE_ALL;
    NetTCP_ConnCfg(p_conn, cfg_code);
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerRxQ_Sync()
*
* Description : (1) (a) Handle TCP connection's transport receive queue ... :
*
*                       (1) Update TCP connection initial receive sequence numbers          See Note #2b
*                       (2) Queue  received TCP segments into transport receive queue       See Note #3
*                       (3) Update TCP connection receive window
*
*                   (b) ... for the following connection-request/synchronization states :
*
*                       (1) LISTEN
*                       (2) SYN-SENT
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but
*                                                                       NO data to queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled &
*                                                                          data    queued to receive queue(s)
*                                                                       for later processing (see Note #2c).
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection receive queue
*                                                                       state.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg().
*
* Note(s)     : (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that "segments are processed in sequence ... processing is done in SEG.SEQ
*                       order."
*
*                   (b) The following sections generalize that for the LISTEN & SYN-SENT states that "if the
*                       SYN bit is on and ... acceptable then ... RCV.NXT is set to SEG.SEQ+1, IRS is set to
*                       SEG.SEQ" :
*
*                       (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State] :
*                               Check for SYN'
*                       (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                               Check SYN Bit'
*
*                   (c) (1) The following sections generalize that for the LISTEN & SYN-SENT states that "if
*                           there are other controls or text in the segment, queue them for later processing
*                           after the ESTABLISHED state has been reached" :
*
*                           (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State] :
*                                   Check for SYN'
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                                   Check SYN Bit'
*
*                       (2) If any control or text is queued for later processing, the next sequence octet to
*                           receive (RCV.NXT) MUST include the length of this received segment (SEG.LEN) :
*
*                           (A) RCV.NXT = SEG.SEQ + SEG.LEN + 1
*               (3) TCP segments with receive data are sequenced into the appropriate TCP connection
*                   receive queue(s) to be made available & ready to be read by the application layer.
*
*                   See also 'NetTCP_RxPktConnHandlerRxQ_Conn()     Note #3'
*                          & 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #2'.
*
*               (4) Some buffer controls were previously initialized in NetBuf_Get() when the buffer was
*                   allocated.  These buffer controls do NOT need to be re-initialized but are shown for
*                   completeness.
*
*               (5) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that "the window
*                   sent in each segment indicates the range of sequence numbers the sender of the window
*                   (the data receiver) is currently prepared to accept.  There is an assumption that this
*                   is related to the currently available data buffer space available for this connection
*                   ... One strategy would be to ... [update the] information when the window" changes.
*
*                   See also 'NetTCP_RxAppData()                 Note #6',
*                            'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #6',
*                          & 'NetTCP_RxConnWinSizeHandler()      Note #2a'.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerRxQ_Sync (NET_TCP_CONN  *p_conn,
                                               NET_BUF       *p_buf,
                                               NET_BUF_HDR   *p_buf_hdr,
                                               NET_ERR       *p_err)
{
    NET_TCP_SEG_SIZE  seg_len_data;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------- VALIDATE RX Q CONN STATE ------------- */
    switch (p_conn->RxQ_State) {
        case NET_TCP_RX_Q_STATE_CLOSED:
             break;


        case NET_TCP_RX_Q_STATE_NONE:
        case NET_TCP_RX_Q_STATE_SYNC:
        case NET_TCP_RX_Q_STATE_CONN:
        case NET_TCP_RX_Q_STATE_CLOSING:
        default:
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
#endif

                                                                /* Update TCP conn rx seq nbrs (see Notes #2b & #2c2).  */
    p_conn->RxSeqNbrSync =  p_buf_hdr->TCP_SeqNbr;
    p_conn->RxSeqNbrNext = (p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
    p_conn->RxQ_State    =  NET_TCP_RX_Q_STATE_SYNC;


    seg_len_data = p_buf_hdr->TCP_SegLenData;
    if (seg_len_data > 0) {                                     /* If rx'd seg len data > 0, ...                        */
                                                                /* ... Q seg to TCP conn rx Q  (see Notes #3 & #2c1).   */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        NetTCP_ConnFreeBufQ(&p_conn->RxQ_Transport_Head, &p_conn->RxQ_Transport_Tail);
#endif
        p_conn->RxQ_Transport_Head = p_buf;
        p_conn->RxQ_Transport_Tail = p_buf;
#if 0                                                           /* Init'd in NetBuf_Get() [see Note #4].                */
        p_buf_hdr->PrevPrimListPtr = DEF_NULL;
        p_buf_hdr->NextPrimListPtr = DEF_NULL;
#endif
                                                                /* Dec TCP conn's rx win size (see Note #5).            */
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
        NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, seg_len_data, NET_TCP_CONN_RX_WIN_DEC);
#else
        NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, 1, NET_TCP_CONN_RX_WIN_DEC);
#endif
       *p_err = NET_TCP_ERR_CONN_DATA_VALID;

    } else {
       *p_err = NET_TCP_ERR_CONN_DATA_NONE;
    }
}


/*
*********************************************************************************************************
*                                  NetTCP_RxPktConnHandlerRxQ_Conn()
*
* Description : (1) (a) Handle TCP connection's transport receive queue ... :
*
*                       (1) Update TCP connection receive sequence numbers          See Notes #2c  & #2e
*                       (2) Insert received TCP segments in sequence order          See Notes #3   & #4
*                       (3) Update TCP connection receive window
*
*                   (b) ... for the following connected states :
*
*                       (1) SYN-RECEIVED                                            See Notes #1bA & #2b2
*                       (2) SYN-SENT                                                See Notes #1bA & #2b1
*                       (3) ESTABLISHED                                             See Note  #1bB
*                       (4) FIN-WAIT-1                                              See Note  #1bB
*                       (5) FIN-WAIT-2                                              See Note  #1bB
*                       (6) CLOSING                                                 See Note  #1bC
*                       (7) TIME-WAIT                                               See Note  #1bC
*                       (8) CLOSE-WAIT                                              See Note  #1bC
*                       (9) LAST-ACK                                                See Note  #1bC
*
*
*                           (A) For synchronization-to-connected state transitions, segments are queued to
*                               the TCP connection's transport receive queue, but NOT to the TCP connection's
*                               application receive queue, until the application layer is signaled that the
*                               transport layer connection is complete.
*
*                               See also 'NetTCP_RxPktConnHandlerSyncRxd()  Note #1c1'
*                                      & 'NetTCP_RxPktConnHandlerSyncTxd()  Note #1c1'.
*
*                           (B) For connected states,       segments are queued to the TCP connection's
*                               transport &/or application receive queue(s) as appropriate (see Note #3).
*
*                           (C) For closing states; closing segments are queued to the TCP connection's
*                               transport &/or application receive queue(s) as for connected states.
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_buf        Pointer to network buffer that received TCP packet.
*               ----        Argument checked   in NetTCP_Rx().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_CONN_DATA_NONE          Received packet successfully handled; but
*                                                                       NO data to queue  to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_VALID         Received packet successfully handled &
*                                                                          data    queued to receive queue(s)
*                                                                       for later processing (see Note #3).
*                               NET_TCP_ERR_CONN_DATA_INVALID       Received packet contains invalid   segment
*                                                                       data; NOT queued to receive queue(s).
*                               NET_TCP_ERR_CONN_DATA_DUP           Received packet contains duplicate segment
*                                                                       data; NOT queued to receive queue(s)
*                                                                       (see Note #2a2).
*
*                               NET_TCP_ERR_CONN_SEQ_INVALID        Received segment's sequence number is NOT
*                                                                       valid for current TCP connection.
*
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection receive queue state.
*
*                                                                   - RETURNED BY NetTCP_RxPktConnIsValidSeq() : -
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg().
*
* Note(s)     : (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
*                       states that :
*
*                       (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
*
*                           (A) Assumes received segment's sequences previously validated.
*
*                       (2) "Initial tests on arrival are used to discard old duplicates."
*
*                       (3) (A) (1) "If a segment's contents straddle the boundary between old and new,
*                                    only the new parts should be processed."
*
*                               (2) "One could tailor actual segments to ... the idealized segment that
*                                    begins at RCV.NXT and does not exceed the window ... by trimming off
*                                    any portions that lie outside the window (including SYN and FIN),
*                                    and only processing further if the segment then begins at RCV.NXT.
*                                    Segments with higher beginning sequence numbers may be held for later
*                                    processing."
*
*                           (B) (1) Sequencing     received segments with duplicate data that overlaps
*                                   multiple previously-received segments' non-contiguous sequence numbers
*                                   is data intensive/expensive.
*
*                               (2) Therefore, any received segment  with duplicate data that overlaps
*                                   multiple previously-received segments' non-contiguous sequence numbers
*                                   is trimmed of duplicate data starting from the end of the received
*                                   segment's data.
*
*                                   In other words, only the first contiguous, non-duplicate data sequence
*                                   starting from the start of the received segment's data is sequenced
*                                   into the TCP connection's receive queue(s).
*
*                           (C) RFC #1122, Section 4.2.2.20 states that "a TCP SHOULD be capable of queueing
*                               out-of-order TCP segments".
*
*                   (b) The following sections generalize that in the "SYN-SENT [or] ... SYN-RECEIVED
*                       STATE[s], ... [that] if the ACK bit is on [and] our SYN has been ACKed ...
*                       then enter the ESTABLISHED state and continue processing" :
*
*                       (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                               Check SYN Bit'
*                       (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                               SYN-RECEIVED STATE'
*
*                   (c) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                       Check SYN Bit' states that "if the SYN bit is on and ... acceptable then ...
*                       RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ".
*
*                   (d) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                           Check SYN Bit' states that "if there are other controls or text in the segment,
*                           queue them for later processing after the ESTABLISHED state has been reached"
*                           (see also Note #2b).
*
*                       (2) If any control or text is queued for later processing, the next sequence octet to
*                           receive (RCV.NXT) MUST include the length of this received segment (SEG.LEN) :
*
*                           (A) RCV.NXT = SEG.SEQ + SEG.LEN + 1
*
*                   (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                           that "if the FIN bit is set ... advance RCV.NXT over the FIN".
*
*                       (2) However, the next octet to receive is NOT updated with the sequence number of the
*                           last octet to receive.  Instead, the generic sequence algorithm maintains & updates
*                           BOTH the next & last octets to receive for the closing TCP connection.
*
*               (3) TCP segments with receive data are sequenced first into the TCP connection's transport
*                   receive queue to be made available & ready to be read by the application layer from the
*                   TCP connection's application receive queue (see 'NetTCP_RxPktConnHandlerRxQ_AppData()
*                   Note #2').
*
*                   (a) Received TCP segments are inserted into a doubly-linked Transport Receive Queue,
*                       sorted by their sequence number(s).
*
*                       In the diagram below, ... :
*
*                       (1) (A) TCP connections' 'RxQ_Transport_Head' points to the head of a TCP connections'
*                                   Transport Receive Queue;
*                           (B) TCP connections' 'RxQ_Transport_Tail' points to the tail of a TCP connections'
*                                   Transport Receive Queue.
*
*                       (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr'  doubly-link each
*                           segment to form the Transport Receive Queue.
*
*                       (3) Fragmented segment buffer's 'PrevBufPtr' & 'NextBufPtr' doubly-link each
*                           fragmented segment (see also 'net_ip.c  NetIP_RxPktFragReasm()  Note #2b1E').
*
*                   (b) (1) Typically & most-frequently, TCP segments will be received in sequence-order.
*                           Therefore, the sequence sort algorithm starts at the tail of the Transport
*                           Receive Queue.
*
*                       (2) As segments are inserted into the Transport Receive Queue, segments migrate to
*                           the head of the Transport Receive Queue.  Queued segments with sequence numbers
*                           that are contiguous from the next expected receive sequence number are ready to
*                           be read by the application layer, so are immediately moved from the Transport
*                           Receive Queue to the Application Receive Queue.
*
*                           See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #2'.
*
*
*                                      |                                               |
*                                      |<-- TCP Connection Transport Receive Queue --->|
*                                      |                (see Note #3)                  |
*
*                                  Segments Moved                           Segments Sequenced
*                                  to Application                             into Transport
*                                  Receive Queue                              Receive Queue
*                                 starting at head                           starting at tail
*                                 (see Note #3b2)                            (see Note #3b1)
*
*                                         |        NextPrimListPtr                  |
*                                         |        (see Note #3a2)                  |
*                                         v                   |                     v
*                                                             |
*                        Head of       -------       -------  v    -------       -------   see Note #3a1B)
*                        Receive  ---->|     |------>|     |------>|     |------>|     |
*                         Queue        |     |       |     |       |     |       |     |       Tail of
*                                      |     |<------|     |<------|     |<------|     |<----  Receive
*                   (see Note #3a1A)   |     |       |     |  ^    |     |       |     |        Queue
*                                      |     |       |     |  |    |     |       |     |
*                                      -------       -------  |    -------       -------
*                                        | ^                  |      | ^
*                                        | |       PrevPrimListPtr   | |
*                                        v |       (see Note #3a2)   v |
*                                      -------                     -------
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      -------                     -------
*                                        | ^                         | ^
*                        NextBufPtr ---> | | <--- PrevBufPtr         | |
*                     (see Note #3a3)    v |   (see Note #3a3)       v |
*                                      -------                     -------
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     -------
*                                      |     |
*                                      |     |
*                                      -------
*
*
*               (4) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
*                   comparisons for sequence number windows that overflow the sequence number space.
*
*                   (a) For example, the next sequence octet to receive (RCV.NXT) is typically less than
*                       or equal to  the next received sequence octet (SEG.SEQ) :
*
*                           (1) RCV.NXT <= SEG.SEQ
*
*                       SEG.SEQ itself is also typically less than RCV.NXT plus the current receive window
*                       size (RCV.WND) :
*
*                           (2) SEG.SEQ <  RCV.NXT + RCV.WND
*
*                       However, if (RCV.NXT + RCV.WND) or SEG.SEQ overflows the sequence number space,
*                       these values will be MUCH less than SEG.SEQ or RCV.NXT, respectively, until
*                       SEG.SEQ & RCV.NXT also overflow :
*
*                           (3) RCV.NXT + RCV.WND << RCV.NXT
*                                                 << SEG.SEQ
*
*                           (4) SEG.SEQ           << RCV.NXT
*
*                   (b) Therefore, in order to determine if a received segment's sequence value precedes any
*                       previously received segment(s) in the TCP connection's receive queue(s), the following
*                       unsigned arithmetic comparisons MUST be checked :
*
*                           (1) RxQCur.SeqNbr - (SEG.SEQ + 1)  <   RX.WIN
*
*                           (2)     RX.NXT    - (SEG.SEQ + 1)  <  SEG.LEN
*
*                       Note that these comparisons bound any received segment's sequence within limits set
*                       by the TCP connection's receive window size & next expected receive octet.
*
*                   (c) In order to determine if a received segment's sequence value overlaps any previously
*                       received segment(s) in the TCP connection's receive queue, the following unsigned
*                       arithmetic comparisons MUST be checked :
*
*                           (1) (   SEG.SEQ    +    SEG.LEN   )  -  (RxQNext.SeqNbr + 1)  <     SEG.LEN
*
*                           (2) (RxQCur.SeqNbr + RxQCur.SegLen)  -  (SEG.SEQ        + 1)  <  RxQCur.SegLen
*
*                   See also 'NetTCP_RxPktConnIsValidSeq()  Note #2'.
*
*               (5) (a) RFC #2581, Section 3.2 states that "a TCP receiver SHOULD send an immediate ACK" :
*
*                       (1) "When an out-of-order segment arrives.  The purpose of this ACK is to inform
*                            the sender that a segment was received out-of-order and which sequence number
*                            is expected."
*
*                       (2) "In addition, ... when the incoming segment fills in all or part of a gap in
*                            the sequence space."
*
*                       See also 'NetTCP_TxConnAck()  Note #4a5'.
*
*                   (b) Since segments are typically received in sequence order (see Notes #5a1 & #3b1) &
*                       since segments received in sequential order are immediately made available & ready
*                       to be read by the application layer (see Note #3b2), received segments are out-of-
*                       order AND/OR fill in sequence number gaps whenever :
*
*                       (1) A TCP connection's Transport Receive Queue is initially non-empty;
*                              OR
*                       (2) A TCP connection's Transport Receive Queue's head segment's sequence number
*                           does NOT equal the TCP connection's next expected receive   sequence number.
*
*                   (c) However, since a TCP connection's next expected receive sequence numbers are NOT
*                       updated until both of the TCP connection's transport & application receive queues
*                       have been handled (see 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #1a3'), the
*                       transmission of any immediate acknowledgement MUST follow the handling of BOTH
*                       of the TCP connection's receive queues.
*
*                       See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Notes #1a3 & #4'.
*
*               (6) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that "the window
*                   sent in each segment indicates the range of sequence numbers the sender of the window
*                   (the data receiver) is currently prepared to accept.  There is an assumption that this
*                   is related to the currently available data buffer space available for this connection
*                   ... One strategy would be to ... [update the] information when the window" changes.
*
*                   See also 'NetTCP_RxAppData()                 Note #6',
*                            'NetTCP_RxPktConnHandlerRxQ_Sync()  Note #5',
*                          & 'NetTCP_RxConnWinSizeHandler()      Note #2a'.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerRxQ_Conn (NET_TCP_CONN  *p_conn,
                                               NET_BUF       *p_buf,
                                               NET_BUF_HDR   *p_buf_hdr,
                                               NET_ERR       *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_SEQ_CODE   seq_code;
#endif
    NET_BUF           *p_buf_q;
    NET_BUF           *p_buf_q_head;
    NET_BUF           *p_buf_q_prev;
    NET_BUF           *p_buf_q_next;
    NET_BUF_HDR       *p_buf_q_hdr;
    NET_BUF_HDR       *p_buf_q_hdr_head;
    NET_BUF_HDR       *p_buf_q_hdr_next;
    NET_TCP_SEQ_NBR    seq_nbr;
    NET_TCP_SEQ_NBR    seq_nbr_next;
    NET_TCP_SEQ_NBR    seq_nbr_dup;
    NET_TCP_SEQ_NBR    seq_nbr_delta;
    NET_TCP_SEQ_NBR    seq_nbr_win;
    CPU_BOOLEAN        seq_srch_done;
    CPU_BOOLEAN        seq_unordered_prev;
    CPU_BOOLEAN        seq_unordered_cur;
    CPU_BOOLEAN        seq_unordered;


                                                                /* ----------- UPDATE TCP CONN RX SEQ NBRS ------------ */
    if (p_conn->ConnState == NET_TCP_CONN_STATE_SYNC_TXD) {
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        switch (p_conn->RxQ_State) {
            case NET_TCP_RX_Q_STATE_CLOSED:
                 break;


            case NET_TCP_RX_Q_STATE_NONE:
            case NET_TCP_RX_Q_STATE_SYNC:
            case NET_TCP_RX_Q_STATE_CONN:
            case NET_TCP_RX_Q_STATE_CLOSING:
            default:
                *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                 return;
        }
#endif
                                                                /* Init SYN-SENT state (see Notes #2c & #2d2).          */
        p_conn->RxSeqNbrSync = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SeqNbr;
        p_conn->RxSeqNbrNext = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
        p_conn->RxQ_State    =  NET_TCP_RX_Q_STATE_SYNC;


    } else {
        switch (p_conn->RxQ_State) {
            case NET_TCP_RX_Q_STATE_SYNC:
                 break;


            case NET_TCP_RX_Q_STATE_CONN:
                                                                /* Chk TCP conn closing (see Note #2e).                 */
                 if (p_buf_hdr->TCP_SegClose == DEF_YES) {
                     p_conn->RxSeqNbrLast  = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
                     p_conn->RxSeqNbrClose = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrLast  - NET_TCP_SEG_LEN_CLOSE);
                     p_conn->RxQ_State     =  NET_TCP_RX_Q_STATE_CLOSING;
                 }
                                                                /* 'break' intentionally omitted; MUST execute the ..   */
                                                                /* .. following case : 'NET_TCP_RX_Q_STATE_CLOSED'.     */

            case NET_TCP_RX_Q_STATE_CLOSED:
            case NET_TCP_RX_Q_STATE_CLOSING:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
                                                                /* Chk valid rx'd seq nbr.                              */
                 seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return;
                 }
                 if (seq_code != NET_TCP_CONN_RX_SEQ_VALID) {
                    *p_err = NET_TCP_ERR_CONN_SEQ_INVALID;
                     return;
                 }
#endif
                 break;


            case NET_TCP_RX_Q_STATE_NONE:
            default:
                *p_err = NET_TCP_ERR_CONN_DATA_INVALID;
                 return;
        }
    }


    if (p_buf_hdr->TCP_SegLenData < 1) {                        /* If seg data len < 1,             AND ...             */
                                                                /* ... NOT in rx conn closing state OR  ...             */
        if ((p_conn->RxQ_State       != NET_TCP_RX_Q_STATE_CLOSING) ||
            (p_buf_hdr->TCP_SegClose != DEF_YES)) {             /* ... fin/close NOT rx'd;              ...             */
            *p_err = NET_TCP_ERR_CONN_DATA_NONE;                /* ... rtn data  NOT avail.                             */
             return;
        }                                                       /* Else seq & handle closing-ctrl seg.                  */
    }


                                                                /* ------- INSERT SEG INTO SEQ'D TRANSPORT RX Q ------- */
    p_buf_q             = (NET_BUF *)p_conn->RxQ_Transport_Tail;/* Start seq insert alg from rx Q tail (see Note #3b1). */
    p_buf_q_next        = DEF_NULL;
    seq_srch_done      =  DEF_NO;
                                                                /* Chk init'l rx Q seq order (see Note #5b1).           */
    seq_unordered_prev = (p_conn->RxQ_Transport_Head != DEF_NULL)
                       ?  DEF_YES : DEF_NO;

    while (seq_srch_done == DEF_NO) {                           /* Srch rx Q to insert rx'd seg into seq nbr position.  */
        if (p_buf_q != DEF_NULL) {                              /* While NOT @ rx Q head, chk if seg ...                */

            p_buf_q_hdr    = (NET_BUF_HDR   *)&p_buf_q->Hdr;
            p_buf_q_prev   = (NET_BUF       *) p_buf_q_hdr->PrevPrimListPtr;
                                                                /* ... before or after cur  rx Q seg (see Note #2a1).   */
            seq_nbr_next  = (NET_TCP_SEQ_NBR) p_buf_q_hdr->TCP_SeqNbr;
            seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr   + 1u);
            seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next           - seq_nbr);
            seq_nbr_win   = (NET_TCP_SEQ_NBR) p_conn->RxWinSizeCfgd;

            if (seq_nbr_delta < seq_nbr_win) {                  /* If seg's seq nbr < cur rx Q's seq nbr (see Note #4b1)*/
                                                                /* ... adv to prev rx Q seg; but chk ...                */
                                                                /* ... for dup seqs in next rx Q seg.                   */
                seq_nbr_next  = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr   + p_buf_hdr->TCP_SegLen);
                seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_q_hdr->TCP_SeqNbr + 1u);
                seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next           - seq_nbr);
                seq_nbr_win   = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SegLen;

                if (seq_nbr_delta < seq_nbr_win) {              /* If seg overlaps next rx Q seqs (see Note #4c1), ...  */

                    seq_nbr_dup   = seq_nbr_delta + 1u;         /* ... trim dup seqs from seg     (see Note #2a3); ...  */
                    if (p_buf_hdr->TCP_SegLenData  > (NET_TCP_SEG_SIZE)seq_nbr_dup) {
                        p_buf_hdr->TCP_SegLenData -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
                        p_buf_hdr->TCP_SegLen     -= (NET_TCP_SEG_SIZE)seq_nbr_dup;

                    } else {                                    /* ... else discard ALL dup seqs  (see Note #2a2).      */
                       *p_err = NET_TCP_ERR_CONN_DATA_DUP;
                        return;
                    }
                }
                                                                /* Adv to prev rx Q seg.                                */
                p_buf_q_next = p_buf_q;
                p_buf_q      = p_buf_q_prev;


            } else {                                            /* Else insert seg between cur/next rx Q segs.          */
                                                                /* Chk for dup seqs in cur rx Q seg.                    */
                seq_nbr_next  = (NET_TCP_SEQ_NBR)(p_buf_q_hdr->TCP_SeqNbr + p_buf_q_hdr->TCP_SegLen);
                seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr   + 1u);
                seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next           - seq_nbr);
                seq_nbr_win   = (NET_TCP_SEQ_NBR) p_buf_q_hdr->TCP_SegLen;

                if (seq_nbr_delta < seq_nbr_win) {              /* If seg overlaps prev'ly rx'd seqs (see Note #4c2),   */
                    seq_nbr_dup   = seq_nbr_delta + 1u;         /* ... trim dup seqs from seg    (see Note #2a3); ...   */
                    if (p_buf_hdr->TCP_SegLenData  > (NET_TCP_SEG_SIZE)seq_nbr_dup) {
                        p_buf_hdr->TCP_SegLenData -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
                        p_buf_hdr->TCP_SegLen     -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
                        p_buf_hdr->TCP_SeqNbr      = (NET_TCP_SEQ_NBR )seq_nbr_next;

                    } else {                                    /* ... else discard ALL dup seqs (see Note #2a2).       */
                       *p_err = NET_TCP_ERR_CONN_DATA_DUP;
                        return;
                    }
                }

                seq_srch_done = DEF_YES;
            }

        } else {                                                /* Else if @ head of rx Q, entire rx Q srch'd; ...      */
                                                                /* ... chk for dup seqs prior to TCP conn's    ...      */
                                                                /* ... next expected rx octet.                          */
            seq_nbr_next  = (NET_TCP_SEQ_NBR) p_conn->RxSeqNbrNext;
            seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + 1u);
            seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next         - seq_nbr);
            seq_nbr_win   = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SegLen;

            if (seq_nbr_delta < seq_nbr_win) {                  /* If seg overlaps prev'ly rx'd seqs (see Note #4b2),   */
                seq_nbr_dup   = seq_nbr_delta + 1u;             /* ... trim dup seqs from seg    (see Note #2a3),       */
                if (p_buf_hdr->TCP_SegLenData  > (NET_TCP_SEG_SIZE)seq_nbr_dup) {
                    p_buf_hdr->TCP_SegLenData -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
                    p_buf_hdr->TCP_SegLen     -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
                    p_buf_hdr->TCP_SeqNbr      = (NET_TCP_SEQ_NBR )seq_nbr_next;

                } else {                                        /* ... else discard ALL dup seqs (see Note #2a2).       */
                   *p_err = NET_TCP_ERR_CONN_DATA_DUP;
                    return;
                }
            }

            seq_srch_done = DEF_YES;
        }
    }

                                                                /* Insert rx'd seg between cur/next rx Q segs.          */
    p_buf_hdr->PrevPrimListPtr = p_buf_q;
    if (p_buf_q != DEF_NULL) {                                  /* If avail, insert rx'd seg after  cur  rx Q seg.      */
        p_buf_q_hdr->NextPrimListPtr = p_buf;
    } else {                                                    /* Else      insert rx'd seg @ rx Q head.               */
        p_conn->RxQ_Transport_Head   = p_buf;
    }

    p_buf_hdr->NextPrimListPtr = p_buf_q_next;
    if (p_buf_q_next != DEF_NULL) {                             /* If avail, insert rx'd seg before next rx Q seg.      */
        p_buf_q_hdr_next                  = &p_buf_q_next->Hdr;
        p_buf_q_hdr_next->PrevPrimListPtr =  p_buf;
    } else {                                                    /* Else      insert rx'd seg @ rx Q tail.               */
        p_conn->RxQ_Transport_Tail        =  p_buf;
    }


                                                                /* Chk rx'd out-of-order seg(s) [see Note #5a].         */
    if (p_conn->RxQ_Transport_Head != DEF_NULL) {
        p_buf_q_head        =  p_conn->RxQ_Transport_Head;
        p_buf_q_hdr_head    = &p_buf_q_head->Hdr;
                                                                /* Chk cur rx Q seq order       (see Note #5b2).        */
        seq_unordered_cur  = (p_buf_q_hdr_head->TCP_SeqNbr
                          !=  p_conn->RxSeqNbrNext)    ? DEF_YES : DEF_NO;
    } else {
        seq_unordered_cur  =  DEF_NO;
    }

    seq_unordered = ((seq_unordered_prev == DEF_YES) ||
                     (seq_unordered_cur  == DEF_YES)) ? DEF_YES : DEF_NO;

    if (seq_unordered != DEF_NO) {                              /* If out-of-order seg(s) rx'd   (see Note #5a) ...     */
        if (p_conn->RxQ_State != NET_TCP_RX_Q_STATE_SYNC) {     /* ... in non-sync state,                       ...     */
                                                                /* ... req immed TCP conn ack tx (see Note #5c).        */
            p_buf_hdr->TCP_SegAckTxReqCode = NET_TCP_CONN_TX_ACK_IMMED;
        }
    }


                                                                /* ----------- UPDATE TCP CONN RX WIN SIZE ------------ */
                                                                /* Dec TCP conn's rx win size (see Note #6).            */
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
    NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, p_buf_hdr->TCP_SegLenData, NET_TCP_CONN_RX_WIN_DEC);
#else
    NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, 1, NET_TCP_CONN_RX_WIN_DEC);
#endif

   *p_err = NET_TCP_ERR_CONN_DATA_VALID;
}


/*
*********************************************************************************************************
*                                NetTCP_RxPktConnHandlerRxQ_AppData()
*
* Description : (1) (a) Handle TCP connection's application receive queue ... :
*
*                       (1) Remove segments from  TCP connection's transport   receive queue    See Note #3b1B
*                       (2) Update TCP connection transport receive queue
*                       (3) Update TCP connection receive sequence numbers
*                       (4) Move   segments into  TCP connection's application receive queue    See Note #2
*                       (5) Update TCP connection receive window                                See Note #6
*
*                   (b) ... for the following connected states :
*
*                       (1) SYN-RECEIVED                                                        See Note #1bA
*                       (2) SYN-SENT                                                            See Note #1bA
*                       (3) ESTABLISHED                                                         See Note #1bB
*                       (4) FIN-WAIT-1                                                          See Note #1bB
*                       (5) FIN-WAIT-2                                                          See Note #1bB
*                       (6) CLOSING                                                             See Note #1bC
*                       (7) TIME-WAIT                                                           See Note #1bC
*                       (8) CLOSE-WAIT                                                          See Note #1bC
*                       (9) LAST-ACK                                                            See Note #1bC
*
*
*                           (A) For synchronization-to-connected state transitions, segments are queued to
*                               the TCP connection's transport receive queue, but NOT to the TCP connection's
*                               application receive queue, until the application layer is signaled that the
*                               transport layer connection is complete.
*
*                               See also 'NetTCP_RxPktConnHandlerSyncRxd()  Note #1c1'
*                                      & 'NetTCP_RxPktConnHandlerSyncTxd()  Note #1c1'.
*
*                           (B) For connected states, segments are queued to the TCP connection's application
*                               receive queue as appropriate (see Notes #2 & #3b).
*
*                           (C) For closing states; closing segments are queued to the TCP connection's
*                               transport &/or application receive queue(s) as for connected states.
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection's application receive queue
*                                                                       successfully handled.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection receive queue state.
*
*                                                                   ---- RETURNED BY NetTCP_RxQ_Signal() : ----
*                               NET_TCP_ERR_RX_Q_FULL               TCP connection receive queue full.
*                               NET_TCP_ERR_RX_Q_SIGNAL_FAULT       TCP connection receive queue signal fault.
*
*                                                                   ----- RETURNED BY NetTCP_RxQ_Clr() : ------
*                               NET_TCP_ERR_RX_Q_SIGNAL_CLR         TCP connection receive queue clear failed.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg(),
*               NetTCP_RxPktConnHandlerSyncRxd(),
*               NetTCP_RxPktConnHandlerSyncTxd().
*
* Note(s)     : (2) TCP segments with receive data that are available & ready to be read by the application
*                   layer are linked in a TCP connection's application receive queue.
*
*                   (a) Received TCP segments are moved from the doubly-linked Transport Receive Queue,
*                       sorted by their sequence number(s), into the Application Receive Queue.
*
*                       In the diagram below, ... :
*
*                       (1) (A) TCP connections' 'RxQ_App_Head' points to the head of a TCP connections'
*                                   Application Receive Queue;
*                           (B) TCP connections' 'RxQ_App_Tail' points to the tail of a TCP connections'
*                                   Application Receive Queue.
*
*                       (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr'  doubly-link each
*                           segment to form the Application Receive Queue.
*
*                       (3) Fragmented segment buffer's 'PrevBufPtr' & 'NextBufPtr' doubly-link each
*                           fragmented segment (see also 'net_ip.c  NetIP_RxPktFragReasm()  Note #2b1E').
*
*                   (b) (1) TCP segments are appended in sequence order from the head of a TCP connection's
*                           Transport Receive Queue to the tail of the TCP connection's Application Receive
*                           Queue.
*
*                           See also 'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #3'.
*
*                       (2) Application data is read from segments starting from the head of the Application
*                           Receive Queue.  Segments that are read by the application layer are removed from
*                           the Application Receive Queue.
*
*
*                                      |                                               |
*                                      |<- TCP Connection Application Receive Queue -->|
*                                      |                (see Note #2)                  |
*
*                                 Segments Read by                         Segments Appended to
*                                 Application Layer                      Application Receive Queue
*                                 starting at head                           starting at tail
*                                 (see Note #2b2)                            (see Note #2b1)
*
*                                         |        NextPrimListPtr                  |
*                                         |        (see Note #2a2)                  |
*                                         v                   |                     v
*                                                             |
*                        Head of       -------       -------  v    -------       -------  (see Note #2a1B)
*                        Receive  ---->|     |------>|     |------>|     |------>|     |
*                         Queue        |     |       |     |       |     |       |     |       Tail of
*                                      |     |<------|     |<------|     |<------|     |<----  Receive
*                   (see Note #2a1A)   |     |       |     |  ^    |     |       |     |        Queue
*                                      |     |       |     |  |    |     |       |     |
*                                      -------       -------  |    -------       -------
*                                        | ^                  |      | ^
*                                        | |       PrevPrimListPtr   | |
*                                        v |       (see Note #2a2)   v |
*                                      -------                     -------
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      -------                     -------
*                                        | ^                         | ^
*                        NextBufPtr ---> | | <--- PrevBufPtr         | |
*                     (see Note #2a3)    v |   (see Note #2a3)       v |
*                                      -------                     -------
*                                      |     |                     |     |
*                                      |     |                     |     |
*                                      |     |                     -------
*                                      |     |
*                                      |     |
*                                      -------
*
*               (3) (a) (1) RFC #793, Section 3.8 'Interfaces : User/TCP Interface : TCP User Commands :
*                           Receive' states that :
*
*                           (A) "If enough data arrive [sic] to fill the buffer before a PUSH is seen,
*                                the PUSH flag will not be set in the response to the RECEIVE.  The
*                                buffer will be filled with as much data as it can hold."
*
*                           (B) "If the PUSH is seen before the buffer is filled the buffer will be
*                                returned partially filled and PUSH indicated."
*
*                               See Notes #3b1B & #3b1B.
*
*                       (2) RFC #1122, Section 4.2.2.2 states that :
*
*                           (A) (1) "At the receiver, the PSH bit forces buffered data to be delivered to
*                                    the application (even if less than a full buffer has been received)."
*
*                               (2) (a) "Conversely, the lack of a PSH bit can be used to avoid unnecessary
*                                        wakeup calls to the application process; this can be an important
*                                        performance optimization for large timesharing hosts."
*
*                                   (b) "When a series of segments is received without the PSH bit, a TCP
*                                        MAY queue the data internally without passing it to the receiving
*                                        application."
*
*                           (B) (1) "Passing the PSH bit to the receiving application allows an ...
*                                    optimization within the application."
*
*                               (2) "RFC-793 ... erroneously implies that a received PSH flag must be passed
*                                    to the application layer.  Passing a received PSH flag to the application
*                                    layer is now OPTIONAL."
*
*                           (C) "The PSH bit is not a record marker and is independent of segment boundaries."
*
*                   (b) (1) (A) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 20.5, Page 284
*                                   states that "Berkeley-derived implementations ignore a received PUSH flag
*                                   because they normally never delay the delivery of received data to the
*                                   application".
*
*                               (2) Therefore, for TCP connections in any connected state, received TCP segment
*                                   data is made available to the application receive queue as soon as it is
*                                   enqueued to the application receive queue.
*
*                           (B) Thus for TCP connections in any connected state, TCP segments are moved from
*                               a TCP connection's transport receive queue to its application receive queue
*                               whenever the transport receive queue's enqueued TCP segments are consecutively
*                               sequenced starting from the TCP connection's next expected receive octet.
*
*                       (2) Thus TCP application-receive PUSH feature is obsoleted & NOT implemented.
*
*                       See also 'NetTCP_TxConnAck()  Note #4a4'.
*
*               (4) A TCP connection's next expected receive sequence numbers are NOT updated until
*                   both of the TCP connection's transport & application receive queues have been
*                   handled.  Thus the transmission of any TCP connection data or acknowledgements
*                   MUST follow the handling of BOTH of the TCP connection's receive queues.
*
*                   See also Note #1a3 & 'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #5c'.
*
*               (5) Stream-type connections receive all data octets in one or more non-distinct
*                   packets.  In other words, the application data is NOT bounded by any specific
*                   packet(s); rather, it is contiguous & sequenced from one packet to the next.
*
*                   Therefore, the TCP connection receive queue is signaled ONLY when data is received
*                   for a connection where data was previously unavailable.
*
*               (6) (a) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that
*                       "the window sent in each segment indicates the range of sequence numbers the
*                       sender of the window (the data receiver) is currently prepared to accept.
*                       There is an assumption that this is related to the currently available data
*                       buffer space available for this connection".
*
*                   (b) (1) A TCP connection's advertised receive window MUST NEVER be decreased to zero
*                           if NO receive data is available & ready to be read by the application layer.
*
*                           In other words, if NO received data starting from the next expected receive
*                           sequence number(s) is queued, then NO data is available to be read by the
*                           application layer.  Therefore, the receive window size MUST NOT be decreased
*                           to zero, otherwise the receive window would deadlock since the application
*                           layer would NOT be able to read & extract any data from the receive window
*                           & the TCP connection would NOT be able to receive any more data into the
*                           receive window.
*
*                       (2) (A) In case the advertised receive window size has decreased to zero, ...
*                           (B) & NO data is available to be read by the application layer;       ...
*                           (C) then remove & free the last received TCP segment from the tail
*                                   of the TCP connection's transport receive queue,              ...
*                           (D) & increase the advertised receive window size by this freed
*                                   segment's length.
*
*                           This is permissible because removing the last received TCP segment from
*                           the TCP connection's transport receive queue does NOT interfere with TCP
*                           communications since the next expected receive sequence number(s) remains
*                           unchanged.
*
*                       (3) (A) A TCP connection's receive window SHOULD NOT become deadlocked during
*                               correct operation of TCP communication.  However, these TCP receive
*                               zero-sized window cases are included as an extra precaution in the
*                               case that TCP communication is incorrectly handled &/or corrupted.
*
*                           (B) A deadlocked TCP connection with a receive window of zero-size with
*                               absolutely NO buffers queued in the TCP connection's transport receive
*                               queue SHOULD NEVER occur.  However, the TCP receive window size reset
*                               case is included as an extra precaution in the case that a TCP connection
*                               receive window is incorrectly handled &/or corrupted.
*
*                       See also 'NetTCP_RxConnWinSizeHandler()  Note #2a1'.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerRxQ_AppData (NET_TCP_CONN  *p_conn,
                                                  NET_ERR       *p_err)
{
    NET_BUF          *p_buf;
    NET_BUF          *p_buf_head;
    NET_BUF          *p_buf_tail;
    NET_BUF          *p_buf_q_head;
    NET_BUF          *p_buf_q_tail;
    NET_BUF_HDR      *p_buf_hdr;
    NET_BUF_HDR      *p_buf_hdr_head;
    NET_BUF_HDR      *p_buf_hdr_tail;
    NET_BUF_HDR      *p_buf_hdr_q_head;
    NET_BUF_HDR      *p_buf_hdr_q_tail;
    NET_TCP_SEQ_NBR   seq_nbr;
    NET_TCP_SEQ_NBR   seq_nbr_inc;
    CPU_BOOLEAN       done;


                                                                /* ------ REMOVE RX'D SEG(S) FROM TRANSPORT RX Q ------ */
    switch (p_conn->RxQ_State) {                                /* Cfg starting seq nbr.                                */
        case NET_TCP_RX_Q_STATE_SYNC:
             if (p_conn->RxQ_Transport_Head == DEF_NULL) {      /* If   sync seg NOT      q'd with rx'd data, ...       */
                 seq_nbr = p_conn->RxSeqNbrNext;                /* ...  start rx seq move from next rx seq.             */
             } else {                                           /* Else sync seg possibly q'd with rx'd data.           */
                 p_buf_q_head     =  p_conn->RxQ_Transport_Head;
                 p_buf_hdr_q_head = &p_buf_q_head->Hdr;
                                                                /* If sync seg q'd,                             ...     */
                 seq_nbr          = (p_buf_hdr_q_head->TCP_SegSync == DEF_YES)
                                  ?  p_conn->RxSeqNbrSync       /* ...      start rx seq move from sync rx seq; ...     */
                                  :  p_conn->RxSeqNbrNext;      /* ... else start rx seq move from next rx seq.         */
             }

             p_conn->RxQ_State = NET_TCP_RX_Q_STATE_CONN;
             break;


        case NET_TCP_RX_Q_STATE_CONN:
        case NET_TCP_RX_Q_STATE_CLOSING:
             seq_nbr = p_conn->RxSeqNbrNext;
             break;


        case NET_TCP_RX_Q_STATE_CLOSED:
            *p_err = NET_TCP_ERR_NONE;
             return;


        case NET_TCP_RX_Q_STATE_NONE:
        default:
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }

    p_buf      = p_conn->RxQ_Transport_Head;
    p_buf_head = p_buf;
    p_buf_tail = DEF_NULL;
    done       = DEF_NO;

    while (done == DEF_NO) {                                    /* Srch for ALL segs with consecutive seq nbrs ...      */
                                                                /* ... from next expected rx seq.                       */
        if (p_buf != DEF_NULL) {
            p_buf_hdr = &p_buf->Hdr;
            if (p_buf_hdr->TCP_SeqNbr == seq_nbr) {             /* If seq consecutive from next expected rx seq, ..     */
                seq_nbr_inc  = p_buf_hdr->TCP_SegLen;
                seq_nbr     += seq_nbr_inc;                     /* ..               update next expected rx seq.        */
                p_buf_tail   = p_buf;
                p_buf        = p_buf_hdr->NextPrimListPtr;
            } else {
                done = DEF_YES;
            }
        } else {
            done = DEF_YES;
        }
    }


                                                                /* ---------- UPDATE TCP CONN TRANSPORT RX Q ---------- */
    if (p_buf != DEF_NULL) {                                    /* If transport rx Q NOT empty, update ..               */
                                                                /* .. transport rx Q head.                              */
        p_buf_hdr->PrevPrimListPtr = DEF_NULL;
        p_conn->RxQ_Transport_Head = p_buf;

    } else {                                                    /* Else clr transport rx Q.                             */
        p_conn->RxQ_Transport_Head = DEF_NULL;
        p_conn->RxQ_Transport_Tail = DEF_NULL;
    }


    p_conn->RxSeqNbrNext = seq_nbr;                             /* Update next expected rx seq.                         */
    if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSING) {
        if (p_conn->RxSeqNbrNext == p_conn->RxSeqNbrLast) {     /* If last seq rx'd, close TCP conn rx.                 */
            p_conn->RxQ_State = NET_TCP_RX_Q_STATE_CLOSED;
        }
    }


                                                                /* ---------- MOVE RX'D SEG(S) ONTO APP RX Q ---------- */
    if (p_buf_tail != DEF_NULL) {                               /* If avail, move rx'd seg(s) from transport rx Q       */
                                                                /* ... into app rx Q (see Note #3b1B).                  */
        p_buf_hdr_head                  = &p_buf_head->Hdr;
        p_buf_hdr_tail                  = &p_buf_tail->Hdr;
        p_buf_hdr_head->PrevPrimListPtr =  p_conn->RxQ_App_Tail;
        p_buf_hdr_tail->NextPrimListPtr =  DEF_NULL;

        if (p_conn->RxQ_App_Tail != DEF_NULL) {                 /* If app rx Q NOT empty, ...                           */
                                                                /* ... append seg(s) @ Q tail (see Note #2b1).          */
            p_buf_q_tail                      =  p_conn->RxQ_App_Tail;
            p_buf_hdr_q_tail                  = &p_buf_q_tail->Hdr;
            p_buf_hdr_q_tail->NextPrimListPtr =  p_buf_head;
            p_conn->RxQ_App_Tail              =  p_buf_tail;

        } else {                                                /* Else add seg(s) to empty app rx Q ...                */
            p_conn->RxQ_App_Head              =  p_buf_head;
            p_conn->RxQ_App_Tail              =  p_buf_tail;

            NetTCP_RxQ_Signal(p_conn->ID, p_err);               /* ...   & signal non-empty app rx Q (see Note #5).     */
            if (*p_err != NET_TCP_ERR_NONE) {
                 return;
            }
        }


    } else {                                                    /* ----------------- CHK RX WIN SIZE ------------------ */
        if (p_conn->RxWinSizeActual < 1) {                      /* If avail rx win size zero  (see Note #6b2A)  ...     */
            if (p_conn->RxQ_App_Head == DEF_NULL) {             /* ... & NO avail app rx data (see Note #6b2B); ...     */
                                                                /* ... inc rx win size (see Note #6b).                  */
                p_buf = p_conn->RxQ_Transport_Tail;
                if (p_buf != DEF_NULL) {                        /* If transport rx Q NOT empty;              ...        */
                                                                /* ... remove last q'd seg (see Note #6b2C), ...        */
                    p_buf_hdr    = &p_buf->Hdr;
                    p_buf_q_tail =  p_buf_hdr->PrevPrimListPtr;
                    if (p_buf_q_tail != DEF_NULL) {
                        p_conn->RxQ_Transport_Tail        =  p_buf_q_tail;
                        p_buf_hdr_q_tail                  = &p_buf_q_tail->Hdr;
                        p_buf_hdr_q_tail->NextPrimListPtr =  DEF_NULL;

                    } else {
                        p_conn->RxQ_Transport_Head        =  DEF_NULL;
                        p_conn->RxQ_Transport_Tail        =  DEF_NULL;

                        NetTCP_RxQ_Clr(p_conn->ID, p_err);
                        if (*p_err != NET_TCP_ERR_NONE) {
                             NetTCP_ConnClose(p_conn, DEF_NULL, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
                             return;
                        }
                    }


#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN                           /* ... inc win size by seg's len (see Note #6b2D),      */
                    NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, p_buf_hdr->TCP_SegLenData, NET_TCP_CONN_RX_WIN_SET);
#else
                    NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, 1, NET_TCP_CONN_RX_WIN_INC);
#endif
                    NetTCP_RxPktFree(p_buf);                     /* ... & free seg (see Note #6b2C).                     */

                } else {                                          /* Else reset TCP conn rx win size (see Note #6b3B).    */
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
                    NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, 0u, NET_TCP_CONN_RX_WIN_RESET);
#else
                    NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, 0u, NET_TCP_CONN_RX_WIN_RESET);
#endif
                }
            }
        }
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                NetTCP_RxPktConnHandlerTxWinRemote()
*
* Description : Handle TCP connection's transmit remote host window update.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               ack_code    Indicates the received segment's acknowledgement condition :
*               --------
*                               NET_TCP_CONN_RX_ACK_VALID           Received acknowledgement number is
*                                                                       valid for the TCP connection.
*
*                               NET_TCP_CONN_RX_ACK_DUP             Received acknowledgement number is a
*                                                                                duplicate for the TCP
*                                                                       connection.
*
*                               NET_TCP_CONN_RX_ACK_PREV            Received acknowledgement number is a
*                                                                       previous duplicate for the TCP
*                                                                       connection.
*
*                           Argument validated in NetTCP_RxPktConnHandler() functions.
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection's transmit remote host
*                                                                       window successfully handled.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg().
*
* Note(s)     : (1) (a) (1) The following sections ... :
*
*                           (A) RFC #1122, Section 4.2.2.20.(c)
*                           (B) RFC #1122, Section 4.2.2.20.(f)
*
*                       (2) ... generalize that "when the connection enters ESTABLISHED STATE, the following
*                           variables should be set" :
*
*                           (A) SND.WND <- SEG.WND
*                           (B) SND.WL1 <- SEG.SEQ
*                           (C) SND.WL2 <- SEG.ACK
*
*                   (b) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                           ESTABLISHED STATE' generalizes ...
*
*                           (A) ... that for the following connected states ... :
*
*                               (1) ESTABLISHED
*                               (2) FIN-WAIT-1
*                               (3) CLOSING
*                               (4) CLOSE-WAIT
*                               (5) LAST-ACK
*                                   (a) See 'NetTCP_RxPktConnHandlerLastAck()  Notes #2d2B'.
*
*                           (B) ... that "if SND.UNA < SEG.ACK <= SND.NXT, the send window should be updated" :
*
*                               (1) If ...
*
*                                   (a)  ((SND.WL1 <  SEG.SEQ)  or
*                                   (b)  ((SND.WL1 == SEG.SEQ)  and
*                                   (c)   (SND.WL2 <= SEG.ACK)) ...
*
*                               (2) ... [then] set ...
*
*                                   (a) SND.WND <- SEG.WND
*                                   (b) SND.WL1 <- SEG.SEQ
*                                   (c) SND.WL2 <- SEG.ACK
*
*                       (2) (A) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
*                               for the segment's acknowledgement to include SND.UNA : "The window should
*                               updated if SND.UNA <= SEG.ACK <= SND.NXT."
*
*                               This allows received segments that exactly acknowledge the TCP connection's
*                               last acknowledged transmit sequence octet to update the transmit window in
*                               case the remote host's receive window size is increasing or decreasing.
*
*                           (B) However, it does NOT seem reasonable to update a TCP connection's remote
*                               transmit window for any received duplicate acknowledgement segment; i.e.
*                               an acknowledgement with the exact same sequence numbers & receive window
*                               size advertisement.  Otherwise, each received duplicate acknowledgement
*                               would incorrectly update the TCP connection's remote transmit window size.
*
*                               Therefore, it seems reasonable & is assumed that the transmit window MUST
*                               be updated for received acknowledgements that exactly acknowledge the TCP
*                               connection's last acknowledged transmit sequence octet, if & only if the
*                               received segment's receive window size advertisement has increased or
*                               decreased since the last received acknowledgement segment.
*
*                           See also RFC #1122, Section 4.2.2.16 & 'NetTCP_TxConnAck()  Note #4b1B1'.
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #3'.
*
*               (2) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
*                   comparisons for sequence number windows that overflow the sequence number space.
*
*                   (a) (1) For example, in order to update the transmit window, a received segment's
*                           acknowledgement value (SEG.ACK) MUST be greater than or equal to the last
*                           received acknowledgement number that updated the transmit window (SND.WL2)
*                           [see Note #1b1B1c] :
*
*                               (A) SEG.ACK >= SND.WL2
*
*                           However, if SEG.ACK overflows the sequence number space, it will be MUCH
*                           less than SND.WL2 until SND.WL2 also overflows :
*
*                               (B) SEG.ACK << SND.WL2
*
*                       (2) Therefore, in order to validate a received segment's acknowledgement number
*                           as valid for updating the TCP connection's transmit window, the following
*                           unsigned arithmetic comparison MUST be true :
*
*                               (A) (SND.NXT - SEG.ACK)  <=  (SND.NXT - SND.WL2)
*
*                   (b) (1) Alternatively, to update the transmit window, a received segment's  sequence
*                           number (SEG.SEQ) MUST be greater than or equal to the last received sequence
*                           number that updated the transmit window (SND.WL1) [see Notes #1b1B1a & #1b1B1b] :
*
*                               (A) SEG.SEQ >= SND.WL1
*
*                       (2) Therefore, in order to validate a received segment's sequence number as valid
*                           for updating the TCP connection's transmit window, the following unsigned
*                           arithmetic comparison MUST be true :
*
*                               (A) (RCV.NXT + RCV.WND) - SEG.SEQ  <  (RCV.NXT + RCV.WND) - SND.WL1
*
*                       See also 'NetTCP_RxPktConnIsValidAck()  Note #3'.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerTxWinRemote (NET_TCP_CONN      *p_conn,
                                                  NET_TCP_ACK_CODE   ack_code,
                                                  NET_BUF_HDR       *p_buf_hdr,
                                                  NET_ERR           *p_err)
{
    CPU_BOOLEAN      tx_win_update;
    NET_TCP_SEQ_NBR  ack_delta_next;
    NET_TCP_SEQ_NBR  ack_delta_win_update;
    NET_TCP_SEQ_NBR  seq_win;
    NET_TCP_SEQ_NBR  seq_win_delta;
    NET_TCP_SEQ_NBR  seq_win_update_delta;
    NET_ERR          err;


                                                                /* ------ VALIDATE TCP CONN TX REMOTE WIN UPDATE ------ */
    tx_win_update = DEF_NO;

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
                                                                /* Validate TCP conn tx Q state.                        */
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CLOSED:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                     *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                      return;
             }
#endif

             tx_win_update = DEF_YES;                           /* Update tx win ctrls (see Note #1a2).                 */
             break;


        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
                                                                /* Validate TCP conn tx Q state.                        */
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                     *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                      return;
             }
#endif
                                                                /* Chk tx win ctrls update      (see Note #1b1B1).      */
                                                                /* If seq = last win update seq (see Note #1b1B1b),  .. */
             if (p_buf_hdr->TCP_SeqNbr == p_conn->TxWinUpdateSeqNbr) {

                 ack_delta_next       = (NET_TCP_SEQ_NBR)(p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr);
                 ack_delta_win_update = (NET_TCP_SEQ_NBR)(p_conn->TxSeqNbrNext - p_conn->TxWinUpdateAckNbr);
                 if (ack_delta_next <= ack_delta_win_update) {  /* .. (next - ack) <= (next - last win update ack),  .. */
                                                                /* .. & rx'd ack OR win != last rx'd ack or win,     .. */
                                                                /* .. update tx win (see Notes #1b1B1c, #1b2B, & #2a2A),*/
                     tx_win_update = ((p_buf_hdr->TCP_AckNbr  != p_conn->TxWinUpdateAckNbr ) ||
                                      (p_buf_hdr->TCP_WinSize != p_conn->TxWinUpdateWinSize)) ? DEF_YES : DEF_NO;
                 }

             } else {
                 seq_win              = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrNext + p_conn->RxWinSizeActual);
                 seq_win_delta        = (NET_TCP_SEQ_NBR)(seq_win             - p_buf_hdr->TCP_SeqNbr);
                 seq_win_update_delta = (NET_TCP_SEQ_NBR)(seq_win             - p_conn->TxWinUpdateSeqNbr);

                 if (seq_win_delta < seq_win_update_delta) {    /* .. else if [(next + win) -                 seq] < .. */
                                                                /* ..         [(next + win) - last win update seq],  .. */
                     tx_win_update = DEF_YES;                   /* .. update tx win (see Notes #1b1B1a & #2b2A).        */
                 }
             }
             break;


        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        case NET_TCP_CONN_STATE_CLOSED:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


                                                                /* ---------- UPDATE TCP CONN TX REMOTE WIN ----------- */
    if (tx_win_update == DEF_YES) {                             /* Update tx win ctrls (see Notes #1a2 & #1b1B2).       */
        NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0, NET_TCP_CONN_TX_WIN_REMOTE_UPDATE, &err);
       (void)&err;                                              /* Ignore err(s).                                       */
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                   NetTCP_RxPktConnHandlerReTxQ()
*
* Description : (1) Handle received valid acknowledgement segments :
*
*                   (a) Update TCP connection re-transmit queue :
*
*                       (1) Update TCP connection's unacknowledged transmit sequences       See Note #2c1
*                       (2) Remove acknowledged TCP segments from a TCP                     See Note #2c2
*                               connection's re-transmit queue
*                       (3) Update TCP connection's round-trip  time calculations
*                               (see 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a1')
*                       (4) Update TCP connection's re-transmit timeout                     See Note #8b
*                       (5) Free   TCP packet buffer(s)
*                       (6) Start  TCP connection's    transmit idle timer
*                               (see 'NetTCP_TxConnTxQ_TimeoutIdleSet()  Note #2a1')
*
*                   (b) Update TCP connection's transmit window(s) :
*
*                       (1) Increment TCP connection's configured         transmit window size
*                       (2) Increment TCP connection's congestion control transmit window size
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandler().
*
*               ack_code    Indicates the received segment's acknowledgement condition :
*               --------
*                               NET_TCP_CONN_RX_ACK_VALID           Received acknowledgement number is
*                                                                       valid     for the TCP connection.
*
*                               NET_TCP_CONN_RX_ACK_DUP             Received acknowledgement number is a
*                                                                       duplicate for the TCP connection.
*
*                           Argument validated in NetTCP_RxPktConnHandler() functions.
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection's re-transmit queue
*                                                                       successfully handled.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                               NET_TCP_ERR_CONN_ACK_INVALID        Invalid received segment acknowledgement.
*                               NET_TCP_ERR_CONN_DATA_INVALID       TCP connection re-transmit queue contains
*                                                                       invalid or improperly sequenced data.
*
*                                                                   ---- RETURNED BY NetTCP_TxConnReTxQ_TimeoutSet() : ----
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*
*                                                                   --- RETURNED BY NetTCP_TxConnWinSizeHandlerCfgd() : ---
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT       TCP connection transmit queue signal fault.
*
*                                                                   - RETURNED BY NetTCP_TxConnWinSizeHandlerCongCtrl() : -
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg().
*
* Note(s)     : (2) (a) The following sections ... :
*
*                       (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                               Check SYN Bit'
*                       (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                               ESTABLISHED STATE'
*
*                   (b) ... generalize that for ...
*
*                       (1) ... the following synchronization-to-connected state transitions ... :
*
*                           (A) SYN-RECEIVED to ESTABLISHED
*                           (B) SYN-SENT     to ESTABLISHED
*
*                       (2) ... & for the following connected states ... :
*
*                           (A) ESTABLISHED
*                           (B) FIN-WAIT-1
*                           (C) CLOSING
*                           (D) CLOSE-WAIT
*                           (E) LAST-ACK
*                               (1) See 'NetTCP_RxPktConnHandlerLastAck()  Notes #2d2B'.
*
*                   (c) ... that ...
*
*                       (1) "If SND.UNA < SEG.ACK <= SND.NXT, SND.UNA should be advanced to equal SEG.ACK" :
*
*                               (A) SND.UNA <- SEG.ACK
*
*                       (2) "Any segments on the retransmission queue which are thereby entirely acknowledged
*                            are removed."
*
*               (3) A TCP connection's re-transmit queue SHOULD be updated ONLY by valid, non-duplicate
*                   received acknowledgement segments.
*
*               (4) Since valid received acknowledgement segments update a TCP connection's last
*                   unacknowledged transmit sequence number ('TxSeqNbrUnackd'), any controls &/or
*                   calculations based on the TCP connection's last unacknowledged transmit sequence
*                   number MUST use the saved/previous value of the TCP connection's last unacknowledged
*                   transmit sequence number ('TxSeqNbrUnackdPrev').
*
*               (5) Since segments enqueued to a TCP connection's re-transmit queue have already been
*                   transmitted to the remote host & reported to the application layer as having been
*                   transmitted, any TCP connection whose re-transmit queue becomes corrupted MUST be
*                   closed to prevent the further transmit of corrupted data.
*
*               (6) Although network packets are NOT required to ensure that network packet headers or
*                   data will locate on CPU word-aligned addresses; many processors may be more efficient
*                   & may even REQUIRE that memory transfers occur on CPU word-aligned addresses [e.g.
*                   processors or devices with direct memory access (DMA) capability].
*
*                   Therefore, to ensure appropriate CPU word alignment; any segment in a TCP connection's
*                   re-transmit queue whose transmit sequences are partially acknowledged MUST acknowledge
*                   an exact number of sequences such that the remaining sequences are aligned on a CPU
*                   word-aligned address.
*
*                   (a) Since RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
*                       Sequence Number' states that in the "SYN-RECEIVED, ESTABLISHED STATE,
*                       FIN-WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE,
*                       LAST-ACK STATE, TIME-WAIT STATE" that "if a segment's contents straddle
*                       the boundary between old and new, only the new parts should be processed";
*                       any data segments partially acknowledged in a TCP connections' re-transmit
*                       queue may be re-transmitted in full or in part since the retransmission of
*                       previously received data is not processed.
*
*               (7) (a) RFC #1122, Section 4.2.3.5 states that "excessive retransmission of the same
*                       segment by TCP indicates some failure of the remote host or the Internet path
*                       ... When the number of transmissions of the same segment reaches a threshold
*                       ... close the connection."
*
*                   (b) However, any segment in a TCP connection's re-transmit queue whose transmit
*                       sequences are partially acknowledged SHOULD NOT be considered the same segment
*                       for purposes of excessive retransmission.
*
*                       Therefore, it seems reasonable that whenever a TCP connection's re-transmit
*                       queue segment's transmit sequences are partially acknowledged; that segment's
*                       re-transmit counter should be reset.
*
*                   See also 'NetTCP_TxConnReTxQ()  Note #3'.
*
*               (8) (a) (1) (A) RFC #793, Section 3.7 'Data Communication : Retransmission Timeout' states
*                               that "the Round Trip Time (RTT) ... [is] the elapsed time between" :
*
*                               (1) "sending a data octet with a particular sequence number and"   ...
*                               (2) "receiving an acknowledgment that covers that sequence number" ...
*                               (3) "(segments sent do not have to match segments received)".
*
*                           (B) (1) RFC #2988, Section 3 adds that :
*
*                                   (a) "Traditionally, TCP implementations have taken one RTT measurement at
*                                        a time (typically once per RTT)."
*
*                               (2) RFC #2988, Section 1 states that "in some situations it may be beneficial
*                                   for a TCP sender to be more conservative than the algorithms detailed in
*                                   this document allow.  However, a TCP MUST NOT be more aggressive than the
*                                   ... algorithms allow".
*
*                           See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a2'.
*
*                       (2) RFC #2988, Section 3 states that "TCP MUST use Karn's algorithm ... for taking
*                           RTT samples.  That is, RTT samples MUST NOT be made using segments that were
*                           retransmitted (and thus for which it is ambiguous whether the reply was for
*                           the first instance of the packet or a later instance)".
*
*                           (A) (1) To determine if any segment(s) from a TCP connection's re-transmit queue
*                                   have been re-transmitted (i.e. transmitted more than once), the TCP
*                                   connection's transmit unacknowledged & un-re-transmitted sequence numbers
*                                   are compared :
*
*                                   (a) If NO  sequences in the TCP connection's re-transmit queue have been
*                                          re-transmitted,  the TCP connection's    transmit unacknowledged &
*                                       un-re-transmitted sequence numbers will be equal.
*
*                                   (b) If ANY sequences in the TCP connection's re-transmit queue have been
*                                          re-transmitted,  the TCP connection's    transmit unacknowledged
*                                          sequence number will be less than the un-re-transmitted sequence
*                                          number.
*
*                               (2) If a received acknowledgement fully acknowledges ALL re-transmitted
*                                   segment(s) from a TCP connection's re-transmit queue, the TCP connection
*                                   advances its un-re-transmitted sequence number to the received segment's
*                                   acknowledgement sequence number.
*
*                           (B) Although RTT measurements could be calculated for ALL transmitted segments;
*                               to simplify implementation of Karn's algorithm :
*
*                               (1) Only a single RTT measurement is calculated, ...        See Note #8a1B1a
*                               (2) (a) per TCP acknowledgement received         ...        See Note #8a1A2
*                                         AND
*                                   (b) the segment at the head of a TCP connection's
*                                           re-transmit queue.                              See Note #8a1A1
*
*                           See also 'NetTCP_TxConnReTxQ()  Note #4'.
*
*                   (b) RFC #2988, Section 5 states that "the following is the RECOMMENDED algorithm for
*                       managing the retransmission timer" :
*
*                       (2) "When all outstanding data has been acknowledged, turn off the retransmission
*                            timer."
*
*                       (3) "When an ACK is received that acknowledges new data, restart the retransmission
*                            timer so that it will expire after RTO seconds (for the current value of RTO)."
*
*                       See also 'NetTCP_TxConnReTxQ()  Note #2b1A'.
*
*               (9) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
*                   comparisons for sequence number windows that overflow the sequence number space.
*
*                   (a) For example, the next sequence octet to transmit (SND.NXT) is typically greater
*                       than or equal to any received segment's acknowledgement number (SEG.ACK) :
*
*                           (1) SND.NXT >= SEG.ACK
*
*                       However, if SND.NXT overflows the sequence number space, it will be MUCH less
*                       than SEG.ACK until SEG.ACK also overflows :
*
*                           (2) SND.NXT << SEG.ACK
*
*                   (b) (1) Therefore, in order to determine if a received segment's acknowledgement value
*                           fully acknowledges previously transmitted segment(s) in the TCP connection's
*                           re-transmit queue, the following unsigned arithmetic comparison MUST be checked :
*
*                               (A) (SND.NXT - SEG.ACK)  <=  SND.NXT - (ReTxQCur.SeqNbr + ReTxQCur.SegLen)
*
*                           See also 'NetTCP_RxPktConnIsValidAck()  Note #3a2'.
*
*                       (2) In order to determine if a received segment's acknowledgement partially
*                           acknowledges a previously received segment in the TCP connection's re-
*                           transmit queue, the following unsigned arithmetic comparison MUST be checked :
*
*                               (A) (ReTxQCur.SeqNbr + ReTxQCur.SegLen) - SEG.ACK  <  ReTxQCur.SegLen
*
*                           See also 'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #4c2'.
*
*                       (3) In order to determine if a received segment's acknowledgement should
*                           advance the TCP connection's un-re-transmitted sequence number(s), the
*                           following unsigned arithmetic comparison MUST be true :
*
*                               (A) (SEG.ACK - ReTxQ.UnReTxdSeqNbr)  <=  (SND.NXT - ReTxQ.UnReTxdSeqNbr)
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerReTxQ (NET_TCP_CONN      *p_conn,
                                            NET_TCP_ACK_CODE   ack_code,
                                            NET_BUF_HDR       *p_buf_hdr,
                                            NET_ERR           *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_SEQ_NBR        seq_nbr_cur                = 0u;
    NET_TCP_SEQ_NBR        seq_nbr_delta              = 0u;
    NET_TCP_SEQ_NBR        seq_nbr_next_qd            = 0u;
#endif
    NET_TCP_SEQ_NBR        ack_delta_seq              = 0u;
    NET_TCP_SEQ_NBR        ack_delta_seq_align        = 0u;
    NET_TCP_SEQ_NBR        ack_delta_seq_align_offset = 0u;
    NET_TCP_SEQ_NBR        ack_delta_unretxd          = 0u;
    NET_TCP_SEQ_NBR        ack_delta_next             = 0u;
    NET_TCP_SEQ_NBR        seq_delta_unretxd          = 0u;
    NET_TCP_SEQ_NBR        seq_delta_next             = 0u;
    NET_TCP_SEQ_NBR        seq_nbr_next               = 0u;
    NET_TCP_SEQ_NBR        seq_nbr                    = 0u;
    NET_TCP_SEG_SIZE       seg_len                    = 0u;
    NET_TCP_SEG_SIZE       seg_len_tot                = 0u;
    NET_TCP_SEG_SIZE       seg_len_data               = 0u;
    NET_TCP_SEG_SIZE       seg_len_data_tot           = 0u;
    NET_TCP_TX_RTT_TS_MS   seg_rtt_ts_txd_ms          = 0u;
    NET_TCP_TX_RTT_TS_MS   seg_rtt_ts_rxd_ms          = 0u;
    CPU_BOOLEAN            segs_re_txd                = DEF_NO;
    CPU_BOOLEAN            seqs_ackd                  = DEF_NO;
    CPU_BOOLEAN            done                       = DEF_NO;
    CPU_BOOLEAN            tmr_update                 = DEF_NO;
    NET_BUF               *p_buf_q                    = DEF_NULL;
    NET_BUF               *p_buf_q_head               = DEF_NULL;
    NET_BUF               *p_buf_q_prev               = DEF_NULL;
    NET_BUF               *p_buf_q_next               = DEF_NULL;
    NET_BUF_HDR           *p_buf_q_hdr                = DEF_NULL;
    NET_BUF_HDR           *p_buf_q_head_hdr           = DEF_NULL;
    NET_BUF_HDR           *p_buf_q_prev_hdr           = DEF_NULL;



#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CLOSED:
                      switch (ack_code) {
                          case NET_TCP_CONN_RX_ACK_VALID:
                               break;


                          case NET_TCP_CONN_RX_ACK_NONE:
                          case NET_TCP_CONN_RX_ACK_INVALID:
                          case NET_TCP_CONN_RX_ACK_DUP:
                          case NET_TCP_CONN_RX_ACK_PREV:
                          default:
                              *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
                               return;
                      }
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                     *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      switch (ack_code) {
                          case NET_TCP_CONN_RX_ACK_VALID:
                          case NET_TCP_CONN_RX_ACK_DUP:
                               break;


                          case NET_TCP_CONN_RX_ACK_NONE:
                          case NET_TCP_CONN_RX_ACK_INVALID:
                          case NET_TCP_CONN_RX_ACK_PREV:
                          default:
                              *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
                               return;
                      }
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                     *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        case NET_TCP_CONN_STATE_CLOSED:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
#endif



                                                                /* ------------- UPDATE UNACK'D TX SEQ(S) ------------- */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    seq_nbr_cur                = p_conn->TxSeqNbrUnAckd;
    seq_nbr_delta              = p_conn->TxSeqNbrUnAckdAlignDelta;
#endif
    p_conn->TxSeqNbrUnAckdPrev = p_conn->TxSeqNbrUnAckd;        /* Save prev tx unack'd seq nbr (see Note #4).          */
    p_conn->TxSeqNbrUnAckd     = p_buf_hdr->TCP_AckNbr;         /* Ack  prev'ly unack'd tx segs (see Note #2c1).        */

    if (p_conn->TxSeqNbrUnAckd == p_conn->TxSeqNbrLast) {       /* If last tx'd seq ack'd, close TCP conn tx.           */
        switch (p_conn->TxQ_State) {
            case NET_TCP_TX_Q_STATE_CLOSING:
                 p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED;
                 break;


            case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                 p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED_SUSPEND;
                 break;


            default:                                            /* 'default' case intentionally empty.                  */
                 break;
        }
    }


                                                                /* --------- REMOVE ACK'D SEG(S) FROM RE-TX Q --------- */
    if (ack_code != NET_TCP_CONN_RX_ACK_VALID) {                /* If ack NOT valid, non-dup ack; ...                   */
       *p_err = NET_TCP_ERR_NONE;                               /* ... do NOT update re-tx Q (see Note #3).             */
        return;
    }

    p_buf_q_head     = p_conn->ReTxQ_Head;
    p_buf_q_prev     = DEF_NULL;
    p_buf_q          = p_buf_q_head;
    seg_len_tot      = 0u;
    seg_len_data_tot = 0u;
                                                                /* Chk re-tx'd seg(s) [see Notes #8a2A1 & #4].          */
    segs_re_txd      = (p_conn->TxSeqNbrUnAckdPrev == p_conn->TxSeqNbrUnReTxd)
                     ?  DEF_NO : DEF_YES;
    seqs_ackd        =  DEF_NO;
    done             =  DEF_NO;

    while ((p_buf_q != DEF_NULL) &&                             /* While NOT @ re-tx Q tail, ...                        */
           (done    ==  DEF_NO)) {                              /* ... srch for ack'd tx segs to remove (see Note #2c2).*/

        p_buf_q_hdr  = &p_buf_q->Hdr;
        p_buf_q_next =  p_buf_q_hdr->NextPrimListPtr;
        seq_nbr      =  p_buf_q_hdr->TCP_SeqNbr;
        seg_len      =  p_buf_q_hdr->TCP_SegLen;
        seg_len_data =  seg_len;
        if (p_buf_q_hdr->TCP_SegSync  == DEF_YES) {             /* If sync  seg                           ...           */
            if (seg_len_data >= NET_TCP_SEG_LEN_SYNC) {         /* ... &        seg len >= sync  seg len, ...           */
                seg_len_data -= NET_TCP_SEG_LEN_SYNC;           /* ... dec data seg len by sync  seg len.               */
            }
        }
        if (p_buf_q_hdr->TCP_SegClose == DEF_YES) {             /* If close seg                           ...           */
            if (seg_len_data >= NET_TCP_SEG_LEN_CLOSE) {        /* ... &        seg len >= close seg len, ...           */
                seg_len_data -= NET_TCP_SEG_LEN_CLOSE;          /* ... dec data seg len by close seg len.               */
            }
        }

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        seq_nbr_next_qd  = seq_nbr + p_conn->TxSeqNbrUnAckdAlignDelta;
        if (seq_nbr_cur != seq_nbr_next_qd) {                   /* If next q'd seg's seq nbr NOT consecutive, ...       */
                                                                /* ... close TCP conn (see Note #5).                    */
            NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
           *p_err = NET_TCP_ERR_CONN_DATA_INVALID;
            return;
        }
#endif
                                                                /* Chk if rx'd seg acks cur re-tx Q seg.                */
        ack_delta_next = (p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr);
        seq_nbr_next   = (seq_nbr + seg_len);
        seq_delta_next = (p_conn->TxSeqNbrNext - seq_nbr_next);

        if (ack_delta_next <= seq_delta_next) {                 /* If seg fully acks cur re-tx Q seg (see Note #9b1A),  */
            p_buf_q_prev                     = p_buf_q;
            p_buf_q                          = p_buf_q_next;    /* ... adv to next re-tx Q seg.                         */
            p_conn->TxSeqNbrUnAckdAlignDelta = 0u;
            seg_len_tot                     += seg_len;
            seg_len_data_tot                += seg_len_data;
            seqs_ackd                        = DEF_YES;

            if (p_buf_q == p_buf_q_prev) {
                done = DEF_YES;
            }

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
            seq_nbr_cur   += (seg_len - seq_nbr_delta);
            seq_nbr_delta  = 0u;
#endif

        } else {                                                /* Else chk partial re-tx Q seg ack (see Note #9b2A) :  */
            ack_delta_seq = p_buf_hdr->TCP_AckNbr - seq_nbr;
            if (ack_delta_seq < 1) {                            /* If NO   seqs ack'd for cur re-tx Q seg, ...          */
                                                                /* ... do NOT update seg.                               */
                                                                /* Empty If Statement                                   */
            } else if (ack_delta_seq < seg_len) {               /* If SOME seqs ack'd for cur re-tx Q seg,  ...         */

                                                                /* Align partial ack to word boundary (see Note #6).    */
                ack_delta_seq_align_offset       = (ack_delta_seq % sizeof(CPU_ALIGN));
                ack_delta_seq_align              = (ack_delta_seq - ack_delta_seq_align_offset);
                p_conn->TxSeqNbrUnAckdAlignDelta =  ack_delta_seq_align_offset;

                                                                /* ...   update cur seg's seq nbr & seg len ...         */
                p_buf_q_hdr->TCP_SeqNbr         += ack_delta_seq_align;
                p_buf_q_hdr->TCP_SegLen         -= ack_delta_seq_align;
                p_buf_q_hdr->TCP_SegLenData     -= ack_delta_seq_align;
                seg_len_tot                     += ack_delta_seq_align;
                seg_len_data_tot                += ack_delta_seq_align;
                                                                /* ... & update TCP tx buf ctrls.                       */
                p_buf_q_hdr->DataIx             += ack_delta_seq_align;
                p_buf_q_hdr->DataLen            -= ack_delta_seq_align;
                p_buf_q_hdr->TotLen             -= ack_delta_seq_align;

                p_buf_q_hdr->TCP_SegReTxCtr      = 0u;          /* Reset re-tx ctr (see Note #7b).                      */

                seqs_ackd                        = DEF_YES;

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
            } else {                                            /* Else fully-ack'd-seg chk failed?; close TCP conn?    */
                NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
               *p_err = NET_TCP_ERR_CONN_DATA_INVALID;
                return;
            }
#else
            } else {
                                                                /* Empty Else Statement                                 */
            }
#endif
            done = DEF_YES;
        }
    }


                                                                /* --------------- UPDATE TCP CONN RTO ---------------- */
    if (seqs_ackd == DEF_YES) {                                 /* If ANY  re-tx Q seq(s) ack'd                     ..  */
        if (segs_re_txd == DEF_NO) {                            /* .. & NO re-tx Q seg(s) re-tx'd (see Note #8a2);  ..  */
                                                                /* ..   get tx'd seg RTT ts       (see Note #8a1A1) ..  */
            p_buf_q_head_hdr  = &p_buf_q_head->Hdr;
            seg_rtt_ts_txd_ms =  p_buf_q_head_hdr->TCP_RTT_TS_Txd_ms;
                                                                /* ..   get rx'd ack RTT ts       (see Note #8a1A2) ..  */
            seg_rtt_ts_rxd_ms =  p_buf_hdr->TCP_RTT_TS_Rxd_ms;
                                                                /* .. & calc/update RTT/RTO       (see Note #1a3).      */
            NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTT_RTO_CALC, seg_rtt_ts_txd_ms, seg_rtt_ts_rxd_ms);
        }

        ack_delta_unretxd = p_buf_hdr->TCP_AckNbr - p_conn->TxSeqNbrUnReTxd;
        seq_delta_unretxd = p_conn->TxSeqNbrNext  - p_conn->TxSeqNbrUnReTxd;
        if (ack_delta_unretxd <= seq_delta_unretxd) {           /* If (ack - un-re-tx'd) < (next - un-re-tx'd), ...     */
                                                                /* ... acks ALL re-tx'd seg(s)        [see Note #9b3A], */
            p_conn->TxSeqNbrUnReTxd = p_buf_hdr->TCP_AckNbr;    /* ... adv   un-re-tx'd seq(s) to ack (see Note #8a2A2).*/
        }
    }


                                                                /* ------------- UPDATE TCP CONN RE-TX Q -------------- */
    tmr_update  = seqs_ackd;                                    /* Update re-tx Q tmr if ANY re-tx Q seqs ack'd ...     */
                                                                /* ... (see Note #8b3).                                 */
    if (p_buf_q != p_buf_q_head) {                              /* If ANY re-tx Q segs fully ack'd, update re-tx Q.     */

        if (p_buf_q != DEF_NULL) {                              /* If re-tx Q still NOT empty, . ..                     */
            p_buf_q_prev_hdr                  = &p_buf_q_prev->Hdr;
            p_buf_q_prev_hdr->NextPrimListPtr =  DEF_NULL;
                                                                /* ... update re-tx Q head.                             */
            p_conn->ReTxQ_Head                =  p_buf_q;
            p_buf_q_hdr->PrevPrimListPtr      =  DEF_NULL;

        } else {                                                /* Else clr   re-tx Q.                                  */
            p_conn->ReTxQ_Head = DEF_NULL;
            p_conn->ReTxQ_Tail = DEF_NULL;

            if (p_conn->ReTxQ_Tmr != DEF_NULL) {                /* Free  re-tx Q      tmr (see Note #8b2).              */
                NetTmr_Free(p_conn->ReTxQ_Tmr);
            }
            p_conn->ReTxQ_Tmr = DEF_NULL;
            tmr_update        = DEF_NO;

            NetTCP_TxConnTxQ_TimeoutIdleSet(p_conn);            /* Start    tx Q idle tmr (see Note #1a6).              */
        }

        (void)NetTCP_TxPktFree(p_buf_q_head);                   /* Free ALL fully ack'd seg pkt buf(s).                 */
    }


    if (tmr_update == DEF_YES) {                                /* Update re-tx Q tmr.                                  */
        NetTCP_TxConnReTxQ_TimeoutSet(p_conn, DEF_NO, NET_TCP_CONN_CLOSE_ALL, p_err);
        if (*p_err != NET_TCP_ERR_NONE) {
             return;
        }
    }

                                                                /* ----------- UPDATE TCP CONN TX WIN SIZES ----------- */
                                                                /* Inc TCP conn's tx win sizes (see Note #1b).          */
    NetTCP_TxConnWinSizeHandlerCfgd(p_conn, seg_len_data_tot, NET_TCP_CONN_TX_WIN_INC, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }

    NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                        DEF_NULL,
                                        NET_TCP_CONN_RX_ACK_NONE,
                                        seg_len_data_tot,
                                        NET_TCP_CONN_TX_WIN_INC,
                                        p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }



   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                              NetTCP_RxPktConnHandlerListenQ_IsAvail()
*
* Description : Check if application layer listen queue is available to queue a new connection.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandlerListen().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Application layer listen queue successfully
*                                                                       checked; check return value for listen
*                                                                       queue availability.
*
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid application connection.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid network connection family.
*
*                                                                   ---- RETURNED BY NetConn_ID_AppGet() : ----
*                               NET_CONN_ERR_INVALID_CONN           Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED               Network connection NOT currently used.
*
* Return(s)   : DEF_YES, if application connection's listen queue is available to queue a new connection.
*
*               DEF_NO,  otherwise.
*
* Caller(s)   : NetTCP_RxPktConnHandlerListen().
*
* Note(s)     : (1) (a) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 257-258 states
*                       that :
*
*                       (1) "Each listening end point has a fixed length queue of connections that have been
*                            accepted by TCP (i.e., the three-way handshake is complete), but not yet accepted
*                            by the application."
*
*                       (2) "The application specifies a limit to this queue, commonly called the backlog" :
*
*                           (A) "This backlog must be between 0 and 5, inclusive."
*                           (B) "(Most applications specify the maximum value of 5.)"
*
*                       (3) "When a connection request arrives (i.e., the SYN segment), ... the current number
*                            of connections already queued for this listening end point [is checked] to see
*                            whether to accept the connection or not."
*
*                       (4) "If there is room on this listening end point's queue for this new connection, ...
*                            the TCP module ACKs the SYN and completes the connection."
*
*                       (5) "If there is not room on the queue for the new connection" :
*
*                           (A) "TCP just ignores the received SYN."
*                           (B) "Nothing is sent back (i.e., no RST segment)."
*
*                   (b) (A) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 15.9, Page 455
*                           reiterates that :
*
*                           (2) A "listen ... socket ... specifies a limit on the number of connections that can
*                               be queued on the socket," ...
*
*                           (5) "after which the socket layer refuses to queue additional connection requests.
*                                When this occurs, TCP ignores incoming connection requests."
*
*                       (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 28.2, Page 930
*                           also states that :
*
*                           (5) (A) "By silently dropping the segment" ...
*                               (B) "and not replying with an RST,"    ...
*                               (C) "The client's connection request should time out, causing the client to
*                                    retransmit the SYN."
*
*                       (C) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 259-260
*                           summarizes that :
*
*                           (5) (A) "TCP ignores the incoming SYN when the queue is full," ...
*                               (B) "and doesn't respond with an RST,"                     ...
*
*                               (C) (1) "because ... this condition could change in a short while ... [and] by
*                                        ignoring the SYN, the server forces the client TCP to re-transmit the
*                                        SYN later, hoping that the queue will then have room for the new
*                                        connection".
*
*                                   (2) Whereas page 259-260 counters that "if the server's TCP responded with
*                                       a reset, the client's active open would abort".
*
*                   See also 'net_sock.c  NetSock_ListenQ_IsAvail()  Note #2'.
*
*               (2) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
*                   since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
*                   is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
*                   The 'else'-conditional code is included for completeness & as an extra precaution in case
*                   'net_conn.h' is incorrectly modified.
*********************************************************************************************************
*/

static  CPU_BOOLEAN  NetTCP_RxPktConnHandlerListenQ_IsAvail (NET_TCP_CONN  *p_conn,
                                                             NET_ERR       *p_err)
{
    NET_CONN_ID  conn_id;
    NET_CONN_ID  conn_id_app;
    CPU_BOOLEAN  q_avail;
    NET_ERR      err;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err =  NET_TCP_ERR_CONN_NOT_USED;
             return (DEF_NO);


        case NET_TCP_CONN_STATE_LISTEN:
             break;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_OP;
             return (DEF_NO);


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
             return (DEF_NO);
    }
#endif


    conn_id     = p_conn->ID_Conn;
    conn_id_app = NetConn_ID_AppGet(conn_id, p_err);            /* Get TCP listen conn's app conn id.                   */
    if (*p_err != NET_CONN_ERR_NONE) {
         return (DEF_NO);
    }
    if (conn_id_app == NET_CONN_ID_NONE) {
       *p_err =  NET_TCP_ERR_INVALID_CONN_ID;
        return (DEF_NO);
    }


                                                                /* -------------- CHK APP LISTEN Q AVAIL -------------- */
    if (p_conn->FnctAppListenQ_IsAvail != DEF_NULL) {
        q_avail = p_conn->FnctAppListenQ_IsAvail(conn_id_app, &err);
    } else {
       *p_err = NET_TCP_ERR_INVALID_CONN;
        return (DEF_NO);
    }

   *p_err =  NET_TCP_ERR_NONE;

    return (q_avail);
}


/*
*********************************************************************************************************
*                                 NetTCP_RxPktConnHandlerSignalConn()
*
* Description : (1) Signal application layer that TCP/transport layer connection's state is now connected :
*
*                   (a) From passive SYN-RECEIVED             state,  signal application layer that
*                             connection request received; connection accept now available.
*
*                   (b) From active  SYN-RECEIVED or SYN-SENT states, signal application layer that
*                             connection request complete.
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandlerSyncRxd(),
*                                                 NetTCP_RxPktConnHandlerSyncTxd().
*
*               state       Current TCP connection state at time of connection signal.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Application layer successfully signaled.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAIL               Application layer signal failed.
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid application connection.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid network connection family.
*
*                                                                   --- RETURNED BY NetConn_ID_AppGet() : ----
*                                                                   - RETURNED BY NetConn_ID_AppCloneGet() : -
*                               NET_CONN_ERR_INVALID_CONN           Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED               Network connection NOT currently used.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSyncRxd(),
*               NetTCP_RxPktConnHandlerSyncTxd().
*
* Note(s)     : (2) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
*                   since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
*                   is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
*                   The 'else'-conditional code is included for completeness & as an extra precaution in case
*                   'net_conn.h' is incorrectly modified.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerSignalConn (NET_TCP_CONN        *p_conn,
                                                 NET_TCP_CONN_STATE   state,
                                                 NET_ERR             *p_err)
{
    NET_CONN_ID  conn_id;
    NET_CONN_ID  conn_id_app;
    NET_ERR      err;
    CPU_BOOLEAN  err_conn;


    conn_id = p_conn->ID_Conn;

                                                                /* ------------------- SIGNAL CONN -------------------- */
    switch (state) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;



        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:               /* See Note #1a.                                        */
                                                                /* Get app conn id clone.                               */
             conn_id_app = NetConn_ID_AppCloneGet(conn_id, p_err);
             if (*p_err != NET_CONN_ERR_NONE) {
                  return;
             }
             if (conn_id_app == NET_CONN_ID_NONE) {
                *p_err = NET_TCP_ERR_INVALID_CONN_ID;
                 return;
             }
                                                                /* Signal app conn accept.                              */
#ifdef  NET_IP_MODULE_EN

             NetSock_ConnSignalAccept((NET_SOCK_ID) conn_id_app,
                                      (NET_CONN_ID) conn_id,
                                      (NET_ERR   *)&err);
            *p_err = (err == NET_SOCK_ERR_NONE) ? NET_TCP_ERR_NONE
                                               : NET_TCP_ERR_CONN_FAIL;

#else                                                           /* See Note #2.                                         */
            (void)&err;                                         /* Prevent 'variable unused' compiler warning.          */
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return;
#endif
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;



        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:                /* See Note #1b.                                        */
        case NET_TCP_CONN_STATE_SYNC_TXD:
                                                                /* Get app conn id.                                     */
             conn_id_app = NetConn_ID_AppGet(conn_id, p_err);
             if (*p_err != NET_CONN_ERR_NONE) {
                  return;
             }
             if (conn_id_app == NET_CONN_ID_NONE) {
                *p_err = NET_TCP_ERR_INVALID_CONN_ID;
                 return;
             }
                                                                /* Signal app conn req.                                 */
#ifdef  NET_IP_MODULE_EN
             NetSock_ConnSignalReq((NET_SOCK_ID) conn_id_app,
                                   (NET_ERR   *)&err);
            *p_err = (err == NET_SOCK_ERR_NONE) ? NET_TCP_ERR_NONE
                                               : NET_TCP_ERR_CONN_FAIL;

#else                                                           /* See Note #2.                                         */
            (void)&err;                                         /* Prevent 'variable unused' compiler warning.          */
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return;
#endif
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;



        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Notes #1a & #1b.                                 */
                                                                /* Get app conn id.                                     */
             err_conn    = DEF_NO;
             conn_id_app = NetConn_ID_AppGet(conn_id, p_err);
             if (*p_err != NET_CONN_ERR_NONE) {
                 err_conn = DEF_YES;
             }
             if (conn_id_app == NET_CONN_ID_NONE) {
                 err_conn = DEF_YES;
             }

             if (err_conn == DEF_YES) {                         /* If app conn id get failed, get app conn id clone.    */
                 conn_id_app = NetConn_ID_AppCloneGet(conn_id, p_err);
                 if (*p_err != NET_CONN_ERR_NONE) {
                      return;
                 }
                 if (conn_id_app == NET_CONN_ID_NONE) {
                    *p_err = NET_TCP_ERR_INVALID_CONN_ID;
                     return;
                 }
             }

#ifdef  NET_IP_MODULE_EN
                                                                /* Signal app conn req.                                 */
             NetSock_ConnSignalReq((NET_SOCK_ID) conn_id_app,
                                   (NET_ERR   *)&err);
            *p_err = (err == NET_SOCK_ERR_NONE) ? NET_TCP_ERR_NONE
                                               : NET_TCP_ERR_CONN_FAIL;
             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }

                                                                /* Signal app conn accept.                              */
             NetSock_ConnSignalAccept((NET_SOCK_ID) conn_id_app,
                                      (NET_CONN_ID) conn_id,
                                      (NET_ERR   *)&err);
            *p_err = (err == NET_SOCK_ERR_NONE) ? NET_TCP_ERR_NONE
                                               : NET_TCP_ERR_CONN_FAIL;

#else                                                           /* See Note #2.                                         */
            (void)&err;                                         /* Prevent 'variable unused' compiler warning.          */
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return;
#endif

             if (*p_err != NET_TCP_ERR_NONE) {
                  return;
             }
             break;



        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                 NetTCP_RxPktConnHandlerSignalClose()
*
* Description : Signal application layer that TCP/transport layer connection's state is now closed.
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_TxConnReqClose(),
*                                                     NetTCP_RxPktConnHandlerFinWait1(),
*                                                     NetTCP_RxPktConnHandlerClosing(),
*                                                     NetTCP_RxPktConnHandlerLastAck().
*
*               data_avail      Indicate whether application data is still available on the TCP connection's
*                                   application receive queue :
*
*                                   DEF_YES                         Application data is     available on the
*                                                                       closing TCP connection's application
*                                                                       receive queue.
*                                   DEF_NO                          Application data is NOT available for the
*                                                                       closing TCP connection's application
*                                                                       receive queue.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Application layer successfully signaled.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAIL               Application layer signal failed.
*                               NET_TCP_ERR_INVALID_CONN_ID         Invalid application connection.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid network connection family.
*
*                                                                   -- RETURNED BY NetConn_ID_AppGet() : ---
*                               NET_CONN_ERR_INVALID_CONN           Invalid network connection number.
*                               NET_CONN_ERR_NOT_USED               Network connection NOT currently used.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnReqClose(),
*               NetTCP_RxPktConnHandlerFinWait1(),
*               NetTCP_RxPktConnHandlerClosing(),
*               NetTCP_RxPktConnHandlerLastAck().
*
* Note(s)     : (1) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the user's
*                       CLOSE can be acknowledged".
*
*                   (b) However, TCP connection should signal the application layer that "the user's close
*                       [is] acknowledged" whenever its re-transmit queue becomes &/or is empty :
*
*                       (1) Transition from LISTEN     to CLOSED
*                       (2) Transition from SYN-SENT   to CLOSED
*
*                       (3) Transition from FIN-WAIT-1 to ...           See also 'NetTCP_RxPktConnHandlerFinWait1()
*                                                                                    Note #2d2B2'
*                           (A) FIN-WAIT-2
*                           (B) TIME-WAIT
*
*                       (4) Transition from CLOSING    to TIME-WAIT     See also 'NetTCP_RxPktConnHandlerClosing()
*                                                                                    Note #2d2B2a2'
*
*                       (5) Transition from LAST-ACK   to CLOSED
*
*               (2) Once an application connection has been signaled of its close, the application connection is
*                   responsible for closing its remaining connection(s).
*
*                   See also 'NetTCP_ConnCloseHandler()  Note #2b1B'.
*
*               (3) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
*                   since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
*                   is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
*                   The 'else'-conditional code is included for completeness & as an extra precaution in case
*                   'net_conn.h' is incorrectly modified.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktConnHandlerSignalClose (NET_TCP_CONN  *p_conn,
                                                  CPU_BOOLEAN    data_avail,
                                                  NET_ERR       *p_err)
{
    NET_CONN_ID  conn_id;
    NET_CONN_ID  conn_id_app;
    NET_ERR      err;

                                                                /* Get conn id's.                                       */
    conn_id     = p_conn->ID_Conn;
    conn_id_app = NetConn_ID_AppGet(conn_id, p_err);
    if (*p_err != NET_CONN_ERR_NONE) {
         return;
    }

    if (conn_id_app == NET_CONN_ID_NONE) {
       *p_err = NET_TCP_ERR_INVALID_CONN_ID;
        return;
    }


                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_LISTEN:                         /* See Note #1b1.                                       */
        case NET_TCP_CONN_STATE_SYNC_TXD:                       /* See Note #1b2.                                       */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:                     /* See Note #1b3.                                       */
        case NET_TCP_CONN_STATE_CLOSING:                        /* See Note #1b4.                                       */
        case NET_TCP_CONN_STATE_LAST_ACK:                       /* See Note #1b5.                                       */
             break;


        case NET_TCP_CONN_STATE_NONE:
        case NET_TCP_CONN_STATE_CLOSED:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


                                                                /* ------------------- SIGNAL CLOSE ------------------- */
#ifdef  NET_IP_MODULE_EN
                                                                /* Signal app conn close.                               */
    NetSock_ConnSignalClose((NET_SOCK_ID) conn_id_app,
                            (CPU_BOOLEAN) data_avail,
                            (NET_ERR   *)&err);
   *p_err = (err == NET_SOCK_ERR_NONE) ? NET_TCP_ERR_NONE
                                      : NET_TCP_ERR_CONN_FAIL;

#else                                                           /* See Note #3.                                         */
   (void)&data_avail;                                           /* Prevent 'variable unused' compiler warnings.         */
   (void)&err;
   *p_err = NET_CONN_ERR_INVALID_FAMILY;
    return;
#endif

    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }

                                                                /* Clr app close flag; ...                              */
    p_conn->ConnCloseAppFlag = DEF_NO;                          /* ... app closes rem'ing conn(s) [see Note #2].        */


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                      NetTCP_RxPktConnIsValidSeq()
*
* Description : Validate a received segment's sequence number with current TCP connection.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Sequence number successfully validated;
*                                                                       check return value.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
* Return(s)   : NET_TCP_CONN_RX_SEQ_INVALID,      if received sequence number invalid for the TCP connection.
*
*               NET_TCP_CONN_RX_SEQ_VALID,        if received sequence number   valid for the TCP connection.
*
*               NET_TCP_CONN_RX_SEQ_SYNC_INVALID, if received sequence number is an invalid synchronization
*                                                    for the TCP connection.
*
*               NET_TCP_CONN_RX_SEQ_SYNC,         if received sequence number is a    valid synchronization
*                                                    for the TCP connection.
*
* Caller(s)   : various.
*
* Note(s)     : (1) Validate received TCP connection sequence numbers :
*
*                       (A) Some TCP receive sequence number validation logic implemented in previous
*                           functions; include duplicate validation logic in NetTCP_RxPktConnIsValidSeq()
*                           only if debug/validation code is enabled (i.e. NET_ERR_CFG_ARG_CHK_DBG_EN is
*                           DEF_ENABLED in 'net_cfg.h').
*
*                   (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1' states
*                       that "if [a] connection [is] ... CLOSED then a reset is sent in response to any
*                       incoming segment".  Thus ALL received segments are invalid.
*
*                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]' :
*
*                       (1) "If the SYN bit is set ... the connection state should be changed to SYN-
*                            RECEIVED ... and any other control or text should be queued for processing
*                            later ... Note that any other incoming control or data ... will be processed
*                            in the SYN-RECEIVED state."
*
*                           Therefore, the ONLY TCP segment data that may be queued in the LISTEN state
*                           MUST be received in a TCP connection request segment.
*
*                       (2) Otherwise "any other control or text-bearing segment (not containing SYN)
*                           must have an ACK and thus would be discarded by the ACK processing ...
*                           [so] drop the segment".
*
*                   (c) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                       Check SYN Bit' :
*
*                       (1) "If ... our SYN has been ACKed ... change the connection state to
*                            ESTABLISHED ... [and] if there are other controls or text in the
*                            segment then continue processing" as for the ESTABLISHED state
*                            (see Note #1d).
*
*                       (2) "Otherwise enter SYN-RECEIVED ... [and] if there are other controls or
*                            text in the segment, queue them for processing after the ESTABLISHED
*                            state has been reached."
*
*                       (3) Otherwise "if neither the SYN or RST bits is set then drop the segment".
*
*                           Therefore, the ONLY TCP segment data that may be queued in the SYN-SENT
*                           state MUST be received in a TCP connection request segment.
*
*                   (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence
*                       Number' states that for the "SYN-RECEIVED STATE, ESTABLISHED STATE, FIN-
*                       WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
*                       STATE, TIME-WAIT STATE ... there are four cases for the acceptability test
*                       for an incoming segment :
*
*                                      Local
*                            Segment  Receive
*                            Length   Window   Test
*                            -------  -------  -------------------------------------------------------
*
*                       (1)     0        0        SEG.SEQ =  RCV.NXT
*
*                       (2)     0       >0        RCV.NXT =< SEG.SEQ               < RCV.NXT + RCV.WND
*
*                       (3)    >0        0        not acceptable
*
*                       (4)    >0       >0        RCV.NXT =< SEG.SEQ               < RCV.NXT + RCV.WND
*                                              or RCV.NXT =< SEG.SEQ + SEG.LEN - 1 < RCV.NXT + RCV.WND
*
*
*                       If the RCV.WND is zero, no segments will be acceptable, but special allowance
*                       should be made to accept valid ACKs ... and RSTs.
*
*                       If an incoming segment is not acceptable, an acknowledgment should be sent in
*                       reply".
*
*                       See also Note #2.
*
*                   (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
*                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
*                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
*                       STATE ... if the SYN is in the window it is an error, send a reset, any
*                       outstanding RECEIVEs and SEND[s] should receive 'reset' responses, all segment
*                       queues should be flushed, the user should also receive an unsolicited general
*                      'connection reset' signal[, and] enter the CLOSED state".
*
*               (2) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
*                   comparisons for sequence number windows that overflow the sequence number space.
*
*                   (a) For example, the next sequence octet to receive (RCV.NXT) is typically less than
*                       or equal to  the next received sequence octet (SEG.SEQ) :
*
*                           (1) RCV.NXT <= SEG.SEQ
*
*                       SEG.SEQ itself is also typically less than RCV.NXT plus the current receive window
*                       size (RCV.WND) :
*
*                           (2) SEG.SEQ < (RCV.NXT + RCV.WND)
*
*                       However, if (RCV.NXT + RCV.WND) or SEG.SEQ overflows the sequence number space,
*                       these values will be MUCH less than SEG.SEQ or RCV.NXT, respectively, until
*                       SEG.SEQ & RCV.NXT also overflow :
*
*                           (3) RCV.NXT + RCV.WND << RCV.NXT
*                                                 << SEG.SEQ
*
*                           (4) SEG.SEQ           << RCV.NXT
*
*                   (b) Therefore, in order to validate a received segment's sequence value as within the
*                       TCP connection's current receive window, one of the following unsigned arithmetic
*                       comparisons MUST be true :
*
*                           (1) (A) (RCV.NXT + RCV.WND) -  SEG.SEQ       <=  (RCV.NXT + RCV.WND) - RCV.NXT
*
*                               (B) (RCV.NXT + RCV.WND) -  SEG.SEQ       <=             RCV.WND
*
*                               (C) (RCV.NXT + RCV.WND) -  SEG.SEQ - 1   <   RCV.WND
*
*                               (D) (RCV.NXT + RCV.WND) - (SEG.SEQ + 1)  <   RCV.WND
*
*                                   (a) Comparison #2b1C's left-hand side decremented by one to modify the
*                                       conditional test from less-than-or-equal-to to just less-than in
*                                       order to satisfy the exact boundary conditions shown in the incoming
*                                       segment acceptability test comparisons (see Notes #1d2 & #1d4).
*
*                           (2) Substituting (SEG.SEQ + SEG.LEN - 1) into SEG.SEQ :
*
*                               (A) (RCV.NXT + RCV.WND)  -  (SEG.SEQ + SEG.LEN - 1 + 1)  <  RCV.WND
*
*                               (B) (RCV.NXT + RCV.WND)  -  (SEG.SEQ + SEG.LEN)          <  RCV.WND
*
*                   (c) In order to determine if a received segment's sequence value is within but NOT
*                       following a closing TCP connection's last valid receive sequence numbers, the
*                       following unsigned arithmetic comparison MUST be checked :
*
*                           (1)  RX.LAST  - (SEG.SEQ + SEG.LEN)  <=  (RX.LAST - RX.NXT)
*********************************************************************************************************
*/

static  NET_TCP_SEQ_CODE  NetTCP_RxPktConnIsValidSeq (NET_TCP_CONN  *p_conn,
                                                      NET_BUF_HDR   *p_buf_hdr,
                                                      NET_ERR       *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_ACK_CODE  ack_code;
#endif
    NET_TCP_SEQ_CODE  seq_code;
    NET_TCP_SEQ_NBR   seq_nbr;
    NET_TCP_SEQ_NBR   seq_win;
    NET_TCP_SEQ_NBR   seq_win_next;
    NET_TCP_SEQ_NBR   seq_win_delta;


   *p_err     = NET_TCP_ERR_NONE;
    seq_code = NET_TCP_CONN_RX_SEQ_INVALID;

    if (p_conn != DEF_NULL) {
        switch (p_conn->ConnState) {
            case NET_TCP_CONN_STATE_FREE:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
                *p_err =  NET_TCP_ERR_CONN_NOT_USED;
                 return (NET_TCP_CONN_RX_SEQ_INVALID);


            case NET_TCP_CONN_STATE_CLOSED:                     /* See Note #1a.                                        */
                 break;


            case NET_TCP_CONN_STATE_LISTEN:                     /* See Note #1b.                                        */
                 if (p_buf_hdr->TCP_SegSync == DEF_YES) {       /* If sync rx'd, ..                                     */
                     seq_code = NET_TCP_CONN_RX_SEQ_SYNC;       /* .. sync's seq nbr valid (see Note #1b1).             */
                 }
                 break;


            case NET_TCP_CONN_STATE_SYNC_TXD:                   /* See Note #1c.                                        */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #1A.                                        */
                 ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return (NET_TCP_CONN_RX_SEQ_INVALID);
                 }
                 if (!((ack_code == NET_TCP_CONN_RX_ACK_VALID) ||
                       (ack_code == NET_TCP_CONN_RX_ACK_NONE))) {
                     return (NET_TCP_CONN_RX_SEQ_INVALID);
                 }
#endif
                 if (p_buf_hdr->TCP_SegSync == DEF_YES) {       /* If valid sync rx'd, ..                               */
                     seq_code = NET_TCP_CONN_RX_SEQ_SYNC;       /* .. sync's seq nbr valid.                             */
                 }
                 break;


            case NET_TCP_CONN_STATE_SYNC_RXD:                   /* See Notes #1d & #1e.                                 */
            case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
            case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
            case NET_TCP_CONN_STATE_CONN:
            case NET_TCP_CONN_STATE_FIN_WAIT_1:
            case NET_TCP_CONN_STATE_FIN_WAIT_2:
            case NET_TCP_CONN_STATE_CLOSING:
            case NET_TCP_CONN_STATE_TIME_WAIT:
            case NET_TCP_CONN_STATE_CLOSE_WAIT:
            case NET_TCP_CONN_STATE_LAST_ACK:
                 if (p_buf_hdr->TCP_SegSync != DEF_NO) {        /* If sync rx'd, ...                                    */
                     return (NET_TCP_CONN_RX_SEQ_SYNC_INVALID); /* ... rtn invalid sync (see Note #1e).                 */
                 }

                 if (p_conn->RxWinSizeActual > 0) {             /* If rx win size > 0, ...                              */
                                                                /* ... chk for seg seq within rx win.                   */
                     switch (p_conn->RxQ_State) {
                         case NET_TCP_RX_Q_STATE_SYNC:
                         case NET_TCP_RX_Q_STATE_CONN:
                              seq_win_next  = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrNext  + p_conn->RxWinSizeActual);
                              seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + 1u);
                              seq_win_delta = (NET_TCP_SEQ_NBR)(seq_win_next         - seq_nbr);

                              if (seq_win_delta == p_conn->RxWinSizeActual) {
                                                                /* Keep-Alive message received.                         */
                                  seq_code = NET_TCP_CONN_RX_SEQ_KEEP_ALIVE;
                              } else if (seq_win_delta < p_conn->RxWinSizeActual) {
                                                                /* If [(next + win) -     seq    ] < win size,          */
                                  seq_code = NET_TCP_CONN_RX_SEQ_VALID; /* .. seq nbr within rx win (see Note #1d2).    */

                              } else if (p_buf_hdr->TCP_SegLen > 0) {
                                  seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
                                  seq_win_delta = (NET_TCP_SEQ_NBR)(seq_win_next         - seq_nbr);
                                                                /* If [(next + win) - (seq + len)] < win size,          */
                                  if (seq_win_delta < p_conn->RxWinSizeActual) {
                                                                /* .. seq nbr within rx win (see Note #1d4).            */
                                      seq_code = NET_TCP_CONN_RX_SEQ_VALID;
                                  }
                              } else {
                                                                /* Empty Else Statement                                 */
                              }
                              break;


                         case NET_TCP_RX_Q_STATE_CLOSED:
                         case NET_TCP_RX_Q_STATE_CLOSING:
                              seq_win_next  = (NET_TCP_SEQ_NBR) p_conn->RxSeqNbrLast;
                              seq_nbr       = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
                              seq_win_delta = (NET_TCP_SEQ_NBR)(seq_win_next         - seq_nbr);
                              seq_win       = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrLast  - p_conn->RxSeqNbrNext);
                              if (seq_win_delta <= seq_win) {   /* If [last - (seq + len)] <= [last - next], ..         */
                                  seq_code = NET_TCP_CONN_RX_SEQ_VALID; /* .. seq nbr within close win (see Note #2c1). */
                              }
                              break;


                         case NET_TCP_RX_Q_STATE_NONE:
                         default:
                              return (NET_TCP_CONN_RX_SEQ_INVALID);
                     }

                 } else {                                       /* Else chk for valid, zero-len seg.                    */
                     if (p_buf_hdr->TCP_SegLenData > 0) {       /* If seg len > 0, ...                                  */
                        *p_err =  NET_TCP_ERR_INVALID_LEN_SEG;  /* ... rtn invalid seg len (see Note #1d3).             */
                         return (NET_TCP_CONN_RX_SEQ_INVALID);
                     }

                     if (p_buf_hdr->TCP_SeqNbr == p_conn->RxSeqNbrNext) { /* If seq nbr equals next rx seq expected, .. */
                         seq_code = NET_TCP_CONN_RX_SEQ_VALID;  /* .. seq nbr valid (see Note #1d1).                    */
                     }
                 }
                 break;


            case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
                 break;


            case NET_TCP_CONN_STATE_NONE:
            default:
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
                *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
                 return (NET_TCP_CONN_RX_SEQ_INVALID);
        }
    }

    return (seq_code);
}


/*
*********************************************************************************************************
*                                      NetTCP_RxPktConnIsValidAck()
*
* Description : Validate a received segment's acknowledgement number with current TCP connection.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Acknowledgement number successfully
*                                                                       validated; check return value.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*
* Return(s)   : NET_TCP_CONN_RX_ACK_INVALID, if    received acknowledgement number invalid for the TCP connection.
*
*               NET_TCP_CONN_RX_ACK_VALID,   if    received acknowledgement number   valid for the TCP connection.
*
*               NET_TCP_CONN_RX_ACK_NONE,    if NO received acknowledgement number.
*
*               NET_TCP_CONN_RX_ACK_DUP,     if    received acknowledgement number is a          duplicate for the
*                                               TCP connection.
*
*               NET_TCP_CONN_RX_ACK_PREV,    if    received acknowledgement number is a previous duplicate for the
*                                               TCP connection.
*
* Caller(s)   : various.
*
* Note(s)     : (1) Validate received TCP connection acknowledgements :
*
*                   (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1' states
*                       that "if [a] connection [is] ... CLOSED then a reset is sent in response to any
*                       incoming segment".  Thus ALL received segments, including acknowledgement
*                       segments, are invalid.
*
*                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
*                       Check for ACK' states that "any acknowledgment is bad if it arrives on a
*                       connection still in the LISTEN state".
*
*                   (c) (1) The following sections generalize that "if SND.UNA < SEG.ACK =< SND.NXT then
*                           the ACK is acceptable", whereas "if SEG.ACK =< SND.UNA, or SEG.ACK > SND.NXT"
*                           then the acknowledgement is unacceptable :
*
*                           (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT
*                                   [State] : Check ACK Bit'
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK
*                                   Field : SYN-RECEIVED STATE'
*                           (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK
*                                   Field : ESTABLISHED  STATE'
*
*                           Including states with similar "processing as for the ESTABLISHED STATE" (see
*                           RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field') :
*
*                           (D) FIN-WAIT-1 STATE
*                           (E) FIN-WAIT-2 STATE
*                           (F) CLOSING    STATE
*                           (G) CLOSE-WAIT STATE
*
*                           See also Note #3a.
*
*                       (2) However, RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT
*                           [State] : Check SYN Bit' also states to "check the SYN bit ... if the ACK is
*                           ok, or there is no ACK".
*
*                           Therefore, the lack of an acknowledgement in the SYN-SENT state is acceptable.
*
*                       (3) However, RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
*                           ACK Field : ESTABLISHED STATE' also states that in the "ESTABLISHED STATE"
*                           or any state with similar "processing as for the ESTABLISHED STATE ... if
*                           the ACK is a duplicate (SEG.ACK =< SND.UNA), it can be ignored".
*
*                           See also Note #3b.
*
*                   (d) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                               TIME-WAIT STATE' states that "the only thing that can arrive in this state is
*                               a retransmission of the remote FIN".
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                               LAST-ACK STATE' states that "the only thing that can arrive in this state is
*                               an acknowledgement of our FIN".
*
*                       (2) However, it is possible that some but NOT all transmitted data has been received
*                           by the remote host.  In other words, the remote host may have received some but
*                           NOT ALL transmitted data preceding this host's connection close request.
*
*                           Therefore, acknowledgements validated by as within the transmit window MUST
*                           be received & processed as in connected states.
*
*               (2) RFC #793 contains multiple errors/inconsistencies regarding the boundary conditions
*                   of TCP sequence/acknowledgement inequalities -- i.e. some of the expressions incorrectly
*                   include or exclude the equality condition.
*
*                   RFC #1122, Section 4.2.2.20 corrects some but NOT all of these errors/inconsistencies.
*
*               (3) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
*                   comparisons for sequence number windows that overflow the sequence number space.
*
*                   (a) (1) For example, the next sequence octet to transmit (SND.NXT) is typically greater
*                           than or equal to the last unacknowledged transmit sequence octet (SND.UNA) :
*
*                               (A) SND.NXT >= SND.UNA
*
*                           However, when SND.NXT overflows the sequence number space, it will be MUCH less
*                           than SND.UNA until SND.UNA also overflows :
*
*                               (B) SND.NXT << SND.UNA
*
*                       (2) Therefore, in order to validate a received segment's acknowledgement value
*                           (SEG.ACK) as within the TCP connection's current transmit acknowledgement
*                           window, the following unsigned arithmetic comparison MUST be true :
*
*                               (A) (SND.NXT - SEG.ACK)  <  (SND.NXT - SND.UNA)
*
*                   (b) (1) Typically, duplicate acknowledgements are less than or equal to the last
*                           unacknowledged transmit sequence octet (SND.UNA) :
*
*                               (A) SEG.ACK <= SND.UNA
*
*                           However, when SND.UNA overflows the sequence number space, it will be MUCH less
*                           than duplicate acknowledgements until these duplicates also overflow :
*
*                               (B) SEG.ACK >> SND.UNA
*
*                       (2) Therefore, in order to validate SEG.ACK as a recent duplicate acknowledgement
*                           for the TCP connection's current transmit acknowledgement window, the following
*                           unsigned arithmetic comparison MUST be true :
*
*                               (A) (SND.UNA - SEG.ACK)  <=  (WIN_SIZE_SCALE * TxWinSizeRemote)
*
*                                       where
*
*                                           WIN_SIZE_SCALE          is some window-size scalar multiplier
*                                           TxWinSizeRemote         is the remote host's last-advertised
*                                                                       receive window size, which is this
*                                                                       host's transmit remote window size
*********************************************************************************************************
*/

static  NET_TCP_ACK_CODE  NetTCP_RxPktConnIsValidAck (NET_TCP_CONN  *p_conn,
                                                      NET_BUF_HDR   *p_buf_hdr,
                                                      NET_ERR       *p_err)
{
    NET_TCP_ACK_CODE  ack_code;
    NET_TCP_SEQ_NBR   ack_delta_next;
    NET_TCP_SEQ_NBR   ack_delta_unackd;
    NET_TCP_SEQ_NBR   ack_win;
    NET_TCP_SEQ_NBR   ack_dup_win;


   *p_err     = NET_TCP_ERR_NONE;
    ack_code = NET_TCP_CONN_RX_ACK_INVALID;

    if (p_conn != DEF_NULL) {
        switch (p_conn->ConnState) {
            case NET_TCP_CONN_STATE_FREE:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
                *p_err =  NET_TCP_ERR_CONN_NOT_USED;
                 return (NET_TCP_CONN_RX_ACK_INVALID);


            case NET_TCP_CONN_STATE_CLOSED:                     /* See Note #1a.                                        */
            case NET_TCP_CONN_STATE_LISTEN:                     /* See Note #1b.                                        */
                 if (p_buf_hdr->TCP_SegAck != DEF_NO) {         /* If ack rx'd, ...                                     */
                     return (NET_TCP_CONN_RX_ACK_INVALID);      /* ... rtn invalid ack.                                 */
                 }
                 ack_code = NET_TCP_CONN_RX_ACK_NONE;
                 break;


            case NET_TCP_CONN_STATE_SYNC_TXD:
                 if (p_buf_hdr->TCP_SegAck == DEF_NO) {         /* If NO ack rx'd, ...                                  */
                     return (NET_TCP_CONN_RX_ACK_NONE);         /* ... rtn valid ack (see Note #1c2).                   */
                 }
                                                                /* 'break' intentionally omitted; MUST execute ...      */
                                                                /* ...  the following case (see Note #1c1A) :  ...      */
                                                                /* -------- ... 'NET_TCP_CONN_STATE_SYNC_RXD'. -------- */
            case NET_TCP_CONN_STATE_SYNC_RXD:                   /* See Note #1c1B.                                      */
            case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
            case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
                 if (p_buf_hdr->TCP_SegAck != DEF_YES) {        /* If NO ack rx'd, ...                                  */
                     return (NET_TCP_CONN_RX_ACK_NONE);         /* ... rtn NO ack.                                      */
                 }



                 ack_delta_next = p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr;
                 ack_win        = p_conn->TxSeqNbrNext - p_conn->TxSeqNbrUnAckd;

                 if (p_buf_hdr->TCP_SegClose == DEF_YES) {
                     ack_win++;
                 }


                 if (ack_delta_next < ack_win) {                /* If (next - ack) < ack win, ...                       */
                     ack_code = NET_TCP_CONN_RX_ACK_VALID;      /* ... ack is within ack win (see Note #3a2A).          */
                 }
                 break;


            case NET_TCP_CONN_STATE_CONN:                       /* See Note #1c1C.                                      */
            case NET_TCP_CONN_STATE_FIN_WAIT_1:                 /* See Note #1c1D.                                      */
            case NET_TCP_CONN_STATE_FIN_WAIT_2:                 /* See Note #1c1E.                                      */
            case NET_TCP_CONN_STATE_CLOSING:                    /* See Note #1c1F.                                      */
            case NET_TCP_CONN_STATE_CLOSE_WAIT:                 /* See Note #1c1G.                                      */
            case NET_TCP_CONN_STATE_TIME_WAIT:                  /* See Note #1d2.                                       */
            case NET_TCP_CONN_STATE_LAST_ACK:                   /* See Note #1d2.                                       */
                 if (p_buf_hdr->TCP_SegAck != DEF_YES) {        /* If NO ack rx'd, ...                                  */
                     return (NET_TCP_CONN_RX_ACK_NONE);         /* ... rtn NO ack.                                      */
                 }

                 ack_delta_next = p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr;
                 ack_win        = p_conn->TxSeqNbrNext - p_conn->TxSeqNbrUnAckd;

                 if (p_buf_hdr->TCP_SegClose == DEF_YES) {
                     ack_win++;
                 }

                 if (ack_delta_next < ack_win) {                /* If (next - ack) < ack win, ...                       */
                     ack_code = NET_TCP_CONN_RX_ACK_VALID;      /* ... ack is within ack win (see Note #3a2A).          */

                 } else {
                     ack_delta_unackd = p_conn->TxSeqNbrUnAckd - p_buf_hdr->TCP_AckNbr;
                     if (ack_delta_unackd < 1) {                /* If (unackd - ack) = 0, ...                           */
                         ack_code = NET_TCP_CONN_RX_ACK_DUP;    /* ... ack is           dup ack.                        */
                                                                /* ... (see Note  #1c3).                                */

                     } else {
                         ack_dup_win  = (NET_TCP_SEQ_NBR)(NET_TCP_ACK_NBR_DUP_WIN_SIZE_SCALE * p_conn->TxWinSizeRemote);
                         if (ack_delta_unackd <= ack_dup_win) { /* If (unackd - ack) <= dup ack win, ...                */
                             ack_code =  NET_TCP_CONN_RX_ACK_PREV; /* ... ack is recent    dup ack      ...             */
                                                                /* ... (see Notes #1c3 & #3b2A).                        */
                         } else {
                             ack_code =  NET_TCP_CONN_RX_ACK_OTW;
                         }
                     }
                 }
                 break;


            case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
                 break;


            case NET_TCP_CONN_STATE_NONE:
            default:
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
                *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
                 return (NET_TCP_CONN_RX_ACK_INVALID);
        }
    }

    return (ack_code);
}


/*
*********************************************************************************************************
*                                     NetTCP_RxPktConnIsValidReset()
*
* Description : Validate a received segment's reset flag, if any, with current TCP connection.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    Received segment's reset flag successfully
*                                                                       validated; check return value.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*
*                                                                   - RETURNED BY NetTCP_RxPktConnIsValidSeq() : -
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
* Return(s)   : NET_TCP_CONN_RX_RESET_INVALID, if    received reset flag invalid for the TCP connection.
*
*               NET_TCP_CONN_RX_RESET_VALID,   if    received reset flag   valid for the TCP connection;
*                                                 i.e. reset the TCP connection.
*
*               NET_TCP_CONN_RX_RESET_NONE,    if NO received reset flag.
*
* Caller(s)   : various.
*
* Note(s)     : (1) See the following RFC's for TCP reset validation summary :
*
*                   (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
*                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES'
*                   (c) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2
*
*               (2) Validate received TCP connection resets :
*
*                       (A) Some TCP receive reset validation logic implemented in previous functions; include
*                           duplicate validation logic in NetTCP_RxPktConnIsValidReset() only if debug/validation
*                           code is enabled (i.e. NET_ERR_CFG_ARG_CHK_DBG_EN is DEF_ENABLED in 'net_cfg.h').
*
*                   (a) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED [State]' states
*                           that "if the state is CLOSED ... an incoming segment containing a RST is discarded".
*
*                       (2) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]'
*                               states that if "the state is LISTEN ... an incoming RST should be ignored".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "if the receiver ... of a RST ... was in the LISTEN state, it ignores it".
*
*                       (3) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                               Check RST Bit' states that "if the RST bit is set [and] if the ACK was
*                               acceptable then ... enter CLOSED state".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
*                               that "in the SYN-SENT state (a RST received in response to an initial SYN), the
*                               RST is acceptable if the ACK field acknowledges the SYN".
*
*                               (1) However, since receiving a TCP connection request/synchronization segment
*                                   with no acknowledgement number in the SYN-SENT state is permitted, then
*                                   a received TCP reset segment with no acknowledgement number MUST also be
*                                   acceptable.
*
*                           See also Note #2a5C.
*
*                       (4) (A) (1) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
*                                   summarizes that "in all states except SYN-SENT, all reset (RST) segments
*                                   are validated by checking their SEQ-fields.  A reset is valid if its
*                                   sequence number is in the window".
*
*                               (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                                   reiterates that the received segment's reset is valid if and only if its
*                                   sequence number is valid since it follows RFC #793, Section 3.9 'Event
*                                   Processing : SEGMENT ARRIVES : Check Sequence Number'.
*
*                               (3) RFC #793, Section 3.3 states "that when the receive window is zero no
*                                   segments should be acceptable except ACK segments ... However, even when
*                                   the receive window is zero, a TCP must process the RST ... fields of all
*                                   incoming segments".
*
*                                   However, this contradicts the following sections which state that a
*                                   "received segment's reset is valid if and only if its sequence number if
*                                   valid" & that "if an incoming segment is not acceptable ... [and] the RST
*                                   bit is set, ... drop the segment" :
*
*                                   (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
*                                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
*                                           Sequence Number'
*
*                               See also Note #2a5B.
*
*                           (B) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                                   states that in the "SYN-RECEIVED STATE" that "if the RST bit is set [and]
*                                   this connection was initiated with a passive OPEN (i.e., came from the
*                                   LISTEN state), then return this connection to the LISTEN state ... If this
*                                   connection was initiated with an active OPEN (i.e., came from SYN-SENT state)
*                                   then the connection was refused, ... enter the CLOSED state".
*
*                               (2) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
*                                   reiterates that "if the receiver ... of a RST ... was in SYN-RECEIVED state
*                                   and had previously been in the LISTEN state, then the receiver returns to
*                                   the LISTEN state, otherwise the receiver aborts the connection and goes to
*                                   the CLOSED state".
*
*                               (3) However, since TCP connections opened from the LISTEN state are cloned from
*                                   the original LISTEN-state TCP connection, it is NOT necessary to return ANY
*                                   reset TCP connection from the SYN-RECEIVED state back to the LISTEN state.
*
*                               See also Note #2a5A.
*
*                           (C) (1) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' states
*                                   that "if the receiver ... of a RST ... was in any other state [other than
*                                   LISTEN or SYN-RECEIVED], it aborts the connection and advises the user and
*                                   goes to the CLOSED state".
*
*                               (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                                   states that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states
*                                   that "if the RST bit is set then, any outstanding RECEIVEs and SEND[s] should
*                                   receive 'reset' responses.  All segment queues should be flushed.  Users
*                                   should also receive an unsolicited general 'connection reset' signal[, and]
*                                   enter the CLOSED state".
*
*                               (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                                   states that in the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT" states that
*                                   "if the RST bit is set then, enter the CLOSED state".
*
*                               See also Note #2a5A.
*
*                       (5) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
*                               with the RST bit when in a synchronized state" to "provide some protection against
*                                ... blind reset attack[s] using the RST bit" :
*
*                               (a) "If the RST bit is set and the sequence number is outside the expected window,
*                                    silently drop the segment."
*
*                               (b) "If the RST bit is exactly the next expected sequence number [sic], reset the
*                                    connection"; it is assumed that this should read "if the RST bit is set and
*                                    the sequence number is exactly the next expected sequence number, reset the
*                                    connection."
*
*                               (c) "If the RST bit is set and the sequence number does not exactly match
*                                    the next expected sequence value, yet is within the acceptable window
*                                    (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
*
*                           (B) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
*                               amendment applies only to the "handling of a ... RST ... when in a synchronized
*                               state", it is assumed that this should also apply to the SYN-RECEIVED state.
*
*                           (C) (1) In addition, it is assumed that a similar validation should also
*                                   apply to the SYN-SENT state.  Since the SYN-SENT state validates a
*                                   received TCP reset segment based only on the segment's acknowledgement,
*                                   a similar validation could require that the acknowledgement "exactly
*                                   match the next expected sequence value" -- i.e. the initial connection
*                                   synchronization sequence number plus one.
*
*                               (2) However, a specific check for the exact acknowledgement is NOT necessary
*                                   since NO data is transmitted from the SYN-SENT state.  Therefore, the ONLY
*                                   value to be acknowledged is the initial connection synchronization sequence
*                                   number.
*
*                           (D) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
*                               priority for handling TCP segments received with BOTH the RST & SYN bits set.
*
*                               Therefore, since it does NOT seem reasonable to reset a TCP connection
*                               due to a TCP segment that also attempted to synchronize the TCP connection,
*                               it is assumed that the amended handling of the SYN bit should take precedence
*                               over the amended handling of the RST bit.
*
*                   (b) RFC #1122, Section 4.2.2.12 states that "a TCP SHOULD allow a received RST segment
*                       to include data".
*********************************************************************************************************
*/

static  NET_TCP_RESET_CODE  NetTCP_RxPktConnIsValidReset (NET_TCP_CONN  *p_conn,
                                                          NET_BUF_HDR   *p_buf_hdr,
                                                          NET_ERR       *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_ACK_CODE    ack_code;
    NET_TCP_SEQ_CODE    seq_code;
#endif
    NET_TCP_RESET_CODE  reset_code;


   *p_err = NET_TCP_ERR_NONE;
    if (p_buf_hdr->TCP_SegReset != DEF_YES) {                   /* If NO reset rx'd, ...                                */
        return (NET_TCP_CONN_RX_RESET_NONE);                    /* ... rtn NONE.                                        */
    }


    reset_code = NET_TCP_CONN_RX_RESET_INVALID;

    if (p_conn != DEF_NULL) {
        switch (p_conn->ConnState) {
            case NET_TCP_CONN_STATE_FREE:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
                *p_err =  NET_TCP_ERR_CONN_NOT_USED;
                 return (NET_TCP_CONN_RX_RESET_INVALID);


            case NET_TCP_CONN_STATE_CLOSED:                     /* See Note #2a1.                                       */
            case NET_TCP_CONN_STATE_LISTEN:                     /* See Note #2a2.                                       */
                 break;


            case NET_TCP_CONN_STATE_SYNC_TXD:                   /* See Note #2a3.                                       */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #2A.                                        */
                 ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return (NET_TCP_CONN_RX_RESET_INVALID);
                 }
                 if (ack_code == NET_TCP_CONN_RX_ACK_INVALID) {
                     return (NET_TCP_CONN_RX_RESET_INVALID);
                 }
#endif
                 reset_code = NET_TCP_CONN_RX_RESET_VALID;
                 break;


            case NET_TCP_CONN_STATE_SYNC_RXD:                   /* See Notes #2a4B & #2a5B.                             */
            case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
            case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
            case NET_TCP_CONN_STATE_CONN:                       /* See Notes #2a4C & #2a5A.                             */
            case NET_TCP_CONN_STATE_FIN_WAIT_1:
            case NET_TCP_CONN_STATE_FIN_WAIT_2:
            case NET_TCP_CONN_STATE_CLOSING:
            case NET_TCP_CONN_STATE_TIME_WAIT:
            case NET_TCP_CONN_STATE_CLOSE_WAIT:
            case NET_TCP_CONN_STATE_LAST_ACK:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #2A.                                        */
                 seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return (NET_TCP_CONN_RX_RESET_INVALID);
                 }
                 if (seq_code != NET_TCP_CONN_RX_SEQ_VALID) {
                     return (NET_TCP_CONN_RX_RESET_INVALID);
                 }
#endif
                 if (p_buf_hdr->TCP_SeqNbr == p_conn->RxSeqNbrNext) { /* If seq nbr equals next rx seq expected ...     */
                     reset_code = NET_TCP_CONN_RX_RESET_VALID;  /* ... (see Note #2a5Ab), rtn valid reset.              */
                 }
                 break;


            case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
                 break;


            case NET_TCP_CONN_STATE_NONE:
            default:
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
                *p_err =  NET_TCP_ERR_INVALID_CONN_STATE;
                 return (NET_TCP_CONN_RX_RESET_INVALID);
        }
    }

    return (reset_code);
}


/*
*********************************************************************************************************
*                                         NetTCP_RxPktFree()
*
* Description : Free network buffer(s).
*
* Argument(s) : p_buf_q      Pointer to network buffer queue.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxAppData(),
*               NetTCP_RxPktConnHandler(),
*               NetTCP_RxPktConnHandlerRxQ_AppData().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  NET_BUF_QTY  NetTCP_RxPktFree (NET_BUF  *p_buf_q)
{
    NET_BUF_QTY  nbr_freed;


    nbr_freed = NetBuf_FreeBufQ_PrimList(p_buf_q, DEF_NULL);

    return (nbr_freed);
}


/*
*********************************************************************************************************
*                                        NetTCP_RxPktDiscard()
*
* Description : On any TCP receive error(s), discard TCP packet(s) & buffer(s).
*
* Argument(s) : p_buf        Pointer to network buffer.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_ERR_RX                      Receive error; packet discarded.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_Rx(),
*               NetTCP_RxPktConnHandler().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_RxPktDiscard (NET_BUF  *p_buf,
                                   NET_ERR  *p_err)
{
    NET_CTR  *pctr;


#if (NET_CTR_CFG_ERR_EN == DEF_ENABLED)
    pctr = (NET_CTR *)&Net_ErrCtrs.TCP.RxPktDiscardedCtr;
#else
    pctr = (NET_CTR *) 0;
#endif
   (void)NetBuf_FreeBufQ_PrimList((NET_BUF *)p_buf,
                                  (NET_CTR *)pctr);

   *p_err = NET_ERR_RX;
}


/*
*********************************************************************************************************
*                                      NetTCP_RxConnWinSizeCfg()
*
* Description : (1) Configure TCP connection's receive window controls :
*
*                   (a) Configure TCP connection's receive window update threshold
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_ConnCfg().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnCfg().
*
* Note(s)     : (2) A TCP connection's receive window controls SHOULD be updated only after the
*                   following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's configured receive window  size ('RxWinSizeCfgd')
*                          [see 'NetTCP_RxConnWinSizeCfgUpdateTh()  Note #2a']
*
*                   (b) TCP connection's connection maximum segment size ('MaxSegSizeConn')
*                          [see 'NetTCP_RxConnWinSizeCfgUpdateTh()  Note #2b']
*
*               (3) RFC #1122, Section 4.2.3.3 states that "the suggested SWS avoidance algorithm for
*                   the receiver is ... to avoid advancing the right window edge RCV.NXT+RCV.WND ...
*                   until the reduction satisfies" :
*
*                       (a) RCV.BUFF - RCV.USER - RCV.WND  >=  min(Fr * RCV.BUFF, Eff.snd.MSS)
*
*                               where
*                                   (1) RCV.BUFF        Total receive buffer space
*                                   (2) RCV.USER        Data  received but not yet consumed
*                                   (3) RCV.WND         Space advertised to sender
*                                   (4) Fr              Fraction whose recommended value is 1/2
*                                   (5) Eff.snd.MSS     Effective send MSS for the connection
*
*               (4) A TCP connection's receive window update threshold SHOULD be updated only after
*                   the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's configured receive window  size ('RxWinSizeCfgd')
*                           [see 'NetTCP_ConnClr()  Note #4']
*
*                   (b) TCP connection's connection maximum segment size ('MaxSegSizeConn')
*                           [see 'NetTCP_ConnCfgMaxSegSize()  Note #1']
*********************************************************************************************************
*/

static  void  NetTCP_RxConnWinSizeCfg (NET_TCP_CONN  *p_conn)
{
    NET_TCP_WIN_SIZE  rx_win_size_th;


    p_conn->RxWinSizeCalcd    =  p_conn->RxWinSizeCfgd;
    p_conn->RxWinSizeActual   =  p_conn->RxWinSizeCfgd;

                                                                /* Cfg silly win min th (see Note #3a).                 */
    rx_win_size_th            = (p_conn->RxWinSizeCfgd * NET_TCP_RX_SILLY_WIN_NUMER) / NET_TCP_RX_SILLY_WIN_DENOM;
    p_conn->RxWinSizeUpdateTh =  DEF_MIN(p_conn->MaxSegSizeConn, rx_win_size_th);
}


/*
*********************************************************************************************************
*                                    NetTCP_RxConnWinSizeHandler()
*
* Description : (1) Handle TCP connection's receive window :
*
*                   (a) Handle   TCP connection receive window                      See Notes #2 & #3
*                   (b) Transmit TCP connection acknowledgment                      See Note  #4
*
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in NetTCP_RxAppData(),
*                                                         NetTCP_RxPktConnHandlerRxQ_Sync(),
*                                                         NetTCP_RxPktConnHandlerRxQ_Conn(),
*                                                         NetTCP_RxPktConnHandlerRxQ_AppData().
*
*               p_buf_hdr            Pointer to network buffer header that received TCP packet.
*
*               win_update_size     Size to update TCP connection's receive window (in octets).
*
*               win_update_code     Indicate how to update TCP connection receive window :
*
*                                       NET_TCP_CONN_RX_WIN_RESET   Reset     TCP connection's available
*                                                                       receive window size.
*                                       NET_TCP_CONN_RX_WIN_INC     Increment TCP connection's available
*                                                                       receive window size.
*                                       NET_TCP_CONN_RX_WIN_DEC     Decrement TCP connection's available
*                                                                       receive window size.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxAppData(),
*               NetTCP_RxPktConnHandlerRxQ_Sync(),
*               NetTCP_RxPktConnHandlerRxQ_Conn(),
*               NetTCP_RxPktConnHandlerRxQ_AppData().
*
* Note(s)     : (2) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that :
*
*                   (a) "The window sent in each segment indicates the range of sequence numbers the
*                        sender of the window (the data receiver) is currently prepared to accept.
*                        There is an assumption that this is related to the currently available data
*                        buffer space available for this connection."
*
*                       (1) A TCP connection's advertised receive window MUST NEVER be decreased to zero
*                           if NO receive data is available & ready to be read by the application layer.
*
*                           In other words, if NO received data starting from the next expected receive
*                           sequence number(s) is queued, then NO data is available to be read by the
*                           application layer.  Therefore, the receive window size MUST NOT be decreased
*                           to zero, otherwise the receive window would deadlock since the application
*                           layer would NOT be able to read & extract any data from the receive window
*                           & the TCP connection would NOT be able to receive any more data into the
*                           receive window.
*
*                       See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #6b'.
*
*                   (b) "The mechanisms provided allow a TCP to advertise a large window and to
*                        subsequently advertise a much smaller window without having accepted that
*                        much data.  This ... 'shrinking the window' is strongly discouraged.  The
*                        robustness principle dictates that TCPs will not shrink the window ... but
*                        will be prepared for such behavior on the part of other TCPs."
*
*                   (c) "Note that ... acknowledgments should not be delayed or unnecessary
*                        retransmissions will result.  One strategy would be to send an acknowledgment
*                        when a small segment arrives (with out [sic] updating the window information),
*                        and then to send another acknowledgment with new window information when the
*                        window is larger."
*
*                       (1) However, the following sections retract this delayed acknowledgement
*                           prohibition & state that "a TCP SHOULD implement a delayed ACK" :
*
*                           (A) RFC # 813, Section 5
*                           (B) RFC #1122, Section 4.2.3.2
*                           (C) RFC #2581, Section 4.2
*
*                       See also Note #4 & 'NetTCP_TxConnAck()  Note #6'.
*
*               (3) (a) RFC #813, Section 2 states that "a bad implementation of the window algorithm
*                       can lead to extremely poor performance ... This particular phenomenon ... has
*                       been given the name of Silly Window Syndrome, or SWS".
*
*                       Section 3 elaborates that "SWS is a degeneration in the throughput which develops
*                       ... whenever the acknowledgement of a small segment ... cause[s] another segment
*                       of the same small size to be sent, until ... the network ... becomes clogged with
*                       many small segments, and an equal number of acknowledgements".
*
*                   (b) (1) RFC #813, Section 4 states that "the receiver of data can take a very simple
*                           step to eliminate SWS.  When it disposes of a small amount of data, it can
*                           artificially reduce the offered window in subsequent acknowledgements, so
*                           that the useable window computed by the sender does not permit the sending
*                           of any further data.
*
*                           At some later time, when the receiver has processed a substantially larger
*                           amount of incoming data, the artificial limitation on the offered window
*                           can be removed all at once, so that the sender computes a sudden large jump
*                           rather than a sequence of small jumps in the useable window.
*
*                           For a simple implementation, ... artificially reduce the offered window until
*                           the reduction constitutes one half of the available space ... [or] at least
*                           permit one reasonably large segment".
*
*                       (2) RFC #1122, Section 4.2.3.3 reiterates that "a TCP MUST include a SWS avoidance
*                           algorithm in the receiver ... This algorithm combines with the delayed ACK
*                           algorithm ... to determine when an ACK segment containing the current window
*                           will really be sent to the receiver [sic]".
*
*                          "The solution to receiver SWS is to avoid advancing the right window edge
*                           RCV.NXT+RCV.WND in small increments, even if data is received from the
*                           network in small segments ...  The suggested SWS avoidance algorithm for
*                           the receiver is to keep RCV.NXT+RCV.WND fixed until the reduction satisfies :
*
*                               (A) RCV.BUFF - RCV.USER - RCV.WND  >=  min(Fr * RCV.BUFF, Eff.snd.MSS)
*
*                                       where
*                                           (1) RCV.BUFF        Total receive buffer space
*                                           (2) RCV.USER        Data  received but not yet consumed
*                                           (3) RCV.WND         Space advertised to sender
*                                           (4) Fr              Fraction whose recommended value is 1/2
*                                           (5) Eff.snd.MSS     Effective send MSS for the connection
*
*
*                           Note that the general effect of this algorithm is to advance RCV.WND in
*                           increments of the Eff.snd.MSS."
*
*               (4) (a) RFC #813, Section 5 states that "the receiver of data will refrain from
*                       sending an acknowledgement under certain circumstances ... Postpone
*                       sending an acknowledgement if ... the following conditions hold" :
*
*                       (1) "There is no revised window information to be sent back."
*
*                           (A) However, if any local receive window size is available to update to
*                               the remote host, an acknowledgement should be immediately transmitted.
*
*                               (1) HOWEVER, since  local receive window size updates will continually
*                                   occur for "a host that is receiving a stream of TCP data segments"
*                                   (RFC #1122, Section 4.2.3.2); it is NOT possible to both update the
*                                   local receive window & implement a delayed acknowledgement.
*
*                                   (a) #### Therefore, in order to implement a delayed acknowledgement,
*                                       the only local receive window size updates that SHOULD transmit
*                                       an immediate acknowledgement :
*
*                                       (1) Local receive window size sets/resets
*                                       (2) Local receive window size increases
*                                       (3) Local receive window size decreases to zero-sized
*
*                                   (b) The following local receive window size updates SHOULD NOT
*                                       transmit an immediate acknowledgement :
*
*                                       (1) Local receive window size decreases
*
*                   (b) RFC #1122, Section 4.2.3.2 states that "a delayed ACK gives the application an
*                       opportunity to update the window and perhaps to send an immediate response".
*
*                   See also 'NetTCP_TxConnAck()  Notes #4b1, #6, & #7'.
*
*               (5) If the configured receive window size is allowed to be asynchronously modified by
*                   the application layer (see 'NetTCP_ConnCfgRxWinSizeHandler()  Note #3'), changes in
*                   the calculated &/or advertised receive window size MUST be appropriately validated
*                   to any possible new value for the configured receive window size :
*
*                   (a) During receive window size increases, if the currently calculated receive
*                       window size is already greater than the currently configured receive window
*                       size; then the calculated window size is NOT increased, but is allowed to
*                       remain greater than  the configured window size until the calculated window
*                       size decreases below the configured window size.
*
*                   (b) During receive window size decreases, if the currently calculated receive
*                       window size is already greater than the currently configured receive window
*                       size; then the calculated window size is further decreased, but is allowed to
*                       remain greater than  the configured window size until the calculated window
*                       size decreases below the configured window size.
*
*                   (c) During receive window size decreases, if the currently configured receive
*                       window size is less than the actual configured receive window size; then
*                       the actual configured receive window size is also decremented by the window
*                       size decrease.
*********************************************************************************************************
*/

static  void  NetTCP_RxConnWinSizeHandler (NET_TCP_CONN      *p_conn,
                                           NET_BUF_HDR       *p_buf_hdr,
                                           CPU_INT16U         val,
                                           NET_TCP_WIN_CODE   win_update_code)
{
    CPU_BOOLEAN        tx_ack = DEF_NO;
    NET_TCP_ACK_CODE   tx_ack_code;
    NET_TCP_WIN_SIZE   rx_payload_max;
    NET_TCP_WIN_SIZE   win_size_calc;
    NET_TCP_WIN_SIZE   win_size_avail;
    NET_TCP_WIN_SIZE   win_size_delta;
    NET_IF_NBR         if_nbr;
    NET_PROTOCOL_TYPE  protocol = NET_PROTOCOL_TYPE_TCP_V4;
    CPU_BOOLEAN        ipv6;
    NET_ERR            err;



#ifndef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
    ipv6 = NetConn_IsIPv6(p_conn->ID_Conn, &err);
    if (ipv6 == DEF_YES) {
        protocol = NET_PROTOCOL_TYPE_TCP_V6;
    }

    if (p_buf_hdr == DEF_NULL) {
        if_nbr = NetConn_IF_NbrGet(p_conn->ID_Conn, &err);
    } else {
        if_nbr = p_buf_hdr->IF_Nbr;
    }


    rx_payload_max = NetIF_GetPayloadRxMax(if_nbr, protocol, &err);
    win_size_calc  = rx_payload_max * val;
#else

    (void)&rx_payload_max;
    (void)&win_size_calc;
    (void)&if_nbr;
    (void)&protocol;
    (void)&ipv6;
#endif

    switch (win_update_code) {
        case NET_TCP_CONN_RX_WIN_ZERO:
             p_conn->RxWinSizeCalcd  = 0;
             p_conn->RxWinSizeCfgd   = 0;
             p_conn->RxWinSizeActual = 0;
             break;


        case NET_TCP_CONN_RX_WIN_INIT:
             p_conn->RxWinSizeCalcd  = val;
             p_conn->RxWinSizeCfgd   = val;
             p_conn->RxWinSizeActual = val;
             tx_ack                  = DEF_YES;
             tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED;       /* See Note #4a1A1a1.                           */
             break;


        case NET_TCP_CONN_RX_WIN_SET:
             if (p_conn->RxWinSizeActual < val) {                       /* If actual rx win size < win update, ...      */
                 p_conn->RxWinSizeActual = val;                         /* ... set   rx win size.                       */
                 p_conn->RxWinSizeCalcd  = val;
                 tx_ack                  = DEF_YES;
                 tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED;   /* See Note #4a1A1a1.                           */
             }
             break;


        case NET_TCP_CONN_RX_WIN_INC:
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
             if (val < 1) {                                            /* If NO win update, MUST NOT update win.       */
                 break;
             }

             if (p_conn->RxWinSizeCalcd <= p_conn->RxWinSizeCfgd) {     /* If <= cfg'd win size (see Note #5a), ...     */
                                                                        /* ... inc  rx win size.                        */
                 win_size_avail = p_conn->RxWinSizeCfgd - p_conn->RxWinSizeCalcd;
                 if (win_size_avail > val) {                           /* If avail rx win size >  win update, ...      */
                     p_conn->RxWinSizeCalcd += val;                    /* ... inc  rx win size by win update.          */
                 } else {                                               /* Else lim to cfg'd rx win size.               */
                     p_conn->RxWinSizeCalcd  = p_conn->RxWinSizeCfgd;
                 }

                 if (p_conn->RxWinSizeCalcd > p_conn->RxWinSizeActual) {
                     win_size_delta = p_conn->RxWinSizeCalcd - p_conn->RxWinSizeActual;
                     if (win_size_delta >= p_conn->RxWinSizeUpdateTh) {  /* If calc'd - actual rx win size >= th, ...   */
                                                                         /* ... update rx win size (see Note #3b2).     */
                         p_conn->RxWinSizeActual = p_conn->RxWinSizeCalcd;
                         tx_ack                  = DEF_YES;
                         tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED;    /* See Note #4a1A1a2.                   */
                     }

                 } else {                                               /* Prevent rx win shrink (see Note #2b).        */
                     p_conn->RxWinSizeCalcd = p_conn->RxWinSizeActual;
                 }
             }
             break;
#else
             if (val < 1) {                                 /* If NO win update, MUST NOT update win.               */
                 break;
             }


             if (p_conn->RxWinSizeCalcd <= p_conn->RxWinSizeCfgd) { /* If <= cfg'd win size (see Note #5a), ...         */
                                                                /* ... inc  rx win size.                                */
                 win_size_avail = p_conn->RxWinSizeCfgd - p_conn->RxWinSizeCalcd;
                 if (win_size_avail > win_size_calc) {          /* If avail rx win size >  win update, ...              */
                     p_conn->RxWinSizeCalcd += win_size_calc;   /* ... inc  rx win size by win update.                  */
                 } else {                                       /* Else lim to cfg'd rx win size.                       */
                     p_conn->RxWinSizeCalcd  = p_conn->RxWinSizeCfgd;
                 }

                 if (p_conn->RxWinSizeCalcd > p_conn->RxWinSizeActual) {
                     win_size_delta = p_conn->RxWinSizeCalcd - p_conn->RxWinSizeActual;
                     if (win_size_delta >= p_conn->RxWinSizeUpdateTh) { /* If calc'd - actual rx win size >= th, ...    */
                                                                /* ... update rx win size (see Note #3b2).              */
                         p_conn->RxWinSizeActual = p_conn->RxWinSizeCalcd;
                         tx_ack                  = DEF_YES;
                         tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED; /* See Note #4a1A1a2.                     */
                     }

                 } else {                                       /* Prevent rx win shrink (see Note #2b).                */
                     p_conn->RxWinSizeCalcd = p_conn->RxWinSizeActual;
                 }
             }
             break;
#endif


        case NET_TCP_CONN_RX_WIN_DEC:
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
            if (val < 1) {                                            /* If NO win update, MUST NOT update win.       */
                break;
            }

            if (p_conn->RxWinSizeCalcd >  val) {                      /* If calc'd rx win size >  win update, ...     */
                p_conn->RxWinSizeCalcd -= val;                        /* ... dec   rx win size by win update.         */
            } else {
                p_conn->RxWinSizeCalcd  = 0u;                          /* Else lim to min rx win size.                 */
            }

            if (p_conn->RxWinSizeActual > 0) {
                if (p_conn->RxWinSizeActual >  val) {                 /* If actual rx win size >  win update, ...     */
                    p_conn->RxWinSizeActual -= val;                   /* ... dec   rx win size by win update.         */
                    tx_ack_code             = NET_TCP_CONN_TX_ACK;     /*     See Note #4a1A1b1.                       */

                } else {
                    p_conn->RxWinSizeActual  = 0u;                         /* Else lim to min rx win size.             */
                    tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED;   /* See Note #4a1A1a3.                       */
                }

                tx_ack = DEF_YES;
            }

#else
             if (val < 1) {                                  /* If NO win update, MUST NOT update win.               */
                 break;
             }

             if (p_conn->RxWinSizeCalcd >  win_size_calc) {     /* If calc'd rx win size >  win update, ...             */
                 p_conn->RxWinSizeCalcd -= win_size_calc;       /* ... dec   rx win size by win update.                 */
             } else {
                 p_conn->RxWinSizeCalcd  = 0u;                  /* Else lim to min rx win size.                         */
             }

             if (p_conn->RxWinSizeActual > 0) {
                 if (p_conn->RxWinSizeActual >  win_size_calc) {/* If actual rx win size >  win update, ...             */
                     p_conn->RxWinSizeActual -= win_size_calc;  /* ... dec   rx win size by win update.                 */
                     tx_ack_code              = NET_TCP_CONN_TX_ACK; /* See Note #4a1A1b1.                              */
                 } else {
                     p_conn->RxWinSizeActual = 0u;              /* Else lim to min rx win size.                         */
                     tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED; /* See Note #4a1A1a3.                         */
                 }
                 tx_ack = DEF_YES;
             }
#endif
             break;


        case NET_TCP_CONN_RX_WIN_RESET:
        default:
             if (p_conn->RxWinSizeCalcd  < p_conn->RxWinSizeCfgd) {     /* If < cfg'd win size  (see Note #5a), ...     */
                 p_conn->RxWinSizeCalcd  = p_conn->RxWinSizeCfgd;       /* ... reset calc'd win size to cfg'd win size. */
             }
             if (p_conn->RxWinSizeActual < p_conn->RxWinSizeCalcd) {    /* Do NOT shrink rx win (see Note #2b).         */
                 p_conn->RxWinSizeActual = p_conn->RxWinSizeCalcd;
                 tx_ack                  = DEF_YES;
                 tx_ack_code             = NET_TCP_CONN_TX_ACK_IMMED;   /* See Note #4a1A1a1.                           */
             }
             break;
    }


                                                                /* ----------------- TX TCP CONN ACK ------------------ */
    if (tx_ack == DEF_YES) {                                    /* If rx win updated, tx ack (see Note #4a1A).          */
        if (p_buf_hdr != DEF_NULL) {                            /* If rx'd pkt avail, req tx ack; but ack ...           */
            p_buf_hdr->TCP_SegAckTxReqCode = (CPU_INT08U)tx_ack_code; /* ... NOT tx'd until after rx'd pkt handling.    */
        } else {
            NetTCP_TxConnAck(p_conn, p_buf_hdr, tx_ack_code, NET_TCP_CONN_CLOSE_ALL, &err);
        }
    }
}


/*
*********************************************************************************************************
*                                      NetTCP_TxConnWinSizeCfg()
*
* Description : (1) Configure TCP connection's transmit window controls :
*
*                   (a) Configure TCP connection's transmit window congestion controls
*                   (b) Configure TCP connection's transmit window minimum    threshold
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_ConnCfg().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnCfg().
*
* Note(s)     : (2) A TCP connection's transmit window controls SHOULD be updated only after the
*                   following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's maximum   transmit remote window size ('TxWinSizeRemoteMax')
*                          [see 'NetTCP_TxConnWinSizeCfgCongCtrl()  Note #5a'
*                             & 'NetTCP_TxConnWinSizeCfgMinTh()     Note #2a']
*
*                   (b) TCP connection's remaining transmit remote window size ('TxWinSizeRemoteRem')
*                          [see 'NetTCP_TxConnWinSizeCfgCongCtrl()  Note #5b']
*
*                   (c) TCP connection's connection maximum segment size ('MaxSegSizeConn')
*                          [see 'NetTCP_TxConnWinSizeCfgCongCtrl()  Note #5c']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeCfg (NET_TCP_CONN  *p_conn)
{
    p_conn->TxWinSizeCfgdRem = p_conn->TxWinSizeCfgd;

    NetTCP_TxConnWinSizeCfgCongCtrl(p_conn);
    NetTCP_TxConnWinSizeCfgMinTh(p_conn);
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnWinSizeCfgCongCtrl()
*
* Description : (1) Configure TCP connection's transmit window congestion controls :
*
*                   (a) Configure TCP connection's transmit window slow start threshold         See Note #2
*                   (b) Configure TCP connection's transmit window congestion controls          See Note #3
*                   (c) Reset     TCP connection's transmit window duplicate acknowledgement
*                           controls
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnWinSizeCfg(),
*                                                 NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeCfg(),
*               NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (2) RFC #2581, Section 3.1 states that "the initial value of ssthresh [slow start
*                   threshold] MAY be arbitrarily high (for example, some implementations use the
*                   size of the advertised window)".
*
*                   (a) This amends RFC #2001, Section 2.1 which previously stated that "initialization
*                       for a given connection sets ... ssthresh to 65535 bytes".
*
*                   (b) To always ensure a sufficiently high initial value, the slow start threshold
*                       initializes to the TCP connection's maximum remote window size.
*
*               (3) "The initial value of cwnd [congestion window], MUST be less than or equal to 2*SMSS
*                    bytes and MUST NOT be more than 2 segments."
*
*                   (a) This amends RFC #2001, Section 2.1 which previously stated that "initialization
*                       for a given connection sets cwnd to one segment".
*
*               (4) (a) RFC #2001, Section 2.2 states that "the TCP output routine never sends more than
*                       the minimum of cwnd and the receiver's advertised window".
*
*                   (b) RFC #2581, Section 3.1 reiterates that "the minimum of cwnd and rwnd [receiver's
*                       advertised window] governs data transmission".
*
*                   See also 'NetTCP_TxConnWinSizeUpdateAvail()  Note #1'.
*
*               (5) A TCP connection's transmit window congestion controls SHOULD be updated only after
*                   the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's maximum    transmit remote window size ('TxWinSizeRemoteMax')
*                           [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
*                              & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A & #3b']
*
*                   (b) TCP connection's remaining  transmit remote window size ('TxWinSizeRemoteRem')
*                           [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
*                              & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A']
*
*                   (c) TCP connection's connection maximum segment size ('MaxSegSizeConn')
*                           [see 'NetTCP_ConnCfgMaxSegSize()  Note #1']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeCfgCongCtrl (NET_TCP_CONN  *p_conn)
{
                                                                /* Cfg tx slow start th (see Note #2b).                 */
    p_conn->TxWinSizeSlowStartThInit = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeRemoteMax;
    p_conn->TxWinSizeSlowStartTh     = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeSlowStartThInit;

                                                                /* Cfg tx cong ctrls    (see Note #3a).                 */
    p_conn->TxWinSizeCongInit        = (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_CONG_WIN_MSS_SCALAR_INIT;
    p_conn->TxWinSizeCongCalcdActual = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeCongInit;
    p_conn->TxWinSizeCongCalcdCur    = (NET_TCP_WIN_SIZE)0u;
    p_conn->TxWinSizeCongRem         = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeCongCalcdActual;

                                                                /* Cfg tx win avail     (see Note #4).                  */
    NetTCP_TxConnWinSizeUpdateAvail(p_conn);


    NetTCP_TxConnWinSizeDupAckCtrlReset(p_conn);                /* Reset dup ack ctrls.                                 */
}


/*
*********************************************************************************************************
*                                   NetTCP_TxConnWinSizeCfgMinTh()
*
* Description : Configure TCP connection's transmit silly window minimum threshold.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnWinSizeCfg(),
*                                                 NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeCfg(),
*               NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (1) RFC #1122, Section 4.2.3.4 states that "the sender's SWS avoidance algorithm is ...
*                   [to] send data ... if at least a fraction Fs of the maximum window can be sent ...
*                   Fs is a fraction whose recommended value is 1/2".
*
*               (2) A TCP connection's transmit window minimum threshold SHOULD be updated only after
*                   the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's maximum transmit remote window size ('TxWinSizeRemoteMax')
*                           [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
*                              & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A & #3b']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeCfgMinTh (NET_TCP_CONN  *p_conn)
{
                                                                /* Cfg silly win min th (see Note #1).                  */
    p_conn->TxWinSizeMinTh = (NET_TCP_WIN_SIZE)(((CPU_INT32U)p_conn->TxWinSizeRemoteMax * NET_TCP_TX_SILLY_WIN_NUMER)
                                                                                      / NET_TCP_TX_SILLY_WIN_DENOM);
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnWinSizeHandlerCfgd()
*
* Description : (1) Handle TCP connection's configured transmit window :
*
*                   (a) Update TCP connection configured transmit window
*                   (b) Update TCP connection total transmit data queued
*
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in NetTCP_TxConnAppData(),
*                                                         NetTCP_RxPktConnHandlerReTxQ().
*
*               win_update_size     Size to update TCP connection's transmit window (in octets).
*
*               win_update_code     Indicate how to update TCP connection transmit window :
*
*                                       NET_TCP_CONN_TX_WIN_RESET       Reset     TCP connection's available
*                                                                           transmit window size.
*                                       NET_TCP_CONN_TX_WIN_SET         Set       TCP connection's available
*                                                                           transmit window size.
*                                       NET_TCP_CONN_TX_WIN_INC         Increment TCP connection's available
*                                                                           transmit window size.
*                                       NET_TCP_CONN_TX_WIN_DEC         Decrement TCP connection's available
*                                                                           transmit window size.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                        TCP connection's configured transmit window
*                                                                           successfully updated.
*
*                                                                       --- RETURNED BY NetTCP_TxQ_Signal() : ---
*                               NET_TCP_ERR_TX_Q_SIGNAL_FAULT           TCP connection transmit queue signal fault.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnAppData(),
*               NetTCP_RxPktConnHandlerReTxQ().
*
* Note(s)     : (2) (a) RFC #793, Section 3.7 'Data Communication : Managing the Window' states
*                       that "the window sent in each segment indicates the range of sequence
*                       numbers the sender of the window (the data receiver) is currently
*                       prepared to accept.  There is an assumption that this is related to the
*                       currently available data buffer space available for this connection".
*
*                   (b) Thus a TCP connection's configured transmit window is constrained by
*                       the available network resources; of which, network buffers are the
*                       primary transmit window network resource.
*
*                       However, since network buffers are discrete resources with non-discrete
*                       packet size; it is NOT necessary to enforce exact/strict compliance with
*                       a TCP connection's configured transmit window.
*
*                       In other words, network buffers allocated for TCP connection transmit
*                       SHOULD be fully used even if the TCP connection's configured transmit
*                       window is zero.
*
*               (3) If the configured transmit window size is allowed to be asynchronously modified
*                   by the application layer, changes in the remaining transmit window size MUST be
*                   appropriately validated to any possible new value for the configured transmit
*                   window size :
*
*                   (a) During transmit window size increases, if the remaining transmit window
*                       size is already greater than the currently configured   transmit window
*                       size; then the remaining window size is NOT increased, but is allowed to
*                       remain greater than  the configured window size until the remaining window
*                       size decreases below the configured window size.
*
*                   (b) During transmit window size decreases, if the remaining transmit window
*                       size is already greater than the currently configured   transmit window
*                       size; then the remaining window size is further decreased, but is allowed
*                       to remain greater than the configured window size until the remaining
*                       window size decreases below the configured window size.
*
*                   (c) Window size update is NOT validated for transmit window size resets.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeHandlerCfgd (NET_TCP_CONN      *p_conn,
                                               NET_TCP_WIN_SIZE   win_update_size,
                                               NET_TCP_WIN_CODE   win_update_code,
                                               NET_ERR           *p_err)
{
    CPU_BOOLEAN       q_prevly_full;
    NET_TCP_WIN_SIZE  win_size_avail;
    NET_TCP_CONN_ID   conn_id_tcp;


    switch (win_update_code) {
        case NET_TCP_CONN_TX_WIN_RESET:                         /* Reset cfg'd tx win size (see Note #1c).              */
        default:
             p_conn->TxWinSizeCfgdRem = p_conn->TxWinSizeCfgd;
             break;


        case NET_TCP_CONN_TX_WIN_SET:
             if (p_conn->TxWinSizeCfgdRem < win_update_size) {  /* If rem cfg'd win size < win update, ...              */
                 p_conn->TxWinSizeCfgdRem = win_update_size;    /* .. set cfg'd win size.                               */
                 break;
             }                                                  /* Else inc; do NOT shrink win.                         */
                                                                /* 'break' intentionally omitted; MUST ...              */
                                                                /* ...  execute the following case :   ...              */
                                                                /* ---------- ... 'NET_TCP_CONN_TX_WIN_INC'. ---------- */
        case NET_TCP_CONN_TX_WIN_INC:
             if (win_update_size < 1) {                         /* If NO win update, do NOT update win.                 */
                 break;
             }

             q_prevly_full = (p_conn->TxWinSizeCfgdRem < 1) ? DEF_YES : DEF_NO;

             if (p_conn->TxWinSizeCfgdRem < p_conn->TxWinSizeCfgd) {
                                                                /* If < cfg'd  win size (see Note #3a), ...             */
                                                                /* ... inc  tx win size.                                */
                 win_size_avail = p_conn->TxWinSizeCfgd - p_conn->TxWinSizeCfgdRem;
                 if (win_size_avail > win_update_size) {        /* If avail tx win size >  win update, ...              */
                                                                /* ... inc  tx win size by win update.                  */
                     p_conn->TxWinSizeCfgdRem += win_update_size;
                 } else {
                                                                /* Else lim to cfg'd tx win size.                       */
                     p_conn->TxWinSizeCfgdRem  = p_conn->TxWinSizeCfgd;
                 }
             }

             if (q_prevly_full == DEF_YES) {                    /* If tx Q prev'ly full, ...                            */
                 conn_id_tcp = p_conn->ID;
                 NetTCP_TxQ_Signal(conn_id_tcp, p_err);         /* ... signal tx Q.                                     */
                 if (*p_err != NET_TCP_ERR_NONE) {
                      NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                       (NET_BUF_HDR      *)0,
                                       (CPU_BOOLEAN       )DEF_YES,
                                       (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
                      return;
                 }
             }
             break;


        case NET_TCP_CONN_TX_WIN_DEC:
             if (win_update_size < 1) {                         /* If NO win update, do NOT update win.                 */
                 break;
             }

             if (p_conn->TxWinSizeCfgdRem >  win_update_size) { /* If rem tx win size >  win update, ..                 */
                 p_conn->TxWinSizeCfgdRem -= win_update_size;   /* .. dec tx win size by win update.                    */
             } else {
                 p_conn->TxWinSizeCfgdRem  = 0u;                /* Else lim to min tx  win size.                        */
             }
             break;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                NetTCP_TxConnWinSizeHandlerCongCtrl()
*
* Description : (1) Handle TCP connection's transmit window congestion controls :
*
*                   (a) Perform slow start / congestion avoidance algorithms            See Note #2c2A
*                   (b) Perform fast re-transmit / fast recovery  algorithms            See Note #2c2B
*                   (c) Handle  remote host's receive window updates                    See Note #3
*
*
* Argument(s) : p_conn              Pointer to a TCP connection.
*               ------              Argument validated in NetTCP_RxPktConnHandlerSeg(),
*                                                         NetTCP_RxPktConnHandlerReTxQ(),
*                                                         NetTCP_TxConnTxQ(),
*                                                         NetTCP_TxConnTxQ_TimeoutIdleSet(),
*                                                         NetTCP_TxConnTxQ_TimeoutIdle(),
*                                                         NetTCP_TxConnReTxQ().
*
*               p_buf_hdr           Pointer to network buffer header that received TCP packet.
*               ---------           Argument validated in NetTCP_Rx().
*
*               ack_code            Indicates the received segment's acknowledgement condition :
*
*                                       NET_TCP_CONN_RX_ACK_NONE            NO received acknowledgement number.
*
*                                       NET_TCP_CONN_RX_ACK_INVALID            Received acknowledgement number
*                                                                              is invalid for the TCP connection.
*
*                                       NET_TCP_CONN_RX_ACK_VALID              Received acknowledgement number
*                                                                              is   valid for the TCP connection.
*
*                                       NET_TCP_CONN_RX_ACK_DUP                Received acknowledgement number
*                                                                              is a          duplicate for the
*                                                                              TCP connection.
*
*                                       NET_TCP_CONN_RX_ACK_PREV               Received acknowledgement number
*                                                                              is a previous duplicate for the
*                                                                              TCP connection.
*
*               win_update_size     Size to update TCP connection's transmit window (in octets).
*
*               win_update_code     Indicate how to update TCP connection transmit window :
*
*                                       NET_TCP_CONN_TX_WIN_RESET           Reset     TCP connection's congestion
*                                                                               control transmit window size.
*                                       NET_TCP_CONN_TX_WIN_SEG_RXD         Update    TCP connection's congestion
*                                                                               control transmit window size
*                                                                               based on received segment.
*                                       NET_TCP_CONN_TX_WIN_TIMEOUT         Update    TCP connection's congestion
*                                                                               control transmit window size
*                                                                               based on transmission timeout.
*                                       NET_TCP_CONN_TX_WIN_INC             Increment TCP connection's congestion
*                                                                               control transmit window sizes.
*                                       NET_TCP_CONN_TX_WIN_DEC             Decrement TCP connection's
*                                                                                       transmit window sizes.
*                                       NET_TCP_CONN_TX_WIN_REMOTE_UPDATE   Update    TCP connection's remote
*                                                                                       receive  window size.
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection's transmit window congestion controls
*                                                                       successfully updated.
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                                                                   --------- RETURNED BY NetTCP_TxConnReTxQ() : ---------
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*
*                                                                   ---------- RETURNED BY NetTCP_TxConnTxQ() : ----------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
*                                                                   --------- RETURNED BY NetTCP_TxConnReTxQ() : ---------
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg(),
*               NetTCP_RxPktConnHandlerReTxQ(),
*               NetTCP_RxPktConnHandlerTxWinRemote(),
*               NetTCP_TxConnTxQ(),
*               NetTCP_TxConnTxQ_TimeoutIdleSet(),
*               NetTCP_TxConnTxQ_TimeoutIdle(),
*               NetTCP_TxConnReTxQ().
*
* Note(s)     : (2) (a) (1) The following sections define, specify, &/or require "TCP's four intertwined congestion
*                           control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery" :
*
*                           (A) RFC #2001                                               See Note  #2c1
*                           (B) RFC #2581                                               See Notes #2c2, #2a2, & #2e
*                           (C) RFC #1122
*                               (1) Section 4.2.2.15
*                               (2) Section 4.2.2.21
*                               (3) Section 4.2.3.9                                     See 'net_tcp.c  Note #1e'
*                                   (a) 'Source Quench'                                 See Note #2e2
*                                   (b) 'Destination Unreachable -- Codes 2-4'
*
*
*                       (2) Although RFC #2581, Section 1 states that "this document is an update of [RFC #2001]";
*                           both references are included as complementary specifications of the congestion control
*                           algorithms.
*
*                           However, since RFC #2581 is the update to RFC #2001, its specifications supercede
*                           those of RFC #2001; & ALL differences are implemented by RFC #2581 specifications.
*
*                   (b) (1) (A) RFC #2581, Section 3.1 states that "the slow start and congestion avoidance
*                               algorithms MUST be used by a TCP sender to control the amount of outstanding
*                               data being injected into the network".
*
*                           (B) RFC #1122, Section 4.2.2.15 reiterates that "a TCP MUST implement ... 'slow
*                               start' with 'congestion avoidance'".
*
*                       (2) (A) RFC #2001, Section 1 states that "the sender's ... congestion window ... is
*                               flow control imposed by the sender, while the advertised window is flow control
*                               imposed by the receiver.  The former is based on the sender's assessment of
*                               perceived network congestion; the latter is related to the amount of available
*                               buffer space at the receiver for this connection".
*
*                           (B) RFC #2581, Section 3.1 reiterates that "the congestion window ... is a sender-
*                               side limit on the amount of data the sender can transmit into the network
*                               before receiving an acknowledgment (ACK), while the receiver's advertised
*                               window ... is a receiver-side limit on the amount of outstanding data."
*
*                       (3) (A) (1) RFC #2001, Section 1 states that "the sender can transmit up to the minimum
*                                   of the congestion window and the advertised window."
*
*                               (2) RFC #2001, Section 2.2 reiterates that "the TCP output routine never sends
*                                   more than the minimum of cwnd and the receiver's advertised window".
*
*                               (3) RFC #2581, Section 3.1 also reiterates that "the minimum of cwnd and rwnd
*                                   [receiver's advertised window] governs data transmission".
*
*                           (B) RFC #2581, Section 3 also states that "a TCP MUST NOT be more aggressive than
*                               the [congestion control] algorithms allow (that is, MUST NOT send data when
*                               the value of cwnd computed by the [congestion control] algorithms would not
*                               allow the data to be sent)".
*
*                           (C) TCP transmit resulting from TCP congestion controls update handled by appropriate
*                               TCP connection state receive handler function(s).
*
*                               See 'NetTCP_RxPktConnHandlerSyncRxd()    Note #1c3',
*                                   'NetTCP_RxPktConnHandlerSyncTxd()    Note #1c3',
*                                   'NetTCP_RxPktConnHandlerConn()       Note #1c',
*                                   'NetTCP_RxPktConnHandlerFinWait1()   Note #1c',
*                                   'NetTCP_RxPktConnHandlerClosing()    Note #1c',
*                                   'NetTCP_RxPktConnHandlerCloseWait()  Note #1c',
*                                 & 'NetTCP_RxPktConnHandlerLastAck()    Note #1c'.
*
*                       (4) (A) RFC #2001, Sections 3 & 4 state that "since ... a duplicate ACK is caused by
*                               a lost segment or just a reordering of segments, ... [fast retransmit] waits
*                               for a small number of duplicate ACKs to be received ... [as] a strong indication
*                               that a segment has been lost ... [and] then performs a retransmission of what
*                               appears to be the missing segment, without waiting for a retransmission timer
*                               to expire.
*
*                               After fast retransmit sends ... the missing segment, congestion avoidance,
*                               but not slow start is performed.  This is the fast recovery algorithm".
*
*                           (B) RFC #2581, Section 3.2 reiterates that "the TCP sender SHOULD use the 'fast
*                               retransmit' algorithm to detect and repair loss, based on ... the arrival of
*                               3 duplicate ACKs (4 identical ACKs without the arrival of any other intervening
*                               packets) as an indication that a segment has been lost.  After receiving 3
*                               duplicate ACKs, TCP performs a retransmission of what appears to be the missing
*                               segment, without waiting for the retransmission timer to expire.
*
*                               After the fast retransmit algorithm sends ... the missing segment, the 'fast
*                               recovery' algorithm ... can continue to transmit new segments ... (using a
*                               reduced cwnd) ... until a non-duplicate ACK arrives".
*
*                   (c) (1) (A) RFC #2001, Section 2 states that the "congestion avoidance and slow start ...
*                               combined algorithm operates as follows" :
*
*                               (1) "Initialization for a given connection sets" :
*
*                                   (a) "cwnd to one segment" ...
*                                   (b) "and ssthresh to 65535 bytes."
*
*                               (3) (a) (1) "When congestion occurs (indicated by" :
*
*                                           (A) "a timeout"                            ...
*                                           (B) "or the reception of duplicate ACKs)," ...
*
*                                       (2) "one-half of the current window size" :
*
*                                           (A) "the minimum of" :
*                                               (1) "cwnd"                                 ...
*                                               (2) "and the receiver's advertised window" ...
*                                           (B) "but at least two segments" ...
*
*                                       (3) "is saved in ssthresh [slow start threshold]."
*
*                                   (b) (1) "Additionally, if the congestion is indicated by a timeout," ...
*                                       (2) "cwnd is set to one segment (i.e., slow start)."
*
*                               (4) "When new data is acknowledged by the other end, increase cwnd, but the way
*                                    it increases depends on whether TCP is performing slow start or congestion
*                                    avoidance" :
*
*                                   (a) (1) (A) (1) (a) "If cwnd is less than or equal to ssthresh," ...
*                                                   (b) "TCP is in slow start."
*
*                                               (2) "Slow start continues until TCP is halfway to where it was
*                                                    when congestion occurred (since it recorded half of the
*                                                    window size that caused the problem)."
*
*                                           (B) (1) "Slow start has cwnd" :
*
*                                                   (a) "Begin at one segment," ...
*
*                                                   (b) (1) "and be incremented by one segment" ...
*                                                       (2) "every time an ACK is received."
*
*                                               (2) "The increase in cwnd ... [for] slow start increments cwnd
*                                                    by the number of ACKs received in a round-trip time ...
*                                                    [which] opens the window exponentially: send one segment,
*                                                    then two, then four, and so on."
*
*                                       (2) RFC #2001, Section 1 states that :
*
*                                           (A) "Early implementations performed slow start only if the other
*                                                end was on a different network."
*
*                                           (B) "Current implementations always perform slow start."
*
*                                   (b) (1) (A) "If cwnd is [not] less than or equal to ssthresh," ...
*                                           (B) "TCP is performing congestion avoidance."
*
*                                       (2) (A) (1) "cwnd [is] incremented by segsize*segsize/cwnd" ...
*                                                   (a) "where segsize is the segment size" ...
*                                                   (b) "and cwnd is maintained in bytes";  ...
*                                               (2) "each time an ACK is received."
*
*                                           (B) "This is a linear growth of cwnd ... The increase in cwnd should
*                                                be at most one segment each round-trip time (regardless how many
*                                                ACKs are received in that RTT)."
*
*                           (B) RFC #2001, Section 4 states that "the fast retransmit and fast recovery
*                               algorithms are usually implemented together as follows" :
*
*                               (1) "When the third duplicate ACK in a row is received" :
*
*                                   (a) "Set ssthresh to" :
*                                       (1) "one-half the current congestion window, cwnd" ...
*                                       (2) "but no less than two segments."
*
*                                   (b) "Retransmit the missing segment."
*
*                                   (c) "Set cwnd to ssthresh plus 3 times the segment size."
*
*                               (2) "Each time another duplicate ACK arrives" :
*
*                                   (a) "Increment cwnd by the segment size."
*                                   (b) "Transmit a packet, if allowed by the new value of cwnd."
*
*                               (3) "When the next ACK arrives that acknowledges new data" :
*
*                                   (a) "Set cwnd to ssthresh" (see Note #2c1B1a).
*
*                       (2) (A) RFC #2581, Section 3.1 defines the "slow start and congestion avoidance algorithms"
*                               as follows :
*
*                               (1) (a) "The initial value of cwnd, MUST be" :
*
*                                       (1) "less than or equal to 2*SMSS bytes" ...
*                                       (2) "and MUST NOT be more than 2 segments."
*
*                                   (b) "The initial value of ssthresh MAY be arbitrarily high" :
*                                       (1) "some implementations use the size of the advertised window."
*
*                               (2) (a) "The slow start algorithm is used when cwnd < ssthresh," ...
*                                   (b) "While the congestion avoidance algorithm is used when cwnd > ssthresh."
*                                   (c) "When cwnd and ssthresh are equal the sender may use either slow start or
*                                        congestion avoidance."
*
*                               (3) (a) "During slow start" :
*
*                                       (1) "a TCP increments cwnd by at most SMSS bytes" ...
*                                       (2) "for each ACK received that acknowledges new data."
*
*                                   (b) "Slow start ends when" :
*
*                                       (1) "cwnd exceeds ... or ... reaches ... ssthresh" ...
*                                       (2) "or when congestion is observed."
*
*                               (4) (a) "During congestion avoidance" :
*
*                                       (1) "cwnd is incremented by 1 full-sized segment per round-trip time (RTT)."
*
*                                       (2) (A) "One formula commonly used to update cwnd during congestion avoidance
*                                                is given" by :
*
*                                               (2) cwnd += (SMSS * SMSS) / cwnd
*
*                                           (B) "Another acceptable way to increase cwnd during congestion avoidance
*                                                is to count the number of bytes that have been acknowledged by ACKs
*                                                for new data" :
*
*                                               (1) "When the number of bytes acknowledged reaches cwnd," ...
*                                               (2) "then cwnd can be incremented by up to SMSS bytes."
*
*                                       (3) "This adjustment is executed on every incoming non-duplicate ACK."
*
*                                   (b) "Congestion avoidance continues until congestion is detected."
*
*                               (5) "When a TCP sender detects segment loss using the retransmission timer" :
*
*                                   (a) "the value of ssthresh MUST be set to no more than" :
*
*                                       (3) ssthresh = max (FlightSize / 2, 2 * SMSS)
*
*                                           (A) "FlightSize is the amount of outstanding data ... that has been
*                                                sent but not yet acknowledged."
*
*                                   (b) "cwnd MUST be set to no more than ... 1 full-sized segment."
*
*                                   (c) "Therefore, after retransmitting the dropped segment the TCP sender uses
*                                        the slow start algorithm to increase the window."
*
*                           (B) RFC #2581, Section 3.2 states that "the fast retransmit and fast recovery algorithms
*                               are usually implemented together as follows" :
*
*                               (1) "When the third duplicate ACK is received" (see Note #2d1) :
*
*                                   (a) "Set ssthresh to no more than the value given [by the] equation"
*                                           (see Note #2c2A5a3), ...
*
*                                   (b) "Retransmit the lost segment"
*                                           (see Note #2d2),     ...
*
*                                   (c) "Set cwnd to ssthresh plus 3*SMSS."
*                                       (1) "This artificially 'inflates' the congestion window by the number of
*                                            segments (three) that have left the network and which the receiver
*                                            has buffered."
*
*                               (2) "For each additional duplicate ACK received" :
*
*                                   (a) "Increment cwnd by SMSS."
*                                       (1) "This artificially inflates the congestion window in order to reflect
*                                            the additional segment that has left the network."
*
*                                   (b) (1) "Transmit a segment, if allowed by" :
*
*                                           (A) "the new value of cwnd" ...
*                                           (B) "and the receiver's advertised window."
*
*                                       (2) TCP transmit resulting from TCP congestion controls update handled by
*                                           appropriate TCP connection state receive handler function(s).
*
*                                           See also Note #2b3C.
*
*                               (3) (a) "When the next ACK arrives that acknowledges new data," ...
*                                   (b) "Set cwnd to ssthresh" (see Note #2c2B1a).
*
*                   (d) (1) (A) RFC #1122, Section 4.2.2.21 states that "'fast retransmit' ... counts the number of
*                               ... 'redundant' ACK's ... received with" :
*
*                               (1) "the same value of SEG.ACK and" ...
*                               (2) "the same right window edge".
*
*                           (B) Although it is not directly stated, it is inferred that duplicate acknowledgements
*                               SHOULD be :
*
*                               (1) Acknowledgement-only segments
*                                   (a) i.e. with NO transmit data                              See Note #2d1C1
*                                       (1) i.e. with NO TCP segment length
*                               (2) With NO sequence number      update
*                               (3) With NO receive  window size update                         See Note #2d1C2
*
*                           (C) Also although RFC #2581, Section 3.2 states that "the TCP sender SHOULD use the
*                               'fast retransmit' algorithm ... based on ... the arrival of ... 4 identical ACKs
*                               without the arrival of any other intervening packets"; it seems reasonable that
*                               the TCP fast retransmit algorithm MUST NOT consider the arrival of non-duplicate
*                               acknowledgement segments as "intervening packets".
*
*                               In other words, TCP fast retransmit MUST ignore the following TCP packets as
*                               duplicate acknowledgement packets :
*
*                               (1) TCP data segments
*                               (2) Remote host receive window updates
*
*                       (2) RFC #1122, Section 4.2.2.21 reiterates that "with this ... 'fast retransmit' ...
*                           algorithm, the sender uses the redundant ACK's to deduce that a segment has been
*                           lost before the retransmission timer has expired.  If more than a threshold number
*                           of such ACK's is received, then the segment containing the octets starting at
*                           SEG.ACK is assumed to have been lost and is retransmitted, without awaiting a
*                           timeout".
*
*                   (e) (1) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
*                           of time ... use slow start to restart transmission" :
*
*                           (A) (1) "If the TCP has not sent data in an interval exceeding the retransmission timeout"
*                               (2) "cwnd is reduced to ... no more than ... the value of the restart window"
*                                       (see Note #2c2A1).
*
*                               See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2a'.
*
*                           (B) Although NO RFC specifies that a TCP connection's slow start threshold should be
*                               reset following a TCP transmit idle timeout; it seems reasonable to reset the slow
*                               start threshold whenever the TCP transmit congestion window is reset.
*
*                           See also 'NetTCP_TxConnWinSizeCfgCongCtrl()  Notes #2 & #3'.
*
*                       (2) RFC #1122, Section 4.2.3.9 'Source Quench' states that "TCP MUST react to a Source Quench
*                           by slowing transmission on the connection.  The RECOMMENDED procedure is ... to trigger a
*                           'slow start', as if a retransmission timeout had occurred".
*
*               (3) (a) (1) The following sections ... :
*
*                           (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                                   ESTABLISHED STATE'
*                           (B) RFC #1122, Section 4.2.2.20.(c)
*                           (C) RFC #1122, Section 4.2.2.20.(f)
*
*                       (2) ... generalize that "the following variables should be set ... [when] the send
*                           window should be updated" :
*
*                           (A) SND.WND <- SEG.WND
*
*                               (1) A TCP connection's remote host receive window advertisements are relative
*                                   to the received window advertisement acknowledgement sequence number, &
*                                   are asynchronous to the TCP connection's recent transmitted sequences.
*
*                                   Therefore, the actual transmit remote window size MUST be compensated by
*                                   the difference in the remote host receive window advertisement & the TCP
*                                   connection's number of recently transmitted sequences :
*
*                                       (a) TxWinSizeRemoteActual  =  SEG.WIN  -  (SND.NXT - SEG.ACK)
*
*                                               where
*
*                                                   TxWinSizeRemoteActual   TCP connection's actual transmit
*                                                                               remote window size
*
*                           (B) SND.WL1 <- SEG.SEQ
*                           (C) SND.WL2 <- SEG.ACK
*
*                   (b) RFC #1122, Section 4.2.3.4 'IMPLEMENTATION' states that "because the sender does not
*                       know (directly) the receiver's total buffer space RCV.BUFF ... An approach [that] has
*                       been found to work well is for the sender to calculate Max(SND.WND), the maximum send
*                       window it has seen so far on the connection, and to use this value as an estimate of
*                       RCV.BUFF".
*
*                   (c) RFC #1122, Section 4.2.2.17 states that although "a TCP MAY keep its offered receive
*                       window closed indefinitely ... the sending TCP MUST allow the connection to stay open
*                       ... as long as the receiving TCP continues to send acknowledgments in response to ...
*                       probe segments".
*
*                       See also 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeHandlerCongCtrl (NET_TCP_CONN      *p_conn,
                                                   NET_BUF_HDR       *p_buf_hdr,
                                                   NET_TCP_ACK_CODE   ack_code,
                                                   NET_TCP_WIN_SIZE   win_update_size,
                                                   NET_TCP_WIN_CODE   win_update_code,
                                                   NET_ERR           *p_err)
{
    CPU_BOOLEAN       ack_dup;
    NET_TCP_WIN_SIZE  tx_win_size_remote_actual;
    NET_TCP_WIN_SIZE  tx_win_size_remote_actual_min;


    switch (win_update_code) {
        case NET_TCP_CONN_TX_WIN_RESET:
        default:
             NetTCP_TxConnWinSizeCfgCongCtrl(p_conn);           /* Reset tx cong ctrls (see Note #2e).                  */
             break;


        case NET_TCP_CONN_TX_WIN_SEG_RXD:
             switch (ack_code) {
                 case NET_TCP_CONN_RX_ACK_VALID:
                                                                /* ------------------ FAST RECOVERY ------------------- */
                                                                /* If valid ack rx'd after fast re-tx th, ..            */
                      if (p_conn->TxWinRxdAckDupCtr >= NET_TCP_FAST_RE_TX_ACK_DUP_TH) {
                                                                /* .. perform fast recovery (see Note #2c2B3) :         */
                                                                /* .. set cong win to slow start th       ..            */
                                                                /* ..                       (see Note #2c2B3b).         */
                          NetTCP_TxConnWinSizeCongSet(p_conn, NET_TCP_CONN_TX_WIN_CONG_SET_SLOW_START);
                          NetTCP_TxConnWinSizeUpdateAvail(p_conn); /* Update avail tx win (see Note #2b3).              */


                      } else {                                  /* ----------- SLOW START / CONG AVOIDANCE ------------ */
                                                                /* If cong win <  slow start th ..                      */
                                                                /* .. (see Notes #2c2A2a),      ..                      */
                          if (p_conn->TxWinSizeCongCalcdActual < p_conn->TxWinSizeSlowStartTh) {
                                                                /* .. perform slow start  (see Note #2c2A3) :           */
                                                                /* .. inc cong win by MSS (see Note #2c2A3a1).          */
                              NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, 0u, NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START);

                          } else {                              /* If cong win >= slow start th     ..                  */
                                                                /* .. (see Note #2c2A2b & #2c2A2c), ..                  */
                                                                /* .. perform cong avoid  (see Note #2c2A4) :           */
                                                                /* .. inc cong win        (see Note #2c2A4a2B).         */
                              NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, 0u, NET_TCP_CONN_TX_WIN_CONG_INC_CONG_AVOID);
                          }

                          NetTCP_TxConnWinSizeUpdateAvail(p_conn); /* Update avail tx win (see Note #2b3A).             */
                      }

#if 0                                                           /* Tx avail seg(s)     [see Note #2b3C].                */
                      NetTCP_TxConnTxQ(p_conn, p_buf_hdr, ack_code, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES, p_err);
                      switch (*p_err) {
                          case NET_TCP_ERR_NONE:
                          case NET_TCP_ERR_CONN_ACK_NONE:
                          case NET_TCP_ERR_CONN_ACK_INVALID:
                          case NET_TCP_ERR_CONN_ACK_DLYD:
                          case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
                          case NET_ERR_TX:                      /* Ignore transitory tx err(s).                         */
                          case NET_ERR_IF_LINK_DOWN:
                               break;


                          case NET_TCP_ERR_CONN_NOT_USED:
                          case NET_TCP_ERR_CONN_CLOSE:
                          case NET_TCP_ERR_CONN_FAULT:
                          case NET_TCP_ERR_CONN_FAIL:
                          case NET_TCP_ERR_INVALID_CONN_STATE:
                          case NET_TCP_ERR_INVALID_CONN_OP:
                          case NET_TCP_ERR_INVALID_LEN_SEG:
                          case NET_TCP_ERR_NONE_AVAIL:
                          case NET_TCP_ERR_TX_PKT:
                          case NET_ERR_IF_LOOPBACK_DIS:
                          case NET_CONN_ERR_INVALID_FAMILY:
                          case NET_CONN_ERR_INVALID_ADDR:
                          case NET_CONN_ERR_INVALID_ADDR_LEN:
                          default:
                               return;
                      }
#endif
                                                                /* Reset dup ack ctrls.                                 */
                      NetTCP_TxConnWinSizeDupAckCtrlUpdate(p_conn, p_buf_hdr, DEF_YES);
                      break;


                 case NET_TCP_CONN_RX_ACK_DUP:                  /* ------------ FAST RE-TX / FAST RECOVERY ------------ */
                                                                /* Chk dup ack (see Notes #2b4 & #2d1).                 */
                      ack_dup = ((p_buf_hdr->TCP_SeqNbr  == p_conn->TxWinRxdLastSeqNbr ) &&
                                 (p_buf_hdr->TCP_AckNbr  == p_conn->TxWinRxdLastAckNbr ) &&
                                 (p_buf_hdr->TCP_WinSize == p_conn->TxWinRxdLastWinSize) &&
                                 (p_buf_hdr->TCP_SegLen  <  1                         )) ? DEF_YES : DEF_NO;

                      if (ack_dup == DEF_YES) {                 /* If     dup ack, ..                                   */
                          p_conn->TxWinRxdAckDupCtr++;          /* .. inc dup ack ctr.                                  */

                                                                /* If equal to fast re-tx th,                ..         */
                          if (p_conn->TxWinRxdAckDupCtr == NET_TCP_FAST_RE_TX_ACK_DUP_TH) {
                                                                /* .. perform fast re-tx (see Note #2c2B1) : ..         */
                                                                /* .. calc slow start th (see Note #2c2B1a); ..         */
                              NetTCP_TxConnWinSizeCalcSlowStartTh(p_conn);
                                                                /* .. re-tx unack'd seg  (see Note #2c2B1b); ..         */
                              NetTCP_TxConnReTxQ(p_conn, DEF_NO, NET_TCP_CONN_CLOSE_ALL, p_err);
                              switch (*p_err) {
                                  case NET_TCP_ERR_NONE:
                                  case NET_ERR_TX:              /* Ignore transitory re-tx err(s).                      */
                                  case NET_ERR_IF_LINK_DOWN:
                                  case NET_ERR_TX_BUF_LOCK:
                                       break;


                                  case NET_TCP_ERR_CONN_NOT_USED:
                                  case NET_TCP_ERR_CONN_FAULT:
                                  case NET_TCP_ERR_INVALID_CONN_STATE:
                                  case NET_TCP_ERR_INVALID_CONN_OP:
                                  case NET_TCP_ERR_TX_PKT:
                                  case NET_TCP_ERR_RE_TX_SEG_TH:
                                  case NET_ERR_IF_LOOPBACK_DIS:
                                  default:
                                       return;
                              }
                                                                /* .. set cong win to fast recovery th      ..          */
                                                                /* ..                    (see Note #2c2B1c).            */
                              NetTCP_TxConnWinSizeCongSet(p_conn, NET_TCP_CONN_TX_WIN_CONG_SET_FAST_RECOVERY);
                              NetTCP_TxConnWinSizeUpdateAvail(p_conn); /* Update avail tx win   (see Note #2b3).        */


                                                                /* Else if  > fast re-tx th,                ..          */
                          } else if (p_conn->TxWinRxdAckDupCtr > NET_TCP_FAST_RE_TX_ACK_DUP_TH) {
                                                                /* .. perform fast recovery (see Note #2c2B2) :         */
                                                                /* .. inc cong win by MSS   (see Note #2c2B2a),         */
                              NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, 0u, NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START);
                              NetTCP_TxConnWinSizeUpdateAvail(p_conn); /* .. update avail tx win   (see Note #2b3) ..   */
#if 0                                                           /* .. & tx avail seg(s)     [see Note #2c2B2b].         */
                              NetTCP_TxConnTxQ(p_conn, p_buf_hdr, ack_code, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES, p_err);
                              switch (*p_err) {
                                  case NET_TCP_ERR_NONE:
                                  case NET_TCP_ERR_CONN_ACK_NONE:
                                  case NET_TCP_ERR_CONN_ACK_INVALID:
                                  case NET_TCP_ERR_CONN_ACK_DLYD:
                                  case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
                                  case NET_ERR_TX:              /* Ignore transitory tx err(s).                         */
                                  case NET_ERR_IF_LINK_DOWN:
                                       break;


                                  case NET_TCP_ERR_CONN_NOT_USED:
                                  case NET_TCP_ERR_CONN_CLOSE:
                                  case NET_TCP_ERR_CONN_FAULT:
                                  case NET_TCP_ERR_CONN_FAIL:
                                  case NET_TCP_ERR_INVALID_CONN_STATE:
                                  case NET_TCP_ERR_INVALID_CONN_OP:
                                  case NET_TCP_ERR_INVALID_LEN_SEG:
                                  case NET_TCP_ERR_NONE_AVAIL:
                                  case NET_TCP_ERR_TX_PKT:
                                  case NET_ERR_IF_LOOPBACK_DIS:
                                  case NET_CONN_ERR_INVALID_FAMILY:
                                  case NET_CONN_ERR_INVALID_ADDR:
                                  case NET_CONN_ERR_INVALID_ADDR_LEN:
                                  default:
                                       return;
                              }
#endif
                          } else {
                                                                /* Empty Else Statement                                 */
                          }


                      } else {                                  /* Else update dup ack ctrls (see Note #2d1C).          */
                          NetTCP_TxConnWinSizeDupAckCtrlUpdate(p_conn, p_buf_hdr, DEF_NO);
                      }
                      break;


                 case NET_TCP_CONN_RX_ACK_PREV:                 /* Ignore prev dup acks.                                */
                     *p_err = NET_TCP_ERR_NONE;
                      return;


                 case NET_TCP_CONN_RX_ACK_NONE:
                 case NET_TCP_CONN_RX_ACK_INVALID:
                 default:
                     *p_err = NET_TCP_ERR_CONN_FAIL;
                      return;
             }
             break;


        case NET_TCP_CONN_TX_WIN_TIMEOUT:                       /* -------------------- SLOW START -------------------- */
                                                                /* On timeout (see Note #2c2A5),             ..         */
                                                                /* .. perform slow start (see Note #2c2A5c) :           */
             NetTCP_TxConnWinSizeCalcSlowStartTh(p_conn);       /* .. calc slow start th (see Note #2c2A5a); ..         */
                                                                /* .. set cong win to timeout th             ..         */
                                                                /* ..                    (see Note #2c2A5b).            */
             NetTCP_TxConnWinSizeCongSet(p_conn, NET_TCP_CONN_TX_WIN_CONG_SET_TIMEOUT);
             NetTCP_TxConnWinSizeUpdateAvail(p_conn);           /* Update avail tx win   (see Note #2b3).               */
             break;


        case NET_TCP_CONN_TX_WIN_INC:
             if (win_update_size < 1) {                         /* If NO win update, do NOT update win.                 */
                 break;
             }
                                                                /* Inc rem cong win size.                               */
             NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, win_update_size, NET_TCP_CONN_TX_WIN_CONG_INC_REM);
             NetTCP_TxConnWinSizeUpdateAvail(p_conn);           /* Update avail tx win (see Note #2b3).                 */
             break;


        case NET_TCP_CONN_TX_WIN_DEC:
             if (win_update_size < 1) {                         /* If NO win update, do NOT update win.                 */
                 break;
             }

             if (p_conn->TxWinSizeCongRem >  win_update_size) { /* If rem cong   win size >  win update, ..             */
                 p_conn->TxWinSizeCongRem -= win_update_size;   /* .. dec cong   win size by win update.                */
             } else {
                 p_conn->TxWinSizeCongRem  = 0u;                /* Else lim to min cong   win size.                     */
             }

             if (p_conn->TxWinSizeRemoteRem >  win_update_size) { /* If rem remote win size >  win update, ..           */
                 p_conn->TxWinSizeRemoteRem -= win_update_size; /* .. dec remote win size by win update.                */
             } else {
                 p_conn->TxWinSizeRemoteRem  = 0u;              /* Else lim to min remote win size.                     */
             }

             NetTCP_TxConnWinSizeUpdateAvail(p_conn);           /* Update avail tx win (see Note #2b3).                 */
             break;


        case NET_TCP_CONN_TX_WIN_REMOTE_UPDATE:
                                                                /* Calc actual tx remote win (see Note #3a2A1a).        */
             tx_win_size_remote_actual     = (NET_TCP_WIN_SIZE)(p_buf_hdr->TCP_WinSize - (p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr));
             tx_win_size_remote_actual_min = (NET_TCP_WIN_SIZE) DEF_MIN(p_buf_hdr->TCP_WinSize, tx_win_size_remote_actual);
                                                                /* Update      tx remote win (see Note #3a2).           */
             p_conn->TxWinSizeRemote        = (NET_TCP_WIN_SIZE) p_buf_hdr->TCP_WinSize;
             p_conn->TxWinSizeRemoteActual  = (NET_TCP_WIN_SIZE) tx_win_size_remote_actual_min;
             p_conn->TxWinSizeRemoteRem     = (NET_TCP_WIN_SIZE) p_conn->TxWinSizeRemoteActual;
             p_conn->TxWinUpdateSeqNbr      = (NET_TCP_SEQ_NBR ) p_buf_hdr->TCP_SeqNbr;
             p_conn->TxWinUpdateAckNbr      = (NET_TCP_SEQ_NBR ) p_buf_hdr->TCP_AckNbr;
             p_conn->TxWinUpdateWinSize     = (NET_TCP_WIN_SIZE) p_buf_hdr->TCP_WinSize;

             if (p_conn->TxWinSizeRemoteMax < p_conn->TxWinSizeRemote) { /* If max < updated remote win size, ...       */
                 p_conn->TxWinSizeRemoteMax = p_conn->TxWinSizeRemote; /* ... set as new max   (see Note #3b).          */

                 NetTCP_TxConnWinSizeCfgMinTh(p_conn);          /* Cfg new tx silly win min th.                         */
             }
                                                                /* Handle zero win size (see Note #3c).                 */
             NetTCP_TxConnWinSizeZeroWinHandler(p_conn, NET_TCP_CONN_TX_WIN_REMOTE_UPDATE, NET_TCP_CONN_CLOSE_ALL);

             NetTCP_TxConnWinSizeUpdateAvail(p_conn);           /* Update avail tx win  (see Note #2b3).                */
             break;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                NetTCP_TxConnWinSizeCalcSlowStartTh()
*
* Description : Calculate TCP connection's transmit slow start threshold.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (1) RFC #2581, Section 3.1 states that :
*
*                   (a) "the value of ssthresh MUST be set to no more than" :
*
*                       (3) ssthresh = max (FlightSize / 2, 2 * SMSS)
*
*                           (A) "FlightSize is the amount of outstanding data ... that has been sent but
*                                not yet acknowledged."
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A5a'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeCalcSlowStartTh (NET_TCP_CONN  *p_conn)
{
    NET_TCP_SEQ_NBR   tx_data_unackd;
    NET_TCP_SEQ_NBR   tx_data_unackd_th;
    NET_TCP_SEG_SIZE  max_seg_size_th;

                                                                /* Calc slow start th (see Note #1a3).                  */
    tx_data_unackd              = (NET_TCP_SEQ_NBR ) (p_conn->TxSeqNbrNext - p_conn->TxSeqNbrUnAckd);
    tx_data_unackd_th           = (NET_TCP_SEQ_NBR )((tx_data_unackd * NET_TCP_SST_UNACKD_DATA_NUMER)
                                                                     / NET_TCP_SST_UNACKD_DATA_DENOM);

    max_seg_size_th             = (NET_TCP_SEG_SIZE)p_conn->MaxSegSizeConn * NET_TCP_SST_MSS_SCALAR;

    p_conn->TxWinSizeSlowStartTh = (NET_TCP_WIN_SIZE)DEF_MAX(tx_data_unackd_th,
                                                            max_seg_size_th);
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnWinSizeCongSet()
*
* Description : Set TCP connection's transmit congestion window.
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_TxConnWinSizeHandlerCongCtrl().
*
*               win_inc_code    Indicate how to set TCP connection transmit congestion window :
*
*                                   NET_TCP_CONN_TX_WIN_CONG_SET_SLOW_START         Set TCP connection's congestion
*                                                                                       control transmit window size
*                                                                                       based on slow start.
*
*                                   NET_TCP_CONN_TX_WIN_CONG_SET_FAST_RECOVERY      Set TCP connection's congestion
*                                                                                       control transmit window size
*                                                                                       based on fast recovery
*                                                                                       (see Note #1a).
*
*                                   NET_TCP_CONN_TX_WIN_CONG_SET_TIMEOUT            Set TCP connection's congestion
*                                                                                       control transmit window size
*                                                                                       based on transmission timeout
*                                                                                       (see Note #1b).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (1) (a) RFC #2581, Section 3.2 states that "when the third duplicate ACK is received ...
*                       [for] fast recovery ... set cwnd to ssthresh plus 3*SMSS".
*
*                       See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2B1c'.
*
*                   (b) RFC #2581, Section 3.1 states that "when a TCP sender detects segment loss using the
*                       retransmission timer ... cwnd MUST be set to no more than ... 1 full-sized segment".
*
*                       See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A5b'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeCongSet (NET_TCP_CONN      *p_conn,
                                           NET_TCP_WIN_CODE   win_inc_code)
{
    NET_TCP_WIN_SIZE  win_size_set;


    switch (win_inc_code) {
        case NET_TCP_CONN_TX_WIN_CONG_SET_SLOW_START:
             win_size_set  = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeSlowStartTh;
             break;


        case NET_TCP_CONN_TX_WIN_CONG_SET_FAST_RECOVERY:        /* See Note #1a.                                        */
             win_size_set  = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeSlowStartTh;
             win_size_set += (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_FAST_RECOVERY_MSS_SCALAR;
             break;


        case NET_TCP_CONN_TX_WIN_CONG_SET_TIMEOUT:              /* See Note #1b.                                        */
        default:
             win_size_set  = (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_CONG_WIN_MSS_SCALAR_TIMEOUT;
             break;
    }

    p_conn->TxWinSizeCongCalcdActual = win_size_set;
    p_conn->TxWinSizeCongCalcdCur    = 0u;
    p_conn->TxWinSizeCongRem         = p_conn->TxWinSizeCongCalcdActual;
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnWinSizeCongInc()
*
* Description : Increment TCP connection's transmit congestion window.
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in NetTCP_TxConnWinSizeHandlerCongCtrl().
*
*               p_buf_hdr            Pointer to network buffer header that received TCP packet.
*               --------            Argument validated in NetTCP_Rx().
*
*               win_update_size     Size to increment TCP connection's transmit congestion window (in octets).
*
*               win_inc_code    Indicate how to increment TCP connection transmit congestion window :
*
*                                   NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START     Increment TCP connection's congestion
*                                                                                   control transmit window size
*                                                                                   based on slow start
*                                                                                   (see Note #1a).
*
*                                   NET_TCP_CONN_TX_WIN_CONG_INC_CONG_AVOID     Increment TCP connection's congestion
*                                                                                   control transmit window size
*                                                                                   based on congestion avoidance
*                                                                                   (see Note #1b).
*
*                                   NET_TCP_CONN_TX_WIN_CONG_INC_REM            Increment TCP connection's congestion
*                                                                                   control transmit window size
*                                                                                   remaining.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (1) RFC #2581, Section 3.1 states that :
*
*                   (a) "During slow start, a TCP increments cwnd by at most SMSS bytes for each ACK received
*                        that acknowledges new data."
*
*                       See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A3a'.
*
*                   (b) "During congestion avoidance, cwnd is incremented by 1 full-sized segment per round-
*                        trip time (RTT) ... [An] acceptable way to increase cwnd during congestion avoidance
*                        is to" :
*
*                       (1) "Count the number of bytes that have been acknowledged by ACKs for new data."
*
*                           (A) The following equation calculates the number of octets that acknowledge
*                               new data for a TCP connection :
*
*                                   Number of Octets Acknowledged  =  (SEG.ACK - SND.UNA)
*
*                           (B) However, since TCP connection transmit congestion controls are
*                               updated following any TCP connection re-transmit queue handling
*                               (see 'NetTCP_RxPktConnHandlerSeg()  Notes #1c & #1d'); the saved
*                               previous value of the TCP connection's last unacknowledged
*                               transmit sequence number ('TxSeqNbrUnackdPrev') MUST be used
*                               (see 'NetTCP_RxPktConnHandlerReTxQ()  Note #4').
*
*                       (2) "When the number of bytes acknowledged reaches cwnd," ...
*                       (3) "then cwnd can be incremented by up to SMSS bytes."
*
*                       See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A4'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeCongInc (NET_TCP_CONN      *p_conn,
                                           NET_BUF_HDR       *p_buf_hdr,
                                           NET_TCP_WIN_SIZE   win_update_size,
                                           NET_TCP_WIN_CODE   win_inc_code)
{
    CPU_BOOLEAN       win_size_rem_update;
    NET_TCP_WIN_SIZE  win_size_inc;
    NET_TCP_WIN_SIZE  win_size_inc_mss;
    NET_TCP_WIN_SIZE  win_size_inc_rem;
    NET_TCP_WIN_SIZE  win_size_avail;


    win_size_rem_update =  DEF_NO;
    win_size_inc_mss    = (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_CONG_WIN_MSS_SCALAR_INC;

    switch (win_inc_code) {
        case NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START:           /* See Note #1a.                                        */
        default:
             win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdActual;
             if (win_size_inc_mss < win_size_avail) {           /* If inc < max avail, ..                               */
                 p_conn->TxWinSizeCongCalcdActual += win_size_inc_mss; /* .. inc cong win by MSS (see Note #1a).        */
             } else {
                 p_conn->TxWinSizeCongCalcdActual  = NET_TCP_WIN_SIZE_MAX; /* Else set cong win to max.                 */
             }

             p_conn->TxWinSizeCongCalcdCur = 0u;
             win_size_rem_update          = DEF_YES;
             win_size_inc_rem             = win_size_inc_mss;
             break;


        case NET_TCP_CONN_TX_WIN_CONG_INC_CONG_AVOID:           /* See Note #1b.                                        */
                                                                /* Calc nbr ack'd octets   (see Note #1b1).             */
             win_size_inc   = (NET_TCP_WIN_SIZE)(p_buf_hdr->TCP_AckNbr - p_conn->TxSeqNbrUnAckdPrev);

             win_size_avail =  NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdActual;
             if (win_size_inc < win_size_avail) {               /* If inc < max avail, ..                               */
                 p_conn->TxWinSizeCongCalcdCur += win_size_inc; /* .. inc nbr ack'd octets (see Note #1b1).             */
                                                                /* If  >= cong win         (see Note #1b2),             */
                                                                /* .. inc cong win by MSS  (see Note #1b3).             */
                 if (p_conn->TxWinSizeCongCalcdCur >= p_conn->TxWinSizeCongCalcdActual) {
                     p_conn->TxWinSizeCongCalcdCur -= p_conn->TxWinSizeCongCalcdActual;

                     win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdActual;
                     if (win_size_inc_mss < win_size_avail) {
                          p_conn->TxWinSizeCongCalcdActual += win_size_inc_mss;
                     } else {
                          p_conn->TxWinSizeCongCalcdActual  = NET_TCP_WIN_SIZE_MAX;
                     }
                                                                /* Cfg rem cong win inc by MSS.                         */
                     win_size_rem_update = DEF_YES;
                     win_size_inc_rem    = win_size_inc_mss;
                 }

             } else {                                           /* Else set cong win to max.                            */
                 p_conn->TxWinSizeCongCalcdActual = NET_TCP_WIN_SIZE_MAX;

                 win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdCur;
                 if (win_size_inc < win_size_avail) {           /* If inc < max avail, ..                               */
                     p_conn->TxWinSizeCongCalcdCur += win_size_inc; /* .. inc nbr ack'd octets (see Note #1b1).         */

                 } else {                                       /* Else set nbr ack'd octets to inc ovf ...             */
                     p_conn->TxWinSizeCongCalcdCur  = win_size_inc - win_size_avail;
                                                                /* ... & cfg rem cong win inc by MSS.                   */
                     win_size_rem_update           = DEF_YES;
                     win_size_inc_rem              = win_size_inc_mss;
                 }
             }
             break;


        case NET_TCP_CONN_TX_WIN_CONG_INC_REM:                  /* Cfg rem cong win inc by win update size.             */
             win_size_rem_update = DEF_YES;
             win_size_inc_rem    = win_update_size;
             break;
    }


    if (win_size_rem_update == DEF_YES) {                       /* If rem tx cong win update req'd  ...                 */
        if (p_conn->TxWinSizeCongRem < p_conn->TxWinSizeCongCalcdActual) { /* ... & < actual tx cong win size, ...      */
                                                                /* ... inc rem tx cong win size.                        */
            win_size_avail = p_conn->TxWinSizeCongCalcdActual - p_conn->TxWinSizeCongRem;
            if (win_size_inc_rem < win_size_avail) {            /* If avail win size > rem inc, ...                     */
                p_conn->TxWinSizeCongRem += win_size_inc_rem;   /* ... inc rem tx cong win size by rem inc.             */
            } else {                                            /* Else lim to actual tx cong win size.                 */
                p_conn->TxWinSizeCongRem  = p_conn->TxWinSizeCongCalcdActual;
            }
        }
    }
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnWinSizeUpdateAvail()
*
* Description : Update TCP connection's available transmit window.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeCfgCongCtrl(),
*               NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (1) (a) RFC #2001, Section 1 states that "the sender can transmit up to the minimum
*                       of the congestion window and the advertised window."
*
*                   (b) RFC #2001, Section 2.2 reiterates that "the TCP output routine never sends
*                       more than the minimum of cwnd and the receiver's advertised window".
*
*                   (c) RFC #2581, Section 3.1 also reiterates that "the minimum of cwnd and rwnd
*                       [receiver's advertised window] governs data transmission".
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2b3'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeUpdateAvail (NET_TCP_CONN  *p_conn)
{
                                                                /* Calc avail tx win (see Note #1).                     */
    p_conn->TxWinSizeAvail = DEF_MIN(p_conn->TxWinSizeCongRem,
                                    p_conn->TxWinSizeRemoteRem);
}


/*
*********************************************************************************************************
*                                NetTCP_TxConnWinSizeDupAckCtrlReset()
*
* Description : Reset TCP connection's transmit window duplicate acknowledgement controls.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnWinSizeCfgCongCtrl().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeCfgCongCtrl().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeDupAckCtrlReset (NET_TCP_CONN  *p_conn)
{
    p_conn->TxWinRxdLastSeqNbr  = p_conn->RxSeqNbrNext;
    p_conn->TxWinRxdLastAckNbr  = p_conn->TxSeqNbrNext;
    p_conn->TxWinRxdLastWinSize = p_conn->TxWinSizeRemote;
    p_conn->TxWinRxdAckDupCtr   = 0u;
}


/*
*********************************************************************************************************
*                               NetTCP_TxConnWinSizeDupAckCtrlUpdate()
*
* Description : Update TCP connection's transmit window duplicate acknowledgment controls.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnWinSizeHandlerCongCtrl().
*
*               p_buf_hdr    Pointer to network buffer header that received TCP packet.
*               --------    Argument validated in NetTCP_Rx().
*
*               reset_ctr   Indicate whether to reset the duplicate acknowledgment counter :
*
*                               DEF_YES                Reset duplicate acknowledgment counter.
*                               DEF_NO          Do NOT reset duplicate acknowledgment counter.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeDupAckCtrlUpdate (NET_TCP_CONN  *p_conn,
                                                    NET_BUF_HDR   *p_buf_hdr,
                                                    CPU_BOOLEAN    reset_ctr)
{
    p_conn->TxWinRxdLastSeqNbr  = p_buf_hdr->TCP_SeqNbr;
    p_conn->TxWinRxdLastAckNbr  = p_buf_hdr->TCP_AckNbr;
    p_conn->TxWinRxdLastWinSize = p_buf_hdr->TCP_WinSize;

    if (reset_ctr == DEF_YES) {
        p_conn->TxWinRxdAckDupCtr = 0u;
    }
}


/*
*********************************************************************************************************
*                                 NetTCP_TxConnWinSizeZeroWinHandler()
*
* Description : Handle TCP connection's transmit queue zero window.
*
* Argument(s) : p_conn              Pointer to TCP connection.
*               -----               Argument validated in NetTCP_TxConnWinSizeHandlerCongCtrl(),
*                                                         NetTCP_TxConnWinSizeZeroWinTimeout().
*
*               win_update_code     Indicate how to update TCP connection transmit window :
*
*                                       NET_TCP_CONN_TX_WIN_REMOTE_UPDATE   Handle TCP connection's remote
*                                                                               receive      window size update.
*                                       NET_TCP_CONN_TX_WIN_TIMEOUT         Handle TCP connection's remote
*                                                                               receive zero window size timeout.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_KEEP_ALIVE       Close connection keep-alive             timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeZeroWinTimeout(),
*               NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (1) RFC #1122, Section 4.2.2.17 states that although "a TCP MAY keep its offered receive
*                   window closed indefinitely ... the sending TCP MUST allow the connection to stay open
*                   ... as long as the receiving TCP continues to send acknowledgments in response to ...
*                   probe segments".
*
*                   (a) "Probing of zero (offered) windows MUST be supported."
*
*                       (1) "If zero window probing is not supported, a connection may hang forever when
*                            an ACK segment that re-opens the window is lost."
*
*                           See also Note #1c2.
*
*                   (b) (1) "The transmitting host SHOULD send the first zero-window probe when a zero
*                            window has existed for the retransmission timeout period," ...
*
*                       (2) "and SHOULD increase exponentially the interval between successive probes."
*
*                           (A) "Exponential backoff is recommended ... similar to ... the retransmission
*                                algorithm, and it may be possible to combine the two procedures in the
*                                implementation."
*
*                               See also 'NetTCP_TxConnRTO_CalcBackOff()  Notes #1 & #2'.
*
*                           (B) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 22.2,
*                                   Page 325 reiterates that "the normal TCP exponential backoff is used
*                                   when calculating the persist timer".
*
*                               (2) However, "the persist timer is always bounded between 5 and 60 seconds".
*
*                           (C) Therefore, it seems reasonable to implement TCP zero window probes with
*                               the same algorithm as TCP retransmissions, including limiting zero window
*                               probes' minimum & maximum timeout values.
*
*                               See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2b1'.
*
*                   (c) (1) (A) "It is extremely important to remember that ACK (acknowledgment) segments
*                                that contain no data are not reliably transmitted by TCP."
*
*                           (B) "This procedure minimizes delay if the zero-window condition is due to a
*                                lost ACK segment containing a window-opening update."
*
*                           (C) Thus Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 22.2,
*                               Page 325 adds that "window probes contain 1 byte of data" but unlike TCP
*                               "retransmission ... TCP never gives up sending window probes ... [which]
*                               continue to be sent ... until the window opens up or either of the
*                               applications using the connection is terminated".
*
*                       (2) RFC #793, Section 3.7 'Data Communication : Managing the Window : Window
*                           Management Suggestions' states that "if a segment containing a single data
*                           octet sent to probe a zero window is accepted, it consumes one octet of the
*                           window now available ... As time goes on, occasional pauses in the receiver
*                           making window allocation available will result in ... the transmitted data
*                           will be[ing] broken into alternating big and small segments ... And after
*                           a while the data transmission will be in mostly small segments ... but TCP
*                           implementations need to actively attempt to combine small window allocations
*                           into larger windows, since the mechanisms for managing the window tend to
*                           lead to many small windows".
*
*                       (3) So although it is suggested, NO RFC requires that a TCP zero window probe
*                           include data.  Therefore, it seems reasonable to transmit TCP zero window
*                           probes similar to TCP Keep-Alive probes, i.e. without any data from the TCP
*                           connection's transmit queue.
*
*                           See also 'NetTCP_TxConnProbe()  Note #2b2'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeZeroWinHandler (NET_TCP_CONN        *p_conn,
                                                  NET_TCP_WIN_CODE     win_update_code,
                                                  NET_TCP_CLOSE_CODE   close_code)
{
    CPU_BOOLEAN         tmr_update;
    NET_TCP_TIMEOUT_MS  timeout_ms;
    NET_TMR_TICK        timeout_tick;
    NET_ERR             err;


                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             return;


        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }


                                                                /* ----------- HANDLE TCP CONN TX ZERO WIN ------------ */
    tmr_update = DEF_NO;

    switch (win_update_code) {
        case NET_TCP_CONN_TX_WIN_REMOTE_UPDATE:
        default:
             if (p_conn->TxWinSizeRemote > 0) {                 /* If remote win size > 0, ...                          */
                 if (p_conn->TxQ_ZeroWinTmr != DEF_NULL) {      /* ... free zero win tmr.                               */
                     NetTmr_Free(p_conn->TxQ_ZeroWinTmr);
                     p_conn->TxQ_ZeroWinTmr  = DEF_NULL;
                 }

             } else {                                           /* Else if remote win size zero            ...          */
                 if (p_conn->TxQ_ZeroWinTmr == DEF_NULL) {      /* ... & NO zero win tmr;                  ...          */
                                                                /* ... set first tx zero win probe timeout ...          */
                     timeout_ms   = p_conn->TxRTT_RTO_ms;       /* ... = RTO (see Note #1b1).                           */
                     timeout_tick = p_conn->TxRTT_RTO_tick;
                     tmr_update   = DEF_YES;
                 }
             }
             break;


        case NET_TCP_CONN_TX_WIN_TIMEOUT:                       /* On timeout,                             ...          */
             NetTCP_TxConnProbe((NET_TCP_CONN     *) p_conn,    /* ... tx zero-win probe   (see Note #1c3) ...          */
                                (CPU_BOOLEAN       ) DEF_NO,
                                (NET_TCP_CLOSE_CODE) close_code,
                                (NET_ERR          *)&err);      /* Ignore transitory tx err(s).                         */
                                                                /* ... & calc next timeout (see Note #1b2).             */
             timeout_ms   =  (NET_TCP_TIMEOUT_MS)NetTCP_TxConnRTO_CalcBackOff(p_conn, p_conn->TxWinZeroWinTimeout_ms);
             timeout_tick = ((NET_TMR_TICK      )timeout_ms * NET_TMR_TIME_TICK_PER_SEC) / DEF_TIME_NBR_mS_PER_SEC;
             tmr_update   =   DEF_YES;
             break;
    }


    if (tmr_update == DEF_YES) {                                /* If tx probe tmr update req'd, ...                    */
                                                                /* ... get tx zero win probe tmr.                       */
        p_conn->TxQ_ZeroWinTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_TxConnWinSizeZeroWinTimeout,
                                            (void        *) p_conn,
                                            (NET_TMR_TICK ) timeout_tick,
                                            (NET_ERR     *)&err);

        if (err == NET_TMR_ERR_NONE) {                          /* If NO err(s), cfg tx zero win probe timeout.         */
            p_conn->TxWinZeroWinTimeout_ms = timeout_ms;
        }                                                       /* Else ignore transitory rsrc err(s) ...               */
                                                                /* ... [see Note #1a1].                                 */
    }
}


/*
*********************************************************************************************************
*                                 NetTCP_TxConnWinSizeZeroWinTimeout()
*
* Description : (1) (a) Handle TCP connection's transmit queue zero window persist timeout ... :
*
*                       (1) Clear  TCP connection's transmit zero window persist timer      See Notes #4a1A & #4a2
*                       (2) Handle TCP connection   transmit zero window                    See Note  #2
*
*                   (b) ... for the following states :
*
*                       (1) ESTABLISHED
*                       (2) FIN-WAIT-1
*                       (3) CLOSING
*                       (4) CLOSE-WAIT
*                       (5) LAST-ACK
*
*
* Argument(s) : p_conn_timeout       Pointer to TCP connection (see Note #3b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_TxConnWinSizeZeroWinHandler().
*
* Note(s)     : (2) RFC #1122, Section 4.2.2.17 states that the "probing of zero (offered) windows
*                   ... SHOULD send the first zero-window probe when a zero window has existed for
*                   the retransmission timeout period and SHOULD increase exponentially the interval
*                   between successive probes".
*
*                   See also 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1'.
*
*               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (4) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection transmit zero window persist timer ('TxQ_ZeroWinTmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared prior to next handler function(s); ...
*                               (2) Cleared prior to invalid state fault exit.
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN
*
*               (5) Certain network connections MUST periodically suspend network transmit(s) to handle
*                   network receive packet(s).  To protect TCP connections from transmit corruption while
*                   suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
*                   suspended connections until the connection is no longer suspended.
*
*                   However, handling the TCP connection's transmit zero window timeout is permitted since
*                   NO new TCP data is prepared from the TCP connection's transmit queue (see Note #1a).
*
*                   See also 'NetTCP_TxConnTxQ()                  Note #12b2A2',
*                            'NetTCP_TxConnTxQ_TimeoutIdle()      Note #5',
*                            'NetTCP_TxConnTxQ_TimeoutSillyWin()  Note #5',
*                          & 'NetTCP_TxConnReTxQ_Timeout()        Note #5'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnWinSizeZeroWinTimeout (void  *p_conn_timeout)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CLOSE_CODE   close_code;


    p_conn      = (NET_TCP_CONN *)p_conn_timeout;               /* See Note #3b2A.                                      */

    close_code =  NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN);/* See Note #4b1.                                       */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             p_conn->TxQ_ZeroWinTmr = DEF_NULL;                 /* See Note #4a2A2.                                     */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1.                                         */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:               /* See Note #5.                                         */
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      p_conn->TxQ_ZeroWinTmr = DEF_NULL;        /* See Note #4a2A2.                                     */
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }
#endif


                                                                /* ------- HANDLE TCP CONN TX ZERO WIN TIMEOUT -------- */
    p_conn->TxQ_ZeroWinTmr = DEF_NULL;                          /* Clr    tx zero win tmr (see Note #4a2A1).            */

                                                                /* Handle tx zero win     (see Note #2).                */
    NetTCP_TxConnWinSizeZeroWinHandler(p_conn, NET_TCP_CONN_TX_WIN_TIMEOUT, close_code);
}


/*
*********************************************************************************************************
*                                         NetTCP_TxConnSync()
*
* Description : (1) Prepare & transmit a TCP connection synchronization :
*
*                   (a) Validate TCP connection state
*                   (b) Prepare  TCP connection synchronization :
*                       (1) Get  timer
*                       (2) Get  buffer
*                       (3) Prepare TCP segment :
*                           (A) TCP segment  addresses
*                           (B) TCP segment  sequence numbers
*                           (C) TCP segment  transmit flags :
*                               (1) SYN
*                               (2) ACK
*                           (D) TCP segment  window size
*                           (E) TCP segment  options
*                           (F) IP  datagram parameters
*                           (G) TCP segment  packet buffer controls
*                   (c) Update  TCP connection :
*                       (1) Queue  TCP connection synchronization packet
*                       (2) Update TCP connection sequence numbers
*                   (d) Transmit   TCP connection synchronization
*
*
*               (2) (a) RFC #793, Section 3.3 'Sequence Numbers : Initial Sequence Number Selection' states
*                       that "for a [TCP] connection to be established or initialized, ... two TCP's must
*                       synchronize ... each other's initial sequence numbers" by transmitting initial
*                       connection request segments (i.e., segments with the SYN control bit set).
*
*                       RFC #793, Section 3.4 states that "this procedure normally is initiated by one TCP
*                       and responded to by another TCP ... [but] works if two TCP simultaneously initiate
*                       the procedure".
*
*                   (b) RFC #793, Section 3.9 'Event Processing : OPEN Call : CLOSED STATE' states that after
*                       "a SYN segment ... is sent ... [to] set SND.UNA to ISS [initial send sequence number],
*                       SND.NXT to ISS+1".
*
*                       The following sections confirm these sequence number configurations summary :
*
*                       (1) RFC #793, Section 3.9 'Event Processing : OPEN Call : LISTEN STATE'
*                       (2) RFC #793, Section 3.9 'Event Processing : SEND Call : LISTEN STATE'
*                       (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
*                               Check for SYN'
*
*               (3) A TCP connection's transmit sequences are initialized when the initial TCP synchronization
*                   segment is queued for transmission :
*
*                   (a) 'TxSeqNbrSync' points to the initial, synchronization (SYN) transmit sequence number.
*
*                   (b) (1) 'TxSeqNbrNextQ' points to the next transmit sequence number to enqueue data octets.
*                       (2) 'TxSeqNbrNext'  points to the next transmit sequence number to transmit.
*
*
*                               -----          -----------------------        Initial Synchronization
*                                 ^            |  Initial SEQ #(SYN) |  <---  Transmit Sequence Number
*                                 |            -----------------------            (see Note #3a)
*                                 |            |    Data Octet #1    |  ---
*                                 |            |    Data Octet #2    |   ^
*                                 |            |    Data Octet #3    |   |
*                                              |          .          |   |         Next / Queued
*                           TCP Connection     |          .          |   |   Transmit Sequence Number(s)
*                         Transmit Sequences   |          .          |   |         (see Note #3b)
*                           (see Note #3)      | Data Octet #(N - 2) |   |
*                                              | Data Octet #(N - 1) |   v
*                                 |            | Data Octet #   N    |  ---
*                                 |            -----------------------
*                                 |            |   Close SEQ #(FIN)  |
*                                 |            -----------------------
*                                 v            |    Last SEQ #       |
*                               -----          -----------------------
*
*
*                   See also 'NetTCP_TxConnClose()  Note #2'.
*
*
* Argument(s) : p_conn      Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnReq(),
*                                                 NetTCP_RxPktConnHandlerListen().
*
*               p_buf_hdr   Pointer to network buffer header that received TCP packet.
*
*               state       Current TCP connection state at time of connection request.
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection synchronization successfully
*                                                                       transmitted.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   - RETURNED BY NetTCP_TxConnPrepareSegAddrs() : -
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
*                                                                   ----- RETURNED BY NetTCP_TxPktHandler() : ------
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN                Network  interface link state down (i.e.
*                                                                       NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnReq(),
*               NetTCP_RxPktConnHandlerListen(),
*               NetTCP_RxPktConnHandlerSyncTxd().
*
* Note(s)     : (4) RFC #1122, Section 4.2.2.6 states that a "TCP SHOULD send an MSS (Maximum Segment Size)
*                   option in every SYN segment".
*
*               (5) Network resources MUST be appropriately allocated/deallocated :
*
*                   (a) Increment network buffer's reference counter to include the TCP connection
*                       synchronization segment now enqueued to the TCP connection's re-transmit
*                       queue as a new reference to the network buffer.
*
*                       This differs from the handling of TCP connection   close segment's reference counter
*                       since NetTCP_TxConnClose() defers incrementing the close segment's reference counter
*                       to NetTCP_TxConnTxQ() when it enqueues the   TCP connection close segment to the TCP
*                       connection's re-transmit queue (see 'NetTCP_TxConnClose()  Note #3a'); whereas
*                       NetTCP_TxConnSync() immediately enqueues the TCP connection synchronization segment
*                       to the TCP connection's re-transmit queue & transmits the segment.
*
*                   (b) On ANY error(s), network resources MUST be appropriately freed :
*
*                       (1) For any network resources NOT  yet       linked to the TCP connection, each
*                           network resource  MUST be freed by appropriate function(s).
*                       (2) For all network resources that have been linked to the TCP connection, ALL
*                           network resources are     freed by NetTCP_ConnClose().
*
*               (6) If transmitting a TCP synchronization packet from the SYN-SENT state :
*
*                   (a) Connection timeout is reset to initial synchronization timeout value
*                   (b) Previous synchronization sequence number MUST be re-used
*                   (c) Previous synchronization packet in TCP connection's re-transmit queue is freed
*
*                   See also 'NetTCP_RxPktConnHandlerSyncTxd()  Note #2c3B2'.
*
*               (7) IP transmit options currently NOT implemented      See 'net_tcp.h  Note #1d'
*********************************************************************************************************
*/

static  void  NetTCP_TxConnSync (NET_TCP_CONN        *p_conn,
                                 NET_BUF_HDR         *p_buf_hdr,
                                 NET_TCP_CONN_STATE   state,
                                 NET_ERR             *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_TTL                   TTL;
    NET_IPv4_TOS                   TOS;
    NET_IPv4_ADDR                  src_addrv4;
    NET_IPv4_ADDR                  dest_addrv4;
    NET_IPv4_FLAGS                 flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_TRAFFIC_CLASS         traffic_class;
    NET_IPv6_FLOW_LABEL            flow_label;
    NET_IPv6_HOP_LIM               hop_lim;
    NET_IPv6_ADDR                  src_addrv6;
    NET_IPv6_ADDR                  dest_addrv6;
    NET_IPv6_FLAGS                 flags_ipv6;
#endif
    NET_CONN_ID                    conn_id;
    NET_CONN                      *p_net_conn;
    NET_IF_NBR                     if_nbr;
    NET_BUF                       *pseg_sync;
    NET_BUF_HDR                   *pseg_sync_hdr;
    NET_BUF_SIZE                   data_len;
    NET_BUF_SIZE                   data_ix;
    NET_BUF_SIZE                   data_ix_offset;
    NET_TCP_PORT_NBR               src_port;
    NET_TCP_PORT_NBR               dest_port;
    NET_TCP_SEQ_NBR                seq_nbr;
    NET_TCP_SEQ_NBR                ack_nbr;
    NET_TCP_WIN_SIZE               win_size;
    NET_PROTOCOL_TYPE              protocol;
    CPU_INT16U                     payload_max;
    NET_TCP_OPT_CFG_MAX_SEG_SIZE  *p_opt_cfg_max_seg_size;
    NET_TCP_OPT_CFG_MAX_SEG_SIZE   opt_cfg_max_seg_size;
    NET_TCP_FLAGS                  flags_tcp;
    NET_PROTOCOL_TYPE              proto_type = NET_PROTOCOL_TYPE_NONE;
    NET_ERR                        err;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (state) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_CONN_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
#endif


                                                                /* ------------ PREPARE TCP CONN SYNC SEG ------------- */
                                                                /* --------------------- GET TMR ---------------------- */
    NetTCP_TxConnReTxQ_TimeoutSet(p_conn, DEF_NO, NET_TCP_CONN_CLOSE_ALL, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }


                                                                /* --------------------- GET BUF ---------------------- */
    conn_id    = p_conn->ID_Conn;
    p_net_conn = (NET_CONN *)&NetConn_Tbl[conn_id];
    if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
    if ( err != NET_CONN_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_CONN_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    data_len  = NET_TCP_DATA_LEN_TX_SYNC;

    switch (p_net_conn->Family) {
        case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
             proto_type = NET_PROTOCOL_TYPE_TCP_V4;
             break;


        case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
             proto_type = NET_PROTOCOL_TYPE_TCP_V6;
             break;


        default:
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return;
    }

    data_ix = 0u;

    NetTCP_GetTxDataIx(if_nbr, proto_type, 4u, data_len, p_conn, &data_ix, p_err);
    pseg_sync = NetBuf_Get(if_nbr, NET_TRANSACTION_TX, data_len, data_ix, &data_ix_offset, NET_BUF_FLAG_NONE, &err);
    if ( err != NET_BUF_ERR_NONE) {                             /* See Note #5b1.                                       */
       *p_err  = NET_TCP_ERR_NONE_AVAIL;
        return;
    }

    data_ix       += data_ix_offset;
    pseg_sync_hdr  = &pseg_sync->Hdr;
                                                                /* ----------------- PREPARE TCP HDR ------------------ */
                                                                /* Prepare seg addrs.                                   */
    if (p_buf_hdr != DEF_NULL) {                                /* If TCP pkt rx'd, cfg TCP tx                ...       */
                                                                /* ...  src  addr from rx'd TCP pkt dest addr ...       */
        if (DEF_BIT_IS_CLR(p_buf_hdr->Flags,   NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
            src_addrv4  = (NET_IPv4_ADDR   )p_buf_hdr->IP_AddrDest;
                                                                /* .. & dest addr from rx'd TCP pkt src  addr.          */
            dest_addrv4 = (NET_IPv4_ADDR   )p_buf_hdr->IP_AddrSrc;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            DEF_BIT_SET(pseg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);

            src_addrv6  = p_buf_hdr->IPv6_AddrDest;
                                                                /* .. & dest addr from rx'd TCP pkt src  addr.          */
            dest_addrv6 = p_buf_hdr->IPv6_AddrSrc;
#endif
        }
        src_port        = (NET_TCP_PORT_NBR)p_buf_hdr->TransportPortDest;
        dest_port       = (NET_TCP_PORT_NBR)p_buf_hdr->TransportPortSrc;
    } else {                                                    /* Else cfg TCP tx pkt addrs from TCP conn addrs.       */

        if (p_net_conn->Family == NET_CONN_FAMILY_IP_V4_SOCK) {

#ifdef  NET_IPv4_MODULE_EN
            NetTCP_TxConnPrepareSegAddrs((NET_TCP_CONN *) p_conn,
                                         (CPU_INT08U   *)&src_addrv4,
                                         (CPU_INT08U   *)&src_port,
                                         (CPU_INT16U    ) sizeof(src_addrv4),
                                         (CPU_INT16U    ) sizeof(src_port),
                                         (CPU_INT08U   *)&dest_addrv4,
                                         (CPU_INT08U   *)&dest_port,
                                         (CPU_INT16U    ) sizeof(dest_addrv4),
                                         (CPU_INT16U    ) sizeof(dest_port),
                                         (NET_ERR      *) p_err);
#endif
        } else if (p_net_conn->Family == NET_CONN_FAMILY_IP_V6_SOCK) {
#ifdef  NET_IPv6_MODULE_EN
            DEF_BIT_SET(pseg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
            NetTCP_TxConnPrepareSegAddrs((NET_TCP_CONN *) p_conn,
                                         (CPU_INT08U   *)&src_addrv6,
                                         (CPU_INT08U   *)&src_port,
                                         (CPU_INT16U    ) sizeof(src_addrv6),
                                         (CPU_INT16U    ) sizeof(src_port),
                                         (CPU_INT08U   *)&dest_addrv6,
                                         (CPU_INT08U   *)&dest_port,
                                         (CPU_INT16U    ) sizeof(dest_addrv6),
                                         (CPU_INT16U    ) sizeof(dest_port),
                                         (NET_ERR      *) p_err);
#endif
        } else {
                                                                /* Empty Else Statement                                 */
        }
        if (*p_err != NET_TCP_ERR_NONE) {                       /* See Note #5b1.                                       */
             NetBuf_Free(pseg_sync);
             return;
        }
    }


                                                                /* Prepare TCP sync seq nbrs.                           */
    if (state != NET_TCP_CONN_STATE_SYNC_TXD) {                 /* For non-sync-tx'd states (see Note #6b), ...         */
#ifndef  NET_TCP_CFG_RANDOM_ISN_GEN
        NET_TCP_TX_GET_SEQ_NBR(seq_nbr);                        /* ... get sync seq nbr. (See Note #1 of macro's def.). */
#else
        NET_TCP_TX_GET_SEQ_NBR(seq_nbr, p_net_conn);            /* ... get sync seq nbr as specified RFC #6528, (i.e ...*/
#endif                                                          /* ... hash IPs, ports, secret key & add to 4uS tmr val.*/
    } else {
        seq_nbr = p_conn->TxSeqNbrSync;
    }
    ack_nbr = (state != NET_TCP_CONN_STATE_CLOSED) ? p_conn->RxSeqNbrNext
                                                   : NET_TCP_ACK_NBR_NONE;

                                                                /* Prepare TCP tx flags (see Note #1b3C).               */
    flags_tcp  = NET_TCP_FLAG_NONE   |
                 NET_TCP_FLAG_TX_SYNC;
    if (state != NET_TCP_CONN_STATE_CLOSED) {                   /* For non-CLOSED state, ...                            */
        DEF_BIT_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);            /* ... tx ACK.                                          */
    }

                                                                /* Prepare TCP rx win size.                             */
    win_size = p_conn->RxWinSizeActual;



                                                                /* Prepare TCP max seg size opt (see Note #4).          */
                                                                /* Get IF's MTU's.                                      */
    if (DEF_BIT_IS_CLR(pseg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
        protocol = NET_PROTOCOL_TYPE_TCP_V4;
    } else {
        protocol = NET_PROTOCOL_TYPE_TCP_V6;
    }

    payload_max = NetIF_GetPayloadTxMax(if_nbr, protocol, &err);
    if (err != NET_IF_ERR_NONE) {
       *p_err  = NET_TCP_ERR_CONN_FAIL;
        return;
    }

                                                                /* Calc TCP conn's local max seg size.                  */
    p_conn->MaxSegSizeLocalActual      =  payload_max;

    p_opt_cfg_max_seg_size             = &opt_cfg_max_seg_size;
    p_opt_cfg_max_seg_size->Type       =  NET_TCP_OPT_TYPE_MAX_SEG_SIZE;
    p_opt_cfg_max_seg_size->MaxSegSize =  p_conn->MaxSegSizeLocalActual;
    p_opt_cfg_max_seg_size->NextOptPtr =  DEF_NULL;

    if (DEF_BIT_IS_CLR(pseg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
                                                                /* Prepare IP params.                                   */
    NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL, &err);
    if ( err != NET_CONN_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_CONN_ALL);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6, &err);
        if ( err != NET_CONN_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_CONN_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
#endif
    }


                                                                /* Init buf ctrls.                                      */
    pseg_sync_hdr                           = &pseg_sync->Hdr;
    pseg_sync_hdr->DataIx                   = (CPU_INT16U  )data_ix;
    pseg_sync_hdr->DataLen                  = (NET_BUF_SIZE)data_len;
    pseg_sync_hdr->TotLen                   = (NET_BUF_SIZE)pseg_sync_hdr->DataLen;


    if (DEF_BIT_IS_CLR(pseg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        pseg_sync_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V4;
        pseg_sync_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V4;
        pseg_sync_hdr->IP_AddrSrc               = (NET_IPv4_ADDR)src_addrv4;
        pseg_sync_hdr->IP_AddrDest              = (NET_IPv4_ADDR)dest_addrv4;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        pseg_sync_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V6;
        pseg_sync_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V6;
        pseg_sync_hdr->IPv6_AddrSrc             = src_addrv6;
        pseg_sync_hdr->IPv6_AddrDest            = dest_addrv6;
#endif
    }


    pseg_sync_hdr->TransportPortSrc          = (NET_PORT_NBR )src_port;
    pseg_sync_hdr->TransportPortDest         = (NET_PORT_NBR )dest_port;

    pseg_sync_hdr->TCP_SegLenInit           = (NET_TCP_SEG_SIZE)NET_TCP_SEG_LEN_SYNC;
    pseg_sync_hdr->TCP_SegLen               = (NET_TCP_SEG_SIZE)pseg_sync_hdr->TCP_SegLenInit;
    pseg_sync_hdr->TCP_SegLenLast           = (NET_TCP_SEG_SIZE)pseg_sync_hdr->TCP_SegLenInit;
    pseg_sync_hdr->TCP_SegLenData           = (NET_TCP_SEG_SIZE)0u;
    pseg_sync_hdr->TCP_SegSync              = (CPU_BOOLEAN     )DEF_YES;
    pseg_sync_hdr->TCP_SegClose             = (CPU_BOOLEAN     )DEF_NO;
    pseg_sync_hdr->TCP_SegAck               = (CPU_BOOLEAN     )DEF_BIT_IS_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
    pseg_sync_hdr->TCP_SegReset             = (CPU_BOOLEAN     )DEF_NO;

    pseg_sync_hdr->TCP_SeqNbrInit           = (NET_TCP_SEQ_NBR )seq_nbr;
    pseg_sync_hdr->TCP_SeqNbrLast           = (NET_TCP_SEQ_NBR )pseg_sync_hdr->TCP_SeqNbrInit;
    pseg_sync_hdr->TCP_SeqNbr               = (NET_TCP_SEQ_NBR )pseg_sync_hdr->TCP_SeqNbrInit;
    pseg_sync_hdr->TCP_AckNbr               = (NET_TCP_SEQ_NBR )ack_nbr;
    pseg_sync_hdr->TCP_AckNbrLast           = (NET_TCP_SEQ_NBR )pseg_sync_hdr->TCP_AckNbr;

    pseg_sync_hdr->TCP_WinSizeLast          = (NET_TCP_WIN_SIZE)win_size;

    pseg_sync_hdr->TCP_Flags                = (NET_TCP_FLAGS   )flags_tcp;

    pseg_sync_hdr->TCP_SegReTxCtr           = (NET_PKT_CTR     )0u;
    pseg_sync_hdr->RefCtr++;                                    /* TCP maintains ref until seg ack'd (see Note #5a).    */


                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* Q conn sync seg to TCP re-tx Q.                      */
    NetTCP_ConnFreeBufQ(&p_conn->ReTxQ_Head, &p_conn->ReTxQ_Tail); /* Free re-tx Q (see Note #6c).                      */
    p_conn->ReTxQ_Head         =  pseg_sync;
    p_conn->ReTxQ_Tail         =  pseg_sync;
                                                                /* Update TCP conn seq nbrs (see Notes #2 & #3).        */
    p_conn->TxSeqNbrSync       = (NET_TCP_SEQ_NBR) seq_nbr;
    p_conn->TxSeqNbrNext       = (NET_TCP_SEQ_NBR)(seq_nbr + pseg_sync_hdr->TCP_SegLen);
    p_conn->TxSeqNbrNextQ      = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrNext;
    p_conn->TxSeqNbrUnAckdPrev = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrUnAckd;
    p_conn->TxSeqNbrUnAckd     = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrSync;
    p_conn->TxSeqNbrUnReTxd    = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrUnAckd;



                                                                /* --------------- TX TCP CONN SYNC SEG --------------- */
    if (DEF_BIT_IS_CLR(pseg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        NetTCP_TxPktHandlerIPv4((NET_BUF        *)pseg_sync,
                                (NET_IPv4_ADDR   )src_addrv4,
                                (NET_TCP_PORT_NBR)src_port,
                                (NET_IPv4_ADDR   )dest_addrv4,
                                (NET_TCP_PORT_NBR)dest_port,
                                (NET_TCP_SEQ_NBR )seq_nbr,
                                (NET_TCP_SEQ_NBR )ack_nbr,
                                (NET_TCP_WIN_SIZE)win_size,
                                (NET_IPv4_TOS    )TOS,
                                (NET_IPv4_TTL    )TTL,
                                (NET_TCP_FLAGS   )flags_tcp,
                                (NET_IPv4_FLAGS  )flags_ipv4,
                                (void           *)p_opt_cfg_max_seg_size,
                                (void           *)0,            /* See Note #7.                                         */
                                (NET_ERR        *)p_err);
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        NetTCP_TxPktHandlerIPv6((NET_BUF              *) pseg_sync,
                                (NET_IPv6_ADDR        *)&src_addrv6,
                                (NET_TCP_PORT_NBR      ) src_port,
                                (NET_IPv6_ADDR        *)&dest_addrv6,
                                (NET_TCP_PORT_NBR      ) dest_port,
                                (NET_TCP_SEQ_NBR       ) seq_nbr,
                                (NET_TCP_SEQ_NBR       ) ack_nbr,
                                (NET_TCP_WIN_SIZE      ) win_size,
                                (NET_IPv6_TRAFFIC_CLASS) traffic_class,
                                (NET_IPv6_FLOW_LABEL   ) flow_label,
                                (NET_IPv6_HOP_LIM      ) hop_lim,
                                (NET_TCP_FLAGS         ) flags_tcp,
                                (void                 *) p_opt_cfg_max_seg_size,
                                (NET_ERR              *) p_err);
#endif
    }

    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s).                         */
             NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnSyncCtr);
             break;


        case NET_ERR_IF_LINK_DOWN:
             NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnSyncCtr);
             return;


        case NET_TCP_ERR_TX_PKT:
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_CONN_ALL);
             return;
    }



   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                        NetTCP_TxConnClose()
*
* Description : (1) Prepare & transmit a TCP connection close :
*
*                   (a) Validate TCP connection state
*                   (b) Prepare  TCP connection close segment :
*                       (1) Get  buffer
*                       (2) Prepare TCP segment :
*                           (A) TCP segment  addresses
*                           (B) TCP segment  sequence numbers
*                           (C) TCP segment  transmit flags :
*                               (1) ACK
*                               (2) FIN
*                           (D) TCP segment  window size
*                           (E) IP  datagram parameters
*                           (F) TCP segment  packet buffer controls
*                   (c) Update  TCP connection :
*                       (1) Queue  TCP connection close packet
*                       (2) Update TCP connection sequence number(s)
*                   (d) Transmit   TCP connection close segment
*
*
*               (2) A TCP connection's transmit sequences are closed when the closing TCP segment is queued
*                   for transmission :
*
*                   (a) 'TxSeqNbrClose' points to the closing (FIN) transmit sequence number.
*
*                   (b) 'TxSeqNbrLast'  points to the last sequence number used to close the TCP connection
*                                           transmit sequences when acknowledged.
*
*
*                                  -----          -----------------------
*                                    ^            |  Initial SEQ #(SYN) |
*                                    |            -----------------------
*                                    |            |    Data Octet #1    |
*                                    |            |    Data Octet #2    |
*                                    |            |    Data Octet #3    |
*                                                 |          .          |
*                              TCP Connection     |          .          |
*                            Transmit Sequences   |          .          |
*                              (see Note #2)      | Data Octet #(N - 2) |
*                                                 | Data Octet #(N - 1) |
*                                    |            | Data Octet #   N    |        Closing Transmit
*                                    |            -----------------------        Sequence Number
*                                    |            |   Close SEQ #(FIN)  |  <---  (see Note #2a)
*                                    |            -----------------------
*                                    v            |    Last SEQ #       |  <---   Last Transmit
*                                  -----          -----------------------        Sequence Number
*                                                                                (see Note #2b)
*
*
*                   See also 'NetTCP_TxConnSync()  Note #3'.
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnReqClose().
*
*               state       Current TCP connection state at time of connection close.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection close successfully
*                                                                       transmitted.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   ------- RETURNED BY NetTCP_TxConnTxQ() : -------
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_ACK_NONE           TCP connection acknowledgement NOT requested.
*                               NET_TCP_ERR_CONN_ACK_DLYD           TCP connection acknowledgement transmit delayed.
*                               NET_TCP_ERR_CONN_ACK_PREVLY_TXD     TCP connection acknowledgement previously
*                                                                       transmitted for segment.
*                               NET_TCP_ERR_CONN_ACK_INVALID        TCP connection acknowledgement NOT valid for
*                                                                       current TCP connection state.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnReqClose().
*
* Note(s)     : (3) Network resources MUST be appropriately allocated/deallocated :
*
*                   (a) Network buffer's reference counter MUST be incremented to include the queued TCP
*                       connection close segment as a new reference to the network buffer.  However, this
*                       additional reference is handled when the TCP connection close segment is enqueued
*                       to the TCP connection's re-transmit queue (see 'NetTCP_TxConnTxQ()  Note #10').
*
*                   (b) On ANY error(s), network resources MUST be appropriately freed :
*
*                       (1) For any network resources NOT  yet       linked to the TCP connection, each
*                           network resource  MUST be freed by appropriate function(s).
*                       (2) For all network resources that have been linked to the TCP connection, ALL
*                           network resources are     freed by NetTCP_ConnClose().
*********************************************************************************************************
*/

static  void  NetTCP_TxConnClose (NET_TCP_CONN        *p_conn,
                                  NET_TCP_CONN_STATE   state,
                                  NET_ERR             *p_err)
{
    NET_TCP_SEG_SIZE   seg_len;
    NET_BUF_SIZE       data_len;
    NET_BUF_SIZE       data_ix;
    NET_BUF_SIZE       data_ix_offset;
    NET_CONN_ID        conn_id;

    NET_IF_NBR         if_nbr;
    NET_BUF           *pseg_close;
    NET_BUF_HDR       *pseg_close_hdr;
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR      src_addrv4;
    NET_IPv4_ADDR      dest_addrv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR      src_addrv6;
    NET_IPv6_ADDR      dest_addrv6;
    NET_IPv6_FLAGS     ip_flags;
#endif
    NET_TCP_PORT_NBR   src_port;
    NET_TCP_PORT_NBR   dest_port;
    NET_TCP_SEQ_NBR    seq_nbr;
    NET_TCP_FLAGS      flags_tcp;
    CPU_BOOLEAN        flag_ipv6;
    NET_PROTOCOL_TYPE  proto_type = NET_PROTOCOL_TYPE_TCP_V4;
    NET_ERR            err;




#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (state) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
#else
   (void)&state;                                                /* Prevent 'variable unused' compiler warning.          */
#endif


                                                                /* ------------ PREPARE TCP CONN CLOSE SEG ------------ */
    seg_len  = NET_TCP_SEG_LEN_CLOSE;
    data_len = NET_TCP_DATA_LEN_TX_CLOSE;

    if (p_conn->TxQ_Tail != DEF_NULL) {                         /* If tx Q NOT empty ...                                */
        pseg_close                      =  p_conn->TxQ_Tail;    /* ... update tx Q tail seg as close seg.               */
        pseg_close_hdr                  = &pseg_close->Hdr;

        pseg_close_hdr->DataLen        += (NET_BUF_SIZE    )data_len;
        pseg_close_hdr->TotLen         += (NET_BUF_SIZE    )data_len;

        pseg_close_hdr->TCP_SegLenInit += (NET_TCP_SEG_SIZE)seg_len;
        pseg_close_hdr->TCP_SegLen     += (NET_TCP_SEG_SIZE)seg_len;
        pseg_close_hdr->TCP_SegLenData += (NET_TCP_SEG_SIZE)data_len;

        DEF_BIT_SET(pseg_close_hdr->TCP_Flags, NET_TCP_FLAG_TX_CLOSE);


    } else {                                                    /* Else get/cfg close seg buf.                          */
                                                                /* Get buf.                                             */
        conn_id = p_conn->ID_Conn;
        if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
        if ( err != NET_CONN_ERR_NONE) {
            NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                             (NET_BUF_HDR      *)0,
                             (CPU_BOOLEAN       )DEF_YES,
                             (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }


                                                                /* Find conn IP family.                                 */
        flag_ipv6 = DEF_NO;

#ifdef  NET_IPv6_MODULE_EN
        NetConn_IPv6TxParamsGet(                            conn_id,
                                (NET_IPv6_TRAFFIC_CLASS  *) DEF_NULL,
                                (NET_IPv6_FLOW_LABEL     *) DEF_NULL,
                                (NET_IPv6_HOP_LIM        *) DEF_NULL,
                                (NET_IPv6_FLAGS          *)&ip_flags,
                                                           &err);
        if (err != NET_CONN_ERR_NONE) {
           *p_err = err;
            return;
        }

        if (DEF_BIT_IS_CLR(ip_flags, NET_IPv6_FLAG)) {
            proto_type = NET_PROTOCOL_TYPE_TCP_V4;
        } else {
            flag_ipv6 = DEF_YES;
            proto_type = NET_PROTOCOL_TYPE_TCP_V6;
        }
#endif

        data_ix = 0u;
        NetTCP_GetTxDataIx(if_nbr,
                           proto_type,
                           0u,
                           data_len,
                           p_conn,
                          &data_ix,
                           p_err);

        pseg_close = NetBuf_Get((NET_IF_NBR     ) if_nbr,
                                (NET_TRANSACTION) NET_TRANSACTION_TX,
                                (NET_BUF_SIZE   ) data_len,
                                (NET_BUF_SIZE   ) data_ix,
                                (NET_BUF_SIZE  *)&data_ix_offset,
                                (NET_BUF_FLAGS  ) NET_BUF_FLAG_NONE,
                                (NET_ERR       *)&err);
        if ( err != NET_BUF_ERR_NONE) {
           *p_err  = NET_TCP_ERR_NONE_AVAIL;
            return;
        }

        data_ix        +=                 data_ix_offset;
        pseg_close_hdr  = (NET_BUF_HDR *)&pseg_close->Hdr;
                                                                /* ----------------- PREPARE TCP HDR ------------------ */

                                                                /* Prepare seg addrs.                                   */
        if (flag_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
            NetTCP_TxConnPrepareSegAddrs((NET_TCP_CONN *) p_conn,
                                         (CPU_INT08U   *)&src_addrv4,
                                         (CPU_INT08U   *)&src_port,
                                         (CPU_INT16U    ) sizeof(src_addrv4),
                                         (CPU_INT16U    ) sizeof(src_port),
                                         (CPU_INT08U   *)&dest_addrv4,
                                         (CPU_INT08U   *)&dest_port,
                                         (CPU_INT16U    ) sizeof(dest_addrv4),
                                         (CPU_INT16U    ) sizeof(dest_port),
                                         (NET_ERR      *)&err);

            pseg_close_hdr->IP_AddrSrc   = (NET_IPv4_ADDR )src_addrv4;
            pseg_close_hdr->IP_AddrDest  = (NET_IPv4_ADDR )dest_addrv4;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            NetTCP_TxConnPrepareSegAddrs((NET_TCP_CONN *) p_conn,
                                         (CPU_INT08U   *)&src_addrv6,
                                         (CPU_INT08U   *)&src_port,
                                         (CPU_INT16U    ) sizeof(src_addrv6),
                                         (CPU_INT16U    ) sizeof(src_port),
                                         (CPU_INT08U   *)&dest_addrv6,
                                         (CPU_INT08U   *)&dest_port,
                                         (CPU_INT16U    ) sizeof(dest_addrv6),
                                         (CPU_INT16U    ) sizeof(dest_port),
                                         (NET_ERR      *)&err);


#endif
        }
        if ( err != NET_TCP_ERR_NONE) {                         /* See Note #3b1.                                       */
            NetBuf_Free(pseg_close);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }


                                                                /* Prepare TCP seq nbr(s).                              */
        seq_nbr   = p_conn->TxSeqNbrNextQ;

                                                                /* Prepare TCP tx flags (see Note #1b2C).               */
        flags_tcp = NET_TCP_FLAG_NONE    |
                    NET_TCP_FLAG_TX_ACK  |
                    NET_TCP_FLAG_TX_CLOSE;


                                                                /* Init buf ctrls.                                      */
        pseg_close_hdr                   = &pseg_close->Hdr;
        pseg_close_hdr->DataIx           = (CPU_INT16U  )data_ix;
        pseg_close_hdr->DataLen          = (NET_BUF_SIZE)data_len;
        pseg_close_hdr->TotLen           = (NET_BUF_SIZE)pseg_close_hdr->DataLen;
        pseg_close_hdr->TransportPortSrc  = (NET_PORT_NBR)src_port;
        pseg_close_hdr->TransportPortDest = (NET_PORT_NBR)dest_port;

        if (flag_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
            pseg_close_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V4;
            pseg_close_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V4;
            pseg_close_hdr->IP_AddrSrc               = (NET_IPv4_ADDR)src_addrv4;
            pseg_close_hdr->IP_AddrDest              = (NET_IPv4_ADDR)dest_addrv4;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            pseg_close_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V6;
            pseg_close_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V6;
            Mem_Copy(&pseg_close_hdr->IPv6_AddrSrc,  &src_addrv6,  NET_IPv6_ADDR_SIZE);
            Mem_Copy(&pseg_close_hdr->IPv6_AddrDest, &dest_addrv6, NET_IPv6_ADDR_SIZE);
#endif
        }

        pseg_close_hdr->TCP_SegLenInit           = (NET_TCP_SEG_SIZE)seg_len;
        pseg_close_hdr->TCP_SegLen               = (NET_TCP_SEG_SIZE)pseg_close_hdr->TCP_SegLenInit;
        pseg_close_hdr->TCP_SegLenData           = (NET_TCP_SEG_SIZE)data_len;
        pseg_close_hdr->TCP_SegSync              = (CPU_BOOLEAN     )DEF_NO;
        pseg_close_hdr->TCP_SegClose             = (CPU_BOOLEAN     )DEF_YES;
        pseg_close_hdr->TCP_SegAck               = (CPU_BOOLEAN     )DEF_YES;
        pseg_close_hdr->TCP_SegReset             = (CPU_BOOLEAN     )DEF_NO;

        pseg_close_hdr->TCP_SeqNbrInit           = (NET_TCP_SEQ_NBR )seq_nbr;
        pseg_close_hdr->TCP_SeqNbr               = (NET_TCP_SEQ_NBR )pseg_close_hdr->TCP_SeqNbrInit;

        pseg_close_hdr->TCP_Flags                = (NET_TCP_FLAGS   )flags_tcp;
    }


                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* Q conn close seg to TCP tx Q : ...                   */
    if (p_conn->TxQ_Tail == DEF_NULL) {                         /* ... if tx Q empty, add close seg to empty tx Q.      */
        p_conn->TxQ_Head  = (NET_BUF *)pseg_close;
        p_conn->TxQ_Tail  = (NET_BUF *)pseg_close;
    }

                                                                /* Update TCP conn seq nbrs (see Note #2).              */
    p_conn->TxSeqNbrNextQ += (NET_TCP_SEQ_NBR) seg_len;         /* Update next tx Q seq nbr by close seg len.           */
    p_conn->TxSeqNbrLast   = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrNextQ;
    p_conn->TxSeqNbrClose  = (NET_TCP_SEQ_NBR)(p_conn->TxSeqNbrLast - seg_len);



                                                                /* -------------- TX TCP CONN CLOSE SEG --------------- */
    NetTCP_TxConnTxQ(p_conn,
                     0,
                     NET_TCP_CONN_TX_ACK_NONE,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_YES,
                     p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
        case NET_TCP_ERR_CONN_ACK_NONE:
        case NET_TCP_ERR_CONN_ACK_INVALID:
        case NET_TCP_ERR_CONN_ACK_DLYD:
        case NET_TCP_ERR_CONN_ACK_PREVLY_TXD:
        case NET_ERR_TX:                                        /* Ignore transitory tx err(s).                         */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_CONN_NOT_USED:
        case NET_TCP_ERR_CONN_CLOSE:
        case NET_TCP_ERR_CONN_FAULT:
        case NET_TCP_ERR_CONN_FAIL:
        case NET_TCP_ERR_INVALID_CONN_STATE:
        case NET_TCP_ERR_INVALID_CONN_OP:
        case NET_TCP_ERR_INVALID_LEN_SEG:
        case NET_TCP_ERR_NONE_AVAIL:
        case NET_TCP_ERR_TX_PKT:
        case NET_ERR_IF_LOOPBACK_DIS:
        case NET_CONN_ERR_INVALID_FAMILY:
        case NET_CONN_ERR_INVALID_ADDR:
        case NET_CONN_ERR_INVALID_ADDR_LEN:
        default:
             return;
    }

    NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnCloseCtr);



   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                         NetTCP_TxConnAck()
*
* Description : (1) Prepare & transmit a TCP connection acknowledgement :
*
*                   (a) Validate TCP connection for TCP acknowledgement         See Notes #2, #4, #5, & #6
*                   (b) Prepare  TCP acknowledgement segment :
*                       (1) Get  buffer
*                       (2) Prepare TCP segment :
*                           (A) TCP segment  addresses
*                           (B) TCP segment  sequence numbers                   See Notes #4a1D1a1, #4a2A1
*                                                                                       & #4a1D3b1B,
*                           (C) TCP segment  transmit flags :
*                               (1) ACK
*                           (D) TCP segment  window size
*                           (E) IP  datagram parameters                         See Note #9
*                           (F) TCP segment  packet buffer controls
*                   (c) Transmit TCP connection acknowledgement
*
*
*               (2) NetTCP_TxConnAck() transmits TCP connection acknowledgements in response to certain
*                   received TCP packets or TCP connection events (see Note #4).  TCP acknowledgements
*                   transmitted with other TCP controls &/or data SHOULD NOT be transmitted with
*                   NetTCP_TxConnAck().
*
*                   See also 'NetTCP_TxConnTxQ()  Note #2'.
*
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in various.
*
*               p_buf_hdr        Pointer to network buffer header that received TCP packet.
*               --------        Argument validated in NetTCP_Rx().
*
*               tx_ack_code     Indicate whether & how to transmit a TCP acknowledgement segment :
*
*                                   NET_TCP_CONN_TX_ACK_NONE        Do NOT transmit a TCP acknowledgement segment.
*                                   NET_TCP_CONN_TX_ACK                    Transmit a TCP acknowledgement segment.
*                                   NET_TCP_CONN_TX_ACK_IMMED              Transmit a TCP acknowledgement segment
*                                                                              immediately (see Note #4a5).
*                                   NET_TCP_CONN_TX_ACK_FAULT              Transmit a TCP acknowledgement segment
*                                                                              immediately in response to an invalid
*                                                                              received TCP packet (see Note #4a1).
*                                   NET_TCP_CONN_TX_ACK_TIMEOUT            Transmit a TCP acknowledgement segment
*                                                                              immediately in response to a delayed
*                                                                              acknowledgement timeout (see Note #6).
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection acknowledgement successfully
*                                                                       transmitted.
*                               NET_TCP_ERR_CONN_ACK_NONE           TCP connection acknowledgement NOT requested.
*                               NET_TCP_ERR_CONN_ACK_DLYD           TCP connection acknowledgement transmit delayed
*                                                                       (see Note #6).
*                               NET_TCP_ERR_CONN_ACK_PREVLY_TXD     TCP connection acknowledgement previously
*                                                                       transmitted for segment (see Note #7).
*                               NET_TCP_ERR_CONN_ACK_INVALID        TCP connection acknowledgement NOT valid for
*                                                                       current TCP connection state.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   -- RETURNED BY NetTCP_RxPktConnIsValidSeq() : --
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
* Return(s)   : none.
*
* Caller(s)   : various.
*
* Note(s)     : (3) See the following RFC's for TCP acknowledgement generation summary :
*
*                   (a) RFC # 793, Section  3.9 'Event Processing : SEGMENT ARRIVES'
*                   (b) RFC # 813, Section  5
*                   (c) RFC #1122, Section  4.2.3.2
*                   (d) RFC #2581, Sections 3.2 & 4.2
*                   (e) RFC Draft-IETF-TCPm-TCPSecure #00, Sections 2 & 3
*
*               (4) (a) TCP connection acknowledgements are transmitted when certain segments are received :
*
*                               (A) Some TCP transmit acknowledgement validation logic implemented in previous
*                                   functions; include duplicate validation logic in NetTCP_TxConnAck() only
*                                   if debug/validation code is enabled (i.e. NET_ERR_CFG_ARG_CHK_DBG_EN is
*                                   DEF_ENABLED in 'net_cfg.h').
*
*                       (1) (A) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1' states that
*                               "if [a] connection does not exist (CLOSED) then a reset is sent in response to any
*                               incoming segment except another reset".
*
*                               Thus ONLY resets are transmitted from the CLOSED state; never acknowledgements.
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]' allows
*                               for the transmission of TCP connection reset & connection synchronization segments
*                               ONLY; never acknowledgement-only segments (see also Note #2).
*
*                           (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                               Check SYN Bit' states that "if ... our SYN has been ACKed ... change the
*                               connection state to ESTABLISHED, form an ACK segment ... and send it".
*
*                               Thus acknowledgements MUST be immediately transmitted in reply to all valid
*                               synchronization segments received.
*
*                           (D) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence
*                                   Number' states that for the "SYN-RECEIVED STATE, ESTABLISHED STATE, FIN-WAIT-1
*                                   STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-
*                                   WAIT STATE ... if an incoming segment is not acceptable" :
*
*                                   (a) "An acknowledgment should be sent in reply" :
*
*                                           (1) <SEQ=SND.NXT> <ACK=RCV.NXT> <CTL=ACK>
*
*                                   (b) (1) "(unless the RST bit is set)".
*
*                                       (2) However, RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 requires
*                                           transmitting a TCP acknowledgement upon receipt of certain TCP
*                                           segments regardless of whether "the RST bit" is set (see Notes
*                                           #4a1D2b1c & #4a1D2b3).
*
*                                   See also Notes #4a1D2b & #4a1D3b.
*
*                               (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
*                                       states that "if the RST bit is set ... enter the CLOSED state".
*
*                                       Note this check is placed following the sequence check to prevent a segment
*                                       from an old connection ... from causing an abort of the current connection".
*
*                                   (b) (1) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling
*                                           of a segment with the RST bit when in a synchronized state" to "provide some
*                                           protection against ... blind reset attack[s] using the RST bit" :
*
*                                           (a) "If the RST bit is set and the sequence number is outside the
*                                                expected window, silently drop the segment."
*
*                                           (b) "If the RST bit is exactly the next expected sequence number [sic],
*                                                reset the connection"; it is assumed that this should read "if the
*                                                RST bit is set and the sequence number is exactly the next expected
*                                                sequence number, reset the connection."
*
*                                           (c) "If the RST bit is set and the sequence number does not exactly
*                                                match the next expected sequence value, yet is within the
*                                                acceptable window (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send
*                                                an acknowledgment."
*
*                                       (2) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
*                                           amendment applies only to the "handling of a ... RST when in a synchronized
*                                           state", it is assumed that this should also apply to the SYN-RECEIVED state.
*
*                                       (3) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a
*                                           precedence priority for handling TCP segments received with BOTH the RST
*                                           & SYN bits set.
*
*                                           Therefore, since it does NOT seem reasonable to reset a TCP connection
*                                           due to a TCP segment that also attempted to synchronize the  TCP connection,
*                                           it is assumed that the amended handling of the SYN bit should take precedence
*                                           over the amended handling of the RST bit.
*
*                                           See also Note #4a1D3b.
*
*                               (3) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN
*                                       Bit' states that for "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT
*                                       STATE-1, FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
*                                       STATE, TIME-WAIT STATE ... [to next] check the SYN bit ... [and] if
*                                       the SYN is in the window it is an error, send a reset ... [and] enter
*                                       the CLOSED state ...
*
*                                       [But] if the SYN is not in the window this step would not have been
*                                       reached and an ack would have been sent".
*
*                                   (b) (1) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the
*                                           "handling of a segment with the SYN bit set in the synchronized state
*                                            ... [by] handling ... the SYN bit" as follows :
*
*                                           (a) "If the SYN bit is set and the sequence number is outside the
*                                                expected window, send an ACK back to the peer."
*
*                                           (b) "If the SYN bit is set and the sequence number is an exact match to
*                                                the next expected sequence (RCV.NXT == SEG.SEQ) then send an ACK
*                                                segment ... but ... subtract one from value being acknowledged."
*
*                                           (c) "If the SYN bit is set and the sequence number is acceptable, i.e.:
*                                                (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) then send an ACK segment."
*
*                                       (2) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that
*                                           this amendment applies only to the "handling of a ... SYN ... in a
*                                           synchronized state", it is assumed that this should also apply to the
*                                           SYN-RECEIVED state.
*
*                               (4) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                                   states that if in the "ESTABLISHED STATE" or any state with similar "processing
*                                   as for the ESTABLISHED STATE", that "if the ACK acks something not yet sent
*                                   (SEG.ACK > SND.NXT) then send an ACK".
*
*                       (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text',
*                           states that in the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... when
*                           ... TCP takes responsibility for ... data ... it must also acknowledge ... the data" :
*
*                           (A) "Send an acknowledgment of the form" :
*
*                                   (1) <SEQ=SND.NXT> <ACK=RCV.NXT> <CTL=ACK>
*
*                           (B) "This acknowledgment should be piggybacked on a segment being transmitted if
*                                possible without incurring undue delay."
*
*                               See also Note #6.
*
*                       (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
*                           that "if the FIN bit is set, ... send an acknowledgment for the FIN".
*
*                       (4) RFC #813, Section 5 states that "the receiver of data will refrain from sending an
*                           acknowledgement under certain circumstances ... The most obvious event on which to
*                           depend is the arrival of another segment.  So, if a segment arrives, postpone sending
*                           an acknowledgement if ... the following conditions hold" :
*
*                           (A) "The push bit is not set in the segment, since it is a reasonable assumption
*                                that there is more data coming in a subsequent segment."
*
*                               (1) However, if the PUSH bit is set in any received segment, an acknowledgement
*                                   should be immediately transmitted.
*
*                           See also Notes #4b1, #5b2, & #6.
*
*                       (5) (A) RFC #2581, Section 3.2 states that "a TCP receiver SHOULD send an immediate ACK" :
*
*                               (1) "When an out-of-order segment arrives.  The purpose of this ACK is to
*                                    inform the sender that a segment was received out-of-order and which
*                                    sequence number is expected."
*
*                               (2) "In addition, ... when the incoming segment fills in all or part of a
*                                    gap in the sequence space.  This will generate more timely information
*                                    for a sender recovering from a ... retransmission timeout ... [or] a
*                                    fast retransmit."
*
*                           (B) RFC #1122, Section 4.2.2.21 reiterates that "a TCP MAY send an ACK segment
*                               acknowledging RCV.NXT when a valid segment arrives that is in the window
*                               but not at the left window edge ... One reason for ACKing out-of-order
*                               segments [is] to support ... 'fast retransmit'".
*
*                   (b) TCP connection acknowledgements are transmitted for certain TCP connection events :
*
*                       (1) RFC #813, Section 5 states that "the receiver of data will refrain from sending an
*                           acknowledgement under certain circumstances ... Postpone sending an acknowledgement
*                           if ... the following conditions hold" :
*
*                           (B) "There is no revised window information to be sent back."
*
*                               (1) However, if any local receive window size is available to update to the
*                                   remote host, an acknowledgement should be immediately transmitted.
*
*                           See also Note #4a4 & 'NetTCP_RxConnWinSizeHandler()  Note #4'.
*
*               (5) (a) Although NO RFC specifies whether an acknowledgement should or should NOT
*                       be transmitted in response to a received acknowledgement-only segment, it
*                       seems reasonable & is assumed that NO TCP connection acknowledgement should
*                       be transmitted in response to any acknowledgement-only segment(s) received.
*
*                       (1) A received TCP segment is considered an acknowledgement-only segment if
*                           the segment was received with zero segment length, i.e. NO received TCP
*                           sequences :
*
*                           (A) NO synchronization or close controls)
*                           (B) NO TCP data
*
*                   (b) (1) However, since acknowledgements are transmitted in response to various
*                           invalid segments received, some acknowledgements MUST be transmitted
*                           even for certain invalid acknowledgement-only segments.
*
*                           See also Note #4a1.
*
*                       (2) Also, acknowledgements SHOULD be transmitted for received segments with
*                           the PUSH bit set, even for segments with NO received TCP data.
*
*                           See also Note #4a4.
*
*                       (3) (A) Also, RFC #1122, Section 4.2.2.17 states that the "probing of zero
*                               (offered) windows MUST be supported.  A TCP MAY keep its offered
*                               receive window closed indefinitely.  As long as the receiving TCP
*                               continues to send acknowledgements in response to the probe segments".
*
*                           (B) In order to always acknowledge a remote host's probing of the local
*                               TCP connection's receive window size :
*
*                               (1) Since probe segments :
*
*                                   (a) may or may NOT contain data, ...
*                                   (b) sequence values may or may NOT be within the TCP connection's
*                                           current receive window;  ...
*
*                                   See also Note #4a1D1a1 & 'NetTCP_RxPktConnIsValidSeq()  Note #1d3'.
*
*                               (2) ... acknowledgements SHOULD be transmitted in reply to ALL valid
*                                   & SOME invalid received segments from the remote host whenever
*                                   the TCP connection's local receive window is zero-sized.
*
*               (6) (a) The following sections state that "a TCP SHOULD implement a delayed ACK" :
*
*                           (A) RFC # 813, Section 5
*                           (B) RFC #1122, Section 4.2.3.2
*                           (C) RFC #2581, Section 4.2
*
*                       (1) (A) (1) RFC #1122, Section 4.2.3.2 states that "in a stream of full-sized segments
*                                   there SHOULD be an ACK for at least every second segment".
*
*                               (2) RFC #2581, Section 4.2 reiterates that "an ACK SHOULD be generated for at
*                                   least every second full-sized segment".
*
*                           (B) However, RFC #2581, Section 4.2 states that "an implementation is deemed to
*                               comply with this requirement ... by acknowledging at least every second segment,
*                               regardless of size".
*
*                       (2) (A) RFC #813, Section 5 states that "the receiver of data will refrain from
*                               sending an acknowledgement under certain circumstances, in which case it
*                               must set a timer which will cause the acknowledgement to be sent later".
*
*                           (B) (1) (a) RFC #1122, Section 4.2.3.2 states that "an ACK should not
*                                       be excessively delayed; in particular, the delay MUST be
*                                       less than 0.5 seconds".
*
*                                   (b) RFC #2581, Section 4.2 reiterates that "an ACK ... MUST
*                                       be generated within 500 ms of the arrival of the first
*                                       unacknowledged packet".
*
*                               (2) However, Stevens, TCP/IP Illustrated, Volume 1, 8th Printing,
*                                   Section 19.3, Page 265 states that "most implementations use
*                                   a 200-ms delay".
*
*                   (b) However, if NO network timer is available to delay the acknowledgement, the TCP
*                       connection acknowledgement SHOULD be immediately transmitted.
*
*               (7) (a) (1) RFC #1122, Section 4.2.2.14 states that "a careless implementation can send
*                           two or more acknowledgment segments per data segment received".
*
*                       (2) RFC #1122, Section 4.2.2.20 states that "in general, the processing of
*                           received segments MUST be implemented to aggregate ACK segments whenever
*                           possible.  For example, if the TCP is processing a series of queued
*                           segments, it MUST process them all before sending any ACK segments".
*
*                       (3) Thus no more than one acknowledgement SHOULD be transmitted in response
*                           to any received segment.
*
*                   (b) RFC #1122, Section 4.2.2.14 also states that "when the application program
*                       subsequently consumes the data and increases the available receive buffer
*                       space again, the receiver may send a second acknowledgement segment to update
*                       the window at the sender".
*
*                       However, the application layer receives data from a TCP connection's application
*                       receive queue asynchronously & irrespective of distinct or specific TCP packets
*                       (see 'NetTCP_RxAppData()  Note #4a').  Thus any acknowledgement transmissions
*                       triggered during asynchronous application receives CANNOT be associated with, &
*                       thereby limited by, any specific received segments.
*
*               (8) (a) (1) (A) RFC #793, Sections 3.7 & 2.6 state that "TCP uses retransmission ... to
*                               ensure delivery of every segment".
*
*                           (B) However, RFC #1122, Section 4.2.2.17 'DISCUSSION' states that "it is
*                               extremely important to remember that ACK (acknowledgment) segments that
*                               contain no data are not reliably transmitted by TCP".
*
*                       (2) Therefore, it is assumed that TCP acknowledgement-ONLY segments should NOT be
*                           queued for retransmission but SHOULD be silently discarded.
*
*                   (b) (1) The network buffer's reference counter is NOT incremented since the TCP layer
*                           does NOT maintain a reference to any transmitted TCP acknowledgement segments.
*
*                       (2) Therefore, the network buffer MUST be freed by lower layer(s).
*
*                   See also 'NetTCP_TxConnReset()  Note #7',
*                          & 'NetTCP_TxConnProbe()  Note #3'.
*
*               (9) (a) RFC #1122, Section 4.2.4.2 states that "the [IP] TOS will be specified independently
*                       in each direction on the connection, so that the receiver application will specify
*                       the TOS used for ACK segments." #### NET-807
*
*                   (b) (1) IP  transmit options currently NOT implemented     See 'net_tcp.c  Note #1d'
*                       (2) TCP transmit options currently NOT implemented     See 'net_tcp.c  Note #1c'
*
*                       See also 'NetTCP_TxPktHandler()  Note #2'.
*
*              (10) On ANY error(s), network resources MUST be appropriately freed :
*
*                   (a) For any network resources NOT linked to the TCP connection, each network resource
*                       MUST be freed by appropriate function(s).
*********************************************************************************************************
*/

static  void  NetTCP_TxConnAck (NET_TCP_CONN        *p_conn,
                                NET_BUF_HDR         *p_buf_hdr,
                                NET_TCP_ACK_CODE     tx_ack_code,
                                NET_TCP_CLOSE_CODE   close_code,
                                NET_ERR             *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_SEQ_CODE         seq_code;
    NET_TCP_RESET_CODE       reset_code;
#endif
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR            src_addrv4;
    NET_IPv4_ADDR            dest_addrv4;
    NET_IPv4_TOS             TOS;
    NET_IPv4_TTL             TTL;
    NET_IPv4_FLAGS           flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR            src_addrv6;
    NET_IPv6_ADDR            dest_addrv6;
    NET_IPv6_TRAFFIC_CLASS   traffic_class;
    NET_IPv6_FLOW_LABEL      flow_label;
    NET_IPv6_HOP_LIM         hop_lim;
    NET_IPv4_FLAGS           flags_ipv6;
#endif
    CPU_BOOLEAN              tx_ack;
    CPU_BOOLEAN              tmr_free;
    CPU_BOOLEAN              push_avail;
    NET_TMR_TICK             timeout_tick;
    NET_BUF_SIZE             data_len;
    NET_BUF_SIZE             data_ix;
    NET_BUF_SIZE             data_ix_offset;
    NET_CONN_ID              conn_id;
    NET_IF_NBR               if_nbr;
    NET_BUF                 *pseg_ack;
    NET_BUF_HDR             *pseg_ack_hdr;
    NET_TCP_PORT_NBR         src_port;
    NET_TCP_PORT_NBR         dest_port;
    NET_TCP_SEQ_NBR          seq_nbr;
    NET_TCP_SEQ_NBR          ack_nbr;
    NET_TCP_SEQ_NBR          ack_nbr_delta;
    NET_TCP_WIN_SIZE         win_size;
    NET_TCP_FLAGS            flags_tcp;
    NET_PROTOCOL_TYPE        proto_type;
    NET_CONN                *p_conn_conn;
    CPU_BOOLEAN              is_ipv6;
    NET_ERR                  err;


                                                                /* ------------- VALIDATE TCP CONN TX ACK ------------- */
    tx_ack   = DEF_NO;
    tmr_free = DEF_YES;

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #4a1A.                                      */
        case NET_TCP_CONN_STATE_LISTEN:                         /* See Note #4a1B.                                      */
             break;


        case NET_TCP_CONN_STATE_SYNC_TXD:                       /* See Note #4a1C.                                      */
             if (p_buf_hdr != DEF_NULL) {
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                 seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                 if (*p_err != NET_TCP_ERR_NONE) {
                      return;
                 }
                 if (seq_code == NET_TCP_CONN_RX_SEQ_SYNC) {    /* If valid sync rx'd, ...                              */
                     tx_ack = DEF_YES;                          /* ... tx TCP conn ack.                                 */
                 }
#else
                 tx_ack = DEF_YES;
#endif
                 if (p_buf_hdr->TCP_SegAckTxd != DEF_NO) {      /* If prev'ly tx'd TCP conn ack for rx'd seg, ..        */
                    *p_err = NET_TCP_ERR_CONN_ACK_PREVLY_TXD;   /* .. do NOT re-tx TCP conn ack (see Note #7a3).        */
                     return;
                 }

             } else {
                 tx_ack = DEF_YES;
             }
             break;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             if (p_buf_hdr != DEF_NULL) {
                 if (p_buf_hdr->TCP_SegAckTxd != DEF_NO) {      /* If prev'ly tx'd TCP conn ack for rx'd seg, ..        */
                    *p_err = NET_TCP_ERR_CONN_ACK_PREVLY_TXD;   /* .. do NOT re-tx TCP conn ack (see Note #7a3).        */
                     return;
                 }
             }

             switch (tx_ack_code) {
                 case NET_TCP_CONN_TX_ACK_NONE:
                     *p_err = NET_TCP_ERR_CONN_ACK_NONE;
                      return;


                 case NET_TCP_CONN_TX_ACK:
                 case NET_TCP_CONN_TX_ACK_IMMED:
                      if (p_buf_hdr != DEF_NULL) {
                          push_avail = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_PUSH);
                          if (push_avail == DEF_YES) {          /* If rx'd seg push'd & en'd, ..                        */
                              if (p_conn->TxAckImmedRxdPushEn != DEF_DISABLED) {
                                  tx_ack  = DEF_YES;            /* .. tx TCP conn ack (see Note #4a4A1).                */
                                  break;
                              }
                          }

                          if (p_buf_hdr->TCP_SegLen < 1) {      /* If ack-ONLY seg       (see Note #5a1);   ..          */
                              if (p_conn->RxWinSizeActual > 0) {/* .. & local rx win > 0,                   ..          */
                                 *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
                                  return;                       /* .. do NOT tx ack      (see Note #5a);    ..          */

                              } else {                          /* .. & local rx win = 0 (see Note #5b3B2), ..          */
                                  tx_ack = DEF_YES;             /* .. tx TCP conn ack.                                  */
                                  break;
                              }
                          }
                      }

                      if (tx_ack_code == NET_TCP_CONN_TX_ACK_IMMED) { /* If immed ack req'd, ...                        */
                          tx_ack = DEF_YES;                     /* ... tx TCP conn ack.                                 */
                          break;
                      }

                      if (p_conn->TxAckDlyTimeout_ms == 0) {    /* If ack dly timeout zero, ...                         */
                          tx_ack = DEF_YES;                     /* ... tx TCP conn ack.                                 */
                          break;
                      }

                      p_conn->TxAckDlyCnt++;                    /* If ack dly cnt >= th, ...                            */
                      if (p_conn->TxAckDlyCnt >= NET_TCP_ACK_DLY_CNT_TH) {
                          tx_ack = DEF_YES;                     /* ... tx TCP conn ack (see Note #6a1B).                */
                          break;
                      }

                      if (p_conn->TxAckDlyTmr != DEF_NULL) {    /* If ack dly tmr prev'ly started, ...                  */
                         *p_err = NET_TCP_ERR_CONN_ACK_DLYD;    /* ... continue ack dly (see Note #6a2A).               */
                          return;
                      }

                      timeout_tick        = p_conn->TxAckDlyTimeout_tick;
                      p_conn->TxAckDlyTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_TxConnAckDlyTimeout,
                                                       (void        *) p_conn,
                                                       (NET_TMR_TICK ) timeout_tick,
                                                       (NET_ERR     *)&err);
                      if ( err == NET_TMR_ERR_NONE) {           /* If ack dly tmr avail, ...                            */
                         *p_err = NET_TCP_ERR_CONN_ACK_DLYD;    /* ... start ack dly (see Note #6a2A).                  */
                          return;

                      } else {                                  /* Else tx TCP conn ack (see Note #6b).                 */
                          tx_ack = DEF_YES;
                      }
                      break;


                 case NET_TCP_CONN_TX_ACK_FAULT:                /* See Note #4a1D.                                      */
                      if (p_buf_hdr != DEF_NULL) {
                          if (p_buf_hdr->TCP_SegSync == DEF_YES) { /* If sync rx'd (see Note #4a1D3b1), ...             */
                              tx_ack = DEF_YES;                 /* ... tx TCP conn ack; ignore possible reset.          */
                          } else {
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                              seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                              reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                              switch (seq_code) {
                                  case NET_TCP_CONN_RX_SEQ_VALID: /* If       valid seq   rx'd  ..                      */
                                                                /* .. but invalid reset rx'd, ..                        */
                                       if (reset_code == NET_TCP_CONN_RX_RESET_INVALID) {
                                           tx_ack = DEF_YES;    /* .. tx TCP conn ack  (see Note #4a1D2b1c).            */
                                       }
                                       break;


                                  case NET_TCP_CONN_RX_SEQ_SYNC:/* If invalid sync rx'd, ..                             */
                                  case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                       tx_ack = DEF_YES;        /* .. tx TCP conn ack  (see Note #4a1D3b1).             */
                                       break;


                                  case NET_TCP_CONN_RX_SEQ_NONE:
                                  case NET_TCP_CONN_RX_SEQ_INVALID: /* If invalid seq rx'd (see Note #4a1D1)    ..      */
                                  default:
                                                                /* .. & reset NOT rx'd (see Note #4a1D1b1), ..          */
                                       if (reset_code == NET_TCP_CONN_RX_RESET_NONE) {
                                           tx_ack = DEF_YES;    /* .. tx TCP conn ack  (see Note #4a1D1a).              */
                                       }
                                       break;
                              }
#else
                              tx_ack = DEF_YES;
#endif
                          }
                      } else {
                          tx_ack = DEF_YES;
                      }
                      break;


                 case NET_TCP_CONN_TX_ACK_OTW:                  /* See Note #4a1D.                                      */
                      if (p_buf_hdr != DEF_NULL) {
                          if (p_buf_hdr->TCP_SegSync == DEF_YES) { /* If sync rx'd (see Note #4a1D3b1), ...             */
                              tx_ack = DEF_YES;                 /* ... tx TCP conn ack; ignore possible reset.          */
                          } else {
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                              seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                              reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                              switch (seq_code) {
                                  case NET_TCP_CONN_RX_SEQ_VALID: /* If       valid seq   rx'd  ..                      */
                                       tx_ack = DEF_YES;
                                       break;


                                  case NET_TCP_CONN_RX_SEQ_SYNC:/* If invalid sync rx'd, ..                             */
                                  case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
                                       tx_ack = DEF_YES;        /* .. tx TCP conn ack  (see Note #4a1D3b1).             */
                                       break;


                                  case NET_TCP_CONN_RX_SEQ_NONE:
                                  case NET_TCP_CONN_RX_SEQ_INVALID: /* If invalid seq rx'd (see Note #4a1D1)    ..      */
                                  default:
                                                                /* .. & reset NOT rx'd (see Note #4a1D1b1), ..          */
                                       if (reset_code == NET_TCP_CONN_RX_RESET_NONE) {
                                           tx_ack = DEF_YES;    /* .. tx TCP conn ack  (see Note #4a1D1a).              */
                                       }
                                       break;
                              }
#else
                              tx_ack = DEF_YES;
#endif
                          }
                      } else {
                          tx_ack = DEF_YES;
                      }
                      break;


                 case NET_TCP_CONN_TX_ACK_TIMEOUT:
                      tx_ack   = DEF_YES;
                      tmr_free = DEF_NO;
                      break;


                 default:
                      break;
             }
             break;


        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }

    if (tx_ack != DEF_YES) {                                    /* If NOT valid, abort tx TCP conn ack.                 */
       *p_err = NET_TCP_ERR_CONN_ACK_INVALID;
        return;
    }


    NetTCP_TxConnAckDlyReset(p_conn, tmr_free);                 /* Reset ack dly ctrls.                                 */

    if (p_buf_hdr != DEF_NULL) {
        p_buf_hdr->TCP_SegAckTxd = DEF_YES;                     /* Set ack tx'd for rx'd seg (see Note #7a).            */
    }


                                                                /* ------------- PREPARE TCP CONN ACK SEG ------------- */
                                                                /* If valid, prepare & tx TCP conn ack.                 */
                                                                /* Get buf.                                             */
    conn_id = p_conn->ID_Conn;
    if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
    if ((err    != NET_CONN_ERR_NONE) &&
        (if_nbr == NET_IF_NBR_NONE  )){
        NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    data_len = NET_TCP_DATA_LEN_TX_ACK;
#if 0
    data_ix = NET_BUF_DATA_IX_TX;
#else
    if (p_buf_hdr == DEF_NULL) {
        p_conn_conn = &NetConn_Tbl[p_conn->ID_Conn];

        switch (p_conn_conn->Family) {
            case NET_CONN_FAMILY_IP_V4_SOCK:
                 proto_type = NET_PROTOCOL_TYPE_TCP_V4;
                 is_ipv6    = DEF_NO;
                 break;


            case NET_CONN_FAMILY_IP_V6_SOCK:
                 proto_type = NET_PROTOCOL_TYPE_TCP_V6;
                 is_ipv6    = DEF_YES;
                 break;


            default:
                *p_err = NET_TCP_ERR_CONN_PROTO_FAMILY;
                return;
        }
    } else {
        if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
            proto_type = NET_PROTOCOL_TYPE_TCP_V4;
            is_ipv6    = DEF_NO;
        } else {
            proto_type = NET_PROTOCOL_TYPE_TCP_V6;
            is_ipv6    = DEF_YES;
        }
    }

    data_ix = 0u;

    NetTCP_GetTxDataIx(if_nbr,
                       proto_type,
                       0u,
                       data_len,
                       p_conn,
                      &data_ix,
                       p_err);
#endif
    pseg_ack = NetBuf_Get((NET_IF_NBR     ) if_nbr,
                          (NET_TRANSACTION) NET_TRANSACTION_TX,
                          (NET_BUF_SIZE   ) data_len,
                          (NET_BUF_SIZE   ) data_ix,
                          (NET_BUF_SIZE  *)&data_ix_offset,
                          (NET_BUF_FLAGS  ) NET_BUF_FLAG_NONE,
                          (NET_ERR       *)&err);
    if ( err != NET_BUF_ERR_NONE) {
       *p_err  = NET_TCP_ERR_NONE_AVAIL;
        return;
    }

    data_ix += data_ix_offset;

                                                                /* ----------------- PREPARE TCP HDR ------------------ */
                                                                /* Prepare seg addrs.                                   */
    if (p_buf_hdr != DEF_NULL) {                                /* If TCP pkt rx'd, cfg TCP tx                ...       */
                                                                /* ...  src  addr from rx'd TCP pkt dest addr ...       */
        if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
            src_addrv4  = p_buf_hdr->IP_AddrDest;
            dest_addrv4 = p_buf_hdr->IP_AddrSrc;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            src_addrv6  = p_buf_hdr->IPv6_AddrDest;
            dest_addrv6 = p_buf_hdr->IPv6_AddrSrc;
#endif
        }

        src_port        = p_buf_hdr->TransportPortDest;
                                                                /* .. & dest addr from rx'd TCP pkt src  addr.          */
        dest_port       = p_buf_hdr->TransportPortSrc;

    } else {                                                    /* Else cfg TCP tx pkt addrs from TCP conn addrs.       */

        if (is_ipv6 == DEF_NO) {

#ifdef  NET_IPv4_MODULE_EN
            NetTCP_TxConnPrepareSegAddrs(p_conn,
                          (CPU_INT08U *)&src_addrv4,
                          (CPU_INT08U *)&src_port,
                                         sizeof(src_addrv4),
                                         sizeof(src_port),
                          (CPU_INT08U *)&dest_addrv4,
                          (CPU_INT08U *)&dest_port,
                                         sizeof(dest_addrv4),
                                         sizeof(dest_port),
                                        &err);
#endif

        } else {
#ifdef  NET_IPv6_MODULE_EN
            NetTCP_TxConnPrepareSegAddrs(p_conn,
                          (CPU_INT08U *)&src_addrv6,
                          (CPU_INT08U *)&src_port,
                                         sizeof(src_addrv6),
                                         sizeof(src_port),
                          (CPU_INT08U *)&dest_addrv6,
                          (CPU_INT08U *)&dest_port,
                                         sizeof(dest_addrv6),
                                         sizeof(dest_port),
                                        &err);
#endif

        }

        if ( err != NET_TCP_ERR_NONE) {                         /* See Note #10a.                                       */
            NetBuf_Free(pseg_ack);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
    }

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (tx_ack_code) {
                 case NET_TCP_CONN_TX_ACK_FAULT:
                 case NET_TCP_CONN_TX_ACK_OTW:
                      if ((p_buf_hdr              != DEF_NULL            ) &&
                          (p_buf_hdr->TCP_SegSync == DEF_YES             ) &&
                          (p_buf_hdr->TCP_SeqNbr  == p_conn->RxSeqNbrNext)) {
                                                                /* If rx'd sync equal to next rx seq nbr, ...           */
                                                                /* ... sub 1 from ack (see Note #4a1D3b1B).             */
                          ack_nbr_delta = 1u;
                      } else {
                          ack_nbr_delta = 0u;
                      }
                      break;


                 default:
                      ack_nbr_delta = 0u;
                      break;
             }
             break;


        default:
             ack_nbr_delta = 0u;
             break;
    }
                                                                /* Prepare TCP seq nbrs (see Note #1b2B).               */
    seq_nbr   = p_conn->TxSeqNbrNext;
    ack_nbr   = p_conn->RxSeqNbrNext - ack_nbr_delta;

                                                                /* Prepare TCP tx flags (see Note #1b2C).               */
    flags_tcp = NET_TCP_FLAG_NONE  |
                NET_TCP_FLAG_TX_ACK;

                                                                /* Prepare TCP win size.                                */
    win_size  = p_conn->RxWinSizeActual;



                                                                /* Prepare IP params (see Note #9).                     */
    if (is_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN

        NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL, &err);
        if ( err != NET_CONN_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6, &err);
        if ( err != NET_CONN_ERR_NONE) {
            NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
#endif
    }

                                                                /* Init buf ctrls.                                      */
    pseg_ack_hdr                           = &pseg_ack->Hdr;
    pseg_ack_hdr->DataIx                   = (CPU_INT16U  )data_ix;
    pseg_ack_hdr->DataLen                  = (NET_BUF_SIZE)data_len;
    pseg_ack_hdr->TotLen                   = (NET_BUF_SIZE)pseg_ack_hdr->DataLen;

    pseg_ack_hdr->TCP_SegSync              = (CPU_BOOLEAN  )DEF_NO;
    pseg_ack_hdr->TCP_SegClose             = (CPU_BOOLEAN  )DEF_NO;
    pseg_ack_hdr->TCP_SegAck               = (CPU_BOOLEAN  )DEF_YES;
    pseg_ack_hdr->TCP_SegReset             = (CPU_BOOLEAN  )DEF_NO;

    pseg_ack_hdr->TCP_Flags                = (NET_TCP_FLAGS)flags_tcp;




                                                                /* --------------- TX TCP CONN ACK SEG ---------------- */
    if (is_ipv6 == DEF_NO) {

#ifdef  NET_IPv4_MODULE_EN
        pseg_ack_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V4;
        pseg_ack_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

        NetTCP_TxPktHandlerIPv4(pseg_ack,
                                src_addrv4,
                                src_port,
                                dest_addrv4,
                                dest_port,
                                seq_nbr,
                                ack_nbr,
                                win_size,
                                TOS,
                                TTL,
                                flags_tcp,
                                flags_ipv4,
                                DEF_NULL,                       /* See Note #9b2.                                       */
                                DEF_NULL,                       /* See Note #9b1.                                       */
                               &err);                           /* Ignore transitory tx err(s).                         */
#endif

    } else {
#ifdef  NET_IPv6_MODULE_EN
        DEF_BIT_SET(pseg_ack_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);

        pseg_ack_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V6;
        pseg_ack_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;

        NetTCP_TxPktHandlerIPv6(pseg_ack,
              (NET_IPv6_ADDR *)&src_addrv6,
                                src_port,
              (NET_IPv6_ADDR *)&dest_addrv6,
                                dest_port,
                                seq_nbr,
                                ack_nbr,
                                win_size,
                                traffic_class,
                                flow_label,
                                hop_lim,
                                flags_tcp,
                                DEF_NULL,
                                &err);

#endif
    }
#if 0                                                           /* Tx buf freed by lower layer(s) [see Note #8b2].      */
    NetTCP_TxPktFree(pseg_ack);
#endif
    NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnAckCtr);



   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                     NetTCP_TxConnAckDlyReset()
*
* Description : Reset TCP connection's delayed acknowledgement controls.
*
* Argument(s) : p_conn       Pointer to TCP connection to reset delayed acknowledgement controls.
*               -----       Argument validated in NetTCP_TxConnAck(),
*                                                 NetTCP_TxConnTxQ(),
*                                                 NetTCP_TxConnReTxQ_Timeout().
*
*               tmr_free    Indicate whether to free network timer :
*
*                               DEF_YES                Free network timer for delayed acknowledgement.
*                               DEF_NO          Do NOT free network timer for delayed acknowledgement
*                                                     [Freed by  NetTmr_TaskHandler()
*                                                            via NetTCP_TxConnAckDlyTimeout()].
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnAck(),
*               NetTCP_TxConnTxQ(),
*               NetTCP_TxConnReTxQ().
*
* Note(s)     : (1) A TCP connection's delayed acknowledgement controls SHOULD be reset whenever :
*
*                   (a) TCP data segment(s) are    transmitted
*                   (b) TCP data segment(s) are re-transmitted
*
*                   ... since any transmitted or re-transmitted data segment(s) always transmit an
*                   accompanying acknowledgement.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnAckDlyReset (NET_TCP_CONN  *p_conn,
                                        CPU_BOOLEAN    tmr_free)
{
    p_conn->TxAckDlyCnt = 0u;                                   /* Reset ack dly cnts ...                               */
    if (p_conn->TxAckDlyTmr != DEF_NULL) {                      /* ... & free/clr ack dly tmr.                          */
        if (tmr_free == DEF_YES) {
            NetTmr_Free(p_conn->TxAckDlyTmr);
        }
        p_conn->TxAckDlyTmr  = DEF_NULL;
    }
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnAckDlyTimeout()
*
* Description : (1) Handle TCP connection's delayed acknowledgement transmit for the following connected
*                   states :
*
*                   (a) SYN-RECEIVED
*                   (b) ESTABLISHED
*                   (c) FIN-WAIT-1
*                   (d) FIN-WAIT-2
*                   (e) CLOSING
*                   (f) TIME-WAIT
*                   (g) CLOSE-WAIT
*                   (h) LAST-ACK
*
*
* Argument(s) : p_conn_timeout       Pointer to TCP connection to transmit delayed acknowledgement (see Note #2b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_TxConnAck().
*
* Note(s)     : (2) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (3) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection transmit acknowledgement delay timer ('TxAckDlyTmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared prior to next handler function(s); ...
*                               (2) Cleared prior to invalid state fault exit.
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY
*********************************************************************************************************
*/

static  void  NetTCP_TxConnAckDlyTimeout (void  *p_conn_timeout)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CLOSE_CODE   close_code;
    NET_ERR              err;


    p_conn      = (NET_TCP_CONN *)p_conn_timeout;               /* See Note #2b2A.                                      */

    close_code =  NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY); /* See Note #3b1.                                       */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             p_conn->TxAckDlyTmr = DEF_NULL;                    /* See Note #3a2A2.                                     */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Note #1.                                         */
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }
#endif


                                                                /* ---------- HANDLE TCP CONN TX ACK TIMEOUT ---------- */
    p_conn->TxAckDlyTmr = DEF_NULL;                             /* Clr tx ack dly tmr (see Note #3a2A1).                */

    NetTCP_TxConnAck((NET_TCP_CONN     *) p_conn,
                     (NET_BUF_HDR      *) 0,
                     (NET_TCP_ACK_CODE  ) NET_TCP_CONN_TX_ACK_TIMEOUT,
                     (NET_TCP_CLOSE_CODE) close_code,
                     (NET_ERR          *)&err);                 /* Ignore transitory tx err(s).                         */
}


/*
*********************************************************************************************************
*                                        NetTCP_TxConnReset()
*
* Description : (1) Prepare & transmit a TCP connection reset :
*
*                   (a) Validate received TCP packet  for TCP reset                     See Note #5
*                   (b) Validate TCP connection state for TCP reset                     See Note #4
*                   (c) Prepare  TCP reset segment :
*                       (1) Get  buffer
*                       (2) Prepare TCP segment :
*                           (A) TCP segment addresses
*                           (B) TCP segment sequence numbers                            See Note #6
*                           (C) TCP segment transmit flags :
*                               (1) RESET
*                               (2) ACK                                                 See Note #6a2A
*                           (D) TCP segment window size
*                           (E) TCP segment packet buffer controls
*                   (d) Transmit TCP connection reset
*
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*
*               p_buf_hdr        Pointer to network buffer header that received TCP packet, if available.
*
*               tx_reset_code   Indicate whether & how to transmit a TCP reset segment :
*
*                                   NET_TCP_CONN_TX_RESET           Transmit a TCP reset segment, if permitted
*                                                                       (see Notes #4 & #5).
*                                   NET_TCP_CONN_TX_RESET_FAULT     Transmit a TCP reset segment immediately for
*                                                                       a closing TCP connection fault.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection reset successfully transmitted.
*                               NET_TCP_ERR_CONN_RESET_INVALID      TCP connection reset NOT valid for current TCP
*                                                                       connection state.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*
*                                                                   - RETURNED BY NetTCP_RxPktConnIsValidSeq() : -
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*
* Return(s)   : none.
*
* Caller(s)   : various.
*
* Note(s)     : (2) The following TCP header fields MUST be decoded &/or converted from network-order to host-
*                   order BEFORE any TCP Reset Segments are transmitted (see 'NetTCP_RxPktValidate()  Note #3') :
*
*                   (a) Sequence        Number
*                   (b) Acknowledgement Number
*                   (c) Segment Length
*
*               (3) See the following RFC's for TCP reset generation summary :
*
*                   (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation'
*                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES'
*                   (c) RFC Draft-IETF-TCPm-TCPSecure #00, Section 3
*
*               (4) TCP connection resets are transmitted :
*
*                   (a) When certain invalid segments are received :
*
*                               (A) Some TCP transmit reset validation logic implemented in previous functions;
*                                   include duplicate validation logic in NetTCP_TxConnReset() only if debug/
*                                   validation code is enabled (i.e. NET_ERR_CFG_ARG_CHK_DBG_EN is DEF_ENABLED
*                                   in 'net_cfg.h').
*
*                       (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED [State]'
*                               states that if the current TCP connection "state is CLOSED", then ...
*
*                               (1) "An incoming segment     containing a RST is discarded".
*                               (2) "An incoming segment NOT containing a RST causes a RST to be sent".
*
*                           (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1'
*                               reiterates that "if [a] connection does not exist (CLOSED) then a reset is
*                               sent in response to any incoming segment except another reset".
*
*                       (2) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
*                               Check for ACK' states that "any acknowledgment is bad if it arrives on a
*                               connection still in the LISTEN state.  An acceptable reset segment should
*                               be formed for any arriving ACK-bearing segment".
*
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
*                               Check for SYN' also states that "if the security/compartment on the incoming
*                               segment does not exactly match the security/compartment in the TCB ... [or]
*                               if the SEG.PRC is ... not allowed [then] send a reset".
*
*                               However, these checks for invalid connection permissions are NOT necessary
*                               since TCP security & precedence NOT supported (see 'net_tcp.c  Note #1a').
*
*                       (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                           Check ACK Bit' states that "if the state is SYN-SENT" & "the ACK bit is set" &
*                           the incoming segment's "SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset".
*
*                       (4) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence
*                               Number' states that for the "SYN-RECEIVED STATE, ESTABLISHED STATE, FIN-
*                               WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
*                               STATE, TIME-WAIT STATE", to "first check [the] sequence number ... [and if
*                               it] is not acceptable, an acknowledgment should be sent in reply ... unless
*                               the RST bit is set".
*
*                           (B) (1) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN
*                                       Bit' states that for "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT
*                                       STATE-1, FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
*                                       STATE, TIME-WAIT STATE ... [to next] check the SYN bit ... [and] if
*                                       the SYN is in the window it is an error, send a reset, any outstanding
*                                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment
*                                       queues should be flushed, the user should also receive an unsolicited
*                                       general 'connection reset' signal[, and] enter the CLOSED state".
*
*                                   (b) But "if the SYN is not in the window this step would not have been
*                                       reached and an ack would have been sent" (see Note #4a4A).
*
*                               (2) (a) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the
*                                       "handling of a segment with the SYN bit set in the synchronized state
*                                        ... [by] handling ... the SYN bit" as follows :
*
*                                       (a) "If the SYN bit is set and the sequence number is outside the
*                                            expected window, send an ACK back to the peer."
*
*                                       (b) "If the SYN bit is set and the sequence number is an exact
*                                            match to the next expected sequence (RCV.NXT == SEG.SEQ)
*                                            then send an ACK segment ... but ... subtract one from
*                                            value being acknowledged."
*
*                                       (c) "If the SYN bit is set and the sequence number is acceptable,
*                                            i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
*                                            ACK segment."
*
*                                   (b) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that
*                                       this amendment applies only to the "handling of a ... SYN ... in a
*                                       synchronized state", it is assumed that this should also apply to the
*                                       SYN-RECEIVED state.
*
*                           (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
*                               states to next "check the ACK Field" :
*
*                               (1) If in the "SYN-RECEIVED STATE ... [and] if the segment acknowledgment
*                                   is not acceptable, form a reset segment".
*
*                               (2) If in the "ESTABLISHED STATE" or any state with similar "processing as
*                                   for the ESTABLISHED STATE", that "if the ACK acks something not yet sent
*                                   (SEG.ACK >  SND.NXT) then send an ACK" but "if the ACK is a duplicate
*                                   (SEG.ACK =< SND.UNA), it can be ignored".
*
*                           (D) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 3'
*                               reiterates that for any TCP "connection ... in a synchronized state
*                               (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
*                               TIME-WAIT), any unacceptable segment (out of window sequence number
*                               or unacceptible [sic] acknowledgment number) must elicit only an empty
*                               acknowledgment segment containing the current send-sequence number and
*                               an acknowledgment indicating the next sequence number expected to be
*                               received".
*
*                   (b) (1) When TCP connection fault-closes from the following synchronization/connected/
*                           closing states :
*
*                           (A) SYN-RECEIVED
*                           (B) SYN-SENT
*                           (C) ESTABLISHED
*                           (D) FIN-WAIT-1
*                           (E) FIN-WAIT-2
*                           (F) CLOSING
*                           (G) TIME_WAIT
*                           (H) CLOSE-WAIT
*                           (I) LAST-ACK
*
*                       (2) Although NO RFC directly states to transmit a TCP reset segment when a TCP
*                           connection fault-closes, it is inferred & seems reasonable that a TCP reset
*                           segment SHOULD be transmitted whenever a TCP connection closes abnormally.
*
*               (5) The following sections reiterate the generalization that "a reset is sent in response
*                   to any [unacceptable segment] ... EXCEPT* another reset"; also "send a reset (UNLESS*
*                   the RST bit is set, if so drop the segment)" :                      [*emphasis added]
*
*                   (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State] :
*                           Check for RST'
*                   (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
*                           Check ACK Bit'
*                   (c) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                           SYN-RECEIVED STATE' (see Note #5A)
*
*                       (A) This confirms that the received segment does NOT contain a TCP reset control
*                           since it follows RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES :
*                           Check RST Bit'.
*
*               (6) (a) (1) The following sections ... :
*
*                           (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED   [State]'
*                           (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State]'
*                               (1) Amended by RFC #1122, Section 4.2.2.20.(b)
*                           (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State]'
*                           (D) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
*                                   SYN-RECEIVED STATE'
*
*                       (2) ... generalize that "the acknowledgment and sequence field values [for the reset
*                           segment to transmit] are selected to make the reset sequence acceptable to the
*                           TCP that sent the offending segment" (see Note #4a) :
*
*                           (A) "If the ACK bit is off, sequence number zero is used,
*
*                                  <SEQ=0> <ACK=SEG.SEQ + SEG.LEN> <CTL=RST, ACK>"
*
*                           (B) "If the ACK bit is on,
*
*                                  <SEQ=SEG.ACK> <CTL=RST>"
*
*                   (b) However, NO RFC specifies the sequence & acknowledgement numbers to use when
*                       transmitting a reset segment for a TCP connection that closes due to any fault
*                       condition(s) [see Note #4b].
*
*                       (1) #### Therefore, TCP transmit reset segments for fault-closing TCP connections
*                           should be prepared as follows :
*
*                           (A) With the following TCP sequence numbers :
*
*                               (1) TCP_SeqNbr  =  TxSeqNbrUnAckd
*
*                               (2) TCP_AckNbr  =  RxSeqNbrNext
*
*                                       where
*
*                                           TCP_SeqNbr          TCP transmit reset segment sequence        number
*                                           TCP_AckNbr          TCP transmit reset segment acknowledgement number
*                                           TxSeqNbrUnAckd      TCP connection's currently unacknowledged transmit
*                                                                   sequence number
*                                           RxSeqNbrNext        TCP connection's currently expected next  receive
*                                                                   sequence number
*
*                           (B) With the following TCP segment header flags set :
*
*                               (1) RESET
*
*                       (2) This TCP transmit reset segment format complies with TCP connection received
*                           reset segment handling as specified in RFC #793, Section 3.9 'Event Processing :
*                           SEGMENT ARRIVES'.
*
*                           See also 'NetTCP_RxPktConnIsValidReset()  Notes #2a2, 2a3, 2a4A1, & 2a4B1'.
*
*               (7) (a) (1) RFC #793, Sections 3.7 & 2.6 state that "TCP uses retransmission ... to ensure
*                           delivery of every segment".
*
*                       (2) However, NO RFC specifies whether TCP connection reset segments should be queued
*                           for retransmission.  Therefore, it is assumed that ALL TCP connection reset
*                           segments SHOULD NOT be queued for retransmission but SHOULD be silently discarded.
*
*                   (b) (1) The network buffer's reference counter is NOT incremented since the TCP layer
*                           does NOT maintain a reference to any transmitted TCP connection reset segments.
*
*                       (2) Therefore, the network buffer MUST be freed by lower layer(s).
*
*                   See also 'NetTCP_TxConnAck()    Note #8',
*                          & 'NetTCP_TxConnProbe()  Note #3'.
*
*               (8) On ANY error(s) :
*
*                   (a) Network resources MUST be appropriately freed :
*
*                       (1) For any network resources NOT linked to the TCP connection, each network resource
*                           MUST be freed by appropriate function(s).
*
*                   (b) TCP connection MUST NOT be re-closed.
*
*                       See also 'NetTCP_ConnClose()  Note #5'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnReset (NET_TCP_CONN        *p_conn,
                                  NET_BUF_HDR         *p_buf_hdr,
                                  NET_TCP_RESET_CODE   tx_reset_code,
                                  NET_TCP_CLOSE_CODE   close_code,
                                  NET_ERR             *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_ACK_CODE           ack_code;
    NET_TCP_SEQ_CODE           seq_code;
#endif
    CPU_BOOLEAN                tx_reset;
    CPU_BOOLEAN                conn_if_nbr_avail;
    NET_CONN_ID                conn_id;
    NET_CONN                  *p_net_conn = DEF_NULL;
    NET_IF_NBR                 if_nbr;
    NET_BUF_SIZE               data_len;
    NET_BUF_SIZE               data_ix;
    NET_BUF_SIZE               data_ix_offset;
    NET_BUF                   *pseg_reset;
    NET_BUF_HDR               *pseg_reset_hdr;
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR              src_addrv4;
    NET_IPv4_ADDR              dest_addrv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR              src_addrv6;
    NET_IPv6_ADDR              dest_addrv6;
#endif
    NET_TCP_PORT_NBR           src_port;
    NET_TCP_PORT_NBR           dest_port;
    NET_TCP_SEQ_NBR            seq_nbr;
    NET_TCP_SEQ_NBR            ack_nbr;
    NET_TCP_WIN_SIZE           win_size;
    NET_TCP_FLAGS              flags_tcp;
    NET_PROTOCOL_TYPE          proto_type;
    NET_CONN_FAMILY            proto_family = NET_CONN_FAMILY_IP_V4_SOCK;
    NET_ERR                    err;


                                                                /* -------------- VALIDATE RX'D TCP PKT --------------- */
    if (p_buf_hdr != DEF_NULL) {
        if (p_buf_hdr->TCP_SegReset != DEF_NO) {                /* If TCP reset pkt rx'd, ...                           */
           *p_err = NET_TCP_ERR_CONN_RESET_INVALID;             /* ... do NOT tx TCP conn reset (see Note #5).          */
            return;
        }
    }


                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    tx_reset = DEF_NO;

    if (p_conn != DEF_NULL) {
        switch (p_conn->ConnState) {
            case NET_TCP_CONN_STATE_FREE:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
                *p_err = NET_TCP_ERR_CONN_NOT_USED;
                 return;


            case NET_TCP_CONN_STATE_CLOSED:                     /* See Note #4a1.                                       */
                 tx_reset          = DEF_YES;
                 conn_if_nbr_avail = DEF_NO;
                 break;


            case NET_TCP_CONN_STATE_LISTEN:                     /* See Note #4a2.                                       */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                 if (p_buf_hdr != DEF_NULL) {                   /* If seg rx'd                 ...                      */
                     ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
                     if (*p_err != NET_TCP_ERR_NONE) {
                          return;
                     }
                     if (ack_code != NET_TCP_CONN_RX_ACK_NONE) {/* ... with ANY (invalid) ack, ...                      */
                         tx_reset  = DEF_YES;                   /* ... tx TCP conn reset (see Note #4a2A).              */
                     }
                 }

#else
                 tx_reset          = DEF_YES;
#endif
                 conn_if_nbr_avail = DEF_NO;
                 break;


            case NET_TCP_CONN_STATE_SYNC_TXD:                   /* See Note #4a3.                                       */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                 switch (tx_reset_code) {
                     case NET_TCP_CONN_TX_RESET:
                     default:
                          if (p_buf_hdr != DEF_NULL) {          /* If seg rx'd            ...                           */
                              ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                                                                /* ...  with invalid ack, ...                           */
                              if (ack_code == NET_TCP_CONN_RX_ACK_INVALID) {
                                  tx_reset  = DEF_YES;          /* ...  tx TCP conn reset (see Note #4a3).              */
                              }

                          } else {                              /* Else no seg rx'd, ...                                */
                              tx_reset = DEF_YES;               /* ...  tx TCP conn reset (see Note #4b1B).             */
                          }
                          break;


                     case NET_TCP_CONN_TX_RESET_FAULT:
                          tx_reset = DEF_YES;
                          break;
                 }

#else
                (void)&tx_reset_code;                           /* Prevent 'variable unused' compiler warning.          */
                 tx_reset          = DEF_YES;
#endif
                 conn_if_nbr_avail = DEF_YES;
                 break;


            case NET_TCP_CONN_STATE_SYNC_RXD:                   /* See Note #4a4.                                       */
            case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
            case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                 switch (tx_reset_code) {
                     case NET_TCP_CONN_TX_RESET:
                     default:
                          if (p_buf_hdr != DEF_NULL) {          /* If seg rx'd                                  ...     */
                              seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                                                                /* ... with   invalid seq/sync,                 ...     */
                              if (seq_code != NET_TCP_CONN_RX_SEQ_VALID) {
                                                                /* ... tx TCP conn ack (see Notes #4a4A & #4a4B2),      */
                                  NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
                                 *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
                                  return;
                              }

                              ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                                                                /* ...  without valid ack,                      ...     */
                              if (ack_code != NET_TCP_CONN_RX_ACK_VALID) {
                                  tx_reset  = DEF_YES;          /* ...  tx TCP conn reset (see Note #4a4C1).            */
                              }

                          } else {                              /* Else no seg rx'd, ...                                */
                              tx_reset = DEF_YES;               /* ...  tx TCP conn reset (see Note #4b1A).             */
                          }
                          break;


                     case NET_TCP_CONN_TX_RESET_FAULT:
                          tx_reset = DEF_YES;
                          break;
                 }

#else
                (void)&tx_reset_code;                           /* Prevent 'variable unused' compiler warning.          */
                 tx_reset          = DEF_YES;
#endif
                 conn_if_nbr_avail = DEF_YES;
                 break;


            case NET_TCP_CONN_STATE_CONN:                       /* See Note #4a4.                                       */
            case NET_TCP_CONN_STATE_FIN_WAIT_1:
            case NET_TCP_CONN_STATE_FIN_WAIT_2:
            case NET_TCP_CONN_STATE_CLOSING:
            case NET_TCP_CONN_STATE_TIME_WAIT:
            case NET_TCP_CONN_STATE_CLOSE_WAIT:
            case NET_TCP_CONN_STATE_LAST_ACK:
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #4aA.                                       */
                 switch (tx_reset_code) {
                     case NET_TCP_CONN_TX_RESET:
                     default:
                          if (p_buf_hdr != DEF_NULL) {          /* If seg rx'd                ...                       */
                              seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr, p_err);
                              if (*p_err != NET_TCP_ERR_NONE) {
                                   return;
                              }
                                                                /* ... with invalid seq/sync, ...                       */
                              if (seq_code != NET_TCP_CONN_RX_SEQ_VALID) {
                                                                /* ... tx TCP conn ack (see Notes #4a4A & #4a4B2).      */
                                  NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &err);
                                 *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
                                  return;
                              }

                          } else {                              /* Else no seg rx'd, ...                                */
                              tx_reset = DEF_YES;               /* ...  tx TCP conn reset (see Notes #4b1C - #4b1I).    */
                          }
                          break;


                     case NET_TCP_CONN_TX_RESET_FAULT:
                          tx_reset = DEF_YES;
                          break;
                 }

#else
                (void)&tx_reset_code;                           /* Prevent 'variable unused' compiler warning.          */
                 tx_reset          = DEF_YES;
#endif
                 conn_if_nbr_avail = DEF_YES;
                 break;


            case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
                 tx_reset          = DEF_YES;
                 conn_if_nbr_avail = DEF_YES;
                 break;


            case NET_TCP_CONN_STATE_NONE:
            default:
                 if (close_code != NET_TCP_CONN_CLOSE_NONE) {   /* If tx reset NOT req'd by TCP conn close fnct(s),     */
                                                                /* ... close TCP conn (see Note #8b).                   */
                     DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_CONN_TX_RESET);
                     NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, close_code);
                 }
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
                *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                 return;
        }

    } else {                                                    /* If NO demux'd TCP conn avail, handle as CLOSED.      */
        if (p_buf_hdr != DEF_NULL) {                            /* If rx'd pkt avail, ...                               */
            tx_reset  =  DEF_YES;                               /* ... tx reset.                                        */
        }
        conn_if_nbr_avail = DEF_NO;
    }


    if (tx_reset != DEF_YES) {                                  /* If NOT valid, abort tx TCP conn reset.               */
       *p_err = NET_TCP_ERR_CONN_RESET_INVALID;
        return;
    }


                                                                /* ------------ PREPARE TCP CONN RESET SEG ------------ */
                                                                /* If valid, prepare & tx TCP conn reset.               */
    if ((p_conn            != DEF_NULL) &&                      /* If avail, ...                                        */
        (conn_if_nbr_avail == DEF_YES )) {
         conn_id = p_conn->ID_Conn;
         if_nbr  = NetConn_IF_NbrGet(conn_id, &err);            /* ...  get TCP conn's IF nbr.                          */
         if ( err != NET_CONN_ERR_NONE) {
             NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, close_code);
            *p_err = NET_TCP_ERR_CONN_FAULT;
             return;
         }

    } else if (p_buf_hdr != DEF_NULL) {                         /* Else get rx'd pkt's IF nbr.                          */

         if_nbr = p_buf_hdr->IF_Nbr;

    } else if (p_conn != DEF_NULL) {
        conn_id = p_conn->ID_Conn;
        if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
        if (err != NET_CONN_ERR_NONE) {
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
            *p_err  = NET_TCP_ERR_CONN_FAULT;
             return;
         }

         if (if_nbr == NET_IF_NBR_NONE) {                           /* Set IF nbr to default if conn IF is not defined. */
             if_nbr = NetIF_GetDflt();
         }

    } else {
        *p_err  = NET_TCP_ERR_CONN_FAULT;
         return;
    }

    proto_family = NET_SOCK_PROTOCOL_FAMILY_NONE;

    if (p_conn != DEF_NULL) {
        conn_id      =  p_conn->ID_Conn;
        p_net_conn   = &NetConn_Tbl[conn_id];
        proto_family =  p_net_conn->Family;

    } else {
        switch(p_buf_hdr->ProtocolHdrTypeNet) {
#ifdef  NET_IPv4_MODULE_EN
            case NET_PROTOCOL_TYPE_IP_V4:
            case NET_PROTOCOL_TYPE_IP_V4_OPT:
                 proto_family = NET_SOCK_PROTOCOL_FAMILY_IP_V4;
                 break;
#endif
#ifdef  NET_IPv6_MODULE_EN
            case NET_PROTOCOL_TYPE_IP_V6:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_HOP_BY_HOP:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_ROUTING:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_FRAG:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_ESP:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_AUTH:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_NONE:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_DEST:
            case NET_PROTOCOL_TYPE_IP_V6_EXT_MOBILITY:
                 proto_family = NET_SOCK_PROTOCOL_FAMILY_IP_V6;
                 break;
#endif

            default:
                 break;
        }
    }

                                                                /* Get buf.                                             */
    data_len = NET_TCP_DATA_LEN_TX_RESET;
    data_ix  = 0u;

    switch (proto_family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
             proto_type = NET_PROTOCOL_TYPE_TCP_V4;
             break;
#endif
#ifdef  NET_IPv6_MODULE_EN
             case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
             proto_type = NET_PROTOCOL_TYPE_TCP_V6;
             break;
#endif

        default:
             proto_type = NET_PROTOCOL_TYPE_NONE;
             break;
    }

    NetTCP_GetTxDataIx(if_nbr,
                       proto_type,
                       0u,
                       data_len,
                       p_conn,
                      &data_ix,
                       p_err);

    pseg_reset = NetBuf_Get(if_nbr,
                            NET_TRANSACTION_TX,
                            data_len,
                            data_ix,
                           &data_ix_offset,
                            NET_BUF_FLAG_NONE,
                           &err);
    if (err  != NET_BUF_ERR_NONE) {
       *p_err = NET_TCP_ERR_NONE_AVAIL;
        return;
    }

    data_ix    +=  data_ix_offset;


                                                                /* ----------------- PREPARE TCP HDR ------------------ */
                                                                /* Prepare seg addrs.                                   */
    if (p_buf_hdr != DEF_NULL) {                                /* If TCP pkt rx'd, cfg TCP tx                ...       */
                                                                /* ...  src  addr from rx'd TCP pkt dest addr ...       */
                                                                /* .. & dest addr from rx'd TCP pkt src  addr.          */
        if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
            src_addrv4  = p_buf_hdr->IP_AddrDest;
            dest_addrv4 = p_buf_hdr->IP_AddrSrc;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            src_addrv6  = p_buf_hdr->IPv6_AddrDest;
            dest_addrv6 = p_buf_hdr->IPv6_AddrSrc;
#endif
        }

        src_port  = p_buf_hdr->TransportPortDest;
        dest_port = p_buf_hdr->TransportPortSrc;

    } else {                                                    /* Else cfg TCP tx pkt addrs from TCP conn addrs.       */

        switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
            case NET_CONN_FAMILY_IP_V4_SOCK:
                 NetTCP_TxConnPrepareSegAddrs(p_conn,
                               (CPU_INT08U *)&src_addrv4,
                               (CPU_INT08U *)&src_port,
                                              sizeof(src_addrv4),
                                              sizeof(src_port),
                               (CPU_INT08U *)&dest_addrv4,
                               (CPU_INT08U *)&dest_port,
                                              sizeof(dest_addrv4),
                                              sizeof(dest_port),
                                             &err);
                 break;
#endif

#ifdef  NET_IPv6_MODULE_EN
            case NET_CONN_FAMILY_IP_V6_SOCK:
                 NetTCP_TxConnPrepareSegAddrs(p_conn,
                               (CPU_INT08U *)&src_addrv6,
                               (CPU_INT08U *)&src_port,
                                              sizeof(src_addrv6),
                                              sizeof(src_port),
                               (CPU_INT08U *)&dest_addrv6,
                               (CPU_INT08U *)&dest_port,
                                              sizeof(dest_addrv6),
                                              sizeof(dest_port),
                                             &err);
                 break;
#endif
            default:
                *p_err = NET_TCP_ERR_CONN_PROTO_FAMILY;
                 return;
        }

        if ( err != NET_TCP_ERR_NONE) {                         /* See Note #8a.                                        */
            NetBuf_Free(pseg_reset);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
    }


                                                                /* Prepare TCP tx flags (see Note #1c2C).               */
    flags_tcp = NET_TCP_FLAG_NONE    |
                NET_TCP_FLAG_TX_RESET;

                                                                /* Prepare TCP seq nbrs (see Note #6).                  */
    if (p_buf_hdr != DEF_NULL) {
        if (p_buf_hdr->TCP_SegAck != DEF_NO) {                  /* If TCP ack rx'd  (see Note #6a2B), ...               */
            seq_nbr = p_buf_hdr->TCP_AckNbr;                    /* .. tx  seq = ack                   ...               */
            ack_nbr = NET_TCP_ACK_NBR_NONE;                     /* .. &   ack = none.                                   */

        } else {                                                /* Otherwise        (see Note #6a2A), ...               */
            seq_nbr = NET_TCP_SEQ_NBR_NONE;                     /* .. tx  seq = 0 (none)              ...               */
            ack_nbr = p_buf_hdr->TCP_SeqNbr                     /* .. &   ack = seg seq               ...               */
                    + p_buf_hdr->TCP_SegLen;                    /* ..         + seg len.                                */

            if (p_buf_hdr->TCP_SegSync == DEF_YES) {
                ack_nbr += 1;
            }

            if (p_buf_hdr->TCP_SegClose == DEF_YES) {
                ack_nbr += 1;
            }

            DEF_BIT_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
        }

    } else {                                                    /* Else no seg rx'd (see Note #6b1A), ...               */
        seq_nbr = p_conn->TxSeqNbrUnAckd;                       /* .. tx  seq = tx unack'd            ...               */
        ack_nbr = p_conn->RxSeqNbrNext;                         /* .. &   ack = rx next.                                */
#ifdef  TEST_TCP_3_18
        DEF_BIT_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
#endif
    }

                                                                /* Prepare TCP win size.                                */
    win_size = NET_TCP_WIN_SIZE_NONE;


                                                                /* Init buf ctrls.                                      */
    pseg_reset_hdr               = &pseg_reset->Hdr;
    pseg_reset_hdr->DataIx       =  data_ix;
    pseg_reset_hdr->DataLen      =  data_len;
    pseg_reset_hdr->TotLen       =  pseg_reset_hdr->DataLen;

    pseg_reset_hdr->TCP_SegSync  =  DEF_NO;
    pseg_reset_hdr->TCP_SegClose =  DEF_NO;
    pseg_reset_hdr->TCP_SegAck   =  DEF_BIT_IS_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
    pseg_reset_hdr->TCP_SegReset =  DEF_YES;

    pseg_reset_hdr->TCP_Flags    =  flags_tcp;



                                                                /* -------------- TX TCP CONN RESET SEG --------------- */
    switch (proto_family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_CONN_FAMILY_IP_V4_SOCK:
             pseg_reset_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V4;
             pseg_reset_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

             NetTCP_TxPktHandlerIPv4(pseg_reset,
                                     src_addrv4,
                                     src_port,
                                     dest_addrv4,
                                     dest_port,
                                     seq_nbr,
                                     ack_nbr,
                                     win_size,
                                     NET_IPv4_TOS_DFLT,
                                     NET_IPv4_TTL_DFLT,
                                     flags_tcp,
                                     NET_IPv4_FLAG_NONE,
                                     DEF_NULL,
                                     DEF_NULL,
                                    &err);                      /* Ignore transitory tx err(s).                         */
             break;
#endif

#ifdef  NET_IPv6_MODULE_EN
        case NET_CONN_FAMILY_IP_V6_SOCK:
             pseg_reset_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V6;
             pseg_reset_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V6;

             NetTCP_TxPktHandlerIPv6(pseg_reset,
                   (NET_IPv6_ADDR *)&src_addrv6,
                                     src_port,
                   (NET_IPv6_ADDR *)&dest_addrv6,
                                     dest_port,
                                     seq_nbr,
                                     ack_nbr,
                                     win_size,
                                     NET_IPv6_TRAFFIC_CLASS_DFLT,
                                     NET_IPv6_FLOW_LABEL_DFLT,
                                     NET_IPv6_HOP_LIM_DFLT,
                                     flags_tcp,
                                     DEF_NULL,
                                     &err);                     /* Ignore transitory tx err(s).                         */
             break;
#endif
        default:
            *p_err = NET_TCP_ERR_CONN_PROTO_FAMILY;
             return;
    }

#if 0                                                           /* Tx buf freed by lower layer(s) [see Note #7b2].      */
    NetTCP_TxPktFree(pseg_reset);
#endif
    NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnResetCtr);



   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                        NetTCP_TxConnProbe()
*
* Description : (1) Prepare & transmit a TCP connection probe :
*
*                   (a) Validate TCP connection state for TCP probe
*                   (b) Prepare  TCP probe segment :                                See Note #2
*                       (1) Get  buffer
*                       (2) Prepare TCP segment :
*                           (A) TCP segment  addresses
*                           (B) TCP segment  sequence numbers                       See Note #2b1
*                           (C) TCP segment  transmit flags :
*                               (1) ACK
*                           (D) TCP segment  window size
*                           (E) IP  datagram parameters
*                           (F) TCP segment  packet buffer controls
*                   (c) Transmit TCP connection probe
*
*
* Argument(s) : p_conn                   Pointer to a TCP connection.
*
*               tx_probe_data_octet     Indicate whether to transmit a single data probe octet (see Note #2b2) :
*
*                                           DEF_YES                Transmit data probe octet.
*                                           DEF_NO          Do NOT transmit data probe octet.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection probe successfully transmitted.
*                               NET_TCP_ERR_CONN_PROBE_INVALID      TCP connection probe NOT valid for current
*                                                                       TCP connection state.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_CONN_FAIL               TCP connection operation(s) failed.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_CONN_ERR_INVALID_FAMILY         Connection's socket protocol family is invalid.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnWinSizeZeroWinHandler(),
*               NetTCP_TxConnKeepAlive().
*
* Note(s)     : (2) TCP connection probes are transmitted for certain TCP conditions :
*
*                       (A) Some TCP transmit probe validation logic implemented in previous functions;
*                           include duplicate validation logic in NetTCP_TxConnProbe() only if debug/
*                           validation code is enabled (i.e. NET_ERR_CFG_ARG_CHK_DBG_EN is DEF_ENABLED
*                           in 'net_cfg.h').
*
*                   (a) RFC #1122, Section 4.2.3.6 specifies a "mechanism [that] periodically probes the
*                       other end of a connection" for the following TCP connection conditions :
*
*                       (1) Probing Zero Windows                                RFC #1122, Section 4.2.2.17
*                               (see 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1b')
*
*                       (2) TCP Keep-Alives                                     RFC #1122, Section 4.2.3.6
*                               (see 'NetTCP_TxConnKeepAlive()  Note #2c')
*
*                   (b) "Send a probe segment ... to elicit a response from the peer TCP" :
*
*                       (1) (A) (1) "Such a segment generally contains SEG.SEQ = SND.NXT-1" ...
*
*                                   (a) "Note that on a quiet connection SND.NXT = RCV.NXT, so that this SEG.SEQ
*                                        will be outside the window.  Therefore, the probe causes the receiver
*                                        to return an acknowledgment segment, confirming that the connection is
*                                        still live.  If the peer has dropped the connection ... it will respond
*                                        with a RST instead of an acknowledgment segment."
*
*                                   (b) However, this contradicts Wright/Stevens, TCP/IP Illustrated, Volume 2,
*                                       3rd Printing, Section 25.6 'Connection Establishment and Keepalive Timers :
*                                       Send a keepalive probe', Page 830 which states that "the sequence number
*                                       field of the keepalive packet ... contains [SND.UNA] minus 1, which is
*                                       the sequence number of a byte of data that the other end has already
*                                       acknowledged ... Since this sequence number is outside the window, the
*                                       other end must respond with an ACK, specifying the next sequence number
*                                       it expects".
*
*                               (2) (a) Although on an idle TCP connection, the next sequence octet to transmit
*                                       (SND.NXT) is equal to the last unacknowledged transmit sequence octet
*                                       (SND.UNA); on a TCP connection whose remote host has zero-window closed
*                                       its receive window, the next sequence octet to transmit is NOT equal to
*                                       the last unacknowledged transmit sequence octet.
*
*                                   (b) Therefore, it seems reasonable to transmit probe segments with a sequence
*                                       number (SEQ.SEQ) that is one less than the last unacknowledged transmit
*                                       sequence octet (SND.UNA).
*
*                           (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                               'Connection Establishment and Keepalive Timers : Send a keepalive probe',
*                               Page 830 states that "the acknowledgment  field of the keepalive packet ...
*                               contains [RCV.NXT], the next sequence number expected on the connection".
*
*                       (2) "and may or may not contain one garbage octet of data."
*
*                           (A) "An implementation SHOULD send a [probe] segment with no data."
*
*                           (B) (1) "Unfortunately, some misbehaved TCP implementations fail to respond to
*                                    a segment with SEG.SEQ = SND.NXT-1 unless the segment contains data."
*
*                               (2) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other
*                                   End Crashes', Page 335 reiterates that "some older implementations based
*                                   on 4.2BSD do not respond to these ... probes unless the segment contains
*                                   data".
*
*                           (C) Therefore, RFC #1122, Section 4.2.3.6 states that a TCP "implementation ...
*                               MAY be configurable to send a [probe] segment containing one garbage octet,
*                               for compatibility with erroneous TCP implementations".
*
*                           See also 'NetTCP_TxConnKeepAlive()  Note #2d2'.
*
*               (3) (a) (1) (A) RFC #793, Sections 3.7 & 2.6 state that "TCP uses retransmission ... to ensure
*                               delivery of every segment".
*
*                           (B) (1) However, RFC #1122, Section 4.2.2.17 'DISCUSSION' states that "it is
*                                   extremely important to remember that ACK (acknowledgment) segments that
*                                   contain no data are not reliably transmitted by TCP".
*
*                               (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                                   'Connection Establishment and Keepalive Timers : Drop connection when no
*                                   response', Page 830 reiterates that "one reason TCP must send multiple
*                                   keepalive probes before considering the connection dead is that the
*                                   ACKs sent in response do not contain data and therefore are not reliably
*                                   transmitted by TCP.  An ACK that is a response to a keepalive probe can
*                                   get lost".
*
*                       (2) Therefore, it is assumed that TCP acknowledgement/probe segments should NOT be
*                           queued for retransmission but SHOULD be silently discarded.
*
*                   (b) (1) The network buffer's reference counter is NOT incremented since the TCP layer
*                           does NOT maintain a reference to any transmitted TCP probe segments.
*
*                       (2) Therefore, the network buffer MUST be freed by lower layer(s).
*
*                   See also 'NetTCP_TxConnAck()    Note #8',
*                          & 'NetTCP_TxConnReset()  Note #7'.
*
*               (4) On ANY error(s), network resources MUST be appropriately freed :
*
*                   (a) For any network resources NOT linked to the TCP connection, each network resource
*                       MUST be freed by appropriate function(s).
*
*               (5) (a) IP  transmit options currently NOT implemented     See 'net_tcp.c  Note #1d'
*                   (b) TCP transmit options currently NOT implemented     See 'net_tcp.c  Note #1c'
*********************************************************************************************************
*/

static  void  NetTCP_TxConnProbe (NET_TCP_CONN        *p_conn,
                                  CPU_BOOLEAN          tx_probe_data_octet,
                                  NET_TCP_CLOSE_CODE   close_code,
                                  NET_ERR             *p_err)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    CPU_BOOLEAN              tx_probe;
#endif
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR            src_addrv4;
    NET_IPv4_ADDR            dest_addrv4;
    NET_IPv4_TOS             TOS;
    NET_IPv4_TTL             TTL;
    NET_IPv4_FLAGS           flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR            src_addrv6;
    NET_IPv6_ADDR            dest_addrv6;
    NET_IPv6_TRAFFIC_CLASS   traffic_class;
    NET_IPv6_FLOW_LABEL      flow_label;
    NET_IPv6_HOP_LIM         hop_lim;
    NET_IPv6_FLAGS           flags_ipv6;
#endif
    NET_BUF_SIZE             data_len;
    NET_BUF_SIZE             data_ix;
    NET_BUF_SIZE             data_ix_offset;
    NET_CONN_ID              conn_id;
    NET_CONN                *p_net_conn;
    NET_IF_NBR               if_nbr;
    NET_BUF                 *pseg_probe;
    NET_BUF_HDR             *pseg_probe_hdr;
    NET_TCP_PORT_NBR         src_port;
    NET_TCP_PORT_NBR         dest_port;
    NET_TCP_SEQ_NBR          seq_nbr;
    NET_TCP_SEQ_NBR          ack_nbr;
    NET_TCP_WIN_SIZE         win_size;
    NET_TCP_FLAGS            flags_tcp;
    CPU_INT08U               probe_data[NET_TCP_DATA_LEN_TX_PROBE_DATA];
    NET_PROTOCOL_TYPE        proto_type = NET_PROTOCOL_TYPE_NONE;
    NET_ERR                  err;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* See Note #2A.                                        */
                                                                /* ------------- VALIDATE TCP CONN STATE -------------- */
    tx_probe = DEF_NO;

    if (p_conn != DEF_NULL) {
        switch (p_conn->ConnState) {
            case NET_TCP_CONN_STATE_FREE:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
                *p_err = NET_TCP_ERR_CONN_NOT_USED;
                 return;


            case NET_TCP_CONN_STATE_CLOSED:
            case NET_TCP_CONN_STATE_LISTEN:
            case NET_TCP_CONN_STATE_SYNC_RXD:
            case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
            case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
            case NET_TCP_CONN_STATE_SYNC_TXD:
            case NET_TCP_CONN_STATE_TIME_WAIT:
            case NET_TCP_CONN_STATE_LAST_ACK:
            case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
                *p_err = NET_TCP_ERR_INVALID_CONN_OP;
                 return;


            case NET_TCP_CONN_STATE_CONN:
            case NET_TCP_CONN_STATE_FIN_WAIT_1:
            case NET_TCP_CONN_STATE_FIN_WAIT_2:
            case NET_TCP_CONN_STATE_CLOSING:
            case NET_TCP_CONN_STATE_CLOSE_WAIT:
                 tx_probe = DEF_YES;
                 break;


            case NET_TCP_CONN_STATE_NONE:
            default:
                 NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                  (NET_BUF_HDR      *)0,
                                  (CPU_BOOLEAN       )DEF_YES,
                                  (NET_TCP_CLOSE_CODE)close_code);
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
                *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                 return;
        }
    }


    if (tx_probe != DEF_YES) {                                  /* If NOT valid, abort tx TCP conn probe.               */
       *p_err = NET_TCP_ERR_CONN_PROBE_INVALID;
        return;
    }
#endif


                                                                /* ------------ PREPARE TCP CONN PROBE SEG ------------ */
                                                                /* If valid, prepare & tx TCP conn probe.               */
                                                                /* Get buf.                                             */
    conn_id = p_conn->ID_Conn;
    if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
    if ( err != NET_CONN_ERR_NONE) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )DEF_YES,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    data_len   = (tx_probe_data_octet == DEF_YES)               /* Cfg data len for probe data (see Note #2b2C).        */
               ?  NET_TCP_DATA_LEN_TX_PROBE_DATA
               :  NET_TCP_DATA_LEN_TX_PROBE_NO_DATA;

    p_net_conn = &NetConn_Tbl[conn_id];

    switch (p_net_conn->Family) {
        case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
             proto_type = NET_PROTOCOL_TYPE_TCP_V4;
             break;


        case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
             proto_type = NET_PROTOCOL_TYPE_TCP_V6;
             break;


        default:
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return;
    }

    data_ix = 0u;

    NetTCP_GetTxDataIx(if_nbr,
                       proto_type,
                       0u,
                       data_len,
                       p_conn,
                      &data_ix,
                       p_err);

    pseg_probe = NetBuf_Get((NET_IF_NBR     ) if_nbr,
                            (NET_TRANSACTION) NET_TRANSACTION_TX,
                            (NET_BUF_SIZE   ) data_len,
                            (NET_BUF_SIZE   ) data_ix,
                            (NET_BUF_SIZE  *)&data_ix_offset,
                            (NET_BUF_FLAGS  ) NET_BUF_FLAG_NONE,
                            (NET_ERR       *)&err);
    if ( err != NET_BUF_ERR_NONE) {
       *p_err  = NET_TCP_ERR_NONE_AVAIL;
        return;
    }

    data_ix += data_ix_offset;

    if (tx_probe_data_octet == DEF_YES) {                       /* If tx probe data req'd,          ...                 */
        probe_data[0] = NET_TCP_TX_PROBE_DATA;                  /* ... prepare data (see Note #2b2) ...                 */
        NetBuf_DataWr((NET_BUF    *) pseg_probe,                /* ... & wr    data into TCP tx buf.                    */
                      (NET_BUF_SIZE) data_ix,
                      (NET_BUF_SIZE) data_len,
                      (CPU_INT08U *)&probe_data[0],
                      (NET_ERR    *)&err);
        if ( err != NET_BUF_ERR_NONE) {                         /* See Note #4a.                                        */
            NetBuf_Free(pseg_probe);
           *p_err  = NET_TCP_ERR_CONN_FAIL;
            return;
        }
    }

                                                                /* ----------------- PREPARE TCP HDR ------------------ */
                                                                /* Prepare seg addrs.                                   */
    pseg_probe_hdr = &pseg_probe->Hdr;

    if (p_net_conn->Family == NET_SOCK_PROTOCOL_FAMILY_IP_V6) {
        DEF_BIT_SET(pseg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
    }

    if (DEF_BIT_IS_CLR(pseg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        NetTCP_TxConnPrepareSegAddrs((NET_TCP_CONN *) p_conn,
                                     (CPU_INT08U   *)&src_addrv4,
                                     (CPU_INT08U   *)&src_port,
                                     (CPU_INT16U    ) sizeof(src_addrv4),
                                     (CPU_INT16U    ) sizeof(src_port),
                                     (CPU_INT08U   *)&dest_addrv4,
                                     (CPU_INT08U   *)&dest_port,
                                     (CPU_INT16U    ) sizeof(dest_addrv4),
                                     (CPU_INT16U    ) sizeof(dest_port),
                                     (NET_ERR      *)&err);
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        NetTCP_TxConnPrepareSegAddrs((NET_TCP_CONN *) p_conn,
                                     (CPU_INT08U   *)&src_addrv6,
                                     (CPU_INT08U   *)&src_port,
                                     (CPU_INT16U    ) sizeof(src_addrv6),
                                     (CPU_INT16U    ) sizeof(src_port),
                                     (CPU_INT08U   *)&dest_addrv6,
                                     (CPU_INT08U   *)&dest_port,
                                     (CPU_INT16U    ) sizeof(dest_addrv6),
                                     (CPU_INT16U    ) sizeof(dest_port),
                                     (NET_ERR      *)&err);
#endif
    }

    if ( err != NET_TCP_ERR_NONE) {                             /* See Note #4a.                                        */
        NetBuf_Free(pseg_probe);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }


                                                                /* Prepare TCP seq nbrs.                                */
    seq_nbr   = p_conn->TxSeqNbrUnAckd;
    ack_nbr   = p_conn->RxSeqNbrNext;                           /* Cfg ACK w/ next    rx seq nbr (see Note #2b1B).      */

                                                                /* Prepare TCP tx flags (see Note #1b2C).               */
    flags_tcp = NET_TCP_FLAG_NONE  |
                NET_TCP_FLAG_TX_ACK;

                                                                /* Prepare TCP win size.                                */
    win_size  = p_conn->RxWinSizeActual;

                                                                /* Prepare IP params.                                   */
    if (DEF_BIT_IS_CLR(pseg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL, &err);
        if ( err != NET_CONN_ERR_NONE) {
            NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                             (NET_BUF_HDR      *)0,
                             (CPU_BOOLEAN       )DEF_YES,
                             (NET_TCP_CLOSE_CODE)close_code);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6, &err);
        if ( err != NET_CONN_ERR_NONE) {
            NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                             (NET_BUF_HDR      *)0,
                             (CPU_BOOLEAN       )DEF_YES,
                             (NET_TCP_CLOSE_CODE)close_code);
           *p_err  = NET_TCP_ERR_CONN_FAULT;
            return;
        }
#endif
    }


                                                                /* Init buf ctrls.                                      */
    pseg_probe_hdr                           = &pseg_probe->Hdr;
    pseg_probe_hdr->DataIx                   = (CPU_INT16U  )data_ix;
    pseg_probe_hdr->DataLen                  = (NET_BUF_SIZE)data_len;
    pseg_probe_hdr->TotLen                   = (NET_BUF_SIZE)pseg_probe_hdr->DataLen;

    pseg_probe_hdr->TCP_SegSync              = (CPU_BOOLEAN  )DEF_NO;
    pseg_probe_hdr->TCP_SegClose             = (CPU_BOOLEAN  )DEF_NO;
    pseg_probe_hdr->TCP_SegAck               = (CPU_BOOLEAN  )DEF_YES;
    pseg_probe_hdr->TCP_SegReset             = (CPU_BOOLEAN  )DEF_NO;

    pseg_probe_hdr->TCP_Flags                = (NET_TCP_FLAGS)flags_tcp;



                                                                /* -------------- TX TCP CONN PROBE SEG --------------- */
    if (DEF_BIT_IS_CLR(pseg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
       pseg_probe_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V4;
       pseg_probe_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V4;

       NetTCP_TxPktHandlerIPv4((NET_BUF        *) pseg_probe,
                               (NET_IPv4_ADDR   ) src_addrv4,
                               (NET_TCP_PORT_NBR) src_port,
                               (NET_IPv4_ADDR   ) dest_addrv4,
                               (NET_TCP_PORT_NBR) dest_port,
                               (NET_TCP_SEQ_NBR ) seq_nbr,
                               (NET_TCP_SEQ_NBR ) ack_nbr,
                               (NET_TCP_WIN_SIZE) win_size,
                               (NET_IPv4_TOS    ) TOS,
                               (NET_IPv4_TTL    ) TTL,
                               (NET_TCP_FLAGS   ) flags_tcp,
                               (NET_IPv4_FLAGS  ) flags_ipv4,
                               (void           *) 0,
                               (void           *) 0,            /* See Note #5.                                         */
                               (NET_ERR        *)&err);         /* Ignore transitory tx err(s).                         */
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
        pseg_probe_hdr->ProtocolHdrType          =  NET_PROTOCOL_TYPE_TCP_V6;
        pseg_probe_hdr->ProtocolHdrTypeTransport =  NET_PROTOCOL_TYPE_TCP_V6;

        NetTCP_TxPktHandlerIPv6((NET_BUF              *) pseg_probe,
                                (NET_IPv6_ADDR        *)&src_addrv6,
                                (NET_TCP_PORT_NBR      ) src_port,
                                (NET_IPv6_ADDR        *)&dest_addrv6,
                                (NET_TCP_PORT_NBR      ) dest_port,
                                (NET_TCP_SEQ_NBR       ) seq_nbr,
                                (NET_TCP_SEQ_NBR       ) ack_nbr,
                                (NET_TCP_WIN_SIZE      ) win_size,
                                (NET_IPv6_TRAFFIC_CLASS) NET_IPv6_TRAFFIC_CLASS_DFLT,
                                (NET_IPv6_FLOW_LABEL   ) NET_IPv6_FLOW_LABEL_DFLT,
                                (NET_IPv6_HOP_LIM      ) NET_IPv6_HOP_LIM_DFLT,
                                (NET_TCP_FLAGS         ) flags_tcp,
                                (void                 *) 0,
                                (NET_ERR              *)&err);  /* Ignore transitory tx err(s).                         */
#endif
    }

#if 0                                                           /* Tx buf freed by lower layer(s) [see Note #3b2].      */
    NetTCP_TxPktFree(pseg_probe);
#endif
    NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnProbeCtr);



   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                      NetTCP_TxConnKeepAlive()
*
* Description : (1) Prepare & transmit a TCP connection keep-alive :
*
*                   (a) Validate transmit keep-alive threshold                      See Note #2c3
*                   (b) Prepare  TCP keep-alive probe :
*                       (1) Garbage dummy data                                      See Note #2d2
*                   (c) Transmit TCP keep-alive probe
*
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_ConnIdleTimeout().
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection keep-alive successfully
*                                                                       transmitted.
*                               NET_TCP_ERR_TX_KEEP_ALIVE_TH        TCP connection closed due to no response
*                                                                       following transmission of configured
*                                                                       number of TCP keep-alive probes.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnIdleTimeout().
*
* Note(s)     : (2) RFC #1122, Section 4.2.3.6 states that "TCP implementations ... MAY include 'keep-alives'
*                   ... although this practice is not universally accepted ... A 'keep-alive' mechanism
*                   periodically probes the other end of a connection when the connection is otherwise idle,
*                   even when there is no data to be sent".
*
*                   (a) RFC #1122, Section 4.2.3.6 states that "if keep-alives are included" :
*
*                       (1) "The application MUST be able to turn them on or off for each TCP connection,"
*                       (2) "and they MUST default to off."
*
*                   (b) (1) RFC #1122, Section 4.2.3.6 states that "keep-alive packets MUST only be sent when
*                           no data or acknowledgement packets have been received for the connection within an
*                           interval" :
*
*                           (A) "This interval MUST be configurable" ...
*                           (B) "and MUST default to no less than two hours."
*
*                       (2) (A) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2, Page 333
*                               states that :
*
*                               (1) "The keepalive ... 2-hour idle time value" ...
*                               (2) "can usually be changed, but ... is [typically] a system-wide value, so
*                                    changing it affects all" TCP connections.
*
*                           (B) However, NO RFC requires that the configurable keep-alive, idle timeout be a
*                               single, system-wide value.  Therefore, it seems reasonable to permit each TCP
*                               connection to maintain its    own configurable keep-alive, idle timeout value.
*
*                       See also 'NetTCP_ConnCfgIdleTimeoutHandler()  Note #1'.
*
*                   (c) (1) (A) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2, Pages 332-333
*                               states that "if there is no activity on a given connection for 2 hours" (see
*                               Note #2b), TCP "sends a probe segment to the" remote host :
*
*                               (1) (a) If "the [remote] host is still up and running and reachable ... [and]
*                                       responds normally ... [then TCP] knows that the other end is still up" :
*                                   (b) (1) "TCP will reset the keepalive timer for 2 hours" ...
*                                       (2) "If there is application traffic across the connection before the
*                                            next 2-hour timer expires, the timer is reset for 2 hours in the
*                                            future, following the exchange of data."
*
*                               (2) (a) If "the [remote] host has crashed [or] is ... unreachable ... [and]
*                                       not responding" ...
*                                   (b) (1) Then "the [TCP] sends a total of 10 ... probes," ...
*                                       (2) "75 seconds apart,"                              ...
*                                   (c) (1) "and if it doesn't receive a response, [then TCP] considers the
*                                           [remote] host as down"          ...
*                                       (2) "and terminates the connection" ...
*                                       (3) The "error ... returned to the ... application by ... TCP ... is
*                                           ... 'connection timed out'".
*
*                               (3) (a) If "the [remote] host has crashed and rebooted"     ...
*                                   (b) (1) Then its "response will be a reset,"            ...
*                                       (2) "causing the [TCP] to terminate the connection" ...
*                                       (3) The "error ... returned to the ... application by ... TCP ... is
*                                           ... 'connection reset by peer'".
*
*                           (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                               'Connection Establishment and Keepalive Timers', Page 828 also states that :
*
*                               (1) (a) "When a segment is received on a connection," ...
*                                   (b)  TCP "resets the keepalive timer for that connection to 2 hours".
*                               (a) (a) (1) "If the keepalive timer expires (2 hours after the last segment
*                                            was received on the connection)," ...
*                                       (2) "and if the socket option is set," ...
*                                   (b) "a keepalive probe is sent to the other end."
*
*                           (C) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                               'Connection Establishment and Keepalive Timers : Keepalive timer expires
*                               after 2 hours of idle time', Page 829 adds that :
*
*                               (1) "Probes are sent only if the connection is in the" ...
*                                   (a) "ESTABLISHED or" ...
*                                   (b) "CLOSE_WAIT states."
*                               (2) "Keepalive probes are not sent ... once the process calls close()
*                                    ... even if the connection is idle for 2 hours."
*
*                       (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                           'Connection Establishment and Keepalive Timers : Drop connection when no
*                           response', Page 830 states that :
*
*                           (A) (1) "If the total idle time for the connection is greater than or equal
*                                    to 2 hours" ...
*                               (2) (a) "plus ... [the] limit of nine keepalive probes," ...
*                                   (b) "75 seconds apart,"                              ...
*                           (B) (1) "with no response" ...
*                               (2)  then the TCP "connection is dropped".
*
*                       (3) (A) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                               'Connection Establishment and Keepalive Timers : Send a keepalive probe',
*                               Page 830 states that "after 2 hours of idle time ... [a TCP] connection ...
*                               sends ... nine keepalive probes".
*
*                               See also Note #2c2A2a.
*
*                           (B) However, this contradicts the TCP keep-alive example in Figure 23.1 of
*                               Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other
*                               End Crashes', Pages 334-335 which shows "that the [remote host] ... send[s]
*                               10 keepalive probes ... before declaring the connection dead".
*
*                               See also Note #2c1A2b1.
*
*                   (d) RFC #1122, Section 4.2.3.6 states that "to confirm that an idle connection is still
*                       active ... send a probe segment ... to elicit a response from the peer TCP" :
*
*                       (1) (A) "Such a segment generally contains SEG.SEQ = SND.NXT-1" ...
*
*                               (1) "Note that on a quiet connection SND.NXT = RCV.NXT, so that this SEG.SEQ
*                                    will be outside the window.  Therefore, the probe causes the receiver
*                                    to return an acknowledgment segment, confirming that the connection is
*                                    still live.  If the peer has dropped the connection ... it will respond
*                                    with a RST instead of an acknowledgment segment."
*
*                               (2) However, this contradicts Wright/Stevens, TCP/IP Illustrated, Volume 2,
*                                   3rd Printing, Section 25.6 'Connection Establishment and Keepalive Timers :
*                                   Send a keepalive probe', Page 830 which states that "the sequence number
*                                   field of the keepalive packet ... contains [SND.UNA] minus 1, which is
*                                   the sequence number of a byte of data that the other end has already
*                                   acknowledged ... Since this sequence number is outside the window, the
*                                   other end must respond with an ACK, specifying the next sequence number
*                                   it expects".
*
*                           (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                               'Connection Establishment and Keepalive Timers : Send a keepalive probe',
*                               Page 830 states that "the acknowledgment field of the keepalive packet ...
*                               contains [RCV.NXT], the next sequence number expected on the connection".
*
*                           See also 'NetTCP_TxConnProbe()  Note #2b1'.
*
*                       (2) "and may or may not contain one garbage octet of data."
*
*                           (A) "An implementation SHOULD send a keep-alive segment with no data".
*
*                               (1) (a) "Unfortunately, some misbehaved TCP implementations fail to respond to
*                                        a segment with SEG.SEQ = SND.NXT-1 unless the segment contains data."
*
*                                   (b) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other
*                                       End Crashes', Page 335 reiterates that "some older implementations based
*                                       on 4.2BSD donot respond to these keepalive probes unless the segment
*                                       contains data".
*
*                               (2) (a) Therefore, RFC #1122, Section 4.2.3.6 states that a TCP "implementation ...
*                                       MAY be configurable to send a keep-alive segment containing one garbage
*                                       octet, for compatibility with erroneous TCP implementations".
*
*                                   (b) (1) (A) "Alternatively, an implementation could determine whether a peer
*                                                responded correctly to keep-alive packets with no garbage data
*                                                octet."
*
*                                           (B) Or as Stevens, TCP/IP Illustrated, Volume 1, 8th Printing,
*                                               Section 23.3 'Other End Crashes', Page 335 states, some
*                                               "systems send" :
*
*                                               (1) "The 4.3BSD-style segment (no data) for the first half of
*                                                    the probe period," ...
*                                               (2) "and if no response is received, switch to the 4.2BSD-style
*                                                    segment for the last half."
*
*                                       (2) Therefore, it seems reasonable to implement the combined BSD 4.3/4.2
*                                           solution since it does NOT require any non-standard configuration
*                                           for the garbage data octet & SHOULD be backwards-compatible with
*                                           all other systems.
*
*                       (3) (A) RFC #1122, Section 4.2.3.6 states that "it is extremely important to remember
*                               that ACK segments that contain no data are not reliably transmitted by TCP.
*                               Consequently, if a keep-alive mechanism is implemented it MUST NOT interpret
*                               failure to respond to any specific probe as a dead connection".
*
*                           (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                               'Connection Establishment and Keepalive Timers : Drop connection when no
*                               response', Page 830 reiterates that "one reason TCP must send multiple
*                               keepalive probes before considering the connection dead is that the
*                               ACKs sent in response do not contain data and therefore are not reliably
*                               transmitted by TCP.  An ACK that is a response to a keepalive probe can
*                               get lost".
*
*                           See also 'NetTCP_TxConnProbe()  Note #3a'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnKeepAlive (NET_TCP_CONN        *p_conn,
                                      NET_TCP_CLOSE_CODE   close_code,
                                      NET_ERR             *p_err)
{
    CPU_BOOLEAN          tx_probe_data_octet;
    NET_PKT_CTR          tx_probe_data_th;
    NET_TCP_TIMEOUT_SEC  timeout_sec;
    NET_TMR_TICK         timeout_tick;
    NET_ERR              err;


                                                                /* -------------- VALIDATE TX KEEP-ALIVE -------------- */
    p_conn->TxKeepAliveCtr++;
    if (p_conn->TxKeepAliveCtr > p_conn->TxKeepAliveTh) {       /* If nbr keep-alives tx'd > th, ...                    */
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,            /* ... close TCP conn (see Note #2c2B2).                */
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err = NET_TCP_ERR_TX_KEEP_ALIVE_TH;
        return;
    }


                                                                /* ----------- SET TCP CONN KEEP-ALIVE TMR ------------ */
    timeout_sec  =  p_conn->TxKeepAliveRetryTimeout_sec;        /* Set keep-alive tmr (see Notes #2c1A2b2 & #2c2A2b).   */
    timeout_tick = (NET_TMR_TICK)timeout_sec * NET_TMR_TIME_TICK_PER_SEC;

    if (p_conn->TimeoutTmr != DEF_NULL) {
        NetTmr_Set((NET_TMR    *) p_conn->TimeoutTmr,
                   (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
    }

    if ( err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    p_conn->TxSeqNbrUnAckd -= 1;                                /* Decrement the sequence number.                       */

                                                                /* ------------------ TX KEEP-ALIVE ------------------- */
    tx_probe_data_th    = (p_conn->TxKeepAliveTh + 1u) / 2u;    /* Cfg garbage octet (see Note #2d2A2b2).               */
    tx_probe_data_octet = (p_conn->TxKeepAliveCtr <= tx_probe_data_th) ? DEF_NO : DEF_YES;
    NetTCP_TxConnProbe(p_conn, tx_probe_data_octet, close_code, &err);
   (void)&err;                                                  /* Ignore transitory tx err(s).                         */


    NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnKAliveCtr);


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnKeepAliveReset()
*
* Description : Reset TCP connection's transmit keep-alive controls.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandlerSeg().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerSeg().
*
* Note(s)     : none.
*
* Note(s)     : (1) A TCP connection's transmit keep-alive controls SHOULD be reset whenever any valid
*                   segment(s) are received :
*
*                   (a) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2,
*                           Pages 332-333 states that after TCP "sends ... probe segment[s] to the"
*                           remote host :
*
*                           (A) If "the [remote] host ... responds normally ... [then TCP] knows
*                               that the other end is still up" :
*                           (B) (1) "TCP will reset the keepalive timer" ...
*                               (2) "If there is application traffic across the connection before
*                                    the next 2-hour timer expires, the timer is reset ... following
*                                    the exchange of data."
*
*                       (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                           'Connection Establishment and Keepalive Timers', Page 828 reiterates that :
*
*                           (A) "When a segment is received on a connection," ...
*                           (B)  TCP "resets the keepalive timer for that connection".
*
*                   (b) (1) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                           'Connection Establishment and Keepalive Timers : Keepalive timer expires
*                           after 2 hours of idle time', Page 829 states that TCP "keepalive probes
*                           ... are sent only if the connection is in the" :
*
*                           (A) "ESTABLISHED or" ...
*                           (B) "CLOSE_WAIT states."
*
*                       (2) However, it seems reasonable to permit any TCP connected states to reset
*                           a TCP connection's transmit keep-alive controls.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnKeepAliveReset (NET_TCP_CONN  *p_conn)
{
    p_conn->TxKeepAliveCtr = 0u;
}


/*
*********************************************************************************************************
*                                         NetTCP_TxConnTxQ()
*
* Description : (1) Transmit TCP data segment(s) from TCP connection transmit queue :
*
*                   (a) Configure TCP connection transmit :
*
*                       (1) Configure TCP connection transmit acknowledgement request :     See Note #1d1
*
*                           (A) Do NOT transmit TCP data/acknowledgement if ...
*                               (1) NO TCP transmit data available or allowed to transmit
*                                      AND
*                               (2) NO transmit acknowledgement requested
*
*                           (B)        Transmit TCP      acknowledgement if ...
*                               (1) NO TCP transmit data available or allowed to transmit
*                                      BUT
*                               (2)    Transmit acknowledgement requested
*
*                       (2) Configure TCP connection transmit free timer request            See Note #1d4
*
*                   (b) Transmit TCP connection transmit queue data :
*
*                       (1) Control TCP connection transmit versus transmit congestion controls :
*
*                               (a) See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2'
*                                          & 'NetTCP_TxConnWinSizeUpdateAvail()      Note #1'
*
*                           (A) Available Transmit Window                            See Note  #1b1a
*                           (B) Transmit Queue Segment                               See Notes #5         & #8
*                           (C) Nagle Algorithm                                      See Notes #6, #7b2B, & #8
*                           (D) Silly Window Syndrome                                See Notes     #7     & #8
*
*                       (2) Update TCP connection transmit queue :
*                           (A) Remove TCP transmit segment(s) from
*                                      TCP connection    transmit queue                     See Note #3
*                           (B) Append TCP transmit segment(s) to
*                                      TCP connection re-transmit queue                     See Note #4
*                           (C) Update TCP connection re-transmit queue timer
*
*                       (3) Update TCP connection :
*                           (A) Update TCP connection sequence number(s)
*                           (B) Update TCP connection transmit congestion window
*
*                       (4) Prepare  TCP data/acknowledgement segment(s) :
*                           (A) TCP segment  addresses
*                           (B) TCP segment  sequence numbers
*                           (C) TCP segment  transmit flags :
*                               (1) ACK
*                           (D) TCP segment  window size
*                           (E) IP  datagram parameters
*                           (F) TCP segment  packet buffer controls
*
*                       (5) Transmit TCP data/acknowledgement segment(s)
*
*                   (c) Suspend TCP transmit :                                              See Note #10
*
*                       (1) Handle any network receive packet(s)                            See Note #10b2A
*
*                   (d) Complete TCP connection transmit :
*
*                       (1) Transmit TCP connection acknowledgement                         See Note #1a1
*                       (2) Clear    TCP connection transmit idle timer
*                               (see 'NetTCP_TxConnTxQ_TimeoutIdleClr()  Note #2b2')
*                       (3) Reset    TCP connection delayed  acknowledgement controls
*                       (4) Free     TCP connection transmit queue persist timer            See Note #1a2
*
*
*               (2) NetTCP_TxConnTxQ() transmits TCP connection data & acknowledgements.  TCP acknowledgements
*                   transmitted independently of TCP controls &/or data MAY be transmitted with NetTCP_TxConnAck().
*
*                   See also 'NetTCP_TxConnAck()  Note #2'.
*
* Argument(s) : p_conn          Pointer to a TCP connection.
*               -----           Argument validated in various.
*
*               p_buf_hdr       Pointer to network buffer header that received TCP packet.
*
*               tx_ack_code     Indicate whether & how to transmit a TCP acknowledgement segment :
*
*                                   NET_TCP_CONN_TX_ACK_NONE            Do NOT transmit a TCP acknowledgement
*                                                                          segment          if TCP transmit data
*                                                                          NOT available.
*                                   NET_TCP_CONN_TX_ACK                 Transmit a TCP acknowledgement segment
*                                                                          even if TCP transmit data NOT available.
*                                   NET_TCP_CONN_TX_ACK_IMMED           Transmit a TCP acknowledgement segment
*                                                                          immediately even if TCP transmit data
*                                                                          NOT available.
*
*               tx_q_timeout    Indicate whether the TCP connection transmit queue timed out :
*
*                                   DEF_NO                              TCP connection transmit queue did
*                                                                           NOT time  out.
*                                   DEF_YES                             TCP connection transmit queue
*                                                                               timed out.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection transmit queue successfully
*                                                                       handled.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_CLOSE              TCP connection closed.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   ------- RETURNED BY NetTCP_TxConnAck() : -------
*                               NET_TCP_ERR_CONN_ACK_NONE           TCP connection acknowledgement NOT requested.
*                               NET_TCP_ERR_CONN_ACK_DLYD           TCP connection acknowledgement transmit delayed.
*                               NET_TCP_ERR_CONN_ACK_PREVLY_TXD     TCP connection acknowledgement previously
*                                                                       transmitted for segment.
*                               NET_TCP_ERR_CONN_ACK_INVALID        TCP connection acknowledgement NOT valid for
*                                                                       current TCP connection state.
*                               NET_TCP_ERR_NONE_AVAIL              Resources NOT available.
*                               NET_TCP_ERR_INVALID_LEN_SEG         Invalid TCP sequence-segment length.
*                               NET_CONN_ERR_INVALID_FAMILY         Invalid     connection family.
*                               NET_CONN_ERR_INVALID_ADDR           Invalid TCP connection address.
*                               NET_CONN_ERR_INVALID_ADDR_LEN       Invalid TCP connection address length.
*
*                                                                   ----- RETURNED BY NetTCP_TxPktHandler() : ------
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error (see Note #14a).
*                               NET_ERR_TX                              Transmit        error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN                Network  interface link state down (i.e.
*                                                                       NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : various.
*
* Note(s)     : (3) See 'NetTCP_TxConnAppData()  Note #3' for TCP connection Transmit Queue diagram.
*
*               (4) TCP segments that have been transmitted but NOT yet acknowledged are sequenced into
*                   the TCP connection's re-transmit queue to await acknowledgement or retransmission.
*
*                   (a) Transmitted TCP segments are inserted into a doubly-linked Re-Transmit Queue,
*                       ordered consecutively by sequence number(s) [see also Note #4b].
*
*                       In the diagram below, ... :
*
*                       (1) (A) TCP connections' 'ReTxQ_Head' points to the head of a TCP connections'
*                                   Re-Transmit Queue;
*                           (B) TCP connections' 'ReTxQ_Tail' points to the tail of a TCP connections'
*                                   Re-Transmit Queue.
*
*                       (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr'  doubly-link each
*                           segment to form the Re-Transmit Queue.
*
*                   (b) (1) Transmit segments are transmitted & await acknowledgement in sequence-order.
*                           Therefore, newly-transmitted segments are sequenced after previously
*                           transmitted segments starting at the tail of the Re-Transmit Queue.
*
*                       (2) Segments at the head of the Re-Transmit Queue are awaiting acknowledgement
*                           & removal from the Re-Transmit Queue; & are ready to be re-transmitted until
*                           acknowledged & removed from the queue.
*
*
*                                      |                                               |
*                                      |<----- TCP Connection Re-Transmit Queue ------>|
*                                      |                (see Note #4)                  |
*
*                                 Segments Awaiting
*                                 Acknowledgement or                        Segments Sequenced
*                                    Re-Transmit                          into Re-Transmit Queue
*                                   start at head                           starting at tail
*                                  (see Note #4b2)                            (see Note #4b1)
*
*                                         |             NextPrimListPtr             |
*                                         |             (see Note #4a2)             |
*                                         v                    |                    v
*                                                              |
*                      Head of         -------       -------   v   -------       -------    (see Note #4a1B)
*                    Re-Transmit  ---->|     |------>|     |------>|     |------>|     |
*                       Queue          |     |       |     |       |     |       |     |         Tail of
*                                      |     |<------|     |<------|     |<------|     |<----  Re-Transmit
*                (see Note #4a1A)      |     |       |     |   ^   |     |       |     |          Queue
*                                      |     |       |     |   |   |     |       |     |
*                                      -------       -------   |   -------       -------
*                                                              |
*                                                       PrevPrimListPtr
*                                                       (see Note #4a2)
*
*
*               (5) In order to simply TCP transmit buffer management, TCP transmit does NOT transmit
*                   partial network-buffer segments (i.e. portions of  TCP segments in the same network
*                   buffer).  This avoids the complexity of queuing & handling partially transmitted
*                   segments on both the TCP transmit & re-transmit queues.
*
*                   (a) However, in order to avoid transmit window deadlock with a remote host's receive
*                       window, the TCP connection's connection maximum segment size MUST be configured
*                       to ensure that full, maximum-segment-sized segments will transmit even for receive
*                       windows less than the default maximum segment size.
*
*                       See also 'NetTCP_ConnCfgMaxSegSize()  Note #2'.
*
*               (6) (a) (1) RFC #896, Section 'The small-packet problem' states that "there is a special
*                           problem associated with small packets ... the congestion ... can result in
*                           lost datagrams and retransmissions, as well as excessive propagation time ...
*                           In practice, throughput may drop so low that TCP connections are aborted".
*
*                       (2) RFC #896, Section 'The solution to the small-packet problem' states that "the
*                           solution to the small-packet problem ... is" :
*
*                           (A) "to inhibit the sending of new TCP segments when new outgoing data arrives
*                                from the user" ...
*
*                           (B) "if any previously transmitted data on the connection remains unacknowledged."
*
*                           (C) "This inhibition is to be unconditional;" :
*                               (1) "no timers,"                       ...
*                               (2) "tests for size of data received," ...
*                               (3) "or other conditions are required."
*
*                   (b) (1) RFC #1122, Section 4.2.3.4 states that "the Nagle algorithm is ... as follows" :
*
*                           (A) "If there is unacknowledged data (i.e., SND.NXT > SND.UNA)," ...
*                           (B) "then the sending TCP buffers all user data" ...
*                               (1) "(regardless of the PSH bit)," ...
*                               (2) "until" :
*                                   (a) "the outstanding data has been acknowledged" ...
*                                   (b) "or until the TCP can send a full-sized segment."
*
*                       (2) (A) (1) "A TCP SHOULD implement the Nagle Algorithm ... to coalesce short segments."
*
*                               (2) "However, there MUST be a way for an application to disable the Nagle
*                                    algorithm on an individual connection."
*
*                           (B) Thus it is assumed from these two requirements that the Nagle algorithm
*                               should be enabled by default.
*
*                       See also Note #7b2Ba2A.
*
*               (7) (a) RFC #813, Section 2 states that "a bad implementation of the window algorithm can
*                       lead to extremely poor performance ... This particular phenomenon ... has been
*                       given the name of Silly Window Syndrome, or SWS".
*
*                       Section 3 elaborates that "SWS is a degeneration in the throughput which develops
*                       ... whenever the acknowledgement of a small segment ... cause[s] another segment
*                       of the same small size to be sent, until ... the network ... becomes clogged with
*                       many small segments, and an equal number of acknowledgements".
*
*                   (b) (1) RFC #813, Section 4 states that "there is an algorithm that the sender can use
*                           ... [which] compares the useable window to the offered window, and refrains from
*                           anything if the ratio of useable to offered is less than a certain fraction ...
*                           Until the useable window reaches a certain amount, the sender should simply refuse
*                           to send anything".
*
*                       (2) (A) RFC #1122, Section 4.2.3.4 reiterates that "a TCP MUST include a SWS avoidance
*                               algorithm in the sender".  However, "the SWS avoidance algorithm ... specified"
*                               in RFC #1122 "is to be used instead of the sender-side algorithm contained in
*                               [RFC #813]".
*
*                           (B) (a) RFC #1122, Section 4.2.3.4 states that "the sender's SWS avoidance algorithm
*                                   is ... [to] send data" :
*
*                                   (1) "If a maximum-sized segment can be sent, i.e, [sic] if" :
*
*                                       (A) "min(D,U) >= Eff.snd.MSS"
*                                           (1) (a) This threshold subtly assumes that the amount of data queued
*                                                   on the TCP connection's transmit queue is queued in maximum-
*                                                   sized segments.
*                                               (b) Although this assumption is typically satisfied since all
*                                                   new TCP transmit data is usually aggregated & appended into
*                                                   the TCP connection's transmit queue in maximum-sized segments
*                                                   (see 'NetTCP_TxConnAppData()  Note #6b1'); to ensure that the
*                                                   maximum-sized-segment threshold is satisfied the transmit
*                                                   segment's length is also checked.
*
*                                   (2) "Or if the data is pushed and all queued data can be sent now, i.e., if" :
*
*                                       (A) "[SND.NXT = SND.UNA and]" ...
*                                           (1) "(the bracketed condition is imposed by the Nagle algorithm)"
*                                                (a) This condition is required ONLY if the Nagle algorithm
*                                                    is enabled (see Note #6b2B).
*
*                                       (B) "PUSHED and"             ...
*                                           (1) See also 'NetTCP_TxConnAppData()  Note #6b3B1b'.
*
*                                       (C) "D <= U"
*                                           (1) (a) This threshold subtly assumes that the amount of data queued
*                                                   on the TCP connection's transmit queue is queued in maximum-
*                                                   sized segments.
*                                               (b) To ensure that the next actual transmit segment is compared
*                                                   to the available transmit window, the following threshold is
*                                                   actually checked :
*
*                                                   (1) min(D, SEG.LEN) <= U
*
*                                               See also Note #7b2Ba1A1.
*
*                                   (3) "Or if at least a fraction Fs of the maximum window can be sent, i.e., if" :
*
*                                       (A) "[SND.NXT = SND.UNA and]" ...
*                                           (1) This condition is required ONLY if the Nagle algorithm is enabled
*                                               (see Note #6b2B).
*
*                                       (B) "min(D,U) >= Fs * Max(SND.WND)"
*
*                                   (4) "or if" :
*
*                                       (A) "data is PUSHed and" ...
*                                           (1) Although it is not directly stated, it is inferred that if
*                                               the segment(s)' data is NOT pushed, the segment transmit
*                                               SHOULD be postponed until the previous transmit silly
*                                               window syndrome avoidance conditions have been satisfied
*                                               (see Notes #7b2Ba1, #7b2Ba2, & #7b2Ba3).
*
*                                           (2) See also 'NetTCP_TxConnAppData()  Note #6b3B1b'.
*
*                                       (B) "the override timeout occurs."
*                                           (1) Although it is not directly stated, it is inferred that the
*                                               transmit silly window override timer should be set when :
*
*                                               (a) The previous transmit silly window syndrome avoidance
*                                                   conditions have NOT been satisfied (see Notes #7b2Ba1,
*                                                   #7b2Ba2, & #7b2Ba3) ...
*                                               (b) BUT                                ...
*                                                   (1) the TCP segment data is pushed ...
*                                                   (2) & no current timeout exists.
*
*                                           (2) However, if NO network timer is available to delay the TCP
*                                               data segment(s), the TCP data segment(s) SHOULD be immediately
*                                               transmitted.
*
*                                           See also Note #7b2Bb.
*
*
*                                   where
*                                       (A) D               Amount of data queued in the sending TCP but not
*                                                               yet sent
*
*                                       (B) U              'Useable window' ... i.e., the offered window less
*                                                               the amount of data sent but not acknowledged :
*
*                                                           (1) U = SND.UNA + SND.WND - SND.NXT
*
*                                                           (2) The 'useable window' is also constrained by the
*                                                               available window & other TCP congestion controls
*                                                               (see 'NetTCP_TxConnWinSizeUpdateAvail()  Note #1').
*
*                                       (C) Eff.snd.MSS     Effective send MSS for the connection
*                                       (D) SND.NXT         Next sequence number to transmit
*                                       (E) SND.UNA         Oldest unacknowledged sequence number
*                                       (F) Max(SND.WND)    Maximum send window ... seen ... on the connection
*                                       (G) Fs              Fraction whose recommended value is 1/2
*
*
*                               (b) (1) Although RFC #813, Section 4 stated "that it is not necessary to set
*                                       a timer to protect against protocol lockup when postponing the send
*                                       operation"; RFC #1122, Section 4.2.3.4 amends that "to avoid a ...
*                                       deadlock, it is necessary to have a timeout to force transmission of
*                                       data, overriding the SWS avoidance algorithm".
*
*                                   (2) "The override timeout should be in the range 0.1 - 1.0 seconds."
*
*                                   (3) "In practice, this timeout should seldom occur."
*
*               (8) (a) Although it is not directly stated, it is inferred that the limitations of
*                       the Nagle & transmit silly window syndrome avoidance algorithms apply only
*                       to discrete, individually-queued data segments & NOT to any stream of data
*                       segments.
*
*                       Therefore, a data segment -- especially the last queued data segment in the
*                       TCP connection's transmit queue -- should NOT be constrained by the Nagle &
*                       transmit silly window syndrome avoidance algorithms if this last queued data
*                       segment is immediately transmitted after the transmission of the preceding
*                       queued data segments.
*
*                       See also 'NetTCP_TxConnAppData()  Notes #6b1 & #6b3B2'.
*
*                   (b) Also, although NO RFC specifies the Nagle algorithm's or the transmit silly
*                       window syndrome avoidance algorithm's compliance, effect, or limitation on
*                       TCP connection closes; it does NOT seem reasonable for the Nagle algorithm
*                       or the transmit silly window syndrome avoidance algorithm to inhibit or
*                       delay the transmission of a TCP connection close segment.
*
*               (9) The following TCP transmit parameters are configured once PRIOR to transmitting
*                   any TCP segment(s) :
*
*                   (a) IP transmit parameters :
*                       (1) TOS
*                       (2) TTL
*                       (3) Flags
*
*              (10) Increment network buffer's reference counter to include the TCP segment now enqueued
*                   to the TCP connection's re-transmit queue as a new reference to the network buffer.
*
*              (11) (a) IP  transmit options currently NOT implemented     See 'net_tcp.c  Note #1d'
*                   (b) TCP transmit options currently NOT implemented     See 'net_tcp.c  Note #1c'
*
*              (12) To balance network receive versus transmit packet loads for certain network connection
*                   types (e.g. stream-type connections), network receive & transmit packets SHOULD be
*                   handled in an APPROXIMATELY balanced ratio.
*
*                   (a) Network task priorities & lock mechanisms partially maintain a balanced ratio
*                       between network receive versus transmit packet handling.
*
*                       However, the handling of network receive & transmit packets :
*
*                       (1) SHOULD be interleaved so that for every few packet(s) received & handled,
*                           several packet(s) should be transmitted; & vice versa.
*
*                       (2) SHOULD NOT exclusively handle receive nor transmit packets, even for a
*                           short period of time, but especially for a prolonged period of time.
*
*                   (b) To implement network receive versus transmit load balancing :
*
*                       (2) Certain network connections MUST periodically suspend network transmit(s)
*                           to handle network interface(s)' receive packet(s) :
*
*                           (A) Suspend network connection transmit(s) if any receive packets are
*                               available on a network interface.
*
*                               (1) To approximate a balanced ratio of network receive versus transmit
*                                   packets handled; the number of consecutive times that a network
*                                   connection transmit suspends itself to check for & handle any
*                                   network receive packet(s) SHOULD APPROXIMATELY correspond to the
*                                   number of queued receive packet(s) available.
*
*                               (2) To protect TCP connections from transmit corruption while suspended,
*                                   ALL TCP data transmits & TCP transmit queue handling MUST be blocked
*                                   for suspended connections until the connection is no longer suspended.
*
*                           (B) Signal or timeout network connection transmit suspend(s) to restart
*                               transmit(s).
*
*                   See also 'net_if.c  NetIF_RxPktIsAvail()  Notes #1 & #2'
*                          & 'net_if.c  NetIF_TxSuspend()     Notes #1 & #2'.
*
*              (13) On ANY error(s), network resources MUST be appropriately freed :
*
*                   (a) For all network resources that have been linked to the TCP connection, ALL
*                       network resources are freed by NetTCP_ConnClose().
*
*              (14) (a) Since segments enqueued to a TCP connection's transmit queue have already been
*                       reported as transmitted to the application & since no mechanism exists for a TCP
*                       connection to re-request previously transmitted data, any TCP connection whose
*                       transmit queue(s) becomes corrupted MUST be closed to force the application layer
*                       to abort &/or recover from the corrupted data.
*
*                   (b) For any internal errors where the TCP connection's transmit queue is NOT corrupted,
*                       the TCP connection is NOT closed.
*
*                   See also 'NetTCP_TxConnAppData()  Note #10'
*                          & 'NetTCP_TxConnReTxQ()    Note #11'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnTxQ (NET_TCP_CONN        *p_conn,
                                NET_BUF_HDR         *p_buf_hdr,
                                NET_TCP_ACK_CODE     tx_ack_code,
                                CPU_BOOLEAN          tx_q_timeout,
                                NET_TCP_CLOSE_CODE   close_code,
                                CPU_BOOLEAN          tx_suspend_en,
                                NET_ERR             *p_err)
{
    NET_BUF                 *pseg;
    NET_BUF                 *pseg_next;
    NET_BUF                 *p_buf_q_tail;
    NET_BUF_HDR             *pseg_hdr;
    NET_BUF_HDR             *pseg_next_hdr;
    NET_BUF_HDR             *p_buf_q_tail_hdr;
    NET_CONN_ID              conn_id;
    NET_CONN                *p_net_conn;
    NET_IF_NBR               if_nbr;
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR            src_addrv4  = NET_IPv4_ADDR_NONE;
    NET_IPv4_ADDR            dest_addrv4 = NET_IPv4_ADDR_NONE;
    NET_IPv4_TOS             TOS;
    NET_IPv4_TTL             TTL;
    NET_IPv4_FLAGS           flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR            src_addrv6;
    NET_IPv6_ADDR            dest_addrv6;
    NET_IPv6_TRAFFIC_CLASS   traffic_class;
    NET_IPv6_FLOW_LABEL      flow_label;
    NET_IPv6_HOP_LIM         hop_lim;
    NET_IPv6_FLAGS           flags_ipv6;
#endif
    NET_TCP_PORT_NBR         src_port;
    NET_TCP_PORT_NBR         dest_port;
    NET_TCP_SEQ_NBR          seq_nbr;
    NET_TCP_SEQ_NBR          ack_nbr;
    NET_TCP_WIN_SIZE         win_size;
    NET_TCP_WIN_SIZE         tx_data_qd;
    NET_TCP_WIN_SIZE         tx_data_min;
    NET_TCP_WIN_SIZE         tx_th_q_min;
    NET_TMR_TICK             timeout_tick;
    NET_TCP_FLAGS            flags_tcp;
    CPU_BOOLEAN              tx_ack;
    CPU_BOOLEAN              tx_seg;
    CPU_BOOLEAN              tx_seg_push;
    CPU_BOOLEAN              tx_seg_close;
    CPU_BOOLEAN              tx_segs_txd;
    CPU_BOOLEAN              tx_segs;
    CPU_BOOLEAN              tx_done;
    CPU_BOOLEAN              tx_nagle;
    CPU_BOOLEAN              tx_th_seg;
    CPU_BOOLEAN              tx_th_mss;
    CPU_BOOLEAN              tx_th_nagle;
    CPU_BOOLEAN              tx_th_silly_win;
    CPU_BOOLEAN              tx_tmr_free;
    CPU_BOOLEAN              net_rx_avail;
    NET_CTR                  net_rx_nbr;
    NET_CTR                  tx_seg_nbr;
    NET_ERR                  err;
    NET_ERR                  err_rtn;


                                                                /* -------------------- CFG TCP TX -------------------- */
    switch (tx_ack_code) {                                      /* Cfg tx ack req.                                      */
        case NET_TCP_CONN_TX_ACK_NONE:
        default:
             tx_ack = DEF_NO;
             break;


        case NET_TCP_CONN_TX_ACK:
        case NET_TCP_CONN_TX_ACK_IMMED:
             tx_ack = DEF_YES;
             break;
    }

                                                                /* Cfg tx tmr free req.                                 */
    tx_tmr_free = (p_conn->TxQ_Head == DEF_NULL) ? DEF_YES : DEF_NO;


    switch (p_conn->ConnState) {                                /* Cfg tx Q seg(s).                                     */
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CLOSED:
                      tx_segs = DEF_YES;
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                 default:
                     *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                      tx_segs = DEF_YES;
                      break;


                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_SUSPEND:               /* See Note #12b2A2.                                    */
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      tx_segs = DEF_NO;
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 default:
                     *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_NONE:
        case NET_TCP_CONN_STATE_CLOSED:
        default:
             NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }


    err_rtn = NET_TCP_ERR_NONE;



                                                                /* ------------ TX DATA FROM TCP CONN TX Q ------------ */
    conn_id = p_conn->ID_Conn;
    if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
    if ( err != NET_CONN_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    p_net_conn = &NetConn_Tbl[conn_id];
                                                                /* Prepare IP params (see Note #9a).                    */
    switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_SOCK_FAMILY_IP_V4:

             NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL, &err);
             if ( err != NET_CONN_ERR_NONE) {
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
                *p_err  = NET_TCP_ERR_CONN_FAULT;
                 return;
             }
             break;
#endif

#ifdef  NET_IPv6_MODULE_EN
        case NET_SOCK_FAMILY_IP_V6:

             NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6, &err);
             if ( err != NET_CONN_ERR_NONE) {
                 NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
                *p_err  = NET_TCP_ERR_CONN_FAULT;
                 return;
             }
             break;
#endif

        default:
             break;
    }

    pseg_next   =  p_conn->TxQ_Head;

    tx_done     = (tx_segs == DEF_YES) ? DEF_NO : DEF_YES;
    tx_segs_txd =  DEF_NO;
    tx_seg_nbr  =  0u;

    while (tx_done == DEF_NO) {                                 /* Tx ALL TCP conn tx Q seg(s) ...                      */
                                                                /* ... allowed by cong ctrls (see Note #1b1).           */
        tx_seg = DEF_NO;

        pseg   = pseg_next;
        if (pseg != DEF_NULL) {
            pseg_hdr  = &pseg->Hdr;
            pseg_next =  pseg_hdr->NextPrimListPtr;
                                                                /* ------------------- CTRL TCP TX -------------------- */
                                                                /* Validate tx win cong th's :                  ...     */
            if (p_conn->TxWinSizeAvail >= pseg_hdr->TCP_SegLenData) { /* ... chk avail tx win >= seg len (see Note #5), */
                tx_seg = DEF_YES;
                                                                /* ... chk prev'ly tx'd  seg(s) [see Note #8a]; ...     */
                                                                /* ... or TCP conn close seg    [see Note #8b]; ...     */
                tx_seg_close = DEF_BIT_IS_SET(pseg_hdr->TCP_Flags, NET_TCP_FLAG_TX_CLOSE);
                tx_th_seg    = ((tx_segs_txd  == DEF_YES) ||
                                (tx_seg_close == DEF_YES)) ? DEF_OK : DEF_FAIL;

                if (tx_th_seg != DEF_OK) {
                    NET_BUF_SIZE  buf_size;


                    buf_size = NetBuf_GetMaxSize(if_nbr, NET_TRANSACTION_TX, pseg, pseg_hdr->DataIx);
                    if (buf_size == pseg_hdr->DataLen) {        /* If the buffer is full then send it.                  */
                        tx_th_mss = DEF_YES;

                    } else {
                                                                /* ... chk MSS       th (see Note #7b2Ba1);     ...     */
                        tx_data_qd  = p_conn->TxSeqNbrNextQ - p_conn->TxSeqNbrNext;
                        tx_data_min = DEF_MIN(tx_data_qd,    pseg_hdr->TCP_SegLenData);
                        tx_th_q_min = DEF_MIN(tx_data_min,   p_conn->TxWinSizeAvail);

                        tx_th_mss   = (tx_th_q_min >= p_conn->MaxSegSizeConn) ? DEF_OK : DEF_FAIL;
                    }


                    if (tx_th_mss != DEF_OK) {
                                                                /* ... chk Nagle     th (see Note #7b2Ba2);     ...     */
                        tx_seg_push = DEF_BIT_IS_SET(pseg_hdr->TCP_Flags, NET_TCP_FLAG_TX_PUSH);
                        tx_nagle    = ((p_conn->TxWinSizeNagleEn == DEF_DISABLED         ) ||
                                       (p_conn->TxSeqNbrNext     == p_conn->TxSeqNbrUnAckd)) ? DEF_YES : DEF_NO;
                        tx_th_nagle = ((tx_nagle    == DEF_YES) &&
                                       (tx_seg_push == DEF_YES) &&
                                       (tx_data_min <= p_conn->TxWinSizeAvail)) ? DEF_OK : DEF_FAIL;

                        if (tx_th_nagle != DEF_OK) {
                                                                /* ... chk silly win th (see Note #7b2Ba3);     ...     */
                            tx_th_silly_win = ((tx_nagle    == DEF_YES) &&
                                               (tx_th_q_min >= p_conn->TxWinSizeMinTh)) ? DEF_OK : DEF_FAIL;

                            if (tx_th_silly_win != DEF_OK) {
                                                                /* ... chk push timeout (see Note #7b2Ba4).             */
                                if (tx_seg_push == DEF_YES) {   /* If data seg pushed   (see Note #7b2Ba4A),    ...     */
                                    if (tx_q_timeout == DEF_NO) { /* ... & no cur timeout (see Note #7b2Ba4B1b2), ...   */
                                                                /* ... & tx Q tmr NOT yet cfg'd,                ...     */
                                        if (p_conn->TxQ_SillyWinTmr == DEF_NULL) {
                                            timeout_tick            =  p_conn->TxWinSillyWinTimeout_tick;
                                            p_conn->TxQ_SillyWinTmr =  NetTmr_Get(        &NetTCP_TxConnTxQ_TimeoutSillyWin,
                                                                                  (void *) p_conn,
                                                                                           timeout_tick,
                                                                                          &err);
                                                                /* ... & tx Q tmr avail,                        ...     */
                                            if (err == NET_TMR_ERR_NONE) {
                                                tx_seg = DEF_NO;/* ... dly  tx seg (see Note #7b2Ba4B1);        ...     */
                                            }                   /* ... else tx seg (see Note #7b2Ba4B2).                */

                                        } else {                /* Else  tx Q tmr already cfg'd, ...                    */
                                            tx_seg = DEF_NO;    /* ... dly  tx seg (see Note #7b2Ba4B1).                */
                                        }
                                    }

                                } else {                        /* If data seg NOT pushed, ...                          */
                                    tx_seg = DEF_NO;            /* ... dly tx seg (see Note #7b2Ba4A1).                 */
                                }
                            }
                        }
                    }
                }
            }
        }


                                                                /* ------------------- TX TCP SEGS -------------------- */
        if (tx_seg == DEF_YES) {                                /* If avail & rdy, tx Q seg(s).                         */

                                                                /* UPDATE TCP CONN TX Q's                               */
                                                                /* Move seg from tx Q to re-tx Q :                      */

            if (pseg_next != DEF_NULL) {                        /* If tx Q next seg(s) avail, ...                       */
                                                                /* ... update TCP conn tx Q.                            */
                pseg_next_hdr                  = &pseg_next->Hdr;
                pseg_next_hdr->PrevPrimListPtr =  DEF_NULL;
                p_conn->TxQ_Head               =  pseg_next;

            } else {                                            /* Else clr tx Q.                                       */
                p_conn->TxQ_Head = DEF_NULL;
                p_conn->TxQ_Tail = DEF_NULL;

                tx_tmr_free     =  DEF_YES;
            }

            pseg_hdr->PrevPrimListPtr = p_conn->ReTxQ_Tail;
            pseg_hdr->NextPrimListPtr = DEF_NULL;

            if (p_conn->ReTxQ_Tail != DEF_NULL) {               /* If re-tx Q NOT empty, ...                            */
                                                                /* ... append seg(s) @ Q tail (see Note #4b1).          */
                p_buf_q_tail                      =  p_conn->ReTxQ_Tail;
                p_buf_q_tail_hdr                  = &p_buf_q_tail->Hdr;
                p_buf_q_tail_hdr->NextPrimListPtr =  pseg;

                p_conn->ReTxQ_Tail                =  pseg;

            } else {                                            /* Else add seg to empty re-tx Q.                       */
                p_conn->ReTxQ_Head                =  pseg;
                p_conn->ReTxQ_Tail                =  pseg;
            }


            if (p_conn->ReTxQ_Tmr == DEF_NULL) {                /* If unavail, get & update re-tx Q tmr.                */
                NetTCP_TxConnReTxQ_TimeoutSet(p_conn, DEF_NO, close_code, p_err);
                if (*p_err != NET_TCP_ERR_NONE) {
                     return;
                }
            }

                                                                /* ----------------- UPDATE TCP CONN ------------------ */
                                                                /* Update TCP conn tx seq nbr(s).                       */
            p_conn->TxSeqNbrNext += pseg_hdr->TCP_SegLen;

                                                                /* Update TCP conn tx win ctrls.                        */
            NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                                DEF_NULL,
                                                NET_TCP_CONN_RX_ACK_NONE,
                                                pseg_hdr->TCP_SegLenData,
                                                NET_TCP_CONN_TX_WIN_DEC,
                                               &err);
            if ( err != NET_TCP_ERR_NONE) {
               *p_err  = NET_TCP_ERR_CONN_FAULT;
                return;
            }


                                                                /* ----------- PREPARE TCP TX DATA/ACK SEG ------------ */
                                                                /* Prepare TCP seg addrs.                               */

            switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
                case NET_SOCK_FAMILY_IP_V4:
                     src_addrv4  = pseg_hdr->IP_AddrSrc;
                     dest_addrv4 = pseg_hdr->IP_AddrDest;
                     break;
#endif

#ifdef  NET_IPv6_MODULE_EN
                case NET_SOCK_FAMILY_IP_V6:
                     src_addrv6  = pseg_hdr->IPv6_AddrSrc;
                     dest_addrv6 = pseg_hdr->IPv6_AddrDest;
                     DEF_BIT_SET(pseg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
                     break;
#endif
                default:
#if 0
                    *p_err = NET_TCP_ERR_CONN_PROTO_FAMILY;
                     return;
#endif
                     break;
            }

            src_port  = pseg_hdr->TransportPortSrc;
            dest_port = pseg_hdr->TransportPortDest;

                                                                /* Prepare TCP seq nbrs.                                */
            seq_nbr   = pseg_hdr->TCP_SeqNbr;
            ack_nbr   = p_conn->RxSeqNbrNext;

                                                                /* Prepare TCP tx flags.                                */
            flags_tcp = pseg_hdr->TCP_Flags;

                                                                /* Prepare TCP win size.                                */
            win_size  = p_conn->RxWinSizeActual;

                                                                /* Prepare IP params (see Note #9a).                    */

            switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
                case NET_SOCK_FAMILY_IP_V4:
                     NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL, &err);
                     if ( err != NET_CONN_ERR_NONE) {
                         NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
                        *p_err  = NET_TCP_ERR_CONN_FAULT;
                         return;
                     }
                     break;
#endif

#ifdef  NET_IPv6_MODULE_EN
                case NET_SOCK_FAMILY_IP_V6:
                     NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6, &err);
                     if ( err != NET_CONN_ERR_NONE) {
                         NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, close_code);
                        *p_err  = NET_TCP_ERR_CONN_FAULT;
                         return;
                     }
                     break;
#endif

                default:
#if 0
                    *p_err = NET_TCP_ERR_CONN_PROTO_FAMILY;
                     return;
#endif
                     break;

            }

                                                                /* Update TCP tx buf ctrls.                             */
            pseg_hdr->TCP_SeqNbrLast  = seq_nbr;
            pseg_hdr->TCP_AckNbrLast  = ack_nbr;
            pseg_hdr->TCP_SegLenLast  = pseg_hdr->TCP_SegLen;
            pseg_hdr->TCP_WinSizeLast = win_size;

            pseg_hdr->TCP_SegReTxCtr  = 0u;
            pseg_hdr->RefCtr++;                                 /* TCP maintains ref until seg ack'd (see Note #10).    */


                                                                /* --------------- TX TCP DATA/ACK SEG ---------------- */
            if (DEF_BIT_IS_CLR(pseg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
                NetTCP_TxPktHandlerIPv4(pseg,
                                        src_addrv4,
                                        src_port,
                                        dest_addrv4,
                                        dest_port,
                                        seq_nbr,
                                        ack_nbr,
                                        win_size,
                                        TOS,
                                        TTL,
                                        flags_tcp,
                                        flags_ipv4,
                                        DEF_NULL,
                                        DEF_NULL,               /* See Note #9b.                                        */
                                       &err_rtn);               /* Ignore transitory tx err(s).                         */
#endif
            } else {
#ifdef  NET_IPv6_MODULE_EN
                NetTCP_TxPktHandlerIPv6(pseg,
                                       &src_addrv6,
                                        src_port,
                                       &dest_addrv6,
                                        dest_port,
                                        seq_nbr,
                                        ack_nbr,
                                        win_size,
                                        traffic_class,
                                        flow_label,
                                        hop_lim,
                                        flags_tcp,
                                        DEF_NULL,               /* See Note #9b.                                        */
                                       &err_rtn);
#endif
            }

            switch (err_rtn) {
                case NET_TCP_ERR_NONE:                          /* If NO tx err(s);         ...                         */
                     tx_segs_txd = DEF_YES;                     /* ... indicate seg(s) tx'd ...                         */
                     tx_seg_nbr++;                              /* ... & inc tx ctrs.                                   */
                     NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnTxQ_Ctr);
                     break;


                case NET_ERR_TX:                                /* Else indicate tx done.                               */
                case NET_ERR_IF_LINK_DOWN:
                     tx_done = DEF_YES;
                     break;


                case NET_TCP_ERR_TX_PKT:                        /* See Note #14a.                                       */
                case NET_ERR_IF_LOOPBACK_DIS:
                default:
                     NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, close_code);
                    *p_err = err_rtn;
                     return;
            }


        } else {                                                /* Else if seg NOT tx'd, ...                            */
            tx_done = DEF_YES;                                  /* ... indicate tx done.                                */
        }


                                                                /* ------------------ SUSPEND TCP TX ------------------ */
        if ((tx_suspend_en == DEF_YES) &&
            (tx_done       == DEF_NO)  &&                       /* If tx NOT done &                            ..       */
            (tx_seg_nbr     > 1))       {                       /* .. tx'd > 1 seg,                            ..       */
             net_rx_nbr   = 0u;
             net_rx_avail = NetIF_RxPktIsAvail(if_nbr, net_rx_nbr);
             if (net_rx_avail == DEF_YES) {                     /* .. & rx pkt(s) avail;                       ..       */
                 switch (p_conn->TxQ_State) {                   /* .. set TCP conn tx Q state to SUSPEND,      ..       */
                     case NET_TCP_TX_Q_STATE_CONN:
                     case NET_TCP_TX_Q_STATE_SUSPEND:
                          p_conn->TxQ_State = NET_TCP_TX_Q_STATE_SUSPEND;
                          break;


                     case NET_TCP_TX_Q_STATE_CLOSING:
                     case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                          p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSING_SUSPEND;
                          break;


                     case NET_TCP_TX_Q_STATE_CLOSED:
                     case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                          p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED_SUSPEND;
                          break;


                     case NET_TCP_TX_Q_STATE_NONE:
                     default:
                          NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, close_code);
                         *p_err = NET_TCP_ERR_CONN_CLOSE;
                          return;
                 }


                 Net_GlobalLockRelease();
                 do {
                     NetIF_TxSuspend(if_nbr);                   /* .. & suspend TCP tx       (see Note #12b2A) ..       */

                     net_rx_nbr++;
                     net_rx_avail = NetIF_RxPktIsAvail(if_nbr, net_rx_nbr);
                 } while (net_rx_avail == DEF_YES);             /* .. while     net rx avail (see Note #12b2A1).        */

                 Net_GlobalLockAcquire((void *)&NetTCP_TxConnTxQ, &err);
                 if (err != NET_ERR_NONE) {
                     NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, close_code);
                    *p_err  = NET_TCP_ERR_CONN_CLOSE;
                     return;
                 }

                 switch (p_conn->TxQ_State) {                   /* Restore TCP conn tx Q state.                         */
                     case NET_TCP_TX_Q_STATE_SUSPEND:
                          p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CONN;
                          break;


                     case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                          p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSING;
                          break;


                     case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                          p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED;
                          break;


                     case NET_TCP_TX_Q_STATE_CLOSED:            /* If prev'ly CLOSED, don't re-close TCP conn.          */
                         *p_err = NET_TCP_ERR_CONN_CLOSE;
                          return;


                     case NET_TCP_TX_Q_STATE_CLOSING:
                          break;


                     case NET_TCP_TX_Q_STATE_NONE:
                     case NET_TCP_TX_Q_STATE_CONN:
                     default:
                          NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, close_code);
                         *p_err = NET_TCP_ERR_CONN_CLOSE;
                          return;
                 }
             }
        }
    }


                                                                /* ----------------- COMPLETE TCP TX ------------------ */
    if (tx_segs_txd != DEF_YES) {                               /* If NO   tx Q seg(s) tx'd, ...                        */
        if (tx_ack  == DEF_YES) {                               /* ... but tx ack req'd;     ...                        */
                                                                /* ... tx TCP conn ack (see Note #1c1).                 */
            NetTCP_TxConnAck(p_conn, p_buf_hdr, tx_ack_code, close_code, &err_rtn);
        }

    } else {                                                    /* Else if ANY tx Q seg(s) tx'd;         ..             */
        NetTCP_TxConnTxQ_TimeoutIdleClr(p_conn);                /* .. clr tx Q idle tmr (see Note #1c2), ..             */
        NetTCP_TxConnAckDlyReset(p_conn, DEF_YES);              /* .. reset ack dly ctrls,               ..             */
        tx_tmr_free  = DEF_YES;                                 /* .. free tx Q tmr.                                    */
    }


    if (tx_tmr_free == DEF_YES) {                               /* If free tx Q tmr req'd, ..                           */
        if (p_conn->TxQ_SillyWinTmr != DEF_NULL) {              /* .. &    tx Q tmr avail, ..                           */
            if (tx_q_timeout == DEF_NO) {                       /* .. & NOT timed out,     ..                           */
                                                                /* .. free tx Q tmr.                                    */
                NetTmr_Free(p_conn->TxQ_SillyWinTmr);
            }
            p_conn->TxQ_SillyWinTmr  = DEF_NULL;
        }
    }



   *p_err = err_rtn;                                            /* Rtn err from tx handler(s).                          */
}


/*
*********************************************************************************************************
*                                   NetTCP_TxConnTxQ_TimeoutIdle()
*
* Description : (1) (a) Handle TCP connection's transmit queue idle timeout ... :
*
*                       (1) Clear TCP connection's transmit idle timer                      See Notes #4a1A & #4a2
*                       (2) Reset TCP connection's transmit congestion window controls      See Note  #2a
*                       (3) Reset TCP connection's transmit round-trip time   controls      See Note  #2b
*
*                   (b) ... for the following states :
*
*                       (1) ESTABLISHED
*                       (2) FIN-WAIT-1
*                       (3) CLOSING
*                       (4) CLOSE-WAIT
*                       (5) LAST-ACK
*
*
* Argument(s) : p_conn_timeout       Pointer to TCP connection (see Note #3b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_TxConnTxQ_TimeoutIdleSet().
*
* Note(s)     : (2) (a) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
*                       of time ... use slow start to restart transmission" :
*
*                       (1) (A) "When TCP has not received a segment for more than one retransmission timeout," ...
*                           (B) "cwnd is reduced to the value of the restart window."
*
*                       (2) However, RFC #2581, Section 4.1 re-states that "using the last time a segment was
*                           received to determine whether or not to decrease cwnd fails to deflate cwnd in the
*                           common case of persistent ... connections ... The reception of [segments] makes the
*                           test for an idle connection fail, and allows the TCP to begin transmission with a
*                           possibly inappropriately large cwnd."
*
*                           (A) "Therefore, ... if the TCP has not sent data ... in an interval exceeding the
*                                retransmission timeout" ...
*
*                           (B) "a TCP SHOULD set cwnd to no more than RW before beginning transmission."
*
*                       See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2e1'.
*
*                   (b) Similarly, although NO RFC specifies that a TCP connection's RTT average & deviation
*                       should be reset following a TCP transmit idle timeout; it seems reasonable to reset a
*                       TCP connection's RTT average & deviation controls whenever a TCP connection's transmit
*                       is idle for a period exceeding the re-transmit timeout.
*
*                       See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4A2'.
*
*               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (4) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection transmit queue idle timer ('TxQ_IdleTmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared prior to next handler function(s); ...
*                               (2) Cleared prior to invalid state fault exit.
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_TX_IDLE
*
*               (5) Certain network connections MUST periodically suspend network transmit(s) to handle
*                   network receive packet(s).  To protect TCP connections from transmit corruption while
*                   suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
*                   suspended connections until the connection is no longer suspended.
*
*                   However, handling the TCP connection's transmit queue idle timeout is permitted since
*                   NO new TCP data is prepared from the TCP connection's transmit queue (see Note #1a).
*
*                   See also 'NetTCP_TxConnTxQ()                    Note #12b2A2',
*                            'NetTCP_TxConnTxQ_TimeoutSillyWin()    Note #5',
*                            'NetTCP_TxConnReTxQ_Timeout()          Note #5',
*                          & 'NetTCP_TxConnWinSizeZeroWinTimeout()  Note #5'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnTxQ_TimeoutIdle (void  *p_conn_timeout)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NET_TCP_CLOSE_CODE   close_code;
#endif
    NET_TCP_CONN        *p_conn;
    NET_ERR              err;


    p_conn      = (NET_TCP_CONN *)p_conn_timeout;               /* See Note #3b2A.                                      */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    close_code =  NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_TX_IDLE);    /* See Note #4b1.                                       */

                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }


    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             p_conn->TxQ_IdleTmr = DEF_NULL;                    /* See Note #4a2A2.                                     */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1.                                         */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:               /* See Note #5.                                         */
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      p_conn->TxQ_IdleTmr = DEF_NULL;           /* See Note #4a2A2.                                     */
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }
#endif


                                                                /* -------- HANDLE TCP CONN TX Q IDLE TIMEOUT --------- */
    p_conn->TxQ_IdleTmr = DEF_NULL;                             /* Clr tx Q idle tmr  (see Note #4a2A1).                */

                                                                /* Reset tx win ctrls (see Note #2a2B).                 */
    NetTCP_TxConnWinSizeHandlerCongCtrl((NET_TCP_CONN   *) p_conn,
                                        (NET_BUF_HDR    *) 0,
                                        (NET_TCP_ACK_CODE) NET_TCP_CONN_RX_ACK_NONE,
                                        (NET_TCP_WIN_SIZE) 0u,
                                        (NET_TCP_WIN_CODE) NET_TCP_CONN_TX_WIN_RESET,
                                        (NET_ERR        *)&err);

                                                                /* Reset RTT ctrls (see Note #2b).                      */
    NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTT_RESET, NET_TCP_TX_RTT_NONE, NET_TCP_TX_RTT_NONE);
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnTxQ_TimeoutIdleSet()
*
* Description : (1) Start TCP connection's transmit queue idle timeout for the following states :
*
*                   (a) SYN-RECEIVED
*                   (b) SYN-SENT
*                   (c) ESTABLISHED
*                   (d) FIN-WAIT-1
*                   (e) CLOSING
*                   (f) CLOSE-WAIT
*                   (g) LAST-ACK
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandlerReTxQ().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerReTxQ().
*
* Note(s)     : (2) (a) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
*                       of time ... use slow start to restart transmission" :
*
*                       (1) "If the TCP has not sent data in an interval exceeding the retransmission timeout" ...
*                       (2) "cwnd is reduced to ... no more than ... the value of the restart window."
*
*                       See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2a'.
*
*                   (b) However, if NO network timer is available to time the transmit queue idle interval, the
*                       TCP connection SHOULD be immediately slow started.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnTxQ_TimeoutIdleSet (NET_TCP_CONN  *p_conn)
{
    NET_TMR_TICK  timeout_tick;
    NET_ERR       err;


                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Note #1a.                                        */
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:                       /* See Note #1b.                                        */
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CLOSED:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1c.                                        */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }


                                                                /* ----------- START TCP CONN TX Q IDLE TMR ----------- */
    timeout_tick = p_conn->TxRTT_RTO_tick;                      /* Tx Q idle timeout = RTO (see Note #2a1).             */
    if (p_conn->TxQ_IdleTmr == DEF_NULL) {                      /* If       tx Q idle tmr NOT avail, ...                */
                                                                /* ...  get tx Q idle tmr.                              */
        p_conn->TxQ_IdleTmr  =  NetTmr_Get((CPU_FNCT_PTR )&NetTCP_TxConnTxQ_TimeoutIdle,
                                           (void        *) p_conn,
                                           (NET_TMR_TICK ) timeout_tick,
                                           (NET_ERR     *)&err);
    } else {                                                    /* Else set tx Q idle tmr.                              */
        NetTmr_Set((NET_TMR    *) p_conn->TxQ_IdleTmr,
                   (CPU_FNCT_PTR)&NetTCP_TxConnTxQ_TimeoutIdle,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    }

    if (err != NET_TMR_ERR_NONE) {                              /* If any err(s), ...                                   */
                                                                /* ... reset tx win ctrls (see Note #2b).               */
        NetTCP_TxConnWinSizeHandlerCongCtrl((NET_TCP_CONN   *) p_conn,
                                            (NET_BUF_HDR    *) 0,
                                            (NET_TCP_ACK_CODE) NET_TCP_CONN_RX_ACK_NONE,
                                            (NET_TCP_WIN_SIZE) 0u,
                                            (NET_TCP_WIN_CODE) NET_TCP_CONN_TX_WIN_RESET,
                                            (NET_ERR        *)&err);
    }
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnTxQ_TimeoutIdleClr()
*
* Description : (1) Clear TCP connection's transmit queue idle timer for the following states :
*
*                   (a) ESTABLISHED
*                   (b) FIN-WAIT-1
*                   (c) CLOSING
*                   (d) CLOSE-WAIT
*                   (e) LAST-ACK
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnTxQ().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnTxQ().
*
* Note(s)     : (2) (a) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
*                       of time ... use slow start to restart transmission" :
*
*                       (1) "If the TCP has not sent data in an interval exceeding the retransmission timeout" ...
*                       (2) "cwnd is reduced to ... no more than ... the value of the restart window."
*
*                       See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2a'.
*
*                   (b) (1) However, if the TCP connection's re-transmit queue is NOT empty, then TCP data has
*                           has been transmitted & is awaiting acknowledgement.
*
*                       (2) Therefore, NO transmit queue idle timeout is currently needed.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnTxQ_TimeoutIdleClr (NET_TCP_CONN  *p_conn)
{
    CPU_BOOLEAN  tmr_free;


                                                                /* ---------------- VALIDATE TCP CONN ----------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1.                                         */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }


                                                                /* ------------ CLR TCP CONN TX Q IDLE TMR ------------ */
    tmr_free = (p_conn->ReTxQ_Head != DEF_NULL) ? DEF_YES : DEF_NO;

    if (tmr_free == DEF_YES) {                                  /* If re-tx Q NOT empty   (see Note #2b1), ...          */
        if (p_conn->TxQ_IdleTmr != DEF_NULL) {
            NetTmr_Free(p_conn->TxQ_IdleTmr);                   /* ... free tx Q idle tmr (see Note #2b2).              */
            p_conn->TxQ_IdleTmr  = DEF_NULL;
        }
    }
}


/*
*********************************************************************************************************
*                                 NetTCP_TxConnTxQ_TimeoutSillyWin()
*
* Description : (1) (a) Handle TCP connection's transmit queue silly window timeout ... :
*
*                       (1) Clear    TCP connection's transmit silly window persist timer   See Notes #4a1A & #4a2
*                       (2) Transmit TCP connection's transmit data                         See Note  #2
*
*                   (b) ... for the following states :
*
*                       (1) ESTABLISHED
*                       (2) FIN-WAIT-1
*                       (3) CLOSING
*                       (4) CLOSE-WAIT
*                       (5) LAST-ACK
*
*
* Argument(s) : p_conn_timeout       Pointer to TCP connection (see Note #3b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_TxConnTxQ().
*
* Note(s)     : (2) RFC #1122, Section 4.2.3.4 states that on "timeout ... force transmission of data,
*                   overriding the SWS avoidance algorithm".
*
*                   See also 'NetTCP_TxConnTxQ()  Note #7b2Bb'.
*
*               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (4) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection transmit silly window persist timer ('TxQ_SillyWinTmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared prior to next handler function(s); ...
*                               (2) Cleared prior to invalid state fault exit.
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN
*
*               (5) Certain network connections MUST periodically suspend network transmit(s) to handle
*                   network receive packet(s).  To protect TCP connections from transmit corruption while
*                   suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
*                   suspended connections until the connection is no longer suspended.
*
*                   (a) The transmit queue silly window timeout is reconfigured with one timer tick to
*                       ensure that a non-zero delay is implemented.
*
*                   (b) If NO timer is available, a TCP connection will NOT be able to re-schedule the
*                       transmission of its TCP transmit queue data.  Thus the TCP transmit queue data
*                       will be delayed until triggered by any received acknowledgement packets or by
*                       additional data transmits from the applications layer.
*
*                   See also 'NetTCP_TxConnTxQ()                    Note #12b2A2',
*                            'NetTCP_TxConnTxQ_TimeoutIdle()        Note #5',
*                            'NetTCP_TxConnReTxQ_Timeout()          Note #5',
*                          & 'NetTCP_TxConnWinSizeZeroWinTimeout()  Note #5'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnTxQ_TimeoutSillyWin (void  *p_conn_timeout)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CLOSE_CODE   close_code;
    NET_TMR_TICK         timeout_tick;
    NET_ERR              err;


    p_conn      = (NET_TCP_CONN *)p_conn_timeout;               /* See Note #3b2A.                                      */

    close_code =  NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN); /* See Note #4b1.                                     */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }
#endif

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             p_conn->TxQ_SillyWinTmr = DEF_NULL;                /* See Note #4a2A2.                                     */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1.                                         */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                      break;


                 case NET_TCP_TX_Q_STATE_SUSPEND:               /* See Note #5 & #5a.                                   */
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      timeout_tick            = (NET_TMR_TICK)1u;
                      p_conn->TxQ_SillyWinTmr =  NetTmr_Get((CPU_FNCT_PTR )&NetTCP_TxConnTxQ_TimeoutSillyWin,
                                                            (void        *) p_conn,
                                                            (NET_TMR_TICK ) timeout_tick,
                                                            (NET_ERR     *)&err);
                     (void)&err;                                /* Ignore transitory rsrc err(s) [see Note #5b].        */
                      return;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      p_conn->TxQ_SillyWinTmr = DEF_NULL;       /* See Note #4a2A2.                                     */
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }


                                                                /* ------ HANDLE TCP CONN TX Q SILL WIN TIMEOUT ------- */
    p_conn->TxQ_SillyWinTmr = DEF_NULL;                         /* Clr tx Q silly win tmr (see Note #4a2A1).            */

    NetTCP_TxConnTxQ(p_conn,                                    /* Tx Q data          (see Note #2).                    */
                     0,
                     NET_TCP_CONN_TX_ACK_NONE,
                     DEF_YES,
                     close_code,
                     DEF_NO,
                    &err);                                      /* Ignore ALL tx err(s), transitory or fatal.           */
}


/*
*********************************************************************************************************
*                                        NetTCP_TxConnReTxQ()
*
* Description : (1) Re-transmit  TCP data segment(s) from TCP connection re-transmit queue :
*
*                   (a) Validate TCP connection re-transmit :
*                       (1) Validate re-transmit segment available
*                       (2) Validate re-transmit segment threshold                          See Note #3
*
*                   (b) Update TCP connection :
*                       (1) Update     TCP connection's re-transmit queue timeout :
*                           (A) Update TCP connection's re-transmit queue timer             See Note #2b
*                           (B) Reset  TCP connection's    transmit round-trip time         See Note #2b2A2
*                                   controls
*                       (2) Update     TCP connection's    transmit congestion controls :
*                           (A) Update TCP connection's transmit congestion window          See Note #5
*                           (B) Reset  TCP connection's delayed acknowledgement controls    See Note #6
*
*                   (c) Prepare TCP segment re-transmit :
*                       (1) Prepare unchanged TCP segment for re-transmit                   See Note #7
*
*                       (2) Prepare updated   TCP segment for re-transmit :
*                           (A) TCP segment   sequence numbers
*                           (B) TCP segment   window size
*                           (C) TCP segment   addresses
*                           (D) TCP segment   transmit flags
*                           (E) IP  datagram  parameters
*                           (F) Update TCP    segment's last transmit values :
*                               (1) Sequence        Number
*                               (2) Acknowledgement Number
*                               (3) Segment Length
*                               (4) Window  Size
*                           (G) Unlink TCP segment packet buffer from any other network layer(s)
*                           (H) Update TCP segment packet buffer controls
*
*                   (d) Re-transmit TCP segment                                             See Note #2a
*
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in NetTCP_TxConnReTxQ_Timeout(),
*                                                         NetTCP_TxConnWinSizeHandlerCongCtrl().
*
*               re_tx_q_timeout     Indicate whether the TCP connection re-transmit queue timed out :
*
*                                       DEF_NO                      TCP connection re-transmit queue did
*                                                                       NOT time  out.
*                                       DEF_YES                     TCP connection re-transmit queue
*                                                                           timed out.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection re-transmit queue successfully handled.
*                               NET_TCP_ERR_RE_TX_SEG_TH            TCP connection closed due to excessive retransmission.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_ERR_TX_BUF_LOCK                 Network buffer transmit lock still locked.
*                               NET_CONN_ERR_INVALID_FAMILY         Connection's socket protocol family is invalid.
*
*                                                                   --- RETURNED BY NetTCP_TxConnReTxQ_TimeoutSet() : ----
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
*                                                                   -------- RETURNED BY NetTCP_TxPktHandler() : ---------
*                                                                   ------------- RETURNED BY NetIP_ReTx() : -------------
*                               NET_ERR_TX                          Transmit error.
*                               NET_ERR_IF_LOOPBACK_DIS             Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN                Network  interface link state down (i.e.
*                                                                       NOT available for receive or transmit).
*
*                                                                   -------- RETURNED BY NetTCP_TxPktHandler() : ---------
*                               NET_TCP_ERR_TX_PKT                  TCP transmit packet error (see Note #11a).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnReTxQ_Timeout(),
*               NetTCP_TxConnWinSizeHandlerCongCtrl().
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : RETRANSMISSION TIMEOUT'
*                   states that "for any state if the retransmission timeout expires on a segment in
*                   the retransmission queue" :
*
*                       (A) RFC #1122, Section 4.2.3.1 reiterates that "retransmission of SYN segments
*                           SHOULD use the same algorithm as data segments".
*
*                   (a) "Send the segment at the front of the retransmission queue."
*
*                           (A) RFC #2988, Section 5.4 reiterates that "when the retransmission timer
*                               expires ... retransmit the earliest segment that has not been acknowledged
*                               by the TCP receiver".
*
*                       (1) RFC #1122, Section 4.2.2.16 states that "a TCP receiver SHOULD NOT shrink the
*                           window ... However, a sending TCP MUST be robust against window shrinking ...
*                           If this happens, the sender SHOULD NOT send new data, but SHOULD retransmit
*                           normally the old unacknowledged data between SND.UNA and SND.UNA+SND.WND.  The
*                           sender MAY also retransmit old data beyond SND.UNA+SND.WND, but SHOULD NOT time
*                           out the connection if data beyond the right window edge is not acknowledged".
*
*                           Therefore, ALL data segments previously transmitted & awaiting acknowledgement
*                           in a TCP connections' re-transmit queue may be re-transmitted regardless of the
*                           TCP connection's current transmit congestion control window size or the remote
*                           host's receive window size.
*
*                       (2) (A) RFC #2581, Section 3.2 states that "the fast retransmit algorithm uses the
*                               arrival of 3 duplicate ACKs ... as an indication that a segment has been
*                               lost ... [and] performs a retransmission of what appears to be the missing
*                               segment".
*
*                           (B) RFC #1122, Section 4.2.2.21 reiterates that "'fast retransmit' ... uses the
*                               redundant ACK's to deduce that a segment has been lost ... If more than a
*                               threshold number of such ACK's is received, then the segment containing the
*                               octets starting at SEG.ACK is assumed to have been lost and is retransmitted".
*
*                   (b) "Reinitialize the retransmission timer."
*
*                       (1) RFC #2988, Section 5 states that "an implementation MUST manage the retransmission
*                           timer(s) in such a way that a segment is never retransmitted too early, i.e. less
*                           than one RTO after the previous transmission of that segment".
*
*                           (A) "The following is the RECOMMENDED algorithm for managing the retransmission
*                                timer" :
*
*                               (1) "Every time a packet containing data is sent (including a retransmission),
*                                    if the timer is not running, start it running so that it will expire after
*                                    RTO seconds (for the current value of RTO)."
*
*                                    Therefore, the TCP connection re-transmit queue timer is reset whenever a
*                                    segment is re-transmitted.
*
*                               (2) "When all outstanding data has been acknowledged, turn off the retransmission
*                                    timer."
*
*                               (3) "When an ACK is received that acknowledges new data, restart the retransmission
*                                    timer so that it will expire after RTO seconds (for the current value of RTO)."
*
*                           (B) "When the retransmission timer expires, do the following" :
*
*                               (5) "The host MUST set RTO <- RTO * 2 ('back off the timer')."
*
*                                    See also Note #2b2A1.
*
*                               (6) "Start the retransmission timer, such that it expires after RTO seconds
*                                    (for the value of RTO after the doubling operation)."
*
*                       (2) (A) (1) RFC #1122, Section 4.2.3.1 reiterates that an "implementation MUST also
*                                   include 'exponential backoff' for successive RTO values for the same
*                                   segment".
*
*                                   (a) RFC #2988, Section 5.5 states that "when the retransmission timer
*                                       expires ... the host MUST set RTO <- RTO * 2 ('back off the timer')".
*
*                                       Thus the TCP retransmission timer exponential back-off scalar
*                                       value is 2.
*
*                                   (b) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2,
*                                       Page 299 reiterates that "this doubling is called an 'exponential
*                                       backoff'".
*
*                                   See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2b2'.
*
*                               (2) RFC #2988, Section 5 adds "that a TCP implementation MAY clear SRTT [TCP
*                                   smoothed round-trip time] and RTTVAR [TCP round-trip time variance] after
*                                   backing off the timer multiple times as it is likely that the current SRTT
*                                   and RTTVAR are bogus in this situation.  Once SRTT and RTTVAR are cleared
*                                   they should be initialized with the next RTT sample taken".
*
*                                   See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4A1'.
*
*                           (B) (1) (a) RFC #2581, Section 3.2 states that "after receiving 3 duplicate ACKs
*                                       ... the fast retransmit algorithm ... performs a retransmission of
*                                       what appears to be the missing segment, without waiting for the
*                                       retransmission timer to expire".
*
*                                   (b) RFC #1122, Section 4.2.2.21 reiterates that with "'fast retransmit' ...
*                                       the [lost] segment ... is retransmitted, without awaiting a timeout".
*
*                               (2) If a segment is re-transmitted due to the TCP fast re-transmit algorithm
*                                   & NOT due to the TCP connection's re-transmit queue timer expiring, the
*                                   TCP connection's re-transmit queue timer is :
*
*                                   (a) NOT backed-off because the re-transmit queue        See Note #2b2B1
*                                           timer did NOT expire
*                                   (b) Restarted with its current RTO value                See Note #2b1A1
*
*                           (C) A TCP connection's RTO timeout controls do NOT need to be explicitly reset
*                               since RFC #2988, Section 5 states that "once a new RTT measurement is obtained
*                               (which can only happen when new data has been sent and acknowledged), the
*                               computations ... of RTO ... are performed ... which may result in 'collapsing'
*                               RTO back down after it has been subject to exponential backoff".
*
*                               See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4B'.
*
*               (3) RFC #1122, Section 4.2.3.5 states that "excessive retransmission of the same segment
*                   by TCP indicates some failure of the remote host or the Internet path ... The following
*                   procedure MUST be used to handle excessive retransmissions of data segments" :
*
*                   (c) "When the number of transmissions of the same segment reaches a threshold ...
*                        close the connection."
*
*                   See also 'NetTCP_RxPktConnHandlerReTxQ()  Note #7'.
*
*               (4) RFC #2988, Section 3 states that "TCP MUST use Karn's algorithm ... for taking RTT samples.
*                   That is, RTT samples MUST NOT be made using segments that were retransmitted (and thus for
*                   which it is ambiguous whether the reply was for the first instance of the packet or a later
*                   instance)".
*
*                   (a) To ensure implementation of Karn's algorithm, while ANY re-transmitted segment(s)
*                       remain unacknowledged in a TCP connection's re-transmit queue :
*
*                       (1) (A) NO RTT calculations are performed; ...                      See Note #4
*
*                           (B) The TCP connection's re-transmit timeout :
*                               (1) MAY be backed-off ...                                   See Note  #2b1B5
*                                     OR
*                               (2) MAY be latched at a previously backed-off value;        See Notes #2b2B2 & #2b2C
*                                     BUT
*                               (3) MUST NOT be updated by RTT calculations.                See Note  #4a1A
*
*                       (2) Each time a TCP connection re-transmits a segment, the TCP connection advances
*                           its un-re-transmitted sequence number to the TCP connection's next sequence
*                           number to transmit.  This ensures that NO RTT or RTO calculations are performed
*                           until ALL re-transmitted data is acknowledged & removed from the TCP connection's
*                           re-transmit queue.
*
*               (5) RFC #2581, Section 3.1 states that "when a TCP sender detects segment loss using the
*                   retransmission timer, the value of ssthresh [TCP transmit congestion control slow start
*                   threshold] ... [and] cwnd [TCP transmit congestion control window] MUST be set".
*
*                   See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #2c2A5a & #2c2A5b'.
*
*               (6) A TCP connection's delayed acknowledgement controls :
*
*                   (a) SHOULD be reset whenever a TCP connection re-transmits data segment(s) since
*                           any re-transmit always transmits an accompanying acknowledgement;
*                   (b) MAY    be reset whenever a TCP connection re-transmits a connection request
*                           segment since NO delayed acknowledgement controls should be active.
*
*                   See also 'NetTCP_TxConnAckDlyReset()  Note #1'.
*
*               (7) RFC #1122, Section 4.2.2.15 states that "if a retransmitted packet is identical to the
*                   original packet (which implies not only that the data boundaries have not changed, but
*                   also that the window and acknowledgment fields of the header have not changed), then
*                   the same IP Identification field MAY be used".
*
*                   In other words, if the following TCP segment header values are unchanged since the
*                   last transmission of the TCP segment, then the TCP segment may be transmitted without
*                   re-calculation of the TCP header :
*
*                       (a) Sequence        Number
*                       (b) Acknowledgement Number
*                       (c) Segment Length
*                       (d) Window  Size
*
*               (8) (a) Some network interfaces require a minimum packet size & may also require that
*                       packets smaller than the minimum packet size be appended with trailing pad
*                       octets.  Therefore, all network transmit packets MUST be prepared to satisfy
*                       a possible network interface minimum packet size requirement.
*
*                   (b) To ensure that TCP re-transmit segments will be properly prepared to satisfy
*                       a network interface minimum packet size requirement, the following equations
*                       are used to validate a TCP re-transmit segment size :
*
*                           (A) (1) TCP Re-transmit Segment Size  =  Segment's Re-transmit Protocol Header Sizes +
*                                                                    Segment's Remaining   Segment  Data   Size
*
*                               (2)                               =  Segment's Previous    Protocol Header Sizes +
*                                                                    Segment's Remaining   Segment  Data   Size
*
*                               (3)                               = (Segment's Previous    Total    Packet Size  -
*                                                                    Segment's Previous             Data   Size) +
*                                                                    Segment's Remaining   Segment  Data   Size
*
*                           (B) (1) TCP Re-transmit Minimum Segment Size         =  Network Interface Minimum Packet Size
*
*                               (2) [(Segment's          Total   Packet Size  -
*                                     Segment's                  Data   Size) +
*                                     Segment's Minimum  Segment Data   Size ]   =  Network Interface Minimum Packet Size
*
*                               (3)   Segment's Minimum  Segment Data   Size     =  Network Interface Minimum Packet Size  -
*                                                                                  (Segment's         Total   Packet Size  -
*                                                                                   Segment's                 Data   Size)
*
*                       (1) Equation #8bA2 subtly assumes that the TCP re-transmit segment's network
*                           protocol header sizes equal the segment's previously transmitted network
*                           protocol header sizes.  In other words, it is assumed that a TCP transmit
*                           segment's network protocol header sizes will remain constant for the
*                           segment's initial transmission & any subsequent retransmissions.
*
*                           This assumption is true if & only if the TCP segment is re-transmitted
*                           with no changes in any of the segment's network protocol header sizes,
*                           which typically vary only for changes in the network protocol header
*                           types or in the number of network protocol header options.
*
*                           However, since TCP segments that have already been transmitted can
*                           NOT modify their segment data (see 'NetTCP_TxConnAppData()  Note #10a'),
*                           it seems reasonable that TCP segments that have already been transmitted
*                           will NOT likely modify their network protocol header types & SHOULD NOT
*                           modify their network protocol header options.
*
*                           Therefore, it seems reasonable that TCP segments that have already
*                           been transmitted will NOT likely vary their network protocol header sizes.
*                           Thus TCP segments may validate their re-transmit segment size versus any
*                           possible network interface minimum packet size requirement based on their
*                           previously transmitted network protocol header & packet sizes.
*
*                       (2) (A) Equation #8bB calculates a TCP re-transmit segment's minimum data size
*                               as required by a possible network interface minimum packet size.  If
*                               the TCP re-transmit segment's data size is smaller than the network
*                               interface minimum packet size, the network buffer MUST be checked for
*                               sufficient & available trailing octets, as required by the network
*                               interface layer to append pad octets.
*
*                           (B) (1) (a) (1) If the TCP re-transmit segment's minimum data size is smaller
*                                           than the required network interface minimum packet size ...
*                                             AND
*                                       (2) there is insufficient network buffer octets available for
*                                           the network interface layer to append pad octets, ...
*
*                                   (b) then the TCP segment's remaining data octets MUST be moved to
*                                       the network buffer's transmit index to provide sufficient
*                                       network buffer data octets for the network interface layer to
*                                       append pad octets.
*
*                               (2) A network interface that appends cleared trailing pad octets MAY be
*                                   optimized to skip clearing the trailing pad octets if the network
*                                   buffer's memory clear flag is set.  Since a partially-acknowledged
*                                   TCP segment's network buffer contains previously acknowledged data
*                                   octets, the network buffer's memory clear flag MUST be cleared to
*                                   ensure that the network interface layer clears the trailing pad
*                                   octets.
*
*               (9) If a packet buffer's unlink function is available, it is assumed that the function ...
*
*                   (a) Correctly unlinks the packet buffer from any other network protocol layers
*                         AND
*                   (b) Correctly updates the network buffer's reference counter to decrement the
*                       number of network protocol layers that no longer maintain a reference to
*                       the packet buffer.
*                         AND
*                   (c) Clears both the unlink function & object pointers.
*
*              (10) Increment network buffer's reference counter to include the TCP segment STILL enqueued
*                   to the TCP connection's re-transmit queue as a reference to the network buffer.
*
*              (11) (a) Since segments enqueued to a TCP connection's transmit queue have already been
*                       reported as transmitted to the application & since no mechanism exists for a TCP
*                       connection to re-request previously transmitted data, any TCP connection whose
*                       transmit queue(s) becomes corrupted MUST be closed to force the application layer
*                       to abort &/or recover from the corrupted data.
*
*                   (b) For any internal errors where the TCP connection's transmit queue is NOT corrupted,
*                       the TCP connection is NOT closed.
*
*                   See also 'NetTCP_TxConnAppData()  Note #10'
*                          & 'NetTCP_TxConnTxQ()      Note #14'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnReTxQ (NET_TCP_CONN        *p_conn,
                                  CPU_BOOLEAN          re_tx_q_timeout,
                                  NET_TCP_CLOSE_CODE   close_code,
                                  NET_ERR             *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
    NET_IPv4_ADDR            src_addrv4;
    NET_IPv4_ADDR            dest_addrv4;
    NET_IPv4_TOS             TOS;
    NET_IPv4_TTL             TTL;
    NET_IPv4_FLAGS           flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_ADDR            src_addrv6;
    NET_IPv6_ADDR            dest_addrv6;
    NET_IPv6_TRAFFIC_CLASS   traffic_class;
    NET_IPv6_FLOW_LABEL      flow_label;
    NET_IPv6_HOP_LIM         hop_lim;
    NET_IPv6_FLAGS           flags_ipv6;
#endif
    NET_BUF                 *pseg;
    NET_BUF_HDR             *pseg_hdr;
    NET_BUF_FNCT             unlink_fnct;
    NET_CONN_ID              conn_id;
    NET_CONN                *p_net_conn;
    NET_IF_NBR               if_nbr;
    NET_TCP_PORT_NBR         src_port;
    NET_TCP_PORT_NBR         dest_port;
    NET_TCP_SEQ_NBR          seq_nbr;
    NET_TCP_SEQ_NBR          ack_nbr;
    NET_TCP_SEG_SIZE         seg_len;
    NET_TCP_WIN_SIZE         win_size;
    NET_BUF_SIZE             min_pkt_size;
    NET_BUF_SIZE             seg_len_tot;
    NET_BUF_SIZE             seg_len_hdr;
    NET_BUF_SIZE             seg_len_data_min;
    NET_BUF_SIZE             buf_size_max;
    NET_BUF_SIZE             data_ix_cur;
    NET_BUF_SIZE             data_ix_re_tx;
    NET_BUF_SIZE             data_len_cur;
    NET_TCP_FLAGS            flags_tcp;
    CPU_INT08U              *pdata_re_tx;
    CPU_BOOLEAN              seg_chngd;
    CPU_BOOLEAN              seg_updated;
    CPU_BOOLEAN              seg_data_moved;
    CPU_BOOLEAN              tx_lock;
    NET_PROTOCOL_TYPE        proto_type = NET_PROTOCOL_TYPE_NONE;
    NET_ERR                  err;
    NET_ERR                  err_rtn = NET_ERR_FAULT_UNKNOWN_ERR;


                                                                /* ----------------- VALIDATE RE-TX Q ----------------- */
    if (p_conn->ReTxQ_Head == DEF_NULL) {
       *p_err = NET_TCP_ERR_NONE;
        return;
    }

    pseg     =  p_conn->ReTxQ_Head;                             /* Re-tx seg @ head of re-tx Q (see Note #2a).          */
    pseg_hdr = &pseg->Hdr;

    pseg_hdr->TCP_SegReTxCtr++;
    if (pseg_hdr->TCP_SegReTxCtr > p_conn->TxSegReTxTh) {       /* If nbr re-tx's > th, close TCP conn (see Note #3).   */
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err = NET_TCP_ERR_RE_TX_SEG_TH;
        return;
    }


                                                                /* ----------------- UPDATE TCP CONN ------------------ */
    if (re_tx_q_timeout != DEF_NO) {                            /* If           re-tx Q timeout,                  ...   */
                                                                /* ... back-off re-tx Q timeout (see Note #2b1B5) ...   */
        NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTO_BACKOFF, NET_TCP_TX_RTT_NONE, NET_TCP_TX_RTT_NONE);
#if 0                                                           /* Implemented with backoff     (see Note #2b2A2).      */
                                                                /* ... & reset RTT ctrls        (see Note #2b2A2).      */
        NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTT_RESET,   NET_TCP_TX_RTT_NONE, NET_TCP_TX_RTT_NONE);
#endif
    }
                                                                /* Update re-tx Q tmr (see Note #2b1A1).                */
    NetTCP_TxConnReTxQ_TimeoutSet(p_conn, re_tx_q_timeout, close_code, p_err);
    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }
                                                                /* Adv   un-re-tx'd seq(s) to ...                       */
    p_conn->TxSeqNbrUnReTxd = p_conn->TxSeqNbrNext;             /* ... not-yet-tx'd seq(s) [see Note #4a2].             */


    if (re_tx_q_timeout != DEF_NO) {                            /* If re-tx Q timeout, ...                              */
                                                                /* ... update tx cong win  (see Note #5).               */
        NetTCP_TxConnWinSizeHandlerCongCtrl((NET_TCP_CONN   *) p_conn,
                                            (NET_BUF_HDR    *) 0,
                                            (NET_TCP_ACK_CODE) NET_TCP_CONN_RX_ACK_NONE,
                                            (NET_TCP_WIN_SIZE) 0u,
                                            (NET_TCP_WIN_CODE) NET_TCP_CONN_TX_WIN_TIMEOUT,
                                            (NET_ERR        *)&err);
       (void)&err;                                              /* Ignore err(s).                                       */
    }

    NetTCP_TxConnAckDlyReset(p_conn, DEF_YES);                  /* Reset ack dly ctrls (see Note #6).                   */

                                                                /* ------------- CHK RE-TX SEG'S TX LOCK -------------- */
    tx_lock = DEF_BIT_IS_SET(pseg_hdr->Flags, NET_BUF_FLAG_TX_LOCK);
    if (tx_lock != DEF_NO) {                                    /* If buf tx locked, CANNOT cur'ly re-tx seg.           */
       *p_err = NET_ERR_TX_BUF_LOCK;
        return;
    }

    conn_id = p_conn->ID_Conn;
    if_nbr  = NetConn_IF_NbrGet(conn_id, &err);
    if ((err    != NET_CONN_ERR_NONE) &&
        (if_nbr == NET_IF_NBR_NONE  )) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )DEF_YES,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err  = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    min_pkt_size = NetIF_GetPktSizeMin(if_nbr, &err);
    if (err != NET_IF_ERR_NONE) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )DEF_YES,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err = NET_TCP_ERR_CONN_FAULT;
        return;
    }

    seg_len_tot    = (NET_BUF_SIZE)pseg_hdr->TotLen        -    /* Seg cur tot len = prev'ly tx'd/ack'd pkt tot  len    */
                     (NET_BUF_SIZE)pseg_hdr->DataLen       +    /* ...               prev'ly tx'd/ack'd pkt data len +  */
                     (NET_BUF_SIZE)pseg_hdr->TCP_SegLenData;    /* ...               rem'ing            seg data len    */
                                                                /* ... (see Note #8bA).                                 */

    if (seg_len_tot < min_pkt_size) {                           /* If TCP re-tx seg tot len                         ... */
                                                                /* ...    < min IF pkt size (see Note #8b2B1a2),    ... */
                                                                /* ... calc min IF seg data len (see Note #8bB);    ... */
        seg_len_hdr      = pseg_hdr->TotLen - pseg_hdr->DataLen;
        seg_len_data_min = min_pkt_size     - seg_len_hdr;

        buf_size_max     = NetBuf_GetMaxSize((NET_IF_NBR     )if_nbr,
                                             (NET_TRANSACTION)NET_TRANSACTION_TX,
                                             (NET_BUF       *)pseg,
                                             (NET_BUF_SIZE   )pseg_hdr->DataIx);

        if (seg_len_data_min > buf_size_max) {                  /* ... & if min IF seg data len                     ... */
                                                                /* ...    > max buf size       (see Note #8b2B1a2), ... */
            data_ix_cur   = (NET_BUF_SIZE) pseg_hdr->DataIx;

#if 0
            data_ix_re_tx = (NET_BUF_SIZE) NET_BUF_DATA_IX_TX;
#else
            p_net_conn = &NetConn_Tbl[conn_id];

            switch (p_net_conn->Family) {
                case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
                     proto_type = NET_PROTOCOL_TYPE_TCP_V4;
                     break;


                case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
                     proto_type = NET_PROTOCOL_TYPE_TCP_V6;
                     break;


                default:
                    *p_err = NET_CONN_ERR_INVALID_FAMILY;
                     return;
            }

            data_ix_re_tx = 0u;

            NetTCP_GetTxDataIx(if_nbr,
                               proto_type,
                               0u,
                               pseg_hdr->DataLen,
                               p_conn,
                              &data_ix_re_tx,
                               p_err);
#endif
            data_len_cur  = (NET_BUF_SIZE) pseg_hdr->TCP_SegLenData;
            pdata_re_tx   = (CPU_INT08U *)&pseg->DataPtr[data_ix_re_tx];

            NetBuf_DataRd((NET_BUF    *) pseg,                  /* ... rd rem'ing TCP seg data                      ... */
                          (NET_BUF_SIZE) data_ix_cur,
                          (NET_BUF_SIZE) data_len_cur,
                          (CPU_INT08U *) pdata_re_tx,           /* ... & move to base re-tx ix (see Note #8b2B1b).      */
                          (NET_ERR    *)&err);
            if (err != NET_BUF_ERR_NONE) {                      /* See Note #11a.                                       */
                NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                 (NET_BUF_HDR      *)0,
                                 (CPU_BOOLEAN       )DEF_YES,
                                 (NET_TCP_CLOSE_CODE)close_code);
               *p_err = NET_TCP_ERR_CONN_FAULT;
                return;
            }

            DEF_BIT_CLR(pseg_hdr->Flags, NET_BUF_FLAG_CLR_MEM); /* MUST clr buf mem clr flag (see Note #8b2B2).         */

            seg_data_moved = DEF_YES;
        } else {
            seg_data_moved = DEF_NO;
        }
    } else {
        seg_data_moved = DEF_NO;
    }
                                                                /* -------------- PREPARE TCP RE-TX SEG --------------- */
                                                                /* Prepare TCP seq nbrs.                                */
    seq_nbr     = pseg_hdr->TCP_SeqNbr;
    ack_nbr     = p_conn->RxSeqNbrNext;

    seg_len     = pseg_hdr->TCP_SegLen;
                                                                /* Prepare TCP win size.                                */
    win_size    = p_conn->RxWinSizeActual;

                                                                /* Chk for re-tx seg update (see Note #7).              */
    seg_updated = ((pseg_hdr->TCP_SeqNbrLast  != seq_nbr ) ||
                   (pseg_hdr->TCP_AckNbrLast  != ack_nbr ) ||
                   (pseg_hdr->TCP_SegLenLast  != seg_len ) ||
                   (pseg_hdr->TCP_WinSizeLast != win_size)) ? DEF_YES : DEF_NO;

    seg_chngd   = ((seg_updated    != DEF_NO) ||
                   (seg_data_moved != DEF_NO)) ? DEF_YES : DEF_NO;


    if (seg_chngd != DEF_NO) {                                  /* If chng'd, prepare seg for re-tx (see Note #1c2).    */
                                                                /* Prepare TCP seg addrs.                               */
        if (DEF_BIT_IS_CLR(pseg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
            src_addrv4  = (NET_IPv4_ADDR   )pseg_hdr->IP_AddrSrc;
            dest_addrv4 = (NET_IPv4_ADDR   )pseg_hdr->IP_AddrDest;
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            src_addrv6  = pseg_hdr->IPv6_AddrSrc;
            dest_addrv6 = pseg_hdr->IPv6_AddrDest;
#endif
        }

        src_port  = (NET_TCP_PORT_NBR)pseg_hdr->TransportPortSrc;
        dest_port = (NET_TCP_PORT_NBR)pseg_hdr->TransportPortDest;

                                                                /* Prepare TCP tx flags.                                */
        flags_tcp =  pseg_hdr->TCP_Flags;

                                                                /* Prepare IP params.                                   */
        if (DEF_BIT_IS_CLR(pseg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
            NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL, &err);
            if ( err != NET_CONN_ERR_NONE) {
                NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                 (NET_BUF_HDR      *)0,
                                 (CPU_BOOLEAN       )DEF_YES,
                                 (NET_TCP_CLOSE_CODE)close_code);
               *p_err  = NET_TCP_ERR_CONN_FAULT;
                return;
            }
#endif
        } else {
#ifdef  NET_IPv6_MODULE_EN
            NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6, &err);
            if ( err != NET_CONN_ERR_NONE) {
                NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                 (NET_BUF_HDR      *)0,
                                 (CPU_BOOLEAN       )DEF_YES,
                                 (NET_TCP_CLOSE_CODE)close_code);
               *p_err  = NET_TCP_ERR_CONN_FAULT;
                return;
            }
#endif
        }

                                                                /* Update re-tx seg's last tx ctrls (see Note #1c2F).   */
        pseg_hdr->TCP_SeqNbrLast  = seq_nbr;
        pseg_hdr->TCP_AckNbrLast  = ack_nbr;
        pseg_hdr->TCP_SegLenLast  = seg_len;
        pseg_hdr->TCP_WinSizeLast = win_size;

                                                                /* Reset protocol & tot len for re-tx.                  */
        pseg_hdr->TotLen          = pseg_hdr->DataLen;
    }



    unlink_fnct = pseg_hdr->UnlinkFnctPtr;
    if (unlink_fnct != (NET_BUF_FNCT)0) {                       /* If unlink fnct avail, ..                             */
        unlink_fnct(pseg);                                      /* .. unlink seg from other layer(s) [see Note #9].     */
    }

    if (pseg_hdr->RefCtr <= 1) {
        pseg_hdr->RefCtr++;                                     /* TCP STILL maintains ref to seg    (see Note #10).    */
    }



                                                                /* ---------------- RE-TX TCP CONN SEG ---------------- */

    if (DEF_BIT_IS_CLR(pseg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        pseg_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V4;
        pseg_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

        if (seg_chngd == DEF_NO) {                              /* If unchng'd,                               ...       */
            NetIPv4_ReTx((NET_BUF *) pseg,                      /* ...      re-tx unchng'd seg (see Note #7); ...       */
                         (NET_ERR *)&err_rtn);

        } else {                                                /* ... else re-tx updated  seg.                         */
            NetTCP_TxPktHandlerIPv4((NET_BUF        *) pseg,
                                    (NET_IPv4_ADDR   ) src_addrv4,
                                    (NET_TCP_PORT_NBR) src_port,
                                    (NET_IPv4_ADDR   ) dest_addrv4,
                                    (NET_TCP_PORT_NBR) dest_port,
                                    (NET_TCP_SEQ_NBR ) seq_nbr,
                                    (NET_TCP_SEQ_NBR ) ack_nbr,
                                    (NET_TCP_WIN_SIZE) win_size,
                                    (NET_IPv4_TOS    ) TOS,
                                    (NET_IPv4_TTL    ) TTL,
                                    (NET_TCP_FLAGS   ) flags_tcp,
                                    (NET_IPv4_FLAGS  ) flags_ipv4,
                                    (void           *) 0,
                                    (void           *) 0,
                                    (NET_ERR        *)&err_rtn);
        }
#endif

    } else {
#ifdef  NET_IPv6_MODULE_EN
        pseg_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V6;
        pseg_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;
        if (seg_chngd == DEF_NO) {                              /* If unchng'd,                               ...       */
            NetIPv6_ReTx((NET_BUF *) pseg,                      /* ...      re-tx unchng'd seg (see Note #7); ...       */
                         (NET_ERR *)&err_rtn);

        } else {                                                /* ... else re-tx updated  seg.                         */
            NetTCP_TxPktHandlerIPv6((NET_BUF              *) pseg,
                                    (NET_IPv6_ADDR        *)&src_addrv6,
                                    (NET_TCP_PORT_NBR      ) src_port,
                                    (NET_IPv6_ADDR        *)&dest_addrv6,
                                    (NET_TCP_PORT_NBR      ) dest_port,
                                    (NET_TCP_SEQ_NBR       ) seq_nbr,
                                    (NET_TCP_SEQ_NBR       ) ack_nbr,
                                    (NET_TCP_WIN_SIZE      ) win_size,
                                    (NET_IPv6_TRAFFIC_CLASS) traffic_class,
                                    (NET_IPv6_FLOW_LABEL   ) flow_label,
                                    (NET_IPv6_HOP_LIM      ) hop_lim,
                                    (CPU_INT16U            ) flags_tcp,
                                    (void                 *) 0,
                                    (NET_ERR              *)&err_rtn);
        }
#endif
    }

    switch (err_rtn) {
        case NET_TCP_ERR_NONE:
        case NET_IPv4_ERR_NONE:
        case NET_IPv6_ERR_NONE:
             err_rtn = NET_TCP_ERR_NONE;
             break;


        case NET_ERR_TX:                                        /* Ignore transitory tx err(s).                         */
        case NET_ERR_IF_LINK_DOWN:
             break;


        case NET_TCP_ERR_TX_PKT:                                /* See Note #11a.                                       */
        case NET_ERR_IF_LOOPBACK_DIS:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                              (NET_TCP_CLOSE_CODE)close_code);
            *p_err = err_rtn;
             return;
    }

    NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnReTxQ_Ctr);



   *p_err = err_rtn;
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnReTxQ_Timeout()
*
* Description : (1) (a) Handle TCP connection re-transmit queue timeout ... :
*
*                       (1) Clear  TCP connection's re-transmit timer                   See Notes #4a1A & #4a2
*                       (2) Handle TCP connection   re-transmit                         See Note  #2
*
*                   (b) (1) ... unconditionally for the following synchronization states :
*
*                           (A) SYN-RECEIVED
*                           (B) SYN-SENT
*
*                       (2) ... but for the following connected states only when the TCP connection
*                               transmit queue is NOT closed  :
*
*                           (A) ESTABLISHED
*                           (B) FIN-WAIT-1
*                           (C) CLOSING
*                           (D) CLOSE-WAIT
*                           (E) LAST-ACK
*
*
* Argument(s) : p_conn_timeout       Pointer to TCP connection to perform re-transmit (see Note #3b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_TxConnReTxQ_TimeoutSet().
*
* Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : RETRANSMISSION TIMEOUT'
*                   states that "if the retransmission timeout expires ... send the segment at the
*                   front of the retransmission queue ... [and] reinitialize the retransmission timer".
*
*                   See also 'NetTCP_TxConnReTxQ()  Note #2'.
*
*               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (4) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection re-transmit queue timer ('ReTxQ_Tmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared prior to next handler function(s); ...
*                               (2) Cleared prior to invalid state fault exit.
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_RE_TX
*
*               (5) Certain network connections MUST periodically suspend network transmit(s) to handle
*                   network receive packet(s).  To protect TCP connections from transmit corruption while
*                   suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
*                   suspended connections until the connection is no longer suspended.
*
*                   However, handling the TCP connection's re-transmit timeout is permitted since NO new
*                   TCP data is prepared from the TCP connection's transmit queue (see Note #1a).
*
*                   See also 'NetTCP_TxConnTxQ()                    Note #12b2A2',
*                            'NetTCP_TxConnTxQ_TimeoutIdle()        Note #5',
*                            'NetTCP_TxConnTxQ_TimeoutSillyWin()    Note #5',
*                          & 'NetTCP_TxConnWinSizeZeroWinTimeout()  Note #5'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnReTxQ_Timeout (void  *p_conn_timeout)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CLOSE_CODE   close_code;
    NET_ERR              err;


    p_conn      = (NET_TCP_CONN *)p_conn_timeout;               /* See Note #3b2A.                                      */

    close_code =  NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_RE_TX);      /* See Note #4b1.                                       */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             p_conn->ReTxQ_Tmr = DEF_NULL;                      /* See Note #4a2A2.                                     */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;


        case NET_TCP_CONN_STATE_SYNC_RXD:                       /* See Note #1b1.                                       */
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CLOSED:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      p_conn->ReTxQ_Tmr = DEF_NULL;             /* See Note #4a2A2.                                     */
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1b2.                                       */
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             switch (p_conn->TxQ_State) {
                 case NET_TCP_TX_Q_STATE_CONN:
                 case NET_TCP_TX_Q_STATE_SUSPEND:               /* See Note #5.                                         */
                 case NET_TCP_TX_Q_STATE_CLOSING:
                 case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
                      break;


                 case NET_TCP_TX_Q_STATE_NONE:
                 case NET_TCP_TX_Q_STATE_CLOSED:
                 case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
                 default:
                      p_conn->ReTxQ_Tmr = DEF_NULL;             /* See Note #4a2A2.                                     */
                      return;
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }
#endif


                                                                /* --------- HANDLE TCP CONN RE-TX Q TIMEOUT ---------- */
    p_conn->ReTxQ_Tmr = DEF_NULL;                               /* Clr    re-tx Q tmr (see Note #4a2A1).                */

    NetTCP_TxConnReTxQ(p_conn, DEF_YES, close_code, &err);      /* Handle re-tx Q     (see Note #2).                    */
   (void)&err;                                                  /* Ignore ALL re-tx err(s), transitory or fatal.        */
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnReTxQ_TimeoutSet()
*
* Description : (1) (a) Set TCP connection's re-transmit queue timer for the following synchronization/
*                       connected states :
*
*                       (1) CLOSED
*                       (2) LISTEN
*                       (3) SYN-RECEIVED
*                       (4) SYN-SENT
*                       (5) ESTABLISHED
*                       (6) FIN-WAIT-1
*                       (7) CLOSING
*                       (8) CLOSE-WAIT
*                       (9) LAST-ACK
*
*                           (A) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : RETRANSMISSION
*                               TIMEOUT' reiterates that "for any state if the retransmission timeout expires
*                               on a segment in the retransmission queue ... reinitialize the retransmission
*                               timer".
*
*                   (b) However, since a TCP connection's transmit & re-transmit queue SHOULD be closed for
*                       the following states, it does NOT seem reasonable to set or reset a TCP connection's
*                       re-transmit queue timer for these states :
*
*                       (1) FIN-WAIT-2
*                       (2) TIME-WAIT
*
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in NetTCP_TxConnSync(),
*                                                         NetTCP_TxConnTxQ(),
*                                                         NetTCP_TxConnReTxQ(),
*                                                         NetTCP_RxPktConnHandlerReTxQ().
*
*               re_tx_q_timeout     Indicate whether the TCP connection re-transmit queue timed out :
*
*                                       DEF_NO                      TCP connection re-transmit queue did
*                                                                       NOT time  out.
*                                       DEF_YES                     TCP connection re-transmit queue
*                                                                           timed out.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                    TCP connection re-transmit queue timer
*                                                                       successfully set.
*                               NET_TCP_ERR_CONN_NOT_USED           TCP connection NOT currently used.
*                               NET_TCP_ERR_CONN_FAULT              TCP connection fault; connection(s) aborted.
*                               NET_TCP_ERR_INVALID_CONN_STATE      Invalid TCP connection state.
*                               NET_TCP_ERR_INVALID_CONN_OP         Invalid TCP connection operation.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnSync(),
*               NetTCP_TxConnTxQ(),
*               NetTCP_TxConnReTxQ(),
*               NetTCP_RxPktConnHandlerReTxQ().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnReTxQ_TimeoutSet (NET_TCP_CONN        *p_conn,
                                             CPU_BOOLEAN          re_tx_q_timeout,
                                             NET_TCP_CLOSE_CODE   close_code,
                                             NET_ERR             *p_err)
{
    NET_TMR_TICK  timeout_tick;
    NET_ERR       err;


#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------- VALIDATE TCP CONN STATE -------------- */
    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
            *p_err = NET_TCP_ERR_CONN_NOT_USED;
             return;


        case NET_TCP_CONN_STATE_FIN_WAIT_2:                     /* See Note #1b.                                        */
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_OP;
             return;


        case NET_TCP_CONN_STATE_CLOSED:                         /* See Note #1a.                                        */
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
            *p_err = NET_TCP_ERR_INVALID_CONN_STATE;
             return;
    }
#endif


                                                                /* ------------- SET TCP CONN RE-TX Q TMR ------------- */
    timeout_tick = p_conn->TxRTT_RTO_tick;

    if ((p_conn->ReTxQ_Tmr != DEF_NULL) &&                      /* If re-tx Q tmr avail  ..                             */
        (re_tx_q_timeout  ==  DEF_NO)) {                        /* .. but NOT timed out, ..                             */
        NetTmr_Set((NET_TMR    *) p_conn->ReTxQ_Tmr,            /* .. reset re-tx Q tmr.                                */
                   (CPU_FNCT_PTR)&NetTCP_TxConnReTxQ_Timeout,
                   (NET_TMR_TICK) timeout_tick,
                   (NET_ERR    *)&err);
    } else {                                                    /* Else get re-tx Q tmr.                                */
        p_conn->ReTxQ_Tmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_TxConnReTxQ_Timeout,
                                      (void        *) p_conn,
                                      (NET_TMR_TICK ) timeout_tick,
                                      (NET_ERR     *)&err);
    }

    if (err != NET_TMR_ERR_NONE) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                         (NET_TCP_CLOSE_CODE)close_code);
       *p_err = NET_TCP_ERR_CONN_FAULT;
        return;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                   NetTCP_TxConnPrepareSegAddrs()
*
* Description : Prepare TCP transmit segment addresses from TCP connection addresses.
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_TxConnAppData();
*                                        checked   in NetTCP_TxConnSync(),
*                                                     NetTCP_TxConnClose(),
*                                                     NetTCP_TxConnAck(),
*                                                     NetTCP_TxConnReset(),
*                                                     NetTCP_TxConnProbe().
*
*               p_src_addr       Pointer to  variable buffer that will receive the return source      address
*               ---------           (see Note #1), if NO error(s).
*
*                               Argument validated in NetTCP_TxConnAppData(),
*                                                     NetTCP_TxConnSync(),
*                                                     NetTCP_TxConnClose(),
*                                                     NetTCP_TxConnAck(),
*                                                     NetTCP_TxConnReset(),
*                                                     NetTCP_TxConnProbe().
*
*               p_src_port       Pointer to  variable buffer that will receive the return source      port number
*               ---------           (see Note #1), if NO error(s).
*
*                               Argument validated in NetTCP_TxConnAppData(),
*                                                     NetTCP_TxConnSync(),
*                                                     NetTCP_TxConnClose(),
*                                                     NetTCP_TxConnAck(),
*                                                     NetTCP_TxConnReset(),
*                                                     NetTCP_TxConnProbe().
*
*               src_addr_len    Size of the variable buffer that will receive the return source      address.
*
*               src_port_len    Size of the variable buffer that will receive the return source      port number.
*
*               p_dest_addr      Pointer to  variable buffer that will receive the return destination address
*               ----------          (see Note #1), if NO error(s).
*
*                               Argument validated in NetTCP_TxConnAppData(),
*                                                     NetTCP_TxConnSync(),
*                                                     NetTCP_TxConnClose(),
*                                                     NetTCP_TxConnAck(),
*                                                     NetTCP_TxConnReset(),
*                                                     NetTCP_TxConnProbe().
*
*               p_dest_port      Pointer to  variable buffer that will receive the return destination port number
*               ----------          (see Note #1), if NO error(s).
*
*                               Argument validated in NetTCP_TxConnAppData(),
*                                                     NetTCP_TxConnSync(),
*                                                     NetTCP_TxConnClose(),
*                                                     NetTCP_TxConnAck(),
*                                                     NetTCP_TxConnReset(),
*                                                     NetTCP_TxConnProbe().
*
*               dest_addr_len   Size of the variable buffer that will receive the return destination address.
*
*               dest_port_len   Size of the variable buffer that will receive the return destination port number.
*
*               p_err            Pointer to variable that will receive the return error code from this function :
*
*                                   NET_TCP_ERR_NONE                TCP connection addresses successfully
*                                                                       prepared.
*
*                                   NET_CONN_ERR_INVALID_FAMILY     Invalid     connection family.
*                                   NET_CONN_ERR_INVALID_ADDR       Invalid TCP connection address.
*                                   NET_CONN_ERR_INVALID_ADDR_LEN   Invalid TCP connection address length.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnAppData(),
*               NetTCP_TxConnSync(),
*               NetTCP_TxConnClose(),
*               NetTCP_TxConnAck(),
*               NetTCP_TxConnReset(),
*               NetTCP_TxConnProbe().
*
* Note(s)     : (1) Variable buffers to receive the returned port & address values may start on any CPU address,
*                   word-aligned or not.
*
*                   See also 'net_util.h  NETWORK DATA VALUE MACRO'S  Note #2b'.
*
*               (2) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
*                   since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
*                   is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
*                   The 'else'-conditional code is included for completeness & as an extra precaution in case
*                   'net_conn.h' is incorrectly modified.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnPrepareSegAddrs (NET_TCP_CONN  *p_conn,
                                            CPU_INT08U    *p_src_addr,
                                            CPU_INT08U    *p_src_port,
                                            CPU_INT16U     src_addr_len,
                                            CPU_INT16U     src_port_len,
                                            CPU_INT08U    *p_dest_addr,
                                            CPU_INT08U    *p_dest_port,
                                            CPU_INT16U     dest_addr_len,
                                            CPU_INT16U     dest_port_len,
                                            NET_ERR       *p_err)
{
    NET_CONN_ID         conn_id;
    NET_CONN           *p_net_conn;
    NET_CONN_ADDR_LEN   addr_len;
    CPU_INT08U          addr_local[NET_CONN_ADDR_LEN_MAX];
    CPU_INT08U          addr_remote[NET_CONN_ADDR_LEN_MAX];
    NET_ERR             err;


    conn_id    =  p_conn->ID_Conn;
    p_net_conn = &NetConn_Tbl[conn_id];

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
                                                                /* ---------------- VALIDATE ADDR LENS ---------------- */
    if (p_net_conn->Family == NET_CONN_FAMILY_IP_V4_SOCK) {
#ifdef  NET_IPv4_MODULE_EN
        if (src_addr_len  != NET_CONN_ADDR_IP_V4_LEN_ADDR) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }
        if (src_port_len  != NET_CONN_ADDR_IP_LEN_PORT) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }

        if (dest_addr_len != NET_CONN_ADDR_IP_V4_LEN_ADDR) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }
        if (dest_port_len != NET_CONN_ADDR_IP_LEN_PORT) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }
#endif
    } else if (p_net_conn->Family == NET_CONN_FAMILY_IP_V6_SOCK) {
#ifdef  NET_IPv6_MODULE_EN
        if (src_addr_len  != NET_CONN_ADDR_IP_V6_LEN_ADDR) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }
        if (src_port_len  != NET_CONN_ADDR_IP_LEN_PORT) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }

        if (dest_addr_len != NET_CONN_ADDR_IP_V6_LEN_ADDR) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }
        if (dest_port_len != NET_CONN_ADDR_IP_LEN_PORT) {
           *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
            return;
        }
#endif
    } else {

                                                                /* See Note #2.                                         */
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )DEF_YES,
                         (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_CONN_ERR_INVALID_FAMILY;
        return;
    }

#else                                                           /* Prevent 'variable unused' compiler warnings.         */
   (void)&src_addr_len;
   (void)&src_port_len;
   (void)&dest_addr_len;
   (void)&dest_port_len;
#endif


                                                                /* ------------------ PREPARE ADDRS ------------------- */
    conn_id  = p_conn->ID_Conn;

    addr_len = sizeof(addr_local);
    NetConn_AddrLocalGet((NET_CONN_ID        ) conn_id,         /* Get local/src addr.                                  */
                         (CPU_INT08U        *)&addr_local[0],
                         (NET_CONN_ADDR_LEN *)&addr_len,
                         (NET_ERR           *)&err);
    if ( err != NET_CONN_ERR_NONE) {
       *p_err  = NET_CONN_ERR_INVALID_ADDR;
        return;
    }
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (addr_len > NET_CONN_ADDR_LEN_MAX) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )DEF_YES,
                         (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
        return;
    }
#endif

    addr_len = sizeof(addr_remote);
    NetConn_AddrRemoteGet((NET_CONN_ID        ) conn_id,        /* Get remote/dest addr.                                */
                          (CPU_INT08U        *)&addr_remote[0],
                          (NET_CONN_ADDR_LEN *)&addr_len,
                          (NET_ERR           *)&err);
    if ( err != NET_CONN_ERR_NONE) {
       *p_err  = NET_CONN_ERR_INVALID_ADDR;
        return;
    }
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (addr_len > NET_CONN_ADDR_LEN_MAX) {
        NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                         (NET_BUF_HDR      *)0,
                         (CPU_BOOLEAN       )DEF_YES,
                         (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
       *p_err = NET_CONN_ERR_INVALID_ADDR_LEN;
        return;
    }
#endif


                                                                /* Prepare src/dest addrs (see Note #1).                */
    switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_CONN_FAMILY_IP_V4_SOCK:
                                                                /* Cfg local  addr as pkt src  addr.                    */
             NET_UTIL_VAL_COPY_GET_NET_16(p_src_port,  &addr_local [NET_CONN_ADDR_IP_IX_PORT]);
             NET_UTIL_VAL_COPY_GET_NET_32(p_src_addr,  &addr_local [NET_CONN_ADDR_IP_V4_IX_ADDR]);
                                                                /* Cfg remote addr as pkt dest addr.                    */
             NET_UTIL_VAL_COPY_GET_NET_16(p_dest_port, &addr_remote[NET_CONN_ADDR_IP_IX_PORT]);
             NET_UTIL_VAL_COPY_GET_NET_32(p_dest_addr, &addr_remote[NET_CONN_ADDR_IP_V4_IX_ADDR]);
             break;
#endif
#ifdef  NET_IPv6_MODULE_EN
        case NET_CONN_FAMILY_IP_V6_SOCK:
             NET_UTIL_VAL_COPY_GET_NET_16(p_src_port,  &addr_local [NET_CONN_ADDR_IP_IX_PORT]);
             Mem_Copy(p_src_addr, &addr_local [NET_CONN_ADDR_IP_V6_IX_ADDR], src_addr_len);
                                                                /* Cfg remote addr as pkt dest addr.                    */
             NET_UTIL_VAL_COPY_GET_NET_16(p_dest_port, &addr_remote[NET_CONN_ADDR_IP_IX_PORT]);
             Mem_Copy(p_dest_addr, &addr_remote [NET_CONN_ADDR_IP_V6_IX_ADDR], dest_addr_len);
             break;
#endif
        default:
                                                                /* See Note #2.                                         */
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_ALL);
            *p_err = NET_CONN_ERR_INVALID_FAMILY;
             return;
    }


   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                       NetTCP_TxConnRTT_Init()
*
* Description : Initialize TCP connection's transmit round-trip time (RTT) controls.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTT_Reset(),
*                                                 NetTCP_TxConnRTT_RTO_Init().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTT_Reset(),
*               NetTCP_TxConnRTT_RTO_Init().
*
* Note(s)     : (1) (A) RFC #1122, Section 4.2.3.1 states that "the following values SHOULD be
*                       used to initialize the estimation parameters for a new connection" :
*
*                           (a) RTT = 0 seconds
*
*                                   where
*                                           RTT                 Round-Trip Time
*
*                       (1) Furthermore, RFC #1122, Section 4.2.3.1.(b) states that "the
*                           smoothed variance is to be initialized to the value that will
*                           result in" these values.
*
*                   (B) However, since RFC #2988, Section 2.2 amends the RFC #1122, Section
*                       4.2.3.1 RTT initialization; the smoothed RTT average & deviation do
*                       NOT truly require explicit initialization.  Nonetheless, these RTT
*                       values are initialized to conform with RFC #1122, Section 4.2.3.1.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTT_Init (NET_TCP_CONN  *p_conn)
{
                                                                /* Init RTT     (see Note #1).                          */
    p_conn->TxRTT_Avg_ms_scaled = NET_TCP_TX_RTT_AVG_INIT_MS_SCALED; /* Init RTT avg (see Note #1Aa).                   */
    p_conn->TxRTT_Dev_ms_scaled = NET_TCP_TX_RTT_DEV_INIT_MS_SCALED; /* Init RTT dev (see Note #1A1).                   */

    NetTCP_TxConnRTT_CalcUpdate(p_conn);
}


/*
*********************************************************************************************************
*                                      NetTCP_TxConnRTT_Reset()
*
* Description : Reset TCP connection's transmit round-trip time (RTT) controls.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTT_RTO_Calc().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTT_RTO_Calc().
*
* Note(s)     : (1) (a) RFC #2988, Section 5 states "that a TCP implementation MAY clear SRTT and
*                       RTTVAR after backing off the timer multiple times as it is likely that the
*                       current SRTT and RTTVAR are bogus in this situation.  Once SRTT and RTTVAR
*                       are cleared they should be initialized with the next RTT sample taken".
*
*                   (b) RFC #2581, Section 4.1 states that "after TCP has been idle for ... an
*                       interval exceeding the retransmission timeout ... use slow start to
*                       restart transmission".
*
*                       Similarly, although NO RFC specifies that a TCP connection's RTT average &
*                       deviation should be reset following a TCP transmit idle timeout; it seems
*                       reasonable to reset a TCP connection's RTT average & deviation controls
*                       whenever a TCP connection's transmit is idle for a period exceeding the
*                       re-transmit timeout.
*
*                   See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4A'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTT_Reset (NET_TCP_CONN  *p_conn)
{
    NetTCP_TxConnRTT_Init(p_conn);

    p_conn->TxRTT_RTO_State = NET_TCP_TX_RTT_RTO_STATE_RESET;
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnRTT_CalcUpdate()
*
* Description : Update TCP connection's transmit round-trip time (RTT) control calculations.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTT_Init(),
*                                                 NetTCP_TxConnRTT_RTO_Calc().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTT_Init(),
*               NetTCP_TxConnRTT_RTO_Calc().
*
* Note(s)     : (1) A TCP connection's transmit round-trip time controls should NOT be updated until
*                   after the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's transmit round-trip time average   (in scaled milliseconds)
*                                                                            ['TxRTT_Avg_ms_scaled']
*
*                   (b) TCP connection's transmit round-trip time deviation (in scaled milliseconds)
*                                                                            ['TxRTT_Dev_ms_scaled']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTT_CalcUpdate (NET_TCP_CONN  *p_conn)
{
    p_conn->TxRTT_Avg_ms = (NET_TCP_TIMEOUT_MS)(p_conn->TxRTT_Avg_ms_scaled / NET_TCP_TX_RTT_SCALE);
    p_conn->TxRTT_Dev_ms = (NET_TCP_TIMEOUT_MS)(p_conn->TxRTT_Dev_ms_scaled / NET_TCP_TX_RTT_SCALE);
}


/*
*********************************************************************************************************
*                                       NetTCP_TxConnRTO_Init()
*
* Description : (1) Initialize TCP connection's re-transmit timeout (RTO) controls :
*
*                   (a) Initialize RTO                                      See Note #2
*                   (b) Configure  RTO maximum timeout                      See Note #3
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTT_RTO_Init().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTT_RTO_Init().
*
* Note(s)     : (2) RFC #1122, Section 4.2.3.1 states that "the following values SHOULD be
*                   used to initialize the estimation parameters for a new connection" :
*
*                       (b) RTO = 3 seconds
*
*                               where
*                                       RTO                 Retransmission Timeout
*
*                   (A) RFC #2988, Section 2.1 reiterates that "until a round-trip time (RTT)
*                       measurement has been made ... the sender SHOULD set RTO <- 3 seconds".
*
*               (3) A TCP connection's re-transmit timeout controls should NOT be updated until
*                   after the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's maximum re-transmit timeout (in seconds)  ['TxRTT_RTO_Max_sec']
*                          [see 'NetTCP_TxConnRTO_CfgMaxTimeout()  Note #2a']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTO_Init (NET_TCP_CONN  *p_conn)
{
    p_conn->TxRTT_RTO_ms_scaled = NET_TCP_TX_RTT_RTO_INIT_MS_SCALED; /* Init RTO (see Note #2).                         */

    NetTCP_TxConnRTO_CalcUpdate_ms_scaled(p_conn);


    NetTCP_TxConnRTO_CfgMaxTimeout(p_conn);                     /* Cfg RTO max timeout (see Note #3).                   */
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnRTO_CfgMaxTimeout()
*
* Description : Configure TCP connection's maximum re-transmit timeout (RTO).
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTO_Init(),
*                                                 NetTCP_ConnCfgReTxMaxTimeout().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTO_Init(),
*               NetTCP_ConnCfgReTxMaxTimeout().
*
* Note(s)     : (1) (a) RFC #2988, Section 2.4 states that "a maximum value MAY be placed on RTO provided
*                       it is at least 60 seconds".
*
*                   (b) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper bound
*                       should be 2*MSL".
*
*                   (c) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299 states
*                       that "the timeout value ... [has] an upper limit of 64 seconds".
*
*               (2) A TCP connection's maximum re-transmit timeouts (in scaled milliseconds or milliseconds)
*                   should NOT be updated until after the following TCP connection control(s) have been
*                   configured :
*
*                   (a) TCP connection's maximum re-transmit timeout (in seconds)  ['TxRTT_RTO_Max_sec']
*                           [see 'NetTCP_ConnClr()  Note #12'
*                              & 'NetTCP_ConnCfgReTxMaxTimeout()  Note #3']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTO_CfgMaxTimeout (NET_TCP_CONN  *p_conn)
{
    p_conn->TxRTT_RTO_Max_ms_scaled = (NET_TCP_TX_RTT_MS_SCALED)p_conn->TxRTT_RTO_Max_sec * NET_TCP_TX_RTT_MS_SCALE;
    p_conn->TxRTT_RTO_Max_ms        = (NET_TCP_TIMEOUT_MS      )p_conn->TxRTT_RTO_Max_sec * DEF_TIME_NBR_mS_PER_SEC;
}


/*
*********************************************************************************************************
*                                    NetTCP_TxConnRTO_CalcUpdate()
*
* Description : Update TCP connection's re-transmit timeout (RTO) control calculations (see Note #1a).
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTO_CalcUpdate_ms(),
*                                                 NetTCP_TxConnRTO_CalcUpdate_ms_scaled().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTO_CalcUpdate_ms(),
*               NetTCP_TxConnRTO_CalcUpdate_ms_scaled().
*
* Note(s)     : (1) A TCP connection's re-transmit timeout controls should NOT be updated until
*                   after the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's re-transmit timeout (in milliseconds)
*                                                             ['TxRTT_RTO_ms']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTO_CalcUpdate (NET_TCP_CONN  *p_conn)
{
    p_conn->TxRTT_RTO_sec  =  (NET_TCP_TIMEOUT_SEC)(p_conn->TxRTT_RTO_ms / DEF_TIME_NBR_mS_PER_SEC);
    p_conn->TxRTT_RTO_tick = ((NET_TMR_TICK       ) p_conn->TxRTT_RTO_ms * NET_TMR_TIME_TICK_PER_SEC) / DEF_TIME_NBR_mS_PER_SEC;
}


/*
*********************************************************************************************************
*                                  NetTCP_TxConnRTO_CalcUpdate_ms()
*
* Description : Update TCP connection's re-transmit timeout (RTO) control calculations for updated
*                   millisecond RTO ('TxRTT_RTO_ms') [see Note #1a].
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTT_RTO_Calc().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTT_RTO_Calc().
*
* Note(s)     : (1) A TCP connection's re-transmit timeout controls should NOT be updated until
*                   after the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's re-transmit timeout (in milliseconds)
*                                                             ['TxRTT_RTO_ms']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTO_CalcUpdate_ms (NET_TCP_CONN  *p_conn)
{
    p_conn->TxRTT_RTO_ms_scaled = (NET_TCP_TX_RTT_MS_SCALED)(p_conn->TxRTT_RTO_ms * NET_TCP_TX_RTT_SCALE);
    NetTCP_TxConnRTO_CalcUpdate(p_conn);
}


/*
*********************************************************************************************************
*                               NetTCP_TxConnRTO_CalcUpdate_ms_scaled()
*
* Description : Update TCP connection's re-transmit timeout (RTO) control calculations for updated scaled
*                   millisecond RTO ('TxRTT_RTO_ms_scaled') [see Note #1a].
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTO_Init(),
*                                                 NetTCP_TxConnRTT_RTO_Calc().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnRTO_Init(),
*               NetTCP_TxConnRTT_RTO_Calc().
*
* Note(s)     : (1) A TCP connection's re-transmit timeout controls should NOT be updated until
*                   after the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's re-transmit timeout (in scaled milliseconds)
*                                                             ['TxRTT_RTO_ms_scaled']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTO_CalcUpdate_ms_scaled (NET_TCP_CONN  *p_conn)
{
    p_conn->TxRTT_RTO_ms = (NET_TCP_TIMEOUT_MS)(p_conn->TxRTT_RTO_ms_scaled / NET_TCP_TX_RTT_SCALE);
    NetTCP_TxConnRTO_CalcUpdate(p_conn);
}


/*
*********************************************************************************************************
*                                   NetTCP_TxConnRTO_CalcBackOff()
*
* Description : Calculate next backed-off re-transmit timeout (RTO) value.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_TxConnRTT_RTO_Calc(),
*                                                 NetTCP_TxConnWinSizeZeroWinHandler().
*
*               rto_ms      Current re-transmit timeout value (in milliseconds).
*
* Return(s)   : Backed-off re-transmit timeout value (in milliseconds).
*
* Caller(s)   : NetTCP_TxConnRTT_RTO_Calc(),
*               NetTCP_TxConnWinSizeZeroWinHandler().
*
* Note(s)     : (1) (a) RFC #1122, Section 4.2.3.1 states that an "implementation MUST also include
*                       'exponential backoff' for successive RTO values for the same segment".
*
*                       (1) RFC #2988, Section 5.5 states that "when the retransmission timer expires
*                           ... the host MUST set RTO <- RTO * 2 ('back off the timer')".
*
*                           Thus the TCP retransmission timer exponential back-off scalar value is 2.
*
*                       (2) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299
*                           reiterates that "this doubling is called an 'exponential backoff'".
*
*                   (b) (1) RFC #2988, Section 2.4 adds that "a maximum value MAY be placed on RTO
*                           provided it is at least 60 seconds".
*
*                       (2) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper
*                           bound should be 2*MSL".
*
*                       (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299
*                           states that "the timeout value is doubled for each retransmission, with an
*                           upper limit of 64 seconds".
*
*                       See also 'NetTCP_TxConnRTO_CfgMaxTimeout()  Note #1'.
*
*               (2) RFC #1122, Section 4.2.2.17 states that "zero-window probe[s] ... SHOULD increase
*                   exponentially the interval between successive probes ... Exponential backoff is
*                   recommended ... similar to ... the retransmission algorithm, and it may be possible
*                   to combine the two procedures in the implementation".
*
*                   See also 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1b2'.
*********************************************************************************************************
*/

static  NET_TCP_TIMEOUT_MS  NetTCP_TxConnRTO_CalcBackOff (NET_TCP_CONN        *p_conn,
                                                          NET_TCP_TIMEOUT_MS   rto_ms)
{
    NET_TCP_TIMEOUT_MS  rto_ms_backoff_calcd;
    NET_TCP_TIMEOUT_MS  rto_ms_backoff;

                                                                /* Calc  backed-off RTO timeout val (see Note #1a).     */
    rto_ms_backoff_calcd = (rto_ms < p_conn->TxRTT_RTO_Max_ms)
                         ? (rto_ms * NET_TCP_TX_RTO_TIMEOUT_BACKOFF_SCALAR)
                         :  p_conn->TxRTT_RTO_Max_ms;
                                                                /* Limit backed-off RTO timeout val (see Note #1b).     */
    rto_ms_backoff       =  DEF_MIN(rto_ms_backoff_calcd, p_conn->TxRTT_RTO_Max_ms);

    return (rto_ms_backoff);
}


/*
*********************************************************************************************************
*                                     NetTCP_TxConnRTT_RTO_Init()
*
* Description : Initialize TCP connection's transmit round-trip time (RTT) & re-transmit timeout (RTO) values.
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_ConnCfg().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnCfg().
*
* Note(s)     : (1) A TCP connection's re-transmit timeout controls should NOT be updated until
*                   after the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's maximum re-transmit timeout (in seconds)  ['TxRTT_RTO_Max_sec']
*                          [see 'NetTCP_TxConnRTO_Init()  Note #3']
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTT_RTO_Init (NET_TCP_CONN  *p_conn)
{
    NetTCP_TxConnRTT_Init(p_conn);
    NetTCP_TxConnRTO_Init(p_conn);

    p_conn->TxRTT_RTO_State = NET_TCP_TX_RTT_RTO_STATE_INIT;
}


/*
*********************************************************************************************************
*                                     NetTCP_TxConnRTT_RTO_Calc()
*
* Description : (1) Calculate TCP connection's transmit round-trip time (RTT) & re-transmit timeout (RTO) values :
*
*                   (a) Perform requested RTT/RTO calculation operation(s)
*                   (b) Prepare & perform RTT     calculations
*                   (c) Prepare & perform RTO     calculations
*
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_RxPktConnHandlerReTxQ(),
*                                                     NetTCP_TxConnReTxQ(),
*                                                     NetTCP_TxConnTxQ_TimeoutIdle().
*
*               calc_code       Indicate which TCP connection transmit round-trip time (RTT) & re-transmit
*                                   timeout (RTO) calculations to perform (see Note #1a) :
*
*                                   NET_TCP_CONN_TX_RTT_RTO_INIT    Initialize TCP connection's RTT & RTO controls
*                                                                       (see 'NetTCP_TxConnRTT_Init()  Note #1'
*                                                                          & 'NetTCP_TxConnRTO_Init()  Note #2').
*
*                                   NET_TCP_CONN_TX_RTT_RESET       Reset      TCP connection's RTT       controls.
*
*                                   NET_TCP_CONN_TX_RTT_RTO_CALC    Calculate  TCP connection's RTT & RTO controls.
*
*                                   NET_TCP_CONN_TX_RTO_BACKOFF     Back-off   TCP connection's       RTO controls.
*
*               rtt_ts_txd_ms   Round-trip timestamp when TCP segment/packet  transmitted (in milliseconds).
*
*               rtt_ts_rxd_ms   Round-trip timestamp when TCP acknowledgement received    (in milliseconds).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerReTxQ(),
*               NetTCP_TxConnReTxQ(),
*               NetTCP_TxConnTxQ_TimeoutIdle().
*
* Note(s)     : (2) (a) (1) RFC #2988, Section 2 states that "the rules governing the computation of SRTT
*                           (smoothed round-trip time), RTTVAR RTTVAR (round-trip time variation), and RTO
*                           are as follows" :
*
*                           (A) RFC #2988, Section 2.2 states that for "the first RTT measurement R ...
*                               the host MUST set" :
*
*                                   (1) SRTT    <-  R
*                                   (2) RTTVAR  <-  R/2
*                                   (3) RTO     <-  SRTT  +  max(G, K * RTTVAR)
*
*                                            where
*                                                   SRTT                    RTT Smoothed Average
*                                                   RTTVAR                  RTT Variance/Deviation
*                                                   RTO                         Retransmission Timeout
*                                                   R                       RTT First Measurement
*                                   (4)             R   = R * 1             RTT First Average   Gain
*                                   (5)             R/2 = R * 1/2           RTT First Deviation Gain
*                                                   G                       RTT Clock Granularity (resolution)
*                                   (6)             K = 4                   RTT-RTO Gain
*
*
*                           (B) RFC #2988, Section 2.3 states that for "subsequent RTT measurement R' ...
*                               a host MUST set" :
*
*                                   (1) RTTVAR  <-  (1 - beta ) * RTTVAR  +  beta  * |SRTT - R'|
*                                   (2) SRTT    <-  (1 - alpha) * SRTT    +  alpha * R'
*                                   (3) RTO     <-  SRTT  +  max(G, K * RTTVAR)
*
*                                            where
*                                                   SRTT                    RTT Smoothed Average
*                                                   RTTVAR                  RTT Variance/Deviation
*                                                   RTO                         Retransmission Timeout
*                                                   R'                      RTT Subsequent Measurement(s)
*                                   (4)             alpha = 1/8             RTT-Average    Gain
*                                   (5)             beta  = 1/4             RTT-Deviation  Gain
*                                                   G                       RTT Clock Granularity (resolution)
*                                   (6)             K = 4                   RTT-RTO Gain
*
*
*                               (a) RFC #2988, Section 2.3 states tht "updating RTTVAR and SRTT MUST be
*                                   computed in ... order ... [since] the value of SRTT used in the update
*                                   to RTTVAR is its value before updating SRTT itself".
*
*                               (b) To reduce the total number of operations for both RTT calculations,
*                                   the equations SHOULD be factored & rearranged as follows :
*
*                                       (1) (A) RTTVAR  <-       (1 - beta) * RTTVAR  +  beta * |SRTT - R'|
*
*                                           (B) RTTVAR  <-  RTTVAR  -  beta * RTTVAR  +  beta * |SRTT - R'|
*
*                                           (C) RTTVAR  <-  RTTVAR  +  beta * (|SRTT - R'| - RTTVAR)
*
*                                           (D) RTTVAR  <-  RTTVAR  +  beta * (|R' - SRTT| - RTTVAR)
*
*
*                                       (2) (A) SRTT    <-     (1 - alpha) * SRTT  +  alpha * R'
*
*                                           (B) SRTT    <-  SRTT  -  alpha * SRTT  +  alpha * R'
*
*                                           (C) SRTT    <-  SRTT  +  alpha * (R' - SRTT)
*
*
*                       (2) (A) RFC #793, Section 3.7 'Data Communication : Retransmission Timeout' states
*                               that "the Round Trip Time (RTT) ... [is] the elapsed time between" :
*
*                               (1) "sending a data octet with a particular sequence number and"   ...
*                               (2) "receiving an acknowledgment that covers that sequence number" ...
*                               (3) "(segments sent do not have to match segments received)".
*
*                           (B) (1) RFC #2988, Section 3 adds that :
*
*                                   (a) "Traditionally, TCP implementations have taken one RTT measurement at
*                                        a time (typically once per RTT)."
*                                   (b) "A TCP implementation MUST take at least one RTT measurement per RTT
*                                        (unless that is not possible per Karn's algorithm) [see Note #2a5]".
*                                   (c) "For fairly modest congestion window sizes research suggests that
*                                        timing each segment does not lead to a better RTT estimator."
*                                   (d) "Additionally, when multiple samples are taken per RTT the alpha and
*                                        beta ... may keep an inadequate RTT history."
*
*                               (2) RFC #2988, Section 1 states that "in some situations it may be beneficial
*                                   for a TCP sender to be more conservative than the algorithms detailed in
*                                   this document allow.  However, a TCP MUST NOT be more aggressive than the
*                                   ... algorithms allow".
*
*                                   Thus the following TCP algorithm(s) are permitted; even if the algorithms
*                                   delay or decrease the number of received acknowledgements, which thereby
*                                   increases the measured time values for RTT samples :
*
*                                       (a) Karn's Algorithm                    See  Note #2a5
*                                       (b) TCP Delayed Acknowledgements        See 'NetTCP_TxConnAck()  Note #6'
*
*                       (3) Jacobson/Karels, "Congestion Avoidance and Control", Appendix A.2 states that RTT
*                           calculations "should be done in integer arithmetic".  RFC #2988, Section 2.3 adds
*                           that RTT calculations "SHOULD be computed using ... 1/8 and ... 1/4" gains (see
*                           Notes #2a1B4 & #2a1B5).
*
*                       (4) (A) (1) RFC #2988, Section 5 states "that a TCP implementation MAY clear SRTT and
*                                   RTTVAR after backing off the timer multiple times as it is likely that the
*                                   current SRTT and RTTVAR are bogus in this situation.  Once SRTT and RTTVAR
*                                   are cleared they should be initialized with the next RTT sample taken per
*                                   [Note #2a1A] rather than using [Note #2a1B]".
*
*                               (2) RFC #2581, Section 4.1 states that "after TCP has been idle for ... an
*                                   interval exceeding the retransmission timeout ... use slow start to
*                                   restart transmission".
*
*                                   Similarly, although NO RFC specifies that a TCP connection's RTT average
*                                   & deviation should be reset following a TCP transmit idle timeout; it
*                                   seems reasonable to reset a TCP connection's RTT average & deviation
*                                   controls whenever a TCP connection's transmit is idle for a period
*                                   exceeding the re-transmit timeout.
*
*                               See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2b'.
*
*                           (B) However, a TCP connection's RTO timeout controls do NOT need to also be
*                               explicitly reset since RFC #2988, Section 5 states that "once a new RTT
*                               measurement is obtained (which can only happen when new data has been
*                               sent and acknowledged), the computations ... of RTO ... are performed".
*
*                       (5) RFC #2988, Section 3 states that "TCP MUST use Karn's algorithm ... for
*                           taking RTT samples.  That is, RTT samples MUST NOT be made using segments
*                           that were retransmitted (and thus for which it is ambiguous whether the
*                           reply was for the first instance of the packet or a later instance)".
*
*                   (b) (1) (A) (1) RFC #2988, Section 2.4 states that "whenever RTO is computed, if it
*                                   is less than 1 second then the RTO SHOULD be rounded up to 1 second".
*
*                                   (a) This amends RFC #1122, Section 4.2.3.1 which previously stated
*                                       that "the recommended ... RTO ... lower bound ... SHOULD be
*                                       measured in fractions of a second".
*
*                               (2) RFC #2988, Section 4 states that "there is no requirement for the
*                                   clock granularity G used for computing RTT measurements ... However,
*                                   if the K*RTTVAR term in the RTO calculation equals zero, the variance
*                                   term MUST be rounded to G seconds".
*
*                                   See also Notes #2a1A3 & #2a1B3.
*
*                           (B) (1) RFC #2988, Section 2.4 adds that "a maximum value MAY be placed on
*                                   RTO provided it is at least 60 seconds".
*
*                               (2) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ...
*                                   upper bound should be 2*MSL".
*
*                               (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2,
*                                   Page 299 states that "the timeout value ... [has] an upper limit of
*                                   64 seconds".
*
*                               See also 'net_tcp.c  NetTCP_TxConnRTO_CfgMaxTimeout()  Note #1'.
*
*                       (2) RFC #1122, Section 4.2.3.1 reiterates that an "implementation MUST also
*                           include 'exponential backoff' for successive RTO values for the same
*                           segment".
*
*                           (a) RFC #2988, Section 5.5 states that "when the retransmission timer
*                               expires ... the host MUST set RTO <- RTO * 2 ('back off the timer')".
*
*                               Thus the TCP retransmission timer exponential back-off scalar
*                               value is 2.
*
*                           (b) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2,
*                               Page 299 reiterates that "this doubling is called an 'exponential
*                               backoff'".
*
*                           See also 'NetTCP_TxConnRTO_CalcBackOff()  Note #1'.
*********************************************************************************************************
*/

static  void  NetTCP_TxConnRTT_RTO_Calc (NET_TCP_CONN          *p_conn,
                                         NET_TCP_CALC_CODE      calc_code,
                                         NET_TCP_TX_RTT_TS_MS   rtt_ts_txd_ms,
                                         NET_TCP_TX_RTT_TS_MS   rtt_ts_rxd_ms)
{
    NET_TCP_TX_RTT_MS         rtt_cur_ms;
    NET_TCP_TX_RTT_MS_SCALED  rtt_cur_ms_scaled;
    NET_TCP_TX_RTT_MS_SCALED  rtt_err_ms_scaled;
    NET_TCP_TX_RTT_MS_SCALED  rtt_err_ms_scaled_abs;
    NET_TCP_TX_RTT_MS_SCALED  rtt_avg_ms_scaled;
    NET_TCP_TX_RTT_MS_SCALED  rtt_dev_ms_scaled;
    NET_TCP_TX_RTT_MS_SCALED  rtt_dev_ms_scaled_gain;
    NET_TCP_TX_RTT_MS_SCALED  rtt_dev_ms_scaled_max;
    NET_TCP_TX_RTT_MS_SCALED  rto_ms_scaled;



                                                                /* ---------------- PERFORM CALC CODE ----------------- */
    switch (calc_code) {
        case NET_TCP_CONN_TX_RTT_RTO_CALC:
             break;


        case NET_TCP_CONN_TX_RTO_BACKOFF:                       /* Back-off RTO (see Note #2b2).                        */
             p_conn->TxRTT_RTO_ms = NetTCP_TxConnRTO_CalcBackOff(p_conn, p_conn->TxRTT_RTO_ms);
             NetTCP_TxConnRTO_CalcUpdate_ms(p_conn);
                                                                /* 'break' intentionally omitted; MUST execute ...      */
                                                                /* ...  the following case (see Note #1c1A) :  ...      */
                                                                /* --------- ... 'NET_TCP_CONN_TX_RTT_RESET'. --------- */
        case NET_TCP_CONN_TX_RTT_RESET:                         /* See Note #2a4.                                       */
             NetTCP_TxConnRTT_Reset(p_conn);
             return;


        case NET_TCP_CONN_TX_RTT_RTO_INIT:
        default:
             NetTCP_TxConnRTT_RTO_Init(p_conn);
             return;
    }



                                                                /* ---------------- PREPARE RTT CALCS ----------------- */
    switch (p_conn->TxRTT_RTO_State) {
        case NET_TCP_TX_RTT_RTO_STATE_INIT:
        case NET_TCP_TX_RTT_RTO_STATE_RESET:
        case NET_TCP_TX_RTT_RTO_STATE_CALC:
             rtt_cur_ms        = (NET_TCP_TX_RTT_MS       )(rtt_ts_rxd_ms - rtt_ts_txd_ms);
             rtt_cur_ms_scaled = (NET_TCP_TX_RTT_MS_SCALED)(rtt_cur_ms    * NET_TCP_TX_RTT_SCALE);
             break;


        case NET_TCP_TX_RTT_RTO_STATE_NONE:
        case NET_TCP_TX_RTT_RTO_STATE_RE_TX:                    /* See Note #2a5.                                       */
        default:
             return;
    }

                                                                /* ---------------- PERFORM RTT CALCS ----------------- */
    switch (p_conn->TxRTT_RTO_State) {
        case NET_TCP_TX_RTT_RTO_STATE_INIT:                     /* Init   RTT calcs (see Notes #2a1A1 & #2a1A2).        */
        case NET_TCP_TX_RTT_RTO_STATE_RESET:
             rtt_avg_ms_scaled      = (rtt_cur_ms_scaled * NET_TCP_TX_RTT_GAIN_AVG_INIT_NUMER)
                                                         / NET_TCP_TX_RTT_GAIN_AVG_INIT_DENOM;

             rtt_dev_ms_scaled      = (rtt_cur_ms_scaled * NET_TCP_TX_RTT_GAIN_DEV_INIT_NUMER)
                                                         / NET_TCP_TX_RTT_GAIN_DEV_INIT_DENOM;

             p_conn->TxRTT_RTO_State =  NET_TCP_TX_RTT_RTO_STATE_CALC;
             break;


        case NET_TCP_TX_RTT_RTO_STATE_CALC:                     /* Update RTT calcs (see Notes #2a1Bb1D & #2a1Bb2C).    */
             rtt_err_ms_scaled     =         rtt_cur_ms_scaled  - p_conn->TxRTT_Avg_ms_scaled;
             rtt_err_ms_scaled_abs = DEF_ABS(rtt_err_ms_scaled);

             rtt_dev_ms_scaled     = p_conn->TxRTT_Dev_ms_scaled + (((rtt_err_ms_scaled_abs - p_conn->TxRTT_Dev_ms_scaled) * NET_TCP_TX_RTT_GAIN_DEV_NUMER)
                                                                                                                         / NET_TCP_TX_RTT_GAIN_DEV_DENOM);

             rtt_avg_ms_scaled     = p_conn->TxRTT_Avg_ms_scaled +  ((rtt_err_ms_scaled                                   * NET_TCP_TX_RTT_GAIN_AVG_NUMER)
                                                                                                                         / NET_TCP_TX_RTT_GAIN_AVG_DENOM);
             break;


        case NET_TCP_TX_RTT_RTO_STATE_NONE:
        case NET_TCP_TX_RTT_RTO_STATE_RE_TX:                    /* See Note #2a5.                                       */
        default:
             return;
    }

                                                                /* -------------------- UPDATE RTT -------------------- */
    p_conn->TxRTT_Avg_ms_scaled = rtt_avg_ms_scaled;
    p_conn->TxRTT_Dev_ms_scaled = rtt_dev_ms_scaled;

    NetTCP_TxConnRTT_CalcUpdate(p_conn);


                                                                /* --------------------- CALC RTO --------------------- */
                                                                /* Calc  RTO     (see Note #2a1B3).                     */
    rtt_dev_ms_scaled_gain = (p_conn->TxRTT_Dev_ms_scaled * NET_TCP_TX_RTT_GAIN_RTO_NUMER)
                                                         / NET_TCP_TX_RTT_GAIN_RTO_DENOM;
                                                                /* Limit RTT dev (see Note #2b1A2).                     */
    rtt_dev_ms_scaled_max  =  DEF_MAX(NET_TCP_TX_RTT_TS_CLK_MS_SCALED,
                                      rtt_dev_ms_scaled_gain);

    rto_ms_scaled          =  p_conn->TxRTT_Avg_ms_scaled + rtt_dev_ms_scaled_max;

                                                                /* Limit RTO (see Note #2b1).                           */
    if (rto_ms_scaled < NET_TCP_TX_RTO_MIN_TIMEOUT_MS_SCALED) {
        rto_ms_scaled = NET_TCP_TX_RTO_MIN_TIMEOUT_MS_SCALED;
    }
    if (rto_ms_scaled > p_conn->TxRTT_RTO_Max_ms_scaled) {
        rto_ms_scaled = p_conn->TxRTT_RTO_Max_ms_scaled;
    }

                                                                /* -------------------- UPDATE RTO -------------------- */
    p_conn->TxRTT_RTO_ms_scaled = rto_ms_scaled;

    NetTCP_TxConnRTO_CalcUpdate_ms_scaled(p_conn);
}


/*
*********************************************************************************************************
*                                       NetTCP_TxPktHandlerIPv4()
*
* Description : (1) Prepare & transmit TCP packet(s) :
*
*                   (a) Validate transmit packet
*                   (b) Transmit TCP packet
*                   (c) Free   transmit packet buffer(s)
*                   (d) Update transmit statistics
*
*
* Argument(s) : p_buf        Pointer to network buffer to transmit TCP packet.
*
*               src_addr    Source      IP  address.
*
*               src_port    Source      TCP port.
*
*               dest_addr   Destination IP  address.
*
*               dest_port   Destination TCP port.
*
*               seq_nbr     TCP segment                 sequence number.
*
*               ack_nbr     TCP segment acknowledgement sequence number.
*
*               win_size    TCP receive window advertisement size.
*
*               TOS         Specific TOS to transmit TCP/IP packet
*                               (see Note #2a & 'net_ip.h  IP HEADER TYPE OF SERVICE (TOS) DEFINES').
*
*               TTL         Specific TTL to transmit TCP/IP packet
*                               (see Note #2b & 'net_ip.h  IP HEADER TIME-TO-LIVE (TTL) DEFINES') :
*
*                               NET_IP_TTL_MIN                  Minimum TTL transmit value   (1)
*                               NET_IP_TTL_MAX                  Maximum TTL transmit value (255)
*                               NET_IP_TTL_DFLT                 Default TTL transmit value (128)
*                               NET_IP_TTL_NONE                 Replace with default TTL
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*               flags_ip    Flags to select IP  transmit options; bit-field flags logically OR'd :
*
*                               NET_IP_FLAG_NONE                No  IP transmit flags selected.
*                               NET_IP_FLAG_TX_DONT_FRAG        Set IP 'Don't Frag' flag.
*
*               p_opts_tcp   Pointer to one or more TCP options configuration data structures :
*
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*               p_opts_ip    Pointer to one or more IP  options configuration data structures
*                               (see Note #2c & 'net_ip.h  IP HEADER OPTION CONFIGURATION DATA TYPES') :
*
*                               NULL                            NO IP transmit options configuration.
*                               NET_IP_OPT_CFG_ROUTE_TS         Route &/or Internet Timestamp options configuration.
*                               NET_IP_OPT_CFG_SECURITY         Security options configuration
*                                                                   (see 'net_ip.c  Note #1e').
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP segments(s) successfully prepared &
*                                                                   transmitted to network layer.
*                               NET_TCP_ERR_TX_PKT              TCP transmit packet error; TCP segment
*                                                                   buffer(s) discarded.
*
*                                                               ------ RETURNED BY NetTCP_TxPkt() : -------
*                               NET_ERR_TX                      Transmit error.
*                               NET_ERR_IF_LOOPBACK_DIS         Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN            Network  interface link state down (i.e.
*                                                                   NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnSync(),
*               NetTCP_TxConnAck(),
*               NetTCP_TxConnReset(),
*               NetTCP_TxConnProbe(),
*               NetTCP_TxConnTxQ(),
*               NetTCP_TxConnReTxQ().
*
* Note(s)     : (2) The following parameters are configured & maintained by a TCP connection's network
*                   connection (see 'net_conn.h  NETWORK CONNECTION DATA TYPE  Note #2') :
*
*                   (a) RFC #1122, Section 4.2.4.2 states that :
*
*                       (1) "The application layer MUST be able to specify the [IP] Type-of-Service (TOS)
*                            for segments that are sent on a connection ... TCP SHOULD pass the current
*                            TOS value without change to the IP layer, when it sends segments on the
*                            connection."
*
*                       (2) "It not required [sic], but the application SHOULD be able to change the [IP]
*                            TOS during the connection lifetime."
*
*                       (3) "The TOS will be specified independently in each direction on the connection,
*                            so that the receiver application will specify the TOS used for ACK segments."
*
*                   (b) RFC #1122, Section 4.2.2.19 states that "the [IP] TTL value used to send TCP
*                       segments MUST be configurable".
*
*                   (c) (1) (A) RFC #1122, Section 4.1.3.2 reiterates that "an application MUST be able
*                               to specify IP options to be sent ... and ... MUST pass these options to
*                               the IP layer".
*
*                           (B) RFC #1122, Section 4.2.3.8 adds that :
*
*                               (1) "A TCP MAY support the [IP] Time Stamp and Record Route options."
*
*                               (2) (a) "An application MUST be able to specify a [IP] source route when
*                                        it actively opens a TCP connection, and this MUST take precedence
*                                        over a source route received in a datagram."
*
*                                   (b) (1) "When a ... connection is OPENed passively and a packet
*                                            arrives with a completed IP Source Route option (containing
*                                            a return route), ... all segments sent on this connection
*                                            ... MUST save ... and use ... [this] return route."
*
*                                       (2) "If a different source route arrives in a later segment, the
*                                            later definition SHOULD override the earlier one."
*
*                       (2) IP transmit options currently NOT implemented      See 'net_tcp.c  Note #1d'
*
*               (3) Network buffer already freed by lower layer; only increment error counter.
*********************************************************************************************************
*/
#ifdef  NET_IPv4_MODULE_EN
static  void  NetTCP_TxPktHandlerIPv4 (NET_BUF           *p_buf,
                                       NET_IPv4_ADDR      src_addr,
                                       NET_TCP_PORT_NBR   src_port,
                                       NET_IPv4_ADDR      dest_addr,
                                       NET_TCP_PORT_NBR   dest_port,
                                       NET_TCP_SEQ_NBR    seq_nbr,
                                       NET_TCP_SEQ_NBR    ack_nbr,
                                       NET_TCP_WIN_SIZE   win_size,
                                       NET_IPv4_TOS       TOS,
                                       NET_IPv4_TTL       TTL,
                                       NET_TCP_FLAGS      flags_tcp,
                                       NET_IPv4_FLAGS     flags_ip,
                                       void              *p_opts_tcp,
                                       void              *p_opts_ip,
                                       NET_ERR           *p_err)
{
    NET_BUF_HDR  *p_buf_hdr;
    NET_ERR       err;



#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------------- VALIDATE PTR ------------------- */
    if (p_buf == DEF_NULL) {
        NetTCP_TxPktDiscard(p_buf, p_err);
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }
#endif


                                                                /* --------------- VALIDATE TX TCP PKT ---------------- */
    p_buf_hdr = &p_buf->Hdr;
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NetTCP_TxPktValidate(p_buf_hdr,
                         src_port,
                         dest_port,
                         seq_nbr,
                         ack_nbr,
                         win_size,
                         flags_tcp,
                         p_opts_tcp,
                         p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
             break;


        case NET_ERR_INVALID_PROTOCOL:
        case NET_BUF_ERR_INVALID_TYPE:
        case NET_BUF_ERR_INVALID_IX:
        case NET_TCP_ERR_INVALID_LEN_DATA:
        case NET_TCP_ERR_INVALID_PORT_NBR:
        case NET_TCP_ERR_INVALID_FLAG:
        case NET_TCP_ERR_INVALID_OPT_TYPE:
        case NET_TCP_ERR_INVALID_OPT_CFG:
        default:
             NetTCP_TxPktDiscard(p_buf, &err);
            *p_err = NET_TCP_ERR_TX_PKT;
             return;
    }
#endif


                                                                /* -------------------- TX TCP PKT -------------------- */
    NetTCP_TxPktIPv4(p_buf,
                     p_buf_hdr,
                     src_addr,
                     src_port,
                     dest_addr,
                     dest_port,
                     seq_nbr,
                     ack_nbr,
                     win_size,
                     TOS,
                     TTL,
                     flags_tcp,
                     flags_ip,
                     p_opts_tcp,
                     p_opts_ip,
                     p_err);


                                                                /* ---------- FREE TX PKT / UPDATE TX STATS ----------- */
    switch (*p_err) {
        case NET_IPv4_ERR_NONE:
             NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegCtr);
            *p_err = NET_TCP_ERR_NONE;
             break;


        case NET_ERR_TX:
        case NET_ERR_IF_LINK_DOWN:
        case NET_ERR_IF_LOOPBACK_DIS:
        case NET_IF_ERR_INVALID_IF:
                                                                /* See Note #3.                                         */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxPktDiscardedCtr);
                                                                /* Rtn err from NetTCP_TxPkt().                         */
             return;


        case NET_IPv4_ERR_TX_PKT:
                                                                /* See Note #3.                                         */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxPktDiscardedCtr);
            *p_err = NET_TCP_ERR_TX_PKT;
             return;


        case NET_TCP_ERR_INVALID_LEN_HDR:
        case NET_TCP_ERR_INVALID_OPT_TYPE:
        case NET_TCP_ERR_INVALID_OPT_LEN:
        case NET_BUF_ERR_INVALID_IX:
        case NET_BUF_ERR_INVALID_LEN:
        case NET_ERR_FAULT_NULL_PTR:
        case NET_UTIL_ERR_NULL_SIZE:
        case NET_UTIL_ERR_INVALID_PROTOCOL:
        default:
             NetTCP_TxPktDiscard(p_buf, &err);
            *p_err = NET_TCP_ERR_TX_PKT;
             return;
    }
}
#endif


/*
*********************************************************************************************************
*                                       NetTCP_TxPktHandlerIPv6()
*
* Description : (1) Prepare & transmit TCP packet(s) :
*
*                   (a) Validate transmit packet
*                   (b) Transmit TCP packet
*                   (c) Free   transmit packet buffer(s)
*                   (d) Update transmit statistics
*
*
* Argument(s) : p_buf        Pointer to network buffer to transmit TCP packet.
*
*               src_addr    Source      IP  address.
*
*               src_port    Source      TCP port.
*
*               dest_addr   Destination IP  address.
*
*               dest_port   Destination TCP port.
*
*               seq_nbr     TCP segment                 sequence number.
*
*               ack_nbr     TCP segment acknowledgement sequence number.
*
*               win_size    TCP receive window advertisement size.
*
*               TOS         Specific TOS to transmit TCP/IP packet
*                               (see Note #2a & 'net_ip.h  IP HEADER TYPE OF SERVICE (TOS) DEFINES').
*
*               TTL         Specific TTL to transmit TCP/IP packet
*                               (see Note #2b & 'net_ip.h  IP HEADER TIME-TO-LIVE (TTL) DEFINES') :
*
*                               NET_IP_TTL_MIN                  Minimum TTL transmit value   (1)
*                               NET_IP_TTL_MAX                  Maximum TTL transmit value (255)
*                               NET_IP_TTL_DFLT                 Default TTL transmit value (128)
*                               NET_IP_TTL_NONE                 Replace with default TTL
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*               flags_ip    Flags to select IP  transmit options; bit-field flags logically OR'd :
*
*                               NET_IP_FLAG_NONE                No  IP transmit flags selected.
*                               NET_IP_FLAG_TX_DONT_FRAG        Set IP 'Don't Frag' flag.
*
*               p_opts_tcp   Pointer to one or more TCP options configuration data structures :
*
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*               p_opts_ip    Pointer to one or more IP  options configuration data structures
*                               (see Note #2c & 'net_ip.h  IP HEADER OPTION CONFIGURATION DATA TYPES') :
*
*                               NULL                            NO IP transmit options configuration.
*                               NET_IP_OPT_CFG_ROUTE_TS         Route &/or Internet Timestamp options configuration.
*                               NET_IP_OPT_CFG_SECURITY         Security options configuration
*                                                                   (see 'net_ip.c  Note #1e').
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP segments(s) successfully prepared &
*                                                                   transmitted to network layer.
*                               NET_TCP_ERR_TX_PKT              TCP transmit packet error; TCP segment
*                                                                   buffer(s) discarded.
*
*                                                               ------ RETURNED BY NetTCP_TxPkt() : -------
*                               NET_ERR_TX                      Transmit error.
*                               NET_ERR_IF_LOOPBACK_DIS         Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN            Network  interface link state down (i.e.
*                                                                   NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnSync(),
*               NetTCP_TxConnAck(),
*               NetTCP_TxConnReset(),
*               NetTCP_TxConnProbe(),
*               NetTCP_TxConnTxQ(),
*               NetTCP_TxConnReTxQ().
*
* Note(s)     : (2) The following parameters are configured & maintained by a TCP connection's network
*                   connection (see 'net_conn.h  NETWORK CONNECTION DATA TYPE  Note #2') :
*
*                   (a) RFC #1122, Section 4.2.4.2 states that :
*
*                       (1) "The application layer MUST be able to specify the [IP] Type-of-Service (TOS)
*                            for segments that are sent on a connection ... TCP SHOULD pass the current
*                            TOS value without change to the IP layer, when it sends segments on the
*                            connection."
*
*                       (2) "It not required [sic], but the application SHOULD be able to change the [IP]
*                            TOS during the connection lifetime."
*
*                       (3) "The TOS will be specified independently in each direction on the connection,
*                            so that the receiver application will specify the TOS used for ACK segments."
*
*                   (b) RFC #1122, Section 4.2.2.19 states that "the [IP] TTL value used to send TCP
*                       segments MUST be configurable".
*
*                   (c) (1) (A) RFC #1122, Section 4.1.3.2 reiterates that "an application MUST be able
*                               to specify IP options to be sent ... and ... MUST pass these options to
*                               the IP layer".
*
*                           (B) RFC #1122, Section 4.2.3.8 adds that :
*
*                               (1) "A TCP MAY support the [IP] Time Stamp and Record Route options."
*
*                               (2) (a) "An application MUST be able to specify a [IP] source route when
*                                        it actively opens a TCP connection, and this MUST take precedence
*                                        over a source route received in a datagram."
*
*                                   (b) (1) "When a ... connection is OPENed passively and a packet
*                                            arrives with a completed IP Source Route option (containing
*                                            a return route), ... all segments sent on this connection
*                                            ... MUST save ... and use ... [this] return route."
*
*                                       (2) "If a different source route arrives in a later segment, the
*                                            later definition SHOULD override the earlier one."
*
*                       (2) IP transmit options currently NOT implemented      See 'net_tcp.c  Note #1d'
*
*               (3) Network buffer already freed by lower layer; only increment error counter.
*********************************************************************************************************
*/
#ifdef  NET_IPv6_MODULE_EN
static  void  NetTCP_TxPktHandlerIPv6 (NET_BUF                 *p_buf,
                                       NET_IPv6_ADDR           *p_src_addr,
                                       NET_TCP_PORT_NBR         src_port,
                                       NET_IPv6_ADDR           *p_dest_addr,
                                       NET_TCP_PORT_NBR         dest_port,
                                       NET_TCP_SEQ_NBR          seq_nbr,
                                       NET_TCP_SEQ_NBR          ack_nbr,
                                       NET_TCP_WIN_SIZE         win_size,
                                       NET_IPv6_TRAFFIC_CLASS   traffic_class,
                                       NET_IPv6_FLOW_LABEL      flow_label,
                                       NET_IPv6_HOP_LIM         hop_lim,
                                       NET_TCP_FLAGS            flags_tcp,
                                       void                    *p_opts_tcp,
                                       NET_ERR                 *p_err)
{
    NET_BUF_HDR  *p_buf_hdr;
    NET_ERR       err;



#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ------------------- VALIDATE PTR ------------------- */
    if (p_buf == DEF_NULL) {
        NetTCP_TxPktDiscard(p_buf, p_err);
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }
#endif


                                                                /* --------------- VALIDATE TX TCP PKT ---------------- */
    p_buf_hdr = &p_buf->Hdr;
    DEF_BIT_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    NetTCP_TxPktValidate(p_buf_hdr,
                         src_port,
                         dest_port,
                         seq_nbr,
                         ack_nbr,
                         win_size,
                         flags_tcp,
                         p_opts_tcp,
                         p_err);
    switch (*p_err) {
        case NET_TCP_ERR_NONE:
             break;


        case NET_ERR_INVALID_PROTOCOL:
        case NET_BUF_ERR_INVALID_TYPE:
        case NET_BUF_ERR_INVALID_IX:
        case NET_TCP_ERR_INVALID_LEN_DATA:
        case NET_TCP_ERR_INVALID_PORT_NBR:
        case NET_TCP_ERR_INVALID_FLAG:
        case NET_TCP_ERR_INVALID_OPT_TYPE:
        case NET_TCP_ERR_INVALID_OPT_CFG:
        default:
             NetTCP_TxPktDiscard(p_buf, &err);
            *p_err = NET_TCP_ERR_TX_PKT;
             return;
    }
#endif


                                                                /* -------------------- TX TCP PKT -------------------- */
    NetTCP_TxPktIPv6(p_buf,
                     p_buf_hdr,
                     p_src_addr,
                     src_port,
                     p_dest_addr,
                     dest_port,
                     seq_nbr,
                     ack_nbr,
                     win_size,
                     traffic_class,
                     flow_label,
                     hop_lim,
                     flags_tcp,
                     p_opts_tcp,
                     p_err);


                                                                /* ---------- FREE TX PKT / UPDATE TX STATS ----------- */
    switch (*p_err) {
        case NET_IPv4_ERR_NONE:
        case NET_IPv6_ERR_NONE:
             NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegCtr);
            *p_err = NET_TCP_ERR_NONE;
             break;


        case NET_ERR_TX:
        case NET_ERR_IF_LINK_DOWN:
        case NET_ERR_IF_LOOPBACK_DIS:
                                                                /* See Note #3.                                         */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxPktDiscardedCtr);
                                                                /* Rtn err from NetTCP_TxPkt().                         */
             return;


        case NET_IPv4_ERR_TX_PKT:
        case NET_IPv6_ERR_TX_PKT:
                                                                /* See Note #3.                                         */
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxPktDiscardedCtr);
            *p_err = NET_TCP_ERR_TX_PKT;
             return;


        case NET_TCP_ERR_INVALID_LEN_HDR:
        case NET_TCP_ERR_INVALID_OPT_TYPE:
        case NET_TCP_ERR_INVALID_OPT_LEN:
        case NET_BUF_ERR_INVALID_IX:
        case NET_BUF_ERR_INVALID_LEN:
        case NET_ERR_FAULT_NULL_PTR:
        case NET_UTIL_ERR_NULL_SIZE:
        case NET_UTIL_ERR_INVALID_PROTOCOL:
        default:
             NetTCP_TxPktDiscard(p_buf, &err);
            *p_err = NET_TCP_ERR_TX_PKT;
             return;
    }
}
#endif


/*
*********************************************************************************************************
*                                       NetTCP_TxPktValidate()
*
* Description : (1) Validate TCP transmit packet parameters & options :
*
*                   (a) Validate the following transmit packet parameters :
*
*                       (1) Supported protocols :
*                           (A) BSD Sockets
*                           (B) TCP                                         See Note #2
*
*                       (2) Buffer protocol index
*                       (3) Data Length
*                       (4) Source      Port
*                       (5) Destination Port
*                       (6) Flags
*
*                   (b) The following parameters are inherently assumed to be valid :
*
*                       (1) Sequence        Number
*                       (2) Acknowledgement Number
*                       (3) Receive Window  Size
*
*
* Argument(s) : p_buf_hdr    Pointer to network buffer header.
*               --------    Argument validated in NetTCP_TxPktHandler().
*
*               src_port    Source      TCP port.
*
*               dest_port   Destination TCP port.
*
*               seq_nbr     TCP segment                 sequence number.
*
*               ack_nbr     TCP segment acknowledgement sequence number.
*
*               win_size    TCP receive window advertisement size.
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*               p_opts_tcp   Pointer to one or more TCP options configuration data structures :
*
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                Transmit packet validated.
*                               NET_ERR_INVALID_PROTOCOL        Invalid/unknown protocol type.
*                               NET_BUF_ERR_INVALID_TYPE        Invalid network buffer   type.
*                               NET_BUF_ERR_INVALID_IX          Invalid/insufficient buffer index.
*                               NET_TCP_ERR_INVALID_LEN_DATA    Invalid protocol/data length.
*                               NET_TCP_ERR_INVALID_PORT_NBR    Invalid TCP port number.
*                               NET_TCP_ERR_INVALID_FLAG        Invalid TCP flag(s).
*
*                                                               - RETURNED BY NetTCP_TxPktValidateOpt() : -
*                               NET_TCP_ERR_INVALID_OPT_TYPE    Invalid TCP option type.
*                               NET_TCP_ERR_INVALID_OPT_CFG     Invalid TCP option configuration.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPktHandler().
*
* Note(s)     : none.
*********************************************************************************************************
*/

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
static  void  NetTCP_TxPktValidate (NET_BUF_HDR       *p_buf_hdr,
                                    NET_TCP_PORT_NBR   src_port,
                                    NET_TCP_PORT_NBR   dest_port,
                                    NET_TCP_SEQ_NBR    seq_nbr,
                                    NET_TCP_SEQ_NBR    ack_nbr,
                                    NET_TCP_WIN_SIZE   win_size,
                                    NET_TCP_FLAGS      flags_tcp,
                                    void              *p_opts_tcp,
                                    NET_ERR           *p_err)
{
    CPU_INT16U     ix;
    CPU_INT16U     len;
    NET_TCP_FLAGS  flag_mask;
    CPU_BOOLEAN    flags_tcp_fin_syn;


                                                                /* -------------- VALIDATE NET BUF TYPE --------------- */
    switch (p_buf_hdr->Type) {
        case NET_BUF_TYPE_TX_LARGE:
        case NET_BUF_TYPE_TX_SMALL:
             break;


        case NET_BUF_TYPE_NONE:
        case NET_BUF_TYPE_BUF:
        case NET_BUF_TYPE_RX_LARGE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.Buf.InvTypeCtr);
            *p_err = NET_BUF_ERR_INVALID_TYPE;
             return;
    }


                                                                /* ---------------- VALIDATE PROTOCOL ----------------- */
    switch (p_buf_hdr->ProtocolHdrType) {
        case NET_PROTOCOL_TYPE_APP:
        case NET_PROTOCOL_TYPE_SOCK:
        case NET_PROTOCOL_TYPE_TCP_V4:
        case NET_PROTOCOL_TYPE_TCP_V6:
             ix  = (CPU_INT16U)p_buf_hdr->DataIx;
             len = (CPU_INT16U)p_buf_hdr->DataLen;
             break;


        case NET_PROTOCOL_TYPE_NONE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxInvalidProtocolCtr);
            *p_err = NET_ERR_INVALID_PROTOCOL;
             return;
    }

    if (ix == NET_BUF_IX_NONE) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxInvalidBufIxCtr);
       *p_err = NET_BUF_ERR_INVALID_IX;
        return;
    }

    if (ix <  NET_TCP_HDR_SIZE_MIN) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxInvalidBufIxCtr);
       *p_err = NET_BUF_ERR_INVALID_IX;
        return;
    }



                                                                /* -------------- VALIDATE TOT DATA LEN --------------- */
    if (len != p_buf_hdr->TotLen) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrDataLenCtr);
       *p_err = NET_TCP_ERR_INVALID_LEN_DATA;
        return;
    }



                                                                /* ---------------- VALIDATE TCP PORTS ---------------- */
    if (src_port  == NET_TCP_PORT_NBR_RESERVED) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrPortSrcCtr);
       *p_err = NET_TCP_ERR_INVALID_PORT_NBR;
        return;
    }

    if (dest_port == NET_TCP_PORT_NBR_RESERVED) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrPortDestCtr);
       *p_err = NET_TCP_ERR_INVALID_PORT_NBR;
        return;
    }



                                                                /* ---------------- VALIDATE TCP FLAGS ---------------- */
    flag_mask = NET_TCP_FLAG_NONE     |
                NET_TCP_FLAG_TX_CLOSE |
                NET_TCP_FLAG_TX_SYNC  |
                NET_TCP_FLAG_TX_RESET |
                NET_TCP_FLAG_TX_PUSH  |
                NET_TCP_FLAG_TX_ACK   |
                NET_TCP_FLAG_TX_URGENT;
                                                                /* If any invalid flags req'd, rtn err.                 */
    if ((flags_tcp & (NET_TCP_FLAGS)~flag_mask) != NET_TCP_FLAG_NONE) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrFlagsCtr);
       *p_err = NET_TCP_ERR_INVALID_FLAG;
        return;
    }

#if 1                                                           /* Allow invalid 'SYN'/'FIN' flag combo.                */
    flag_mask         = NET_TCP_FLAG_TX_SYNC |
                        NET_TCP_FLAG_TX_FIN;
    flags_tcp_fin_syn = DEF_BIT_IS_SET(flags_tcp, flag_mask);
    if (flags_tcp_fin_syn != DEF_NO) {                          /* If invalid 'SYN'/'FIN' flag combo req'd, rtn err.    */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrFlagsCtr);
       *p_err = NET_TCP_ERR_INVALID_FLAG;
        return;
    }
#endif



                                                                /* ---------------- VALIDATE TCP OPTS ----------------- */
    if (p_opts_tcp != (void *)0) {
        NetTCP_TxPktValidateOpt(p_opts_tcp, flags_tcp, p_err);
        if (*p_err != NET_TCP_ERR_NONE) {
             return;
        }
    }



                                                                /* ------------- IGNORE VALID TCP FIELDS -------------- */
   (void)&seq_nbr;                                              /* Prevent 'variable unused' compiler warnings.         */
   (void)&ack_nbr;
   (void)&win_size;


   *p_err = NET_TCP_ERR_NONE;
}
#endif


/*
*********************************************************************************************************
*                                      NetTCP_TxPktValidateOpt()
*
* Description : Validate TCP transmit option configurations.
*
*               (1) TCP transmit options MUST be configured by appropriate transmit options configuration
*                   data structure(s) passed via 'p_opts_tcp'; see 'net_tcp.h  TCP HEADER OPTION CONFIGURATION
*                   DATA TYPES' for TCP options configuration.
*
*               (2) TCP header allows for a maximum option size of 40 octets (see 'net_tcp.h  TCP HEADER
*                   OPTIONS DEFINES  Note #3').
*
*
* Argument(s) : p_opts_tcp   Pointer to one or more TCP options configuration data structures (see Note #1) :
*
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP transmit option configurations validated.
*                               NET_TCP_ERR_INVALID_OPT_TYPE    Invalid TCP option type.
*                               NET_TCP_ERR_INVALID_OPT_CFG     Invalid TCP option configuration.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPktValidate().
*
* Note(s)     : (3) (a) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES' for   supported TCP options' summary.
*
*                   (b) See 'net_tcp.c  Note #1c'                   for unsupported TCP options.
*
*               (4) The following TCP transmit options MUST be configured exclusively--i.e. only one
*                   of each of the following TCP options may be configured for any one TCP segment :
*
*                   (a) NET_TCP_OPT_TYPE_MAX_SEG_SIZE
*********************************************************************************************************
*/

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
static  void  NetTCP_TxPktValidateOpt (void           *p_opts_tcp,
                                       NET_TCP_FLAGS   flags_tcp,
                                       NET_ERR        *p_err)
{
    CPU_INT08U         opt_len_size;
    CPU_INT08U         opt_len;
    CPU_INT08U         opt_nbr_max_seg_size;
    NET_TCP_OPT_TYPE  *p_opt_cfg_type;
    void              *p_opt_cfg;
    void              *p_opt_next;


    opt_len_size         = 0u;
    opt_nbr_max_seg_size = 0u;
    p_opt_cfg             = p_opts_tcp;

    while (p_opt_cfg  != (void *)0) {
        p_opt_cfg_type = (NET_TCP_OPT_TYPE *)p_opt_cfg;
        switch (*p_opt_cfg_type) {
            case NET_TCP_OPT_TYPE_MAX_SEG_SIZE:                 /* ----------------- MAX SEG SIZE OPT ----------------- */
                 if (opt_nbr_max_seg_size > 0) {                /* If > 1 max seg size opt, rtn err.                    */
                     NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptCfgCtr);
                    *p_err = NET_TCP_ERR_INVALID_OPT_CFG;
                     return;
                 }
                 opt_nbr_max_seg_size++;

                 NetTCP_TxPktValidateOptMaxSegSize(p_opt_cfg, &opt_len, &p_opt_next, flags_tcp, p_err);
                 break;
                                                                /* --------------- UNSUPPORTED TCP OPTS --------------- */
                                                                /* See Note #3b.                                        */
            case NET_TCP_OPT_TYPE_WIN_SCALE:
            case NET_TCP_OPT_TYPE_SACK_PERMIT:
            case NET_TCP_OPT_TYPE_SACK:
            case NET_TCP_OPT_TYPE_ECHO_REQ:
            case NET_TCP_OPT_TYPE_ECHO_REPLY:
            case NET_TCP_OPT_TYPE_TS:
            case NET_TCP_OPT_TYPE_NONE:                         /* ----------------- INVALID TCP OPTS ----------------- */
            default:
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxOptTypeCtr);
                *p_err = NET_TCP_ERR_INVALID_OPT_TYPE;
                 return;
        }

        if (*p_err != NET_TCP_ERR_NONE) {
             return;
        }

        opt_len_size += opt_len;
        if (opt_len_size > NET_TCP_HDR_OPT_SIZE_MAX) {          /* If tot opt len exceeds max opt len, rtn err.         */
            NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptLenCtr);
           *p_err = NET_TCP_ERR_INVALID_OPT_LEN;
            return;
        }

        p_opt_cfg = p_opt_next;                                 /* Validate next cfg opt.                               */
    }

   *p_err = NET_TCP_ERR_NONE;
}
#endif


/*
*********************************************************************************************************
*                                 NetTCP_TxPktValidateOptMaxSegSize()
*
* Description : Validate TCP Maximum Segment Size option configuration.
*
*               (1) See 'net_tcp.h  TCP MAXIMUM SEGMENT SIZE OPTION CONFIGURATION DATA TYPE' for valid
*                   TCP Maximum Segment Size option configuration.
*
*               (2) Return option values.
*
*
* Argument(s) : p_opt_tcp    Pointer to TCP Maximum Segment Size option configuration data structure.
*               --------    Argument checked   in NetTCP_TxPktValidateOpt().
*
*               p_opt_len    Pointer to variable that will receive the TCP Maximum Segment Size option length
*               --------        (in octets).
*
*                           Argument validated in NetTCP_TxPktValidateOpt().
*
*               p_opt_next   Pointer to variable that will receive the pointer to the next TCP transmit option.
*               ---------   Argument validated in NetTCP_TxPktValidateOpt().
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP Maximum Segment Size option
*                                                                   configuration validated.
*                               NET_TCP_ERR_INVALID_OPT_TYPE    Invalid TCP option type.
*                               NET_TCP_ERR_INVALID_OPT_CFG     Invalid TCP option configuration.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPktValidateOpt().
*
* Note(s)     : (3) RFC #793, Section 3.1 'Header Format : Options : Maximum Segment Size' states that a
*                   TCP Maximum Segment Size option "must only be sent in the initial connection request
*                   (i.e., in segments with the SYN control bit set)".
*********************************************************************************************************
*/

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
static  void  NetTCP_TxPktValidateOptMaxSegSize (void            *p_opt_tcp,
                                                 CPU_INT08U      *p_opt_len,
                                                 void           **p_opt_next,
                                                 NET_TCP_FLAGS    flags_tcp,
                                                 NET_ERR         *p_err)
{
    NET_TCP_OPT_CFG_MAX_SEG_SIZE  *p_opt_cfg_max_seg_size;
    CPU_BOOLEAN                    flags_tcp_syn;


    p_opt_cfg_max_seg_size = (NET_TCP_OPT_CFG_MAX_SEG_SIZE *)p_opt_tcp;


                                                                /* -------------- VALIDATE MAX SEG SIZE --------------- */
                                                                /* If max seg size > max, rtn err.                      */
    if (p_opt_cfg_max_seg_size->MaxSegSize > NET_TCP_MAX_SEG_SIZE_MAX) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptCfgCtr);
       *p_err = NET_TCP_ERR_INVALID_OPT_CFG;
        return;
    }

                                                                /* -------------- VALIDATE OPT CFG/CTRL --------------- */
    flags_tcp_syn = DEF_BIT_IS_SET(flags_tcp, NET_TCP_HDR_FLAG_SYNC);
    if (flags_tcp_syn != DEF_YES) {                             /* If 'SYN' bit NOT set, rtn err (see Note #3).         */
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptCfgCtr);
       *p_err = NET_TCP_ERR_INVALID_OPT_CFG;
        return;
    }


                                                                /* ------------------- RTN OPT VALS ------------------- */
   *p_opt_len  = NET_TCP_HDR_OPT_LEN_MAX_SEG_SIZE;
   *p_opt_next = p_opt_cfg_max_seg_size->NextOptPtr;
   *p_err      = NET_TCP_ERR_NONE;
}
#endif


/*
*********************************************************************************************************
*                                           NetTCP_TxPktIPv4
*
* Description : (1) Prepare TCP header & transmit TCP packet to network layer :
*
*                   (a) Prepare   TCP options (if any)
*                   (b) Calculate TCP header buffer controls
*                   (c) Prepare   TCP header
*                   (d) Transmit  TCP packet
*
*
* Argument(s) : p_buf        Pointer to network buffer to transmit TCP packet.
*               ----        Argument checked   in NetTCP_TxPktHandler().
*
*               p_buf_hdr    Pointer to network buffer header.
*               --------    Argument validated in NetTCP_TxPktHandler().
*
*               src_addr    Source      IP  address.
*
*               src_port    Source      TCP port.
*               --------    Argument checked   in NetTCP_TxPktValidate().
*
*               dest_addr   Destination IP  address.
*
*               dest_port   Destination TCP port.
*               ---------   Argument checked   in NetTCP_TxPktValidate().
*
*               seq_nbr     TCP segment                 sequence number.
*               -------     Argument validated in NetTCP_TxPktValidate().
*
*               ack_nbr     TCP segment acknowledgement sequence number.
*               -------     Argument validated in NetTCP_TxPktValidate().
*
*               win_size    TCP receive window advertisement size.
*               --------    Argument validated in NetTCP_TxPktValidate().
*
*               TOS         Specific TOS to transmit TCP/IP packet
*                               (see 'net_ip.h  IP HEADER TYPE OF SERVICE (TOS) DEFINES').
*
*               TTL         Specific TTL to transmit TCP/IP packet
*                               (see 'net_ip.h  IP HEADER TIME-TO-LIVE (TTL) DEFINES') :
*
*                               NET_IP_TTL_MIN                  Minimum TTL transmit value   (1)
*                               NET_IP_TTL_MAX                  Maximum TTL transmit value (255)
*                               NET_IP_TTL_DFLT                 Default TTL transmit value (128)
*                               NET_IP_TTL_NONE                 Replace with default TTL
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*               ---------
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*                           Argument checked   in NetTCP_TxPktValidate().
*
*               flags_ip    Flags to select IP  transmit options; bit-field flags logically OR'd :
*
*                               NET_IP_FLAG_NONE                No  IP transmit flags selected.
*                               NET_IP_FLAG_TX_DONT_FRAG        Set IP 'Don't Frag' flag.
*
*               p_opts_tcp   Pointer to one or more TCP options configuration data structures :
*               ---------
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*                           Argument checked   in NetTCP_TxPktValidate().
*
*               p_opts_ip    Pointer to one or more IP  options configuration data structures
*                               (see 'net_ip.h  IP HEADER OPTION CONFIGURATION DATA TYPES') :
*
*                               NULL                            NO IP transmit options configuration.
*                               NET_IP_OPT_CFG_ROUTE_TS         Route &/or Internet Timestamp options configuration.
*                               NET_IP_OPT_CFG_SECURITY         Security options configuration
*                                                                   (see 'net_ip.c  Note #1e').
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_INVALID_LEN_HDR     Invalid TCP header length.
*
*                                                               - RETURNED BY NetTCP_TxPktPrepareOpt() : --
*                               NET_TCP_ERR_INVALID_OPT_TYPE    Invalid TCP option type.
*                               NET_TCP_ERR_INVALID_OPT_LEN     Invalid TCP option length.
*
*                                                               - RETURNED BY NetTCP_TxPktPrepareHdr() : --
*                               NET_BUF_ERR_INVALID_IX          Invalid/insufficient buffer index.
*                               NET_BUF_ERR_INVALID_LEN         Invalid buffer length.
*                               NET_UTIL_ERR_NULL_PTR           Check-sum passed a NULL pointer.
*                               NET_UTIL_ERR_NULL_SIZE          Check-sum passed a zero size.
*                               NET_UTIL_ERR_INVALID_PROTOCOL   Invalid data packet protocol.
*
*                                                               -------- RETURNED BY NetIP_Tx() : ---------
*                               NET_IP_ERR_NONE                 TCP/IP packet     successfully transmitted.
*                               NET_IP_ERR_TX_PKT               TCP/IP packet NOT successfully prepared or
*                                                                   transmitted.
*                               NET_ERR_TX                      Transmit error.
*                               NET_ERR_IF_LOOPBACK_DIS         Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN            Network  interface link state down (i.e.
*                                                                   NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPktHandler().
*
* Note(s)     : none.
*********************************************************************************************************
*/

#ifdef  NET_IPv4_MODULE_EN
static  void  NetTCP_TxPktIPv4 (NET_BUF           *p_buf,
                                NET_BUF_HDR       *p_buf_hdr,
                                NET_IPv4_ADDR      src_addr,
                                NET_TCP_PORT_NBR   src_port,
                                NET_IPv4_ADDR      dest_addr,
                                NET_TCP_PORT_NBR   dest_port,
                                NET_TCP_SEQ_NBR    seq_nbr,
                                NET_TCP_SEQ_NBR    ack_nbr,
                                NET_TCP_WIN_SIZE   win_size,
                                NET_IPv4_TOS       TOS,
                                NET_IPv4_TTL       TTL,
                                NET_TCP_FLAGS      flags_tcp,
                                NET_IPv4_FLAGS     flags_ip,
                                void              *p_opts_tcp,
                                void              *p_opts_ip,
                                NET_ERR           *p_err)
{
    CPU_INT08U         tcp_opt_len_size;
    CPU_INT16U         tcp_hdr_len_size;
    NET_TCP_OPT_SIZE   tcp_hdr_opts[NET_TCP_HDR_OPT_NBR_MAX];


                                                                /* ----------------- PREPARE TCP OPTS ----------------- */
    if (p_opts_tcp != (void *)0) {
        tcp_opt_len_size = NetTCP_TxPktPrepareOpt((void       *) p_opts_tcp,
                                                  (CPU_INT08U *)&tcp_hdr_opts[0],
                                                  (NET_ERR    *) p_err);
        if (*p_err != NET_TCP_ERR_NONE) {
             return;
        }
    } else {
        tcp_opt_len_size = 0u;
    }

                                                                /* ---------------- CALC TCP HDR CTRLS ---------------- */
                                                                /* Calc tot TCP hdr len (in octets).                    */
    tcp_hdr_len_size = (CPU_INT16U)(NET_TCP_HDR_SIZE_MIN + tcp_opt_len_size);
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (tcp_hdr_len_size > NET_TCP_HDR_SIZE_MAX) {
       *p_err = NET_TCP_ERR_INVALID_LEN_HDR;
        return;
    }
#endif


                                                                /* ----------------- PREPARE TCP HDR ------------------ */
    NetTCP_TxPktPrepareHdr(p_buf,
                           p_buf_hdr,
                           tcp_hdr_len_size,
                           tcp_opt_len_size,
                           sizeof(NET_IPv4_ADDR),
                          &src_addr,
                           src_port,
                          &dest_addr,
                           dest_port,
                           seq_nbr,
                           ack_nbr,
                           win_size,
                           flags_tcp,
                          &tcp_hdr_opts[0],
                           p_err);

    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }


                                                                /* -------------------- TX TCP PKT -------------------- */
    NetIPv4_Tx( p_buf,
                src_addr,
                dest_addr,
                TOS,
                TTL,
                flags_ip,
                p_opts_ip,
                p_err);
}
#endif

/*
*********************************************************************************************************
*                                          NetTCP_TxPktIPv6()
*
* Description : (1) Prepare TCP header & transmit TCP packet to network layer :
*
*                   (a) Prepare   TCP options (if any)
*                   (b) Calculate TCP header buffer controls
*                   (c) Prepare   TCP header
*                   (d) Transmit  TCP packet
*
*
* Argument(s) : p_buf        Pointer to network buffer to transmit TCP packet.
*               ----        Argument checked   in NetTCP_TxPktHandler().
*
*               p_buf_hdr    Pointer to network buffer header.
*               --------    Argument validated in NetTCP_TxPktHandler().
*
*               src_addr    Source      IP  address.
*
*               src_port    Source      TCP port.
*               --------    Argument checked   in NetTCP_TxPktValidate().
*
*               dest_addr   Destination IP  address.
*
*               dest_port   Destination TCP port.
*               ---------   Argument checked   in NetTCP_TxPktValidate().
*
*               seq_nbr     TCP segment                 sequence number.
*               -------     Argument validated in NetTCP_TxPktValidate().
*
*               ack_nbr     TCP segment acknowledgement sequence number.
*               -------     Argument validated in NetTCP_TxPktValidate().
*
*               win_size    TCP receive window advertisement size.
*               --------    Argument validated in NetTCP_TxPktValidate().
*
*               TOS         Specific TOS to transmit TCP/IP packet
*                               (see 'net_ip.h  IP HEADER TYPE OF SERVICE (TOS) DEFINES').
*
*               TTL         Specific TTL to transmit TCP/IP packet
*                               (see 'net_ip.h  IP HEADER TIME-TO-LIVE (TTL) DEFINES') :
*
*                               NET_IP_TTL_MIN                  Minimum TTL transmit value   (1)
*                               NET_IP_TTL_MAX                  Maximum TTL transmit value (255)
*                               NET_IP_TTL_DFLT                 Default TTL transmit value (128)
*                               NET_IP_TTL_NONE                 Replace with default TTL
*
*               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
*               ---------
*                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*                           Argument checked   in NetTCP_TxPktValidate().
*
*               flags_ip    Flags to select IP  transmit options; bit-field flags logically OR'd :
*
*                               NET_IP_FLAG_NONE                No  IP transmit flags selected.
*                               NET_IP_FLAG_TX_DONT_FRAG        Set IP 'Don't Frag' flag.
*
*               p_opts_tcp  Pointer to one or more TCP options configuration data structures :
*               ---------
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*                           Argument checked   in NetTCP_TxPktValidate().
*
*               p_opts_ip   Pointer to one or more IP  options configuration data structures
*                               (see 'net_ip.h  IP HEADER OPTION CONFIGURATION DATA TYPES') :
*
*                               NULL                            NO IP transmit options configuration.
*                               NET_IP_OPT_CFG_ROUTE_TS         Route &/or Internet Timestamp options configuration.
*                               NET_IP_OPT_CFG_SECURITY         Security options configuration
*                                                                   (see 'net_ip.c  Note #1e').
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_INVALID_LEN_HDR     Invalid TCP header length.
*
*                                                               - RETURNED BY NetTCP_TxPktPrepareOpt() : --
*                               NET_TCP_ERR_INVALID_OPT_TYPE    Invalid TCP option type.
*                               NET_TCP_ERR_INVALID_OPT_LEN     Invalid TCP option length.
*
*                                                               - RETURNED BY NetTCP_TxPktPrepareHdr() : --
*                               NET_BUF_ERR_INVALID_IX          Invalid/insufficient buffer index.
*                               NET_BUF_ERR_INVALID_LEN         Invalid buffer length.
*                               NET_UTIL_ERR_NULL_PTR           Check-sum passed a NULL pointer.
*                               NET_UTIL_ERR_NULL_SIZE          Check-sum passed a zero size.
*                               NET_UTIL_ERR_INVALID_PROTOCOL   Invalid data packet protocol.
*
*                                                               -------- RETURNED BY NetIP_Tx() : ---------
*                               NET_IP_ERR_NONE                 TCP/IP packet     successfully transmitted.
*                               NET_IP_ERR_TX_PKT               TCP/IP packet NOT successfully prepared or
*                                                                   transmitted.
*                               NET_ERR_TX                      Transmit error.
*                               NET_ERR_IF_LOOPBACK_DIS         Loopback interface disabled.
*                               NET_ERR_IF_LINK_DOWN            Network  interface link state down (i.e.
*                                                                   NOT available for receive or transmit).
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPktHandler().
*
* Note(s)     : none.
*********************************************************************************************************
*/
#ifdef  NET_IPv6_MODULE_EN
static  void  NetTCP_TxPktIPv6 (NET_BUF                 *p_buf,
                                NET_BUF_HDR             *p_buf_hdr,
                                NET_IPv6_ADDR           *p_src_addr,
                                NET_TCP_PORT_NBR         src_port,
                                NET_IPv6_ADDR           *p_dest_addr,
                                NET_TCP_PORT_NBR         dest_port,
                                NET_TCP_SEQ_NBR          seq_nbr,
                                NET_TCP_SEQ_NBR          ack_nbr,
                                NET_TCP_WIN_SIZE         win_size,
                                NET_IPv6_TRAFFIC_CLASS   traffic_class,
                                NET_IPv6_FLOW_LABEL      flow_label,
                                NET_IPv6_HOP_LIM         hop_lim,
                                NET_TCP_FLAGS            flags_tcp,
                                void                    *p_opts_tcp,
                                NET_ERR                 *p_err)
{
    CPU_INT08U         tcp_opt_len_size;
    CPU_INT16U         tcp_hdr_len_size;
    NET_TCP_OPT_SIZE   tcp_hdr_opts[NET_TCP_HDR_OPT_NBR_MAX];


                                                                /* ----------------- PREPARE TCP OPTS ----------------- */
    if (p_opts_tcp != (void *)0) {
        tcp_opt_len_size = NetTCP_TxPktPrepareOpt((void       *) p_opts_tcp,
                                                  (CPU_INT08U *)&tcp_hdr_opts[0],
                                                  (NET_ERR    *) p_err);
        if (*p_err != NET_TCP_ERR_NONE) {
             return;
        }
    } else {
        tcp_opt_len_size = 0u;
    }

                                                                /* ---------------- CALC TCP HDR CTRLS ---------------- */
                                                                /* Calc tot TCP hdr len (in octets).                    */
    tcp_hdr_len_size = (CPU_INT16U)(NET_TCP_HDR_SIZE_MIN + tcp_opt_len_size);
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    if (tcp_hdr_len_size > NET_TCP_HDR_SIZE_MAX) {
       *p_err = NET_TCP_ERR_INVALID_LEN_HDR;
        return;
    }
#endif


                                                                /* ----------------- PREPARE TCP HDR ------------------ */
    NetTCP_TxPktPrepareHdr(p_buf,
                           p_buf_hdr,
                           tcp_hdr_len_size,
                           tcp_opt_len_size,
                           sizeof(NET_IPv6_ADDR),
                           p_src_addr,
                           src_port,
                           p_dest_addr,
                           dest_port,
                           seq_nbr,
                           ack_nbr,
                           win_size,
                           flags_tcp,
                          &tcp_hdr_opts[0],
                           p_err);

    if (*p_err != NET_TCP_ERR_NONE) {
         return;
    }


                                                                /* -------------------- TX TCP PKT -------------------- */

    NetIPv6_Tx(                        p_buf,
                                       p_src_addr,
                                       p_dest_addr,
               (NET_IPv6_EXT_HDR     *)0,
                                       traffic_class,
                                       flow_label,
                                       hop_lim,
                                       p_err);
}
#endif

/*
*********************************************************************************************************
*                                      NetTCP_TxPktPrepareOpt()
*
* Description : (1) Prepare TCP header with TCP transmit options :
*
*                   (a) Prepare ALL TCP options from configuration
*                           data structure(s)
*                   (b) Pad remaining TCP header octets                     See RFC #793, Section 3.1
*                                                                               'Header Format : Padding'
*
*               (2) TCP transmit options MUST be configured by appropriate options configuration data
*                   structure(s) passed via 'p_opts_tcp'; see 'net_tcp.h  TCP HEADER OPTION CONFIGURATION
*                   DATA TYPES' for TCP options configuration.
*
*
* Argument(s) : p_opts_tcp   Pointer to one or more TCP options configuration data structures :
*               ---------
*                               NULL                            NO  TCP transmit         options configuration.
*                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
*
*                           Argument checked   in NetTCP_TxPkt().
*
*               p_opt_hdr    Pointer to TCP transmit option buffer to prepare TCP options.
*               --------    Argument validated in NetTCP_TxPkt().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP header options successfully prepared.
*                               NET_TCP_ERR_INVALID_OPT_TYPE    Invalid TCP option type.
*                               NET_TCP_ERR_INVALID_OPT_LEN     Invalid TCP option length.
*
* Return(s)   : Total TCP option length (in octets), if NO error(s).
*
*               0,                                   otherwise.
*
* Caller(s)   : NetTCP_TxPkt().
*
* Note(s)     : (3) (a) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES' for   supported TCP options' summary.
*
*                   (b) See 'net_tcp.c  Note #1c'                   for unsupported TCP options.
*
*               (4) Transmit arguments & options validated in NetTCP_TxPktValidate()/NetTCP_TxPktValidateOpt() :
*
*                   (a) Assumes ALL   transmit arguments & options are valid.
*                   (b) Assumes total transmit options' lengths    are valid.
*
*               (5) TCP header allows for a maximum option size of 40 octets (see 'net_tcp.h  TCP HEADER
*                   OPTIONS DEFINES  Note #3').
*
*               (6) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
*                       in length" and "may begin on any octet boundary".
*
*                   (b) Since TCP options are NOT required or guaranteed to align multi-octet words on
*                       appropriate word boundaries, ALL TCP options are prepared a single octet at a time.
*
*               (7) Default case already invalidated in NetTCP_TxPktValidateOpt().  However, the default
*                   case is included as an extra precaution in case any of the TCP transmit options types
*                   are incorrectly modified.
*********************************************************************************************************
*/

static  CPU_INT08U  NetTCP_TxPktPrepareOpt (void        *p_opts_tcp,
                                            CPU_INT08U  *p_opt_hdr,
                                            NET_ERR     *p_err)
{
    CPU_INT08U         tcp_opt_len_tot;
    CPU_INT08U         tcp_opt_len;
    CPU_INT08U        *p_opt_cfg_hdr;
    NET_TCP_OPT_TYPE  *p_opt_cfg_type;
    void              *p_opt_next;
    void              *p_opt_cfg;


    tcp_opt_len_tot = 0u;
    p_opt_cfg        = p_opts_tcp;
    p_opt_cfg_hdr    = p_opt_hdr;
                                                                /* ----------------- PREPARE TCP OPTS ----------------- */
    while (p_opt_cfg  != (void *)0) {                           /* Prepare ALL cfg'd TCP opts (see Note #1a).           */
        p_opt_cfg_type = (NET_TCP_OPT_TYPE *)p_opt_cfg;
        switch (*p_opt_cfg_type) {
            case NET_TCP_OPT_TYPE_MAX_SEG_SIZE:
                 NetTCP_TxPktPrepareOptMaxSegSize(p_opt_cfg, p_opt_cfg_hdr, &tcp_opt_len, &p_opt_next, p_err);
                 break;
                                                                /* --------------- UNSUPPORTED TCP OPTS --------------- */
                                                                /* See Note #3b.                                        */
            case NET_TCP_OPT_TYPE_WIN_SCALE:
            case NET_TCP_OPT_TYPE_SACK_PERMIT:
            case NET_TCP_OPT_TYPE_SACK:
            case NET_TCP_OPT_TYPE_ECHO_REQ:
            case NET_TCP_OPT_TYPE_ECHO_REPLY:
            case NET_TCP_OPT_TYPE_TS:
            case NET_TCP_OPT_TYPE_NONE:                         /* ----------------- INVALID TCP OPTS ----------------- */
            default:                                            /* See Note #7.                                         */
                 NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxOptTypeCtr);
                *p_err =  NET_TCP_ERR_INVALID_OPT_TYPE;
                 return (0u);
        }
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        if (*p_err != NET_TCP_ERR_NONE) {                       /* See Note #4a.                                        */
             return (0u);
        }
        if (tcp_opt_len_tot > NET_TCP_HDR_OPT_SIZE_MAX) {       /* See Note #4b.                                        */
            NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptLenCtr);
           *p_err =  NET_TCP_ERR_INVALID_OPT_LEN;
            return (0u);
        }
#endif

        tcp_opt_len_tot += tcp_opt_len;
        p_opt_cfg_hdr    += tcp_opt_len;

        p_opt_cfg         = p_opt_next;                         /* Prepare next cfg opt.                                */
    }


                                                                /* ------------------- PAD TCP HDR -------------------- */
    if (tcp_opt_len_tot > 0) {
                                                                /* Pad rem'ing TCP hdr octets (see Note #1b).           */
        while ((tcp_opt_len_tot %  NET_TCP_HDR_OPT_SIZE_WORD) &&
               (tcp_opt_len_tot <= NET_TCP_HDR_OPT_SIZE_MAX )) {
           *p_opt_cfg_hdr = NET_TCP_HDR_OPT_PAD;
            p_opt_cfg_hdr++;
            tcp_opt_len_tot++;
        }
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        if (tcp_opt_len_tot > NET_TCP_HDR_OPT_SIZE_MAX) {       /* See Note #4b.                                        */
            NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptLenCtr);
           *p_err =  NET_TCP_ERR_INVALID_OPT_LEN;
            return (0u);
        }
#endif
    }


   *p_err =  NET_TCP_ERR_NONE;

    return (tcp_opt_len_tot);
}



/*
*********************************************************************************************************
*                                 NetTCP_TxPktPrepareOptMaxSegSize()
*
* Description : (1) Prepare TCP header with TCP Maximum Segment Size option :
*
*                   (a) Prepare TCP Maximum Segment Size option
*                   (b) Return option values
*
*
* Argument(s) : p_opts_tcp   Pointer to TCP Maximum Segment Size option configuration data structure.
*               ---------   Argument checked   in NetTCP_TxPkt().
*
*               p_opt_hdr    Pointer to TCP transmit option buffer to prepare TCP Maximum Segment Size option.
*               --------    Argument validated in NetTCP_TxPkt().
*
*               p_opt_len    Pointer to variable that will receive the returned TCP option length (in octets).
*               --------    Argument validated in NetTCP_TxPktPrepareOpt().
*
*               p_opt_next   Pointer to variable that will receive the pointer to the next TCP transmit option.
*               --------    Argument validated in NetTCP_TxPktPrepareOpt().
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP Maximum Segment Size option successfully
*                                                                   prepared.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPktPrepareOpt().
*
* Note(s)     : (2) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES  Note #2b1' for TCP Maximum Segment Size
*                   option summary.
*
*               (3) Transmit arguments & options validated in NetTCP_TxPktValidate()/NetTCP_TxPktValidateOpt() :
*                   (a) Assumes ALL   transmit arguments & options are valid.
*                   (b) Assumes total transmit options' lengths    are valid.
*
*               (4) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
*                       in length" and "may begin on any octet boundary".
*
*                   (b) Since TCP options are NOT required or guaranteed to align multi-octet words on
*                       appropriate word boundaries, ALL TCP options are prepared a single octet at a time.
*********************************************************************************************************
*/

static  void  NetTCP_TxPktPrepareOptMaxSegSize (void         *p_opts_tcp,
                                                CPU_INT08U   *p_opt_hdr,
                                                CPU_INT08U   *p_opt_len,
                                                void        **p_opt_next,
                                                NET_ERR      *p_err)
{
    NET_TCP_OPT_CFG_MAX_SEG_SIZE  *p_opt_cfg_max_seg_size;
    CPU_INT08U                    *p_opt_cfg_hdr;
    CPU_INT08U                     opt_len;
    CPU_INT08U                     max_seg_size_hi;
    CPU_INT08U                     max_seg_size_lo;


                                                                /* ------------- PREPARE MAX SEG SIZE OPT ------------- */
    p_opt_cfg_max_seg_size = (NET_TCP_OPT_CFG_MAX_SEG_SIZE *)p_opts_tcp;
    p_opt_cfg_hdr          =  p_opt_hdr;

    opt_len                =  NET_TCP_HDR_OPT_LEN_MAX_SEG_SIZE;
    max_seg_size_hi        = (CPU_INT08U)(p_opt_cfg_max_seg_size->MaxSegSize >> DEF_OCTET_NBR_BITS);
    max_seg_size_lo        = (CPU_INT08U) p_opt_cfg_max_seg_size->MaxSegSize;


   *p_opt_cfg_hdr = NET_TCP_HDR_OPT_MAX_SEG_SIZE;               /* Prepare opt type.                                    */
    p_opt_cfg_hdr++;

   *p_opt_cfg_hdr = opt_len;                                    /* Prepare opt len.                                     */
    p_opt_cfg_hdr++;

   *p_opt_cfg_hdr = max_seg_size_hi;                            /* Prepare max seg size val.                            */
    p_opt_cfg_hdr++;

   *p_opt_cfg_hdr = max_seg_size_lo;


                                                                /* ------------------- RTN OPT VALS ------------------- */
   *p_opt_len  = opt_len;
   *p_opt_next = p_opt_cfg_max_seg_size->NextOptPtr;

   *p_err      = NET_TCP_ERR_NONE;
}



/*
*********************************************************************************************************
*                                      NetTCP_TxPktPrepareHdr()
*
* Description : (1) Prepare TCP header :
*
*                   (a) Update network buffer's protocol index & length controls
*
*                   (b) Prepare the transmit packet's following TCP header fields :
*
*                       (1) Source      Port
*                       (2) Destination Port
*                       (3) Sequence        Number
*                       (4) Acknowledgement Number
*                       (5) Header Length/Flags
*                       (6) Window Advertisement
*                       (7) Check-Sum                                       See Note #3
*                       (8) Urgent Pointer                                  See Note #2
*                       (9) Options
*
*                   (c) Convert the following TCP header fields from host-order to network-order :
*
*                       (1) Source      Port
*                       (2) Destination Port
*                       (3) Sequence        Number
*                       (4) Acknowledgement Number
*                       (5) Header Length/Flags
*                       (6) Window Advertisement
*                       (7) Check-Sum                                       See Note #3e
*                       (8) Urgent Pointer                                  See Note #2
*
*                   (d) Get TCP packet RTT timestamp transmitted            See 'NetTCP_TxConnRTT_RTO_Calc()
*                                                                                   Note #2a2A1'
*
*
* Argument(s) : p_buf               Pointer to network buffer to transmit TCP packet.
*               ----                Argument checked   in NetTCP_TxPktHandler().
*
*               p_buf_hdr           Pointer to network buffer header.
*               --------            Argument validated in NetTCP_TxPktHandler().
*
*               tcp_hdr_len_tot     Total TCP header length.
*               ---------------     Argument checked   in NetTCP_TxPkt().
*
*               tcp_opt_len_tot     Total TCP header options' length.
*               ---------------     Argument checked   in NetTCP_TxPktPrepareOpt().
*
*               src_addr            Source      IP  address.
*
*               src_port            Source      TCP port.
*               --------            Argument checked   in NetTCP_TxPktValidate().
*
*               dest_addr           Destination IP  address.
*
*               dest_port           Destination TCP port.
*               ---------           Argument checked   in NetTCP_TxPktValidate().
*
*               seq_nbr             TCP segment                 sequence number.
*               -------             Argument validated in NetTCP_TxPktValidate().
*
*               ack_nbr             TCP segment acknowledgment sequence number.
*               -------             Argument validated in NetTCP_TxPktValidate().
*
*               win_size            TCP receive window advertisement size.
*               --------            Argument validated in NetTCP_TxPktValidate().
*
*               flags_tcp           Flags to select TCP transmit options; bit-field flags logically OR'd :
*               ---------
*                                       NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
*                                       NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
*                                       NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
*                                       NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
*                                       NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
*                                       NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
*                                       NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
*
*                                   Argument checked   in NetTCP_TxPktValidate().
*
*               p_tcp_hdr_opts      Pointer to TCP options buffer.
*               -------------       Argument checked   in NetTCP_TxPktPrepareOpt().
*
*               p_err       Pointer to variable that will receive the return error code from this function :
*
*                               NET_TCP_ERR_NONE                TCP header successfully prepared.
*
*                                                               ----------- RETURNED BY NetBuf_DataWr() : ------------
*                               NET_BUF_ERR_INVALID_IX          Invalid buffer index  for transmit options.
*                               NET_BUF_ERR_INVALID_LEN         Invalid buffer length for transmit options.
*
*                                                               - RETURNED BY NetUtil_16BitOnesCplChkSumDataCalc() : -
*                               NET_UTIL_ERR_NULL_PTR           Check-sum passed a NULL pointer.
*                               NET_UTIL_ERR_NULL_SIZE          Check-sum passed a zero size.
*                               NET_UTIL_ERR_INVALID_PROTOCOL   Invalid data packet protocol.
*                               NET_BUF_ERR_INVALID_IX          Invalid buffer index.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxPkt().
*
* Note(s)     : (2) Urgent pointer & data NOT supported (see 'net_tcp.c  Note #1b').
*
*               (3) (a) TCP header Check-Sum MUST be calculated AFTER the entire TCP header has been prepared.
*                       In addition, ALL multi-octet words are converted from host-order to network-order
*                       since "the sum of 16-bit integers can be computed in either byte order" [RFC #1071,
*                       Section 2.(B)].
*
*                   (b) TCP header Check-Sum field MUST be cleared to '0' BEFORE the TCP header Check-Sum is
*                       calculated (see RFC #793, Section 3.1 'Header Format : Checksum').
*
*                   (c) (1) In addition to the TCP segment header & data, the TCP Check-Sum calculation
*                           includes "a 96-bit pseudo header conceptually prefixed to the TCP header ...
*                           [which] contains the Source Address, the Destination Address, the Protocol,
*                           and TCP length" (see RFC #793, Section 3.1 'Header Format : Checksum').
*
*                       (2) Since network check-sum functions REQUIRE that 16-bit one's-complement check-
*                           sum calculations be performed on headers & data arranged in network-order (see
*                           'net_util.c  NetUtil_16BitOnesCplChkSumDataCalc()  Note #3'), TCP pseudo-header
*                           values MUST be set or converted to network-order.
*
*                   (d) RFC #793, Section 3.1 'Header Format : Checksum' specifies that "if a segment contains
*                       an odd number of header and text octets ... the last octet is padded ... with zeros to
*                       form a 16-bit word for checksum purposes".
*
*                       See also 'net_util.c  NetUtil_16BitSumDataCalc()  Note #8'.
*
*                   (e) The TCP header Check-Sum field is returned in network-order & MUST NOT be re-
*                       converted back to host-order (see 'net_util.c  NetUtil_16BitOnesCplChkSumDataCalc()
*                       Note #4').
*********************************************************************************************************
*/

static  void  NetTCP_TxPktPrepareHdr (NET_BUF           *p_buf,
                                      NET_BUF_HDR       *p_buf_hdr,
                                      CPU_INT16U         tcp_hdr_len_tot,
                                      CPU_INT08U         tcp_opt_len_tot,
                                      CPU_INT16U         addr_size,
                                      void              *p_src_addr,
                                      NET_TCP_PORT_NBR   src_port,
                                      void              *p_dest_addr,
                                      NET_TCP_PORT_NBR   dest_port,
                                      NET_TCP_SEQ_NBR    seq_nbr,
                                      NET_TCP_SEQ_NBR    ack_nbr,
                                      NET_TCP_WIN_SIZE   win_size,
                                      NET_TCP_FLAGS      flags_tcp,
                                      CPU_INT32U        *p_tcp_hdr_opts,
                                      NET_ERR           *p_err)
{
#if (( defined(NET_IPv4_MODULE_EN)) && \
     (!defined(NET_TCP_CHK_SUM_OFFLOAD_TX)))
    NET_IPv4_ADDR        *p_src_addrv4;
    NET_IPv4_ADDR        *p_dest_addrv4;
    NET_TCP_PSEUDO_HDR    tcp_pseudo_hdr;
#endif
#ifdef  NET_IPv6_MODULE_EN
    NET_IPv6_PSEUDO_HDR   ipv6_pseudo_hdr;
#endif
    NET_TCP_HDR          *p_tcp_hdr;
    CPU_INT16U            tcp_hdr_len;
    NET_TCP_HDR_FLAGS     tcp_flags;
    NET_TCP_HDR_FLAGS     tcp_hdr_len_flags;
    CPU_INT16U            tcp_opt_ix;
    NET_CHK_SUM           tcp_chk_sum;

                                                                /* ----------------- UPDATE BUF CTRLS ----------------- */
    p_buf_hdr->TransportHdrLen   =  tcp_hdr_len_tot;
    p_buf_hdr->TransportHdrIx    =  p_buf_hdr->DataIx - p_buf_hdr->TransportHdrLen;

    p_buf_hdr->TotLen           += (NET_BUF_SIZE)p_buf_hdr->TransportHdrLen;
    p_buf_hdr->TransportTotLen   = (CPU_INT16U  )p_buf_hdr->TotLen;
    p_buf_hdr->TransportDataLen  = (CPU_INT16U  )p_buf_hdr->DataLen;




                                                                /* ----------------- PREPARE TCP HDR ------------------ */
    p_tcp_hdr = (NET_TCP_HDR *)&p_buf->DataPtr[p_buf_hdr->TransportHdrIx];



                                                                /* ---------------- PREPARE TCP PORTS ----------------- */
    NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->PortSrc,  &src_port);
    NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->PortDest, &dest_port);



                                                                /* --------------- PREPARE TCP SEQ NBRS --------------- */
    NET_UTIL_VAL_COPY_SET_NET_32(&p_tcp_hdr->SeqNbr, &seq_nbr);
    NET_UTIL_VAL_COPY_SET_NET_32(&p_tcp_hdr->AckNbr, &ack_nbr);



                                                                /* ------------ PREPARE TCP HDR LEN/FLAGS ------------- */
    tcp_hdr_len        =  p_buf_hdr->TransportHdrLen / NET_TCP_HDR_LEN_WORD_SIZE;
    tcp_hdr_len      <<=  NET_TCP_HDR_LEN_SHIFT;

    tcp_flags          = (NET_TCP_HDR_FLAGS)NET_TCP_HDR_FLAG_NONE;
    tcp_flags         |= (NET_TCP_HDR_FLAGS)flags_tcp;

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    tcp_hdr_len       &=  NET_TCP_HDR_LEN_MASK;
    tcp_flags         &=  NET_TCP_HDR_FLAG_MASK;
#endif

    tcp_hdr_len_flags  = (NET_TCP_HDR_FLAGS)tcp_hdr_len  | tcp_flags;
    NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->HdrLen_Flags, &tcp_hdr_len_flags);



                                                                /* ----------------- PREPARE TCP WIN ------------------ */
    NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->WinSize, &win_size);


                                                                /* -------------- PREPARE TCP URGENT PTR -------------- */
                                                                /* See Note #2.                                         */
    NET_UTIL_VAL_SET_NET_16(&p_tcp_hdr->UrgentPtr, NET_TCP_HDR_URG_PTR_NONE);



                                                                /* ----------------- PREPARE TCP OPTS ----------------- */
    if (tcp_opt_len_tot > 0) {
        tcp_opt_ix = p_buf_hdr->TransportHdrIx + NET_TCP_HDR_OPT_IX;
        NetBuf_DataWr((NET_BUF    *)p_buf,
                      (NET_BUF_SIZE)tcp_opt_ix,
                      (NET_BUF_SIZE)tcp_opt_len_tot,
                      (CPU_INT08U *)p_tcp_hdr_opts,
                      (NET_ERR    *)p_err);
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
        if (*p_err != NET_BUF_ERR_NONE) {
             return;
        }
#endif
    }



                                                                /* --------------- PREPARE TCP CHK SUM ---------------- */
    NET_UTIL_VAL_SET_NET_16(&p_tcp_hdr->ChkSum, 0x0000u);       /* Clr TCP chk sum            (see Note #3b).           */
                                                                /* Cfg TCP chk sum pseudo-hdr (see Note #3c).           */
    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        p_buf_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V4;
        p_buf_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

#ifdef NET_TCP_CHK_SUM_OFFLOAD_TX
        tcp_chk_sum = 0u;
#else
        p_src_addrv4            = (NET_IPv4_ADDR *)p_src_addr;
        p_dest_addrv4           = (NET_IPv4_ADDR *)p_dest_addr;
        tcp_pseudo_hdr.AddrSrc  = (NET_IPv4_ADDR  )NET_UTIL_HOST_TO_NET_32(*p_src_addrv4);
        tcp_pseudo_hdr.AddrDest = (NET_IPv4_ADDR  )NET_UTIL_HOST_TO_NET_32(*p_dest_addrv4);
        tcp_pseudo_hdr.Zero     = 0x00u;
        tcp_pseudo_hdr.Protocol = NET_IP_HDR_PROTOCOL_TCP;
        tcp_pseudo_hdr.TotLen   = NET_UTIL_HOST_TO_NET_16(p_buf_hdr->TransportTotLen);
                                                                /* Calc TCP chk sum.                                    */
        tcp_chk_sum             =  NetUtil_16BitOnesCplChkSumDataCalc((void *) p_buf,
                                                                      (void *)&tcp_pseudo_hdr,
                                                                               NET_TCP_PSEUDO_HDR_SIZE,
                                                                               p_err);
#endif
#endif

    } else {
#ifdef  NET_IPv6_MODULE_EN
        p_buf_hdr->ProtocolHdrType          = NET_PROTOCOL_TYPE_TCP_V6;
        p_buf_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;

        Mem_Copy(&p_buf_hdr->IPv6_AddrSrc,  p_src_addr,  NET_IPv6_ADDR_SIZE);
        Mem_Copy(&p_buf_hdr->IPv6_AddrDest, p_dest_addr, NET_IPv6_ADDR_SIZE);

        ipv6_pseudo_hdr.AddrSrc          =                                     p_buf_hdr->IPv6_AddrSrc;
        ipv6_pseudo_hdr.AddrDest         =                                     p_buf_hdr->IPv6_AddrDest;
        ipv6_pseudo_hdr.UpperLayerPktLen = (CPU_INT32U)NET_UTIL_HOST_TO_NET_32(p_buf_hdr->TransportTotLen);
        ipv6_pseudo_hdr.Zero             = (CPU_INT16U)0x00u;
        ipv6_pseudo_hdr.NextHdr          = (CPU_INT32U)NET_UTIL_HOST_TO_NET_16(NET_IP_HDR_PROTOCOL_TCP);

#ifdef NET_TCP_CHK_SUM_OFFLOAD_TX
        tcp_chk_sum = 0u;
#else
        tcp_chk_sum                      = NetUtil_16BitOnesCplChkSumDataCalc((void     *) p_buf,
                                                                              (void     *)&ipv6_pseudo_hdr,
                                                                              (CPU_INT16U) NET_IPv6_PSEUDO_HDR_SIZE,
                                                                              (NET_ERR  *) p_err);
#endif
#endif
    }

#ifndef NET_TCP_CHK_SUM_OFFLOAD_TX
    if (*p_err != NET_UTIL_ERR_NONE) {
         return;
    }
#endif

    NET_UTIL_VAL_COPY_16(&p_tcp_hdr->ChkSum, &tcp_chk_sum);     /* Copy TCP chk sum in net order (see Note #3e).        */



                                                                /* ---------------- GET TCP RTT TX TS ----------------- */
    p_buf_hdr->TCP_RTT_TS_Txd_ms = (NET_TCP_TX_RTT_TS_MS)NetUtil_TS_Get_ms();


   (void)&addr_size;

   *p_err = NET_TCP_ERR_NONE;
}


/*
*********************************************************************************************************
*                                         NetTCP_TxPktFree()
*
* Description : Free network buffer(s).
*
* Argument(s) : p_buf_q      Pointer to network buffer queue.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerReTxQ(),
*               NetTCP_TxConnAck(),
*               NetTCP_TxConnReset().
*
* Note(s)     : (1) (a) Although TCP Transmit initially requests the network buffer for transmit, the
*                       TCP layer maintains a reference to the buffer for possible retransmission.
*
*                   (b) Therefore, even though the network interface transmit deallocation task frees
*                       ALL unreferenced buffers after successful transmission, the TCP layer MUST free
*                       buffers which are still referenced.
*
*                       See also 'net_if.c  NetIF_TxDeallocTaskHandler()  Note #1c'.
*********************************************************************************************************
*/

static  NET_BUF_QTY  NetTCP_TxPktFree (NET_BUF  *p_buf_q)
{
    NET_BUF_QTY  qty;


    qty = NetBuf_FreeBufQ_PrimList(p_buf_q, DEF_NULL);

    return (qty);
}


/*
*********************************************************************************************************
*                                        NetTCP_TxPktDiscard()
*
* Description : On any TCP transmit packet error(s), discard TCP packet(s) & buffer(s).
*
* Argument(s) : p_buf        Pointer to network buffer.
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_ERR_TX                      Transmit error.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_TxConnAppData(),
*               NetTCP_TxPktHandler().
*
* Note(s)     : (1) Since some TCP Transmit packets are passed the network buffer from other TCP functions,
*                   they may NOT be the buffers' only references & MUST therefore check buffers' reference
*                   counter before freeing buffers.
*********************************************************************************************************
*/

static  void  NetTCP_TxPktDiscard (NET_BUF  *p_buf,
                                   NET_ERR  *p_err)
{
    NET_CTR  *pctr;


#if (NET_CTR_CFG_ERR_EN == DEF_ENABLED)
    pctr = (NET_CTR *)&Net_ErrCtrs.TCP.TxPktDiscardedCtr;
#else
    pctr = (NET_CTR *) 0;
#endif
   (void)NetBuf_FreeBufQ_PrimList((NET_BUF *)p_buf,
                                  (NET_CTR *)pctr);

   *p_err = NET_ERR_TX;
}


/*
*********************************************************************************************************
*                                          NetTCP_ConnCfg()
*
* Description : (1) Configure TCP connection's controls :
*
*                   (a) Configure  TCP connection's connection maximum segment size         See Note #2
*                   (b) Configure  TCP connection's receive  window controls                See Note #3
*                   (c) Configure  TCP connection's transmit window controls                See Note #4
*                   (d) Initialize TCP connection's transmit round-trip time &
*                                                re-transmit timeout controls
*
*
* Argument(s) : p_conn       Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_RxPktConnHandlerCfgConn(),
*                                                 NetTCP_ConnClr().
*
*               cfg_code    Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                               NET_TCP_CONN_CFG_NONE                   Perform NO  configuration actions.
*                               NET_TCP_CONN_CFG_ALL                    Perform ALL configuration actions.
*
*                               NET_TCP_CONN_CFG_MAX_SEG_SIZE_LOCAL     Configure local      maximum segment size.
*                               NET_TCP_CONN_CFG_MAX_SEG_SIZE_REMOTE    Configure remote     maximum segment size.
*                               NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN      Configure connection maximum segment size.
*                               NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL       Configure ALL        maximum segment sizes.
*
*                               NET_TCP_CONN_CFG_WIN_SIZE_RX            Configure receive    window size(s).
*                               NET_TCP_CONN_CFG_WIN_SIZE_TX            Configure transmit   window size(s).
*                               NET_TCP_CONN_CFG_WIN_SIZE_CONN          Configure connection window size(s).
*                               NET_TCP_CONN_CFG_WIN_SIZE_ALL           Configure ALL        window sizes.
*
*                               NET_TCP_CONN_CFG_TX_RTT_RTO             Configure transmit round-trip time (RTT)
*                                                                           & re-transmit timeout (RTO) control(s).
*
*                           See also 'TCP CONNECTION CONFIGURATION CODE DEFINES'.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerCfgConn(),
*               NetTCP_ConnClr().
*
* Note(s)     : (2) A TCP connection's connection maximum segment size should NOT be updated until
*                   after certain other TCP connection control(s) have been configured.
*
*                   See also 'NetTCP_ConnCfgMaxSegSize()   Note #3'.
*
*               (3) A TCP connection's receive  window controls should NOT be updated until after
*                   certain other TCP connection control(s) have been configured.
*
*                   See also 'NetTCP_RxConnWinSizeCfg()    Note #2'.
*
*               (4) A TCP connection's transmit window controls should NOT be updated until after
*                   certain other TCP connection control(s) have been configured.
*
*                   See also 'NetTCP_TxConnWinSizeCfg()    Note #2'.
*
*               (5) A TCP connection's transmit round-trip time & re-transmit timeout controls
*                   should NOT be updated until after certain other TCP connection control(s)
*                   have been configured.
*
*                   See also 'NetTCP_TxConnRTT_RTO_Init()  Note #1'.
*********************************************************************************************************
*/

static  void  NetTCP_ConnCfg (NET_TCP_CONN      *p_conn,
                              NET_TCP_CFG_CODE   cfg_code)
{
    CPU_BOOLEAN  cfg_conn_max_seg_size;
    CPU_BOOLEAN  cfg_conn_win_size;
    CPU_BOOLEAN  cfg_conn_tx_rtt_rto;


    cfg_conn_max_seg_size = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN);
    if (cfg_conn_max_seg_size == DEF_YES) {
        NetTCP_ConnCfgMaxSegSize(p_conn);                       /* Cfg  conn max seg size  (see Note #2).               */
    }

    cfg_conn_win_size = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_WIN_SIZE_RX);
    if (cfg_conn_win_size == DEF_YES) {
        NetTCP_RxConnWinSizeCfg(p_conn);                        /* Cfg  rx win ctrls       (see Note #3).               */
    }

    cfg_conn_win_size = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_WIN_SIZE_TX);
    if (cfg_conn_win_size == DEF_YES) {
        NetTCP_TxConnWinSizeCfg(p_conn);                        /* Cfg  tx win ctrls       (see Note #4).               */
    }

    cfg_conn_tx_rtt_rto = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_TX_RTT_RTO);
    if (cfg_conn_tx_rtt_rto == DEF_YES) {
        NetTCP_TxConnRTT_RTO_Init(p_conn);                      /* Init tx RTT / RTO ctrls (see Note #5).               */
    }
}


/*
*********************************************************************************************************
*                                     NetTCP_ConnCfgMaxSegSize()
*
* Description : Configure TCP connection's maximum segment size.
*
* Argument(s) : p_conn      Pointer to a TCP connection.
*               -----       Argument validated in NetTCP_ConnCfg().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnCfg().
*
* Note(s)     : (1) RFC #1122, Section 4.2.2.6 states that "the maximum size of a segment that TCP really
*                   sends, the 'effective send MSS', MUST be the smaller of the send MSS ... and ... less
*                   than or equal to ... the maximum size ... that can be received".
*
*               (2) In order to avoid transmit window deadlock with a remote host's receive window, the
*                   TCP connection's connection maximum segment size MUST be configured to ensure that
*                   full, maximum-segment-sized segments will transmit even for receive windows less than
*                   the default maximum segment size.
*
*                   (a) RFC #1122, Section 4.2.3.4.(3) states to "send data ... if at least a fraction Fs
*                       of the maximum window can be sent ... Fs is a fraction whose recommended value is
*                       1/2".
*
*                       Thus it seems reasonable to calculate & limit the remote host's maximum window
*                       size by a similar fraction.
*
*               (3) A TCP connection's connection maximum segment size should NOT be updated until after
*                   the following TCP connection control(s) have been configured :
*
*                   (a) TCP connection's local  maximum segment size ('MaxSegSizeLocal')
*                           [see 'NetTCP_ConnClr()  Note #3a']
*
*                   (b) TCP connection's remote maximum segment size ('MaxSegSizeRemote')
*                           [see 'NetTCP_RxPktConnHandlerListen()   Note #7'
*                              & 'NetTCP_RxPktConnHandlerSyncTxd()  Note #3']
*
*                   (c) TCP connection's maximum transmit remote window size ('TxWinSizeRemoteMax')
*                           [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
*                              & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A & #3b']
*********************************************************************************************************
*/

static  void  NetTCP_ConnCfgMaxSegSize (NET_TCP_CONN  *p_conn)
{
    NET_TCP_WIN_SIZE  remote_win_size_th;
    NET_TCP_SEG_SIZE  remote_max_seg_size;

                                                                /* Calc remote max seg size (see Note #2).              */
    remote_win_size_th     = (NET_TCP_WIN_SIZE)(((CPU_INT32U)p_conn->TxWinSizeRemoteMax * NET_TCP_TX_SILLY_WIN_NUMER)
                                                                                        / NET_TCP_TX_SILLY_WIN_DENOM);
    remote_max_seg_size    = (NET_TCP_SEG_SIZE)DEF_MIN(p_conn->MaxSegSizeRemote,
                                                       remote_win_size_th);

                                                                /* Cfg conn max seg size    (see Note #1).              */
    p_conn->MaxSegSizeConn = (NET_TCP_SEG_SIZE)DEF_MIN(p_conn->MaxSegSizeLocalActual,
                                                       remote_max_seg_size);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnIdleTimeout()
*
* Description : (1) Handle an idle TCP connection on timeout :
*
*                   (a) Clear TCP connection's idle connection timer            See Notes #4a1A & #4a2
*
*                   (b) (1) If enabled,  handle TCP connection keep-alive for the following states :
*
*                           (A) ESTABLISHED                                     See Note  #2b1
*                           (B) CLOSE-WAIT                                      See Note  #2b2
*
*                       (2) Otherwise, close TCP connection
*
*
* Argument(s) : p_conn_timeout       Pointer to a TCP connection (see Note #3b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_TxConnReqClose(),
*                             NetTCP_ConnClosingTimeoutDataAvail(),
*                     various NetTCP_RxPktConnHandler() functions.
*
* Note(s)     : (2) RFC #1122, Section 4.2.3.6 states that "TCP ... MAY ... periodically [probe]
*                   the other end of a connection when the connection is ... idle".
*
*                   (a) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2,
*                       Pages 332-333 adds that "if there is no activity on a given connection
*                       for 2 hours", TCP "sends a [keep-alive] probe segment to the" remote host.
*
*                   (b) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
*                       'Connection Establishment and Keepalive Timers : Keepalive timer expires
*                       after 2 hours of idle time', Page 829 states that TCP "keepalive probes
*                       ... are sent only if the connection is in the" :
*
*                       (1) "ESTABLISHED or" ...
*                       (2) "CLOSE_WAIT states."
*
*                   (c) Although NO RFC explicitly states that a TCP connection should or should
*                       not transmit a TCP reset segment when  a TCP connection is closed due to
*                       a lack of response to all keep-alive probe segments from the remote host,
*                       it seems implied & reasonable that a TCP reset is unnecessary since the
*                       remote host has not replied to any TCP keep-alive probe segments.
*
*                       See also 'NetTCP_TxConnKeepAlive()  Note #2c2B'.
*
*                   See also 'NetTCP_TxConnKeepAlive()  Note #2'.
*
*               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (4) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection timeout timer ('TimeoutTmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared prior to next handler function(s).
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_TIMEOUT
*********************************************************************************************************
*/

static  void  NetTCP_ConnIdleTimeout (void  *p_conn_timeout)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CLOSE_CODE   close_code;
    NET_ERR              err;


    p_conn = (NET_TCP_CONN *)p_conn_timeout;                    /* See Note #3b2A.                                      */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }
#endif


                                                                /* --------------- HANDLE IDLE TCP CONN --------------- */
    close_code = NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_TIMEOUT);    /* See Note #4b1.                                       */

    p_conn->TimeoutTmr = DEF_NULL;                              /* Clr TCP conn tmr (see Note #4a2A1).                  */

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_FREE:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
             return;


        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
             return;

                                                                /* ----------- HANDLE TCP CONN KEEP-ALIVES ------------ */
        case NET_TCP_CONN_STATE_CONN:                           /* See Note #1b1.                                       */
        case NET_TCP_CONN_STATE_CLOSE_WAIT:                     /* See Note #1b2.                                       */
             if (p_conn->TxKeepAliveEn == DEF_ENABLED) {        /* If en'd, ...                                         */
                 DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_CONN_TX_RESET); /* See Note #2c.                            */
                 NetTCP_TxConnKeepAlive(p_conn, close_code, &err); /* ... handle keep-alives (see Note #2).             */
                (void)&err;                                     /* Ignore ALL err(s), transitory or fatal.              */
                 return;
             }
                                                                /* 'break' intentionally omitted; MUST ...              */
                                                                /* ... execute the following code block :               */
                                                                /* -------------- ... 'CLOSE TCP CONN'. --------------- */
                                                                /* ------------------ CLOSE TCP CONN ------------------ */
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             if (p_conn->ConnCloseTimeoutFaultFlag != DEF_NO) { /* If TCP conn timeout fault, ...                       */
                                                                /* ... fault-close TCP conn.                            */
                 NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                                  (NET_BUF_HDR      *)0,
                                  (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                                  (NET_TCP_CLOSE_CODE)close_code);

             } else {                                           /* Else      close TCP conn.                            */
                 NetTCP_ConnCloseHandler((NET_TCP_CONN     *)p_conn,
                                         (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                                         (NET_TCP_CLOSE_CODE)close_code);
             }
             break;


        case NET_TCP_CONN_STATE_NONE:
        default:
             NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                              (NET_BUF_HDR      *)0,
                              (CPU_BOOLEAN       )DEF_YES,
                              (NET_TCP_CLOSE_CODE)close_code);
             NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
             return;
    }
}


/*
*********************************************************************************************************
*                                         NetTCP_ConnClose()
*
* Description : (1) Close a TCP connection due to TCP connection fault(s) :
*
*                   (a) Update   TCP connection close statistic(s)
*                   (b) Transmit TCP connection reset to remote host                    See Note #4
*                   (c) Close    TCP connection
*
*
*               (2) TCP connection closed internally by TCP layer when certain TCP connection parameters
*                   are corrupted or when certain valid TCP connection operations fail.
*
*               (3) Since the mechanisms of TCP connection close are independent of the application layer
*                   close; TCP connection MAY need to close application layer connection(s).
*
*                   See also 'NetTCP_ConnCloseHandler()  Note #2b'.
*
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in various.
*
*               p_buf_hdr            Pointer to network buffer header that received TCP packet.
*
*               close_conn_app      Indicate whether to close application connection (see Note #3):
*
*                                       DEF_YES                        Close application connection.
*                                       DEF_NO                  Do NOT close application connection.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                 timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgment delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                      timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                              timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
* Return(s)   : none.
*
* Caller(s)   : various.
*
* Note(s)     : (4) Although NO RFC directly states to transmit a TCP reset segment when a TCP connection
*                   fault-closes, it is inferred & seems reasonable that a TCP reset segment SHOULD be
*                   transmitted whenever a TCP connection closes abnormally from any of the following
*                   synchronization/connected/closing states :
*
*                   (a) SYN-RECEIVED
*                   (b) SYN-SENT
*                   (c) ESTABLISHED
*                   (d) FIN-WAIT-1
*                   (e) FIN-WAIT-2
*                   (f) CLOSING
*                   (g) TIME_WAIT
*                   (h) CLOSE-WAIT
*                   (i) LAST-ACK
*
*                   See also 'NetTCP_TxConnReset()  Note #4b'.
*
*               (5) On any TCP connection handler function fault(s), TCP connection MUST NEVER be re-closed.
*
*                   See also 'NetTCP_ConnCloseHandler()  Note #4'.
*********************************************************************************************************
*/

static  void  NetTCP_ConnClose (NET_TCP_CONN        *p_conn,
                                NET_BUF_HDR         *p_buf_hdr,
                                CPU_BOOLEAN          close_conn_app,
                                NET_TCP_CLOSE_CODE   close_code)
{
    CPU_BOOLEAN   tx_reset;
    NET_SOCK     *p_sock;
    CPU_BOOLEAN   shutdown_wr = DEF_FALSE;
    NET_CONN_ID   conn_id;
    NET_ERR       err;

                                                                /* ---------------- UPDATE CLOSE STATS ---------------- */
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnCloseCtr);

                                                                /* ---------------- TX TCP CONN RESET ----------------- */
    tx_reset = DEF_BIT_IS_SET(close_code, NET_TCP_CONN_CLOSE_CONN_TX_RESET);
    conn_id  = p_conn->ID_Conn;


    p_sock = NetSock_GetObj(NetConn_Tbl[conn_id].ID_App);
    if (p_sock != DEF_NULL) {
        shutdown_wr = (p_sock->ShutdownMode == NET_SOCK_SHUTDOWN_MODE_WR);
    }

    if (tx_reset == DEF_YES) {                                  /* Tx TCP conn reset (see Note #4).                     */
        if ( (shutdown_wr                        == DEF_TRUE                     )   &&
             (p_conn->ConnCloseTimeoutFaultFlag  == DEF_SET                      )   &&
            ((p_conn->ConnState                  == NET_TCP_CONN_STATE_FIN_WAIT_2)   ||
             (p_conn->ConnState                  == NET_TCP_CONN_STATE_TIME_WAIT ))) {
            close_conn_app           = DEF_YES;                 /* Indicate we want to clr app reference to conn. It ...*/
            p_conn->ConnCloseAppFlag = DEF_SET;                 /* ...consequently frees the half-closed socket.        */
            p_conn->ConnState        = NET_TCP_CONN_STATE_CLOSING;
        }
        NetTCP_TxConnReset((NET_TCP_CONN     *) p_conn,
                           (NET_BUF_HDR      *) p_buf_hdr,
                           (NET_TCP_RESET_CODE) NET_TCP_CONN_TX_RESET_FAULT,
                           (NET_TCP_CLOSE_CODE) NET_TCP_CONN_CLOSE_NONE, /* MUST NOT re-close TCP conn (see Note #5).   */
                           (NET_ERR          *)&err);
    }
                                                                /* ------------------ CLOSE TCP CONN ------------------ */
    NetTCP_ConnCloseHandler(p_conn, close_conn_app, close_code);
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnCloseHandler()
*
* Description : (1) Close a TCP connection :
*
*                   (a) Close network connection(s)                                 See Note #2
*                   (b) Free  TCP     connection
*
*
*               (2) (a) TCP connection's network     connection(s) MUST be closed BEFORE the TCP connection
*                       is closed/freed.
*
*                   (b) TCP connection's application connection(s) :
*
*                       (1) MAY be CLOSED &/or reset :
*
*                           (A) For the following TCP connection condition(s), the TCP connection MUST
*                               close the application connection(s) :
*
*                               (1) (a) Invalid TCP connection parameters :
*                                       (1) Invalid TCP connection state(s)
*                                       (2) Invalid/corrupted TCP data queue(s) :
*                                           (A) Invalid sequence numbers
*                                           (B) Invalid segment  lengths
*
*                                   (b) Fatal TCP transmit     fault(s)
*                                   (c) TCP connection closing fault(s)
*
*                               (2) Invalid network connection configuration
*
*                           (B) For the following TCP connection condition(s), the TCP connection SHOULD
*                               close the application connection(s) based on its application close flag
*                               ('ConnCloseAppFlag') :
*
*                               (1) Valid TCP connection closing states/timeouts
*
*                           (C) For the following TCP connection condition(s), the TCP connection MAY --
*                               but is NOT required to -- close the application connection(s) :
*
*                               (1) Initial TCP connection configuration/preparation
*
*                       (2) But possibly NOT freed, since some application connections have NO mechanism
*                           or API to close an application's reference to the connection.
*
*                       See also specific application connection close function(s) for additional notes.
*
*
* Argument(s) : p_conn               Pointer to a TCP connection.
*               -----               Argument validated in NetTCP_ConnClose(),
*                                                         NetTCP_ConnIdleTimeout(),
*                                                         various.
*
*               close_conn_app      Indicate whether to close application connection (see Note #2b):
*
*                                       DEF_YES                        Close application connection.
*                                       DEF_NO                  Do NOT close application connection.
*
*               close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
*                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
*
*                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
*                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
*
*                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
*                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnClose(),
*               NetTCP_ConnIdleTimeout(),
*               various.
*
* Note(s)     : (3) TCP connection free codes are identical to TCP connection close codes.
*
*                   See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES  Note #2'.
*
*               (4) On any TCP connection close, TCP connection MUST NEVER be re-closed.
*********************************************************************************************************
*/

static  void  NetTCP_ConnCloseHandler (NET_TCP_CONN        *p_conn,
                                       CPU_BOOLEAN          close_conn_app,
                                       NET_TCP_CLOSE_CODE   close_code)
{
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    CPU_BOOLEAN        used;
#endif
    NET_CONN_ID        conn_id = p_conn->ID_Conn;
    NET_TCP_FREE_CODE  free_code;

                                                                /* ------------- VALIDATE TCP CONN CLOSE -------------- */
#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)
    used = DEF_BIT_IS_SET(p_conn->Flags, NET_TCP_FLAG_USED);
    if (used != DEF_YES) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
        return;
    }
#endif

    switch (p_conn->ConnState) {
        case NET_TCP_CONN_STATE_CLOSED:
        case NET_TCP_CONN_STATE_LISTEN:
        case NET_TCP_CONN_STATE_SYNC_RXD:
        case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
        case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        case NET_TCP_CONN_STATE_SYNC_TXD:
        case NET_TCP_CONN_STATE_CONN:
        case NET_TCP_CONN_STATE_FIN_WAIT_1:
        case NET_TCP_CONN_STATE_FIN_WAIT_2:
        case NET_TCP_CONN_STATE_CLOSING:
        case NET_TCP_CONN_STATE_TIME_WAIT:
        case NET_TCP_CONN_STATE_CLOSE_WAIT:
        case NET_TCP_CONN_STATE_LAST_ACK:
        case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
             break;


        case NET_TCP_CONN_STATE_NONE:                           /* MUST NOT re-close TCP conn if already ...            */
        case NET_TCP_CONN_STATE_FREE:                           /* ... freed/closed (see Note #4).                      */
        default:
             return;
    }
                                                                /* ------------------ FREE TCP CONN ------------------- */
    free_code = (NET_TCP_FREE_CODE)close_code;                  /* See Note #3.                                         */
    NetTCP_ConnFreeHandler(p_conn, free_code);

                                                                /* ------------------ CLOSE CONN(S) ------------------- */
    NetConn_CloseFromTransport(conn_id, close_conn_app);
}


/*
*********************************************************************************************************
*                                NetTCP_ConnClosingTimeoutDataAvail()
*
* Description : (1) Handle closing TCP connection with available application data :
*
*                   (a) If TCP connection's application receive queue is       now empty,
*                           close the TCP connection
*                   (b) If TCP connection's application receive queue is still NOT empty
*                           after the time-wait timeout, set the user connection timeout
*
*                   See also 'NetTCP_RxPktConnHandlerFinWait1()  Note #2f5A2b',
*                            'NetTCP_RxPktConnHandlerFinWait2()  Note #2f5B2',
*                          & 'NetTCP_RxPktConnHandlerClosing()   Note #2d2B2a1B2'.
*
*
* Argument(s) : p_conn_timeout       Pointer to a TCP connection (see Note #2b).
*
* Return(s)   : none.
*
* Caller(s)   : Referenced in NetTCP_RxPktConnHandlerFinWait1(),
*                             NetTCP_RxPktConnHandlerFinWait2(),
*                             NetTCP_RxPktConnHandlerClosing().
*
* Note(s)     : (2) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
*                   type functions -- even though network timer API functions cast callback functions
*                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
*
*                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
*                           to an object ... may be converted to a pointer to a different object ...
*                           [but] if the resulting pointer is not correctly aligned ... the behavior
*                           is undefined".
*
*                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
*                           pointer arguments, network timer callback functions MUST avoid incorrect
*                           pointer conversion behavior between 'void' pointer parameters & non-'void'
*                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
*
*                       (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
*                           to or from a pointer to any ... object ... A pointer to any ... object ...
*                           may be converted to a pointer to void and back again; the result shall
*                           compare equal to the original pointer".
*
*                   (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
*                       network object pointer objects, network timer callback functions MUST :
*
*                       (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
*                       (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
*                           (A) in this case, a 'NET_TCP_CONN' pointer.
*
*                   See also 'net_tmr.c  NetTmr_Get()  Note #3'.
*
*               (3) This function is a network timer callback function :
*
*                   (a) (1) For the following connection timer(s) ... :
*
*                           (A) TCP connection timeout timer ('TimeoutTmr')
*
*                       (2) (A) Clear the timer pointer ... :
*                               (1) Cleared in NetTCP_ConnFreeTmr() via NetTCP_ConnCloseHandler(),
*                                                                       NetTCP_ConnClose(); or
*                               (2) Reset   by NetTmr_Get().
*
*                           (B) but do NOT re-free the timer.
*
*                   (b) Do NOT set the following close timer flag(s) :
*
*                       (1) NET_TCP_CONN_CLOSE_TMR_TIMEOUT
*
*               (4) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
*                   "for any state if the user timeout expires, flush all queues, signal the user
*                   'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
*********************************************************************************************************
*/

static  void  NetTCP_ConnClosingTimeoutDataAvail (void  *p_conn_timeout)
{
    NET_TCP_CONN        *p_conn;
    NET_TCP_CLOSE_CODE   close_code;
    CPU_BOOLEAN          data_avail;
    NET_TMR_TICK         timeout_tick;
    NET_ERR              err;


    p_conn      = (NET_TCP_CONN *)p_conn_timeout;               /* See Note #2b2A.                                      */

    close_code =  NET_TCP_CONN_CLOSE_ALL;
    DEF_BIT_CLR(close_code, NET_TCP_CONN_CLOSE_TMR_TIMEOUT);    /* See Note #3b1.                                       */

#if (NET_ERR_CFG_ARG_CHK_DBG_EN == DEF_ENABLED)                 /* ---------------- VALIDATE TCP CONN ----------------- */
    if (p_conn == DEF_NULL) {
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NullPtrCtr);
        return;
    }
#endif

                                                                /* Closing data avail for half-closed conns ONLY.       */
    data_avail = ((p_conn->ConnCloseCode !=  NET_CONN_CLOSE_HALF      ) ||
                 ((p_conn->RxQ_State     ==  NET_TCP_RX_Q_STATE_CLOSED) &&
                  (p_conn->RxQ_App_Head  == DEF_NULL))) ? DEF_NO : DEF_YES;

    if (data_avail != DEF_YES) {                                /* If NO app data avail, ...                            */
                                                                /* ... close TCP conn  (see Note  #1a).                 */
        NetTCP_ConnCloseHandler((NET_TCP_CONN     *)p_conn,
                                (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                                (NET_TCP_CLOSE_CODE)close_code);

    } else {                                                    /* Else reset user tmr (see Notes #1b & #4).            */
        timeout_tick       = p_conn->TimeoutUser_tick;
        p_conn->TimeoutTmr = NetTmr_Get((CPU_FNCT_PTR )&NetTCP_ConnIdleTimeout,
                                        (void        *) p_conn,
                                        (NET_TMR_TICK ) timeout_tick,
                                        (NET_ERR     *)&err);
        if (err != NET_TMR_ERR_NONE) {
            NetTCP_ConnClose((NET_TCP_CONN     *)p_conn,
                             (NET_BUF_HDR      *)0,
                             (CPU_BOOLEAN       )p_conn->ConnCloseAppFlag,
                             (NET_TCP_CLOSE_CODE)close_code);
            return;
        }

        p_conn->ConnCloseAppFlag = DEF_YES;
    }
}


/*
*********************************************************************************************************
*                                      NetTCP_ConnFreeHandler()
*
* Description : (1) Free a TCP connection :
*
*                   (a) Free   TCP connection timers
*                   (b) Free   TCP connection packet buffer queues
*                   (c) Clear  TCP connection controls
*                   (d) Free   TCP connection back to TCP connection pool
*                   (e) Update TCP connection pool statistics
*
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_ConnFree(),
*                                                     NetTCP_ConnClose().
*
*               free_code       Select which free action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_FREE_TMR_NONE              Free NO                                timers.
*                                   NET_TCP_CONN_FREE_TMR_ALL               Free ALL                               timers.
*
*                                   NET_TCP_CONN_FREE_TMR_TIMEOUT           Free connection                        timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_IDLE           Free    transmit idle                  timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN      Free    transmit silly window persist  timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN       Free    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_ACK_DLY        Free    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_FREE_TMR_RE_TX             Free re-transmit                       timer.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnFree(),
*               NetTCP_ConnCloseHandler().
*
* Note(s)     : (2) ALL network resources linked to the TCP connection MUST be freed PRIOR to TCP connection
*                   free or discard so that no network resources are lost.
*********************************************************************************************************
*/

static  void  NetTCP_ConnFreeHandler (NET_TCP_CONN       *p_conn,
                                      NET_TCP_FREE_CODE   free_code)
{
    CPU_BOOLEAN  discard;
    NET_ERR      err;


                                                                /* FREE TCP CONN TMR's                                  */
    NetTCP_ConnFreeTmr(p_conn, free_code);


                                                                /* FREE TCP CONN Q's                                    */
    NetTCP_ConnFreeBufQ(&p_conn->RxQ_Transport_Head, &p_conn->RxQ_Transport_Tail);
    NetTCP_ConnFreeBufQ(&p_conn->RxQ_App_Head      , &p_conn->RxQ_App_Tail      );
    NetTCP_ConnFreeBufQ(&p_conn->TxQ_Head          , &p_conn->TxQ_Tail          );
    NetTCP_ConnFreeBufQ(&p_conn->ReTxQ_Head        , &p_conn->ReTxQ_Tail        );


    discard = DEF_NO;

    NetTCP_RxQ_Abort(p_conn->ID, &err);                         /* Abort wait on TCP conn rx Q.                         */
    if (err != NET_TCP_ERR_NONE) {                              /* If  TCP conn rx Q NOT aborted, ...                   */
        discard = DEF_YES;                                      /* ... discard TCP conn (see Note #2b).                 */
    }

    NetTCP_RxQ_Clr(p_conn->ID, &err);                           /* Clr TCP conn rx Q.                                   */
    if (err != NET_TCP_ERR_NONE) {                              /* If  TCP conn rx Q NOT clr'd, ...                     */
        discard = DEF_YES;                                      /* ... discard TCP conn (see Note #2b).                 */
    }

    NetTCP_TxQ_Abort(p_conn->ID, &err);                         /* Abort wait on TCP conn tx Q.                         */
    if (err != NET_TCP_ERR_NONE) {                              /* If  TCP conn rx Q NOT aborted, ...                   */
        discard = DEF_YES;                                      /* ... discard TCP conn (see Note #2b).                 */
    }

    NetTCP_TxQ_Clr(p_conn->ID, &err);                           /* Clr TCP conn tx Q.                                   */
    if (err != NET_TCP_ERR_NONE) {                              /* If  TCP conn tx Q NOT clr'd, ...                     */
        discard = DEF_YES;                                      /* ... discard TCP conn (see Note #2b).                 */
    }

                                                                /* ------------ DISCARD TCP CONN ON ERR(S) ------------ */
    if (discard != DEF_NO) {                                    /* On TCP conn free err(s), ...                         */
        NetTCP_ConnDiscard(p_conn);                             /* ... discard TCP conn (see Note #2a).                 */
        return;
    }



                                                                /* ------------------- CLR TCP CONN ------------------- */
    p_conn->ConnState = NET_TCP_CONN_STATE_FREE;                /* Set TCP conn as freed/NOT used.                      */
    DEF_BIT_CLR(p_conn->Flags, NET_TCP_FLAG_USED);

#if (NET_DBG_CFG_MEM_CLR_EN == DEF_ENABLED)
    NetTCP_ConnClr(p_conn);
#endif


    p_conn->ID_Conn    = NET_CONN_ID_NONE;                      /* Clr TCP conn's net conn id.                          */

                                                                /* ------------------ FREE TCP CONN ------------------- */
    p_conn->NextPtr    = NetTCP_ConnPoolPtr;
    NetTCP_ConnPoolPtr = p_conn;


                                                                /* ------------ UPDATE TCP CONN POOL STATS ------------ */
    NetStat_PoolEntryUsedDec(&NetTCP_ConnPoolStat, &err);
}


/*
*********************************************************************************************************
*                                        NetTCP_ConnFreeTmr()
*
* Description : Clear TCP connection's timers.
*
* Argument(s) : p_conn           Pointer to a TCP connection.
*               -----           Argument validated in NetTCP_ConnFreeHandler(),
*                                                     various NetTCP_ConnHandler() functions.
*
*               free_code       Select which free action(s) to perform; bit-field flags logically OR'd :
*
*                                   NET_TCP_CONN_FREE_TMR_NONE              Free NO                                timers.
*                                   NET_TCP_CONN_FREE_TMR_ALL               Free ALL                               timers.
*
*                                   NET_TCP_CONN_FREE_TMR_TIMEOUT           Free connection                        timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_IDLE           Free    transmit idle                  timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN      Free    transmit silly window persist  timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN       Free    transmit zero  window persist  timer.
*                                   NET_TCP_CONN_FREE_TMR_TX_ACK_DLY        Free    transmit acknowledgement delay timer.
*                                   NET_TCP_CONN_FREE_TMR_RE_TX             Free re-transmit                       timer.
*
*                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnFreeHandler(),
*               various NetTCP_ConnHandler() functions.
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_ConnFreeTmr (NET_TCP_CONN       *p_conn,
                                  NET_TCP_FREE_CODE   free_code)
{
    CPU_BOOLEAN  free_tmr;


    free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TIMEOUT);
    if (free_tmr == DEF_YES) {
        if (p_conn->TimeoutTmr != DEF_NULL) {
            NetTmr_Free(p_conn->TimeoutTmr);
            p_conn->TimeoutTmr  = DEF_NULL;
        }
    }


    free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_IDLE);
    if (free_tmr == DEF_YES) {
        if (p_conn->TxQ_IdleTmr != DEF_NULL) {
            NetTmr_Free(p_conn->TxQ_IdleTmr);
            p_conn->TxQ_IdleTmr  = DEF_NULL;
        }
    }

    free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN);
    if (free_tmr == DEF_YES) {
        if (p_conn->TxQ_SillyWinTmr != DEF_NULL) {
            NetTmr_Free(p_conn->TxQ_SillyWinTmr);
            p_conn->TxQ_SillyWinTmr  = DEF_NULL;
        }
    }

    free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN);
    if (free_tmr == DEF_YES) {
        if (p_conn->TxQ_ZeroWinTmr != DEF_NULL) {
            NetTmr_Free(p_conn->TxQ_ZeroWinTmr);
            p_conn->TxQ_ZeroWinTmr  = DEF_NULL;
        }
    }

    free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_ACK_DLY);
    if (free_tmr == DEF_YES) {
        if (p_conn->TxAckDlyTmr != DEF_NULL) {
            NetTmr_Free(p_conn->TxAckDlyTmr);
            p_conn->TxAckDlyTmr  = DEF_NULL;
        }
    }


    free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_RE_TX);
    if (free_tmr == DEF_YES) {
        if (p_conn->ReTxQ_Tmr != DEF_NULL) {
            NetTmr_Free(p_conn->ReTxQ_Tmr);
            p_conn->ReTxQ_Tmr  = DEF_NULL;
        }
    }
}


/*
*********************************************************************************************************
*                                        NetTCP_ConnFreeBufQ()
*
* Description : Free a TCP connection's buffer queue.
*
* Argument(s) : p_buf_q_head     Pointer to a TCP connection buffer queue's head pointer.
*
*               p_buf_q_tail     Pointer to a TCP connection buffer queue's tail pointer.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerRxQ_Sync(),
*               NetTCP_TxConnSync(),
*               NetTCP_ConnFreeHandler().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_ConnFreeBufQ (NET_BUF  **p_buf_q_head,
                                   NET_BUF  **p_buf_q_tail)
{
    NET_BUF  *p_buf_q;

                                                                /* Free buf Q.                                          */
    p_buf_q = *p_buf_q_head;
   (void)NetBuf_FreeBufQ_PrimList(p_buf_q, DEF_NULL);
                                                                /* Clr  buf Q ptrs to NULL.                             */
   *p_buf_q_head = DEF_NULL;
   *p_buf_q_tail = DEF_NULL;
}


/*
*********************************************************************************************************
*                                          NetTCP_ConnClr()
*
* Description : Clear TCP connection controls.
*
* Argument(s) : p_conn      Pointer to a TCP connection.
*               ------      Argument validated in NetTCP_Init(),
*                                                 NetTCP_ConnGet(),
*                                                 NetTCP_ConnFreeHandler().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_Init(),
*               NetTCP_ConnGet(),
*               NetTCP_ConnFreeHandler().
*
* Note(s)     : (1) Configured in NetTCP_ConnCfg() :
*
*                   (a) Configured  in NetTCP_ConnCfgMaxSegSize().
*
*                   (b) Configured  in NetTCP_RxConnWinSizeCfg() :
*                       (1) Configured in NetTCP_RxConnWinSizeCfgUpdateTh().
*
*                   (c) Configured  in NetTCP_TxConnWinSizeCfg() :
*                       (1) Configured in NetTCP_TxConnWinSizeCfgCongCtrl().
*                       (2) Configured in NetTCP_TxConnWinSizeCfgMinTh().
*
*                   (d) Initialized in NetTCP_TxConnRTT_RTO_Init().
*                       (1) Configured in NetTCP_TxConnRTO_CfgMaxTimeout().
*
*               (2) See 'NetTCP_RxPktConnHandler()  Note #3c'.
*
*               (3) (a) See 'net_tcp.h  TCP SEGMENT SIZE DEFINES  Note #1b1'.
*                   (b) See 'net_tcp.h  TCP SEGMENT SIZE DEFINES  Note #1b2'.
*
*               (4) See 'net_cfg.h  TRANSMISSION CONTROL PROTOCOL LAYER CONFIGURATION  Note #2'.
*
*               (5) See 'NetTCP_TxConnTxQ()  Note #6b2B'.
*
*               (6) See 'net_tcp.h  TCP CONGESTION CONTROL DEFINES  Note #5b4'.
*
*               (7) See 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1b'.
*
*               (8) See 'net_tcp.h  TCP CONGESTION CONTROL DEFINES  Note #6b'.
*
*               (9) See 'NetTCP_TxConnAck()  Note #4a4A1'.
*
*              (10) (a) See 'NetTCP_TxConnKeepAlive()  Note #2a2'.
*                   (b) See 'net_tcp.h  TCP CONNECTION KEEP-ALIVE & PROBE DEFINES  Note #1a1'.
*                   (c) See 'net_tcp.h  TCP CONNECTION KEEP-ALIVE & PROBE DEFINES  Note #1a2'.
*
*              (11) See 'net_tcp.h  TCP CONGESTION CONTROL DEFINES  Note #7'.
*
*              (12) See 'NetTCP_ConnCfgReTxMaxTimeout()  Note #3'.
*
*              (13) (a) See 'net_tcp.h  TCP CONNECTION TIMEOUT DEFINES  Note #2'.
*                   (b) See 'net_tcp.h  TCP CONNECTION TIMEOUT DEFINES  Note #1b'.
*                   (c) See 'NetTCP_RxPktConnHandlerConn()  Note #3a'.
*********************************************************************************************************
*/

static  void  NetTCP_ConnClr (NET_TCP_CONN  *p_conn)
{
    NET_TCP_CONN_ID  conn_id_tcp;
    NET_ERR          err;


    conn_id_tcp                          =  p_conn->ID;
                                                                /* -------------- CLR/INIT TCP CONN VALS -------------- */
    p_conn->NextPtr                      =  DEF_NULL;

    p_conn->ID_Conn                      =  NET_CONN_ID_NONE;

    p_conn->ConnState                    =  NET_TCP_CONN_STATE_FREE;

    p_conn->ConnCloseCode                =  NET_CONN_CLOSE_FULL;/* See Note #2.                                         */
    p_conn->ConnCloseAppFlag             =  DEF_YES;
    p_conn->ConnCloseTimeoutFaultFlag    =  DEF_YES;



    p_conn->MaxSegSizeLocalCfgd          =  NET_TCP_MAX_SEG_SIZE_DFLT_RX; /* See Note #3a.                              */
    p_conn->MaxSegSizeLocalActual        =  p_conn->MaxSegSizeLocalCfgd;
    p_conn->MaxSegSizeRemote             =  NET_TCP_MAX_SEG_SIZE_DFLT_TX; /* See Note #3b.                              */
#if 0                                                           /* See Note #1a.                                        */
    p_conn->MaxSegSizeConn               =  NET_TCP_MAX_SEG_SIZE_NONE;
#endif

    p_conn->RxSeqNbrSync                 =  NET_TCP_SEQ_NBR_NONE;
    p_conn->RxSeqNbrNext                 =  NET_TCP_SEQ_NBR_NONE;
    p_conn->RxSeqNbrLast                 =  NET_TCP_SEQ_NBR_NONE;
    p_conn->RxSeqNbrClose                =  NET_TCP_SEQ_NBR_NONE;
    p_conn->RxWinSizeCfgd                =  NET_TCP_DFLT_RX_WIN_SIZE_OCTET; /* See Note #4.                             */
#if 0                                                           /* See Note #1b.                                        */
    p_conn->RxWinSizeCalcd               =  p_conn->RxWinSizeCfgd;
    p_conn->RxWinSizeActual              =  p_conn->RxWinSizeCfgd;
    p_conn->RxWinSizeUpdateTh            =  NET_TCP_WIN_SIZE_NONE; /* See Note #1b1.                                    */
#endif

    p_conn->RxQ_State                    =  NET_TCP_RX_Q_STATE_CLOSED;
    p_conn->RxQ_Transport_Head           =  DEF_NULL;
    p_conn->RxQ_Transport_Tail           =  DEF_NULL;
    p_conn->RxQ_App_Head                 =  DEF_NULL;
    p_conn->RxQ_App_Tail                 =  DEF_NULL;

    p_conn->TxSeqNbrSync                 =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrNext                 =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrNextQ                =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrUnReTxd              =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrUnAckd               =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrUnAckdPrev           =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrUnAckdAlignDelta     =  0u;
    p_conn->TxSeqNbrLast                 =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxSeqNbrClose                =  NET_TCP_SEQ_NBR_NONE;

    p_conn->TxWinUpdateSeqNbr            =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxWinUpdateAckNbr            =  NET_TCP_ACK_NBR_NONE;
    p_conn->TxWinUpdateWinSize           =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeCfgd                =  NET_TCP_DFLT_TX_WIN_SIZE_OCTET; /* See Note #4.                             */
    p_conn->TxWinSizeRemote              =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeRemoteMax           =  p_conn->TxWinSizeRemote;
    p_conn->TxWinSizeRemoteActual        =  p_conn->TxWinSizeRemote;
    p_conn->TxWinSizeRemoteRem           =  p_conn->TxWinSizeRemote;
    p_conn->TxWinSizeNagleEn             =  DEF_ENABLED;        /* See Note #5.                                         */
    p_conn->TxWinSillyWinTimeout_ms      =  NET_TCP_TX_SILLY_WIN_TIMEOUT_DFLT_MS; /* See Note #6.                       */
    p_conn->TxWinZeroWinTimeout_ms       =  0u;                 /* See Note #7.                                         */
    p_conn->TxWinSillyWinTimeout_tick    =  (p_conn->TxWinSillyWinTimeout_ms * NET_TMR_TIME_TICK_PER_SEC)
                                                                             / DEF_TIME_NBR_mS_PER_SEC;
#if 0                                                           /* See Note #1c.                                        */
    p_conn->TxWinSizeCfgdRem             =  p_conn->TxWinSizeCfgd;
    p_conn->TxWinRxdAckDupCtr            =  0u;
    p_conn->TxWinRxdLastSeqNbr           =  NET_TCP_SEQ_NBR_NONE;
    p_conn->TxWinRxdLastAckNbr           =  NET_TCP_ACK_NBR_NONE;
    p_conn->TxWinRxdLastWinSize          =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeSlowStartTh         =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeSlowStartThInit     =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeCongInit            =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeCongCalcdActual     =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeCongCalcdCur        =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeCongRem             =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeAvail               =  NET_TCP_WIN_SIZE_NONE;
    p_conn->TxWinSizeMinTh               =  NET_TCP_WIN_SIZE_NONE;
#endif

    NetTCP_ConnCfgTxAckDlyTimeoutHandler(conn_id_tcp,
                                         NET_TCP_DFLT_TIMEOUT_CONN_ACK_DLY_MS, /* See Note #8.                          */
                                        &err);

    p_conn->TxAckDlyTmr                  =  DEF_NULL;
    p_conn->TxAckDlyCnt                  =  0u;

    p_conn->TxAckImmedRxdPushEn          =  DEF_ENABLED;        /* See Note #9.                                         */


    p_conn->TxKeepAliveEn                =  DEF_DISABLED;       /* See Note #10a.                                       */
    p_conn->TxKeepAliveCtr               =  0u;
    p_conn->TxKeepAliveTh                =  NET_TCP_TX_KA_TH_DFLT; /* See Note #10b.                                    */
    p_conn->TxKeepAliveRetryTimeout_sec  =  NET_TCP_TX_KA_RETRY_TIMEOUT_DFLT_SEC; /* See Note #10c.                     */


    p_conn->TxSegReTxTh                  =  NET_TCP_RE_TX_TH_DFLT; /* See Note #11.                                     */


    p_conn->TxRTT_RTO_Max_sec            =  NET_TCP_TX_RTO_MAX_TIMEOUT_DFLT_SEC; /* See Note #12.                       */
#if 0                                                           /* See Note #1d.                                        */
    p_conn->TxRTT_Avg_ms_scaled          =  NET_TCP_TX_RTT_NONE;
    p_conn->TxRTT_Dev_ms_scaled          =  NET_TCP_TX_RTT_NONE;
    p_conn->TxRTT_RTO_ms_scaled          =  NET_TCP_TX_RTO_NONE;
    p_conn->TxRTT_RTO_Max_ms_scaled      =  NET_TCP_TX_RTO_NONE;/* See Note #1d1.                                       */
    p_conn->TxRTT_Avg_ms                 =  NET_TCP_TX_RTT_NONE;
    p_conn->TxRTT_Dev_ms                 =  NET_TCP_TX_RTT_NONE;
    p_conn->TxRTT_RTO_ms                 =  NET_TCP_TX_RTO_NONE;
    p_conn->TxRTT_RTO_Max_ms             =  NET_TCP_TX_RTO_NONE;/* See Note #1d1.                                       */
    p_conn->TxRTT_RTO_sec                =  NET_TCP_TX_RTO_NONE;
    p_conn->TxRTT_RTO_tick               =  NET_TMR_TIME_0S;
    p_conn->TxRTT_RTO_State              =  NET_TCP_TX_RTT_RTO_STATE_NONE;
#endif


    p_conn->TxQ_State                    =  NET_TCP_TX_Q_STATE_CLOSED;
    p_conn->TxQ_Head                     =  DEF_NULL;
    p_conn->TxQ_Tail                     =  DEF_NULL;
    p_conn->TxQ_IdleTmr                  =  DEF_NULL;
    p_conn->TxQ_SillyWinTmr              =  DEF_NULL;
    p_conn->TxQ_ZeroWinTmr               =  DEF_NULL;
    p_conn->ReTxQ_Head                   =  DEF_NULL;
    p_conn->ReTxQ_Tail                   =  DEF_NULL;
    p_conn->ReTxQ_Tmr                    =  DEF_NULL;



    p_conn->TimeoutTmr                   =  DEF_NULL;
    p_conn->TimeoutConn_sec              =  NET_TCP_CONN_TIMEOUT_IDLE_DFLT_SEC; /* See Note #13a.                       */
    p_conn->TimeoutUser_sec              =  NET_TCP_CONN_TIMEOUT_USER_DFLT_SEC; /* See Note #13c.                       */
    p_conn->TimeoutMaxSeg_sec            =  NET_TCP_DFLT_TIMEOUT_CONN_MAX_SEG_SEC; /* See Note #13b.                    */
    p_conn->TimeoutConn_tick             =  p_conn->TimeoutConn_sec   * NET_TMR_TIME_TICK_PER_SEC;
    p_conn->TimeoutUser_tick             =  p_conn->TimeoutUser_sec   * NET_TMR_TIME_TICK_PER_SEC;
    p_conn->TimeoutMaxSeg_tick_scaled    =  p_conn->TimeoutMaxSeg_sec * NET_TMR_TIME_TICK_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;



    p_conn->Flags                        =  NET_TCP_FLAG_NONE;

    p_conn->FnctAppListenQ_IsAvail       =  DEF_NULL;
    p_conn->FnctAppPostRx                =  DEF_NULL;
    p_conn->FnctAppPostTx                =  DEF_NULL;


    NetTCP_ConnCfg(p_conn, NET_TCP_CONN_CFG_ALL);               /* See Note #1.                                         */



                                                                /* -------------- CFG DFLT TIMEOUT VALS --------------- */
    NetTCP_RxQ_TimeoutDflt(conn_id_tcp, &err);
    NetTCP_TxQ_TimeoutDflt(conn_id_tcp, &err);
}


/*
*********************************************************************************************************
*                                          NetTCP_ConnCopy()
*
* Description : (1) Copy/clone a TCP connection :
*
*                   (a) Copy connection parameters :
*
*                       (1) TCP connection state
*
*                       (2) Receive  parameters :
*                           (A)    Receive  window size
*
*                       (3) Transmit parameters :
*                           (A)    Transmit window size
*                           (B)    Transmit acknowledgement
*                           (C)    Transmit keep-alive
*
*                           (D) Re-transmit parameters :
*                               (1) Threshold
*                               (2) Maximum timeout
*
*                           (E) IP transmit parameters :
*                               (1) TOS
*                               (2) TTL
*                               (3) IP flags
*
*                       (4) TCP connection timeout values
*
*                   (b) Configure copied connection parameters :
*
*                       (1)    Receive  controls
*                       (2)    Transmit controls
*                       (3) Re-transmit controls
*
*
* Argument(s) : p_conn_dest      Pointer to TCP connection to receive TCP connection copy.
*               ----------      Argument validated in NetTCP_RxPktConnHandlerListen().
*
*               p_conn_src       Pointer to TCP connection to copy.
*               ---------       Argument validated in NetTCP_RxPktConnHandlerListen().
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_RxPktConnHandlerListen().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_ConnCopy (NET_TCP_CONN  *p_conn_dest,
                               NET_TCP_CONN  *p_conn_src)
{
    NET_TCP_CFG_CODE  cfg_code;


    p_conn_dest->ConnState                   = p_conn_src->ConnState;


    p_conn_dest->MaxSegSizeLocalCfgd         = p_conn_src->MaxSegSizeLocalCfgd;


    p_conn_dest->RxWinSizeCfgd               = p_conn_src->RxWinSizeCfgd;


    p_conn_dest->TxWinSizeCfgd               = p_conn_src->TxWinSizeCfgd;
    p_conn_dest->TxWinSizeNagleEn            = p_conn_src->TxWinSizeNagleEn;

    p_conn_dest->TxAckDlyTimeout_ms          = p_conn_src->TxAckDlyTimeout_ms;
    p_conn_dest->TxAckDlyTimeout_tick        = p_conn_src->TxAckDlyTimeout_tick;
    p_conn_dest->TxAckImmedRxdPushEn         = p_conn_src->TxAckImmedRxdPushEn;

    p_conn_dest->TxKeepAliveEn               = p_conn_src->TxKeepAliveEn;
    p_conn_dest->TxKeepAliveTh               = p_conn_src->TxKeepAliveTh;
    p_conn_dest->TxKeepAliveRetryTimeout_sec = p_conn_src->TxKeepAliveRetryTimeout_sec;

    p_conn_dest->TxSegReTxTh                 = p_conn_src->TxSegReTxTh;
    p_conn_dest->TxRTT_RTO_Max_sec           = p_conn_src->TxRTT_RTO_Max_sec;


    p_conn_dest->TimeoutConn_sec             = p_conn_src->TimeoutConn_sec;
    p_conn_dest->TimeoutUser_sec             = p_conn_src->TimeoutUser_sec;
    p_conn_dest->TimeoutMaxSeg_sec           = p_conn_src->TimeoutMaxSeg_sec;
    p_conn_dest->TimeoutConn_tick            = p_conn_src->TimeoutConn_tick;
    p_conn_dest->TimeoutUser_tick            = p_conn_src->TimeoutUser_tick;
    p_conn_dest->TimeoutMaxSeg_tick_scaled   = p_conn_src->TimeoutMaxSeg_tick_scaled;


    NetConn_Copy(p_conn_dest->ID_Conn,
                 p_conn_src->ID_Conn);

                                                                /* Cfg conn (see Note #1b).                             */
    cfg_code = NET_TCP_CONN_CFG_NONE         |
               NET_TCP_CONN_CFG_WIN_SIZE_ALL |
               NET_TCP_CONN_CFG_TX_RTT_RTO;
    NetTCP_ConnCfg(p_conn_dest, cfg_code);
}


/*
*********************************************************************************************************
*                                        NetTCP_ConnDiscard()
*
* Description : (1) Discard an invalid/corrupted TCP connection :
*
*                   (a) Discard TCP connection from available TCP connection pool           See Note #2
*                   (b) Update  TCP connection pool statistics
*
*               (2) Assumes TCP connection is invalid/corrupt & MUST be removed.  TCP connection removed
*                   simply by NOT returning the TCP connection back to the TCP connection pool.
*
*
* Argument(s) : p_conn       Pointer to an invalid/corrupted TCP connection.
*
* Return(s)   : none.
*
* Caller(s)   : NetTCP_ConnGet(),
*               NetTCP_ConnFree().
*
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  NetTCP_ConnDiscard (NET_TCP_CONN  *p_conn)
{
    NET_ERR  err;

                                                                /* ----------------- DISCARD TCP CONN ----------------- */
   (void)&p_conn;                                               /* Prevent 'variable unused' warning (see Note #2).     */

                                                                /* --------------- UPDATE DISCARD STATS --------------- */
    NetStat_PoolEntryLostInc(&NetTCP_ConnPoolStat, &err);
}


/*
*********************************************************************************************************
*                                    NetTCP_ConnFiveTupleSeqNbrGet()
*
* Description : (1) Get the initial sequence number for a new TCP connection just before a SYN is sent for
*                   the first time in an active open OR just after a SYN is recived in a passive open.
*
* Argument(s) : p_conn       Pointer to valid Network Connection associated with the TCP Connection.
*
* Return(s)   : The sequence number as the following:
*
*                              ISN = M + F(localip, localport, remoteip, remoteport, secretkey)
*
*               Where:
*                              M = The value of a counter (NetTCP_TxSeqNbrCtr) maintained by the developer
*                                  at the BSP level. The counter must be incremented by '1' every 4 uS.
*
*                              F = A mixing function (chosen to be MD5) that takes as input the five-tuple:
*                                  (localip, localport, remoteip, remoteport, secretkey); of which the first
*                                  four coordinates are known but 'secretkey' must be chosen preferably at
*                                  boot time (See NetTCP_Init()).
*
* Caller(s)   :  via NET_TCP_TX_GET_SEQ_NBR() macro.
*
* Note(s)     : none.
*********************************************************************************************************
*/

#ifdef  NET_TCP_CFG_RANDOM_ISN_GEN
NET_TCP_SEQ_NBR  NetTCP_ConnFiveTupleSeqNbrGet (NET_CONN  *p_conn)
{
    NET_CONN_FAMILY          conn_family;
    CPU_INT08U               hash_output[16u];
    NET_TCP_SEQ_NBR          seq_nbr;
    NET_TCP_ISN_FIVE_TUPLE   isn_five_tuple;
#ifdef  NET_IPv6_MODULE_EN
    CPU_INT08U               ipv6_addr_offset;
#endif

    conn_family = p_conn->Family;

    Mem_Clr(hash_output, sizeof(hash_output));

    switch (conn_family) {
#ifdef  NET_IPv4_MODULE_EN
        case  NET_CONN_FAMILY_IP_V4_SOCK:
              Mem_Copy(&isn_five_tuple.Local_IP,
                       &p_conn->AddrLocal[NET_SOCK_ADDR_IP_LEN_PORT],
                        NET_IPv4_ADDR_LEN);

              Mem_Copy(&isn_five_tuple.Local_Port,
                        p_conn->AddrLocal,
                        NET_SOCK_ADDR_IP_LEN_PORT);

              Mem_Copy(&isn_five_tuple.Remote_IP,
                       &p_conn->AddrRemote[NET_SOCK_ADDR_IP_LEN_PORT],
                        NET_IPv4_ADDR_LEN);

              Mem_Copy(&isn_five_tuple.Remote_Port,
                        p_conn->AddrRemote,
                        NET_SOCK_ADDR_IP_LEN_PORT);

              isn_five_tuple.Local_Port  = NET_UTIL_HOST_TO_NET_16(isn_five_tuple.Local_Port);
              isn_five_tuple.Remote_Port = NET_UTIL_HOST_TO_NET_16(isn_five_tuple.Remote_Port);
              break;
#endif

#ifdef  NET_IPv6_MODULE_EN
        case  NET_CONN_FAMILY_IP_V6_SOCK:                       /* Skip Port & FlowInfo fields to calculate addr offset.*/
              ipv6_addr_offset = sizeof(NET_PORT_NBR) + sizeof(CPU_INT32U);

              Mem_Copy(                &isn_five_tuple.Local_IP,
                       (NET_IPv6_ADDR *)p_conn->AddrLocal[ipv6_addr_offset],
                                        NET_IPv6_ADDR_LEN);

              Mem_Copy(&isn_five_tuple.Local_Port,
                       &p_conn->AddrLocal,
                        NET_SOCK_ADDR_IP_LEN_PORT);

              Mem_Copy(                &isn_five_tuple.Remote_IP,
                       (NET_IPv6_ADDR *)p_conn->AddrRemote[ipv6_addr_offset],
                                        NET_IPv6_ADDR_LEN);

              Mem_Copy(&isn_five_tuple.Remote_Port,
                       &p_conn->AddrRemote,
                        NET_SOCK_ADDR_IP_LEN_PORT);

              isn_five_tuple.Local_Port = NET_UTIL_HOST_TO_NET_16(isn_five_tuple.Local_Port);
              isn_five_tuple.Remote_Port = NET_UTIL_HOST_TO_NET_16(isn_five_tuple.Remote_Port);
              break;
#endif

        default:                                                /* Shouldn't get here. Conn family validated by caller. */
              break;
    }

    Mem_Copy(isn_five_tuple.Secret,                             /* Load secret key obtained by NetTCP_Init() on startup.*/
             &NetTCP_ISN_SecretKey,
              sizeof(NetTCP_ISN_SecretKey));

    NetMD5_Init(&NetTCP_ISN_MD5_Handle);                        /* Initialize ISN Handle for MD5 hashing.               */
    NetMD5_Update(              &NetTCP_ISN_MD5_Handle,         /* Update and obtain final MD5 digest.                  */
                  (CPU_INT08U *)&isn_five_tuple,
                                 sizeof(NET_TCP_ISN_FIVE_TUPLE));

    NetMD5_Final(hash_output, &NetTCP_ISN_MD5_Handle);

    seq_nbr = *(CPU_INT32U *)hash_output + NetTCP_TxSeqNbrCtr;  /* Add lower 4 bytes of the hash to sequence nbr counter.*/

    Mem_Clr(&NetTCP_ISN_MD5_Handle, sizeof(NET_MD5_CONTEXT));

    return (seq_nbr);
}
#endif


/*
*********************************************************************************************************
*                                         NetUDP_GetTxDataIx()
*
* Description : Get the offset of a buffer at which the UDP data can be written.
*
* Argument(s) : if_nbr
*
*               protocol
*
*               data_len
*
*               flags
*
*               p_ix
*
*               p_err        Pointer to variable that will receive the return error code from this function :
*
*                               NET_ERR_TX                      Transmit error.
*
* Return(s)   : none.
*
* Caller(s)   : none.
*
* Note(s)     : none.
*********************************************************************************************************
*/
static  void  NetTCP_GetTxDataIx (NET_IF_NBR          if_nbr,
                                  NET_PROTOCOL_TYPE   protocol,
                                  CPU_INT16U          additial_hdr_size,
                                  CPU_INT16U          data_len,
                                  NET_TCP_CONN       *p_conn,
                                  CPU_INT16U         *p_ix,
                                  NET_ERR            *p_err)
{
    NET_MTU  mtu;


   *p_ix += (NET_TCP_HDR_SIZE_MIN + additial_hdr_size);

#if 0
    remove extra tcp header option length.
#endif

    switch (protocol) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_PROTOCOL_TYPE_TCP_V4:
             mtu = NetIF_MTU_GetProtocol(if_nbr, NET_PROTOCOL_TYPE_TCP_V4, NET_IF_FLAG_NONE, p_err);

             NetIPv4_TxIxDataGet(if_nbr,
                                 data_len,
                                 mtu,
                                 p_ix,
                                 p_err);
             break;
#endif
#ifdef  NET_IPv6_MODULE_EN
        case NET_PROTOCOL_TYPE_TCP_V6:
             mtu = NetIF_MTU_GetProtocol(if_nbr, NET_PROTOCOL_TYPE_TCP_V6, NET_IF_FLAG_NONE, p_err);

             if (*p_err != NET_IF_ERR_NONE) {
                return;
             }

             NetIPv6_GetTxDataIx(if_nbr,
                                 DEF_NULL,
                                 data_len,
                                 mtu,
                                 p_ix,
                                 p_err);
             break;
#endif

        default:
            *p_err = NET_ERR_INVALID_PROTOCOL;
             return;
    }

   (void)&p_conn;
}


/*
*********************************************************************************************************
*********************************************************************************************************
*                                             MODULE END
*********************************************************************************************************
*********************************************************************************************************
*/

#endif                                                          /* ---------------- NET_TCP_MODULE_EN ----------------- */
