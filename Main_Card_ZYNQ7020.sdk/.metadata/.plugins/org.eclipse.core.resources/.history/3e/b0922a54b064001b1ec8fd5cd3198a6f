#include "xil_exception.h"
#include "xparameters.h"
#include "xil_printf.h"
#include "xil_types.h"
#include "xil_cache.h"
#include "XScuGic.h"
#include "xcanfd_hw.h"
#include "xcanfd.h"
#include "sleep.h"

#include "My_Main_Define.h"

//VFC_Is_Bypassed 3765
//GLB_Counter_Samples_Total_New
//memset(eMMC____WRITE_BUFF, 0, sizeof(eMMC____WRITE_BUFF));

//-----------S: CAN Network Parameter -----------
#define CARD_TYPE____MASK 											0xFF
#define CARD_SERIAL____MASK											0x1FFFFF

#define CARD_TYPE 													(uint8_t)0xA2  		// 2 ~ 255
#define CARD_SERIAL													(uint32_t)0x100002 	// 3 ~ 2097150

#define CARD____MID 					 							(uint32_t)(((0x01 & CARD_TYPE____MASK)<<21U) | (0x000001 & CARD_SERIAL____MASK)) 			// Master ID
#define CARD____GID 					 							(uint32_t)(((0x01 & CARD_TYPE____MASK)<<21U) | (0x000002 & CARD_SERIAL____MASK)) 			// Global ID, All CARDs can Answer this
#define CARD____EID 					 							(uint32_t)(((CARD_TYPE & CARD_TYPE____MASK)<<21U) | (CARD_SERIAL & CARD_SERIAL____MASK))	// Extend ID
//-----------E: CAN Network Parameter -----------


//-----------S: CAN Network Commands -----------
#define CANFD_ANS____READ												(uint8_t)0x01U
#define CANFD_ANS____WRITE											(uint8_t)0x02U
#define CANFD_ANS____VERIFY											(uint8_t)0x03U

#define CANFD_CMD____ID_QUERY 									(uint8_t)0x04U
#define CANFD_CMD____SYS_RST										(uint8_t)0x08U
#define CANFD_CMD____SET_CYCLE									(uint8_t)0x0CU
#define CANFD_CMD____VERSION										(uint8_t)0x10U
#define CANFD_CMD____SET_MODE										(uint8_t)0x14U
#define CANFD_CMD____FILE_TRANSFER____START			(uint8_t)0x18U
#define CANFD_CMD____FILE_TRANSFER____DATA			(uint8_t)0x1CU
#define CANFD_CMD____FILE_TRANSFER____STOP			(uint8_t)0x20U
#define CANFD_CMD____FILE_TRANSFER____VERIFY		(uint8_t)0x24U
#define CANFD_CMD____ERROR											(uint8_t)0x28U
#define CANFD_CMD____SUCCESS										(uint8_t)0x2CU
#define CANFD_CMD____FAIL												(uint8_t)0x30U
#define CANFD_CMD____ACK_BYTE										(uint8_t)0x34U
#define CANFD_CMD____NACK_BYTE									(uint8_t)0x38U
#define CANFD_CMD____BUSY_BYTE									(uint8_t)0x3CU
#define CANFD_CMD____SYNC_BYTE									(uint8_t)0x40U
#define CANFD_CMD____FW_FLASH_ERASE							(uint8_t)0x44U
#define CANFD_CMD____FW_FLASH_WRITE							(uint8_t)0x48U
#define CANFD_CMD____FW_FLASH_WRITE_INFO				(uint8_t)0x4CU
#define CANFD_CMD____FW_FLASH_READ							(uint8_t)0x50U
#define CANFD_CMD____FW_FLASH_EXECUTE						(uint8_t)0x54U
#define CANFD_CMD____DATA_FLASH_ERASE						(uint8_t)0x58U
#define CANFD_CMD____DATA_FLASH_WRITE						(uint8_t)0x5CU
#define CANFD_CMD____DATA_FLASH_WRITE_INFO			(uint8_t)0x60U
#define CANFD_CMD____DATA_FLASH_READ						(uint8_t)0x64U
#define CANFD_CMD____DATA_FLASH_LOAD						(uint8_t)0x68U
#define CANFD_CMD____SPI_BUS_ACTIVITY						(uint8_t)0x6CU
//-----------E: CAN Network Commands -----------

//-----------S: FW Config -----------
#define FW____VERSION 												(uint32_t)0xA123B987
//-----------E: FW Config -----------


#define AXI_BUS_CAPACITY 150U
#define AXI_BUS_SPI_DATA_COUNT 143U

uint32_t *GPS_SYNCHRONIZER____AXI_BUS = (uint32_t *)XPAR_GPS_SYNCHRONIZER_0_S00_AXI_BASEADDR;

uint32_t GPS_SYNCHRONIZER____AXI_BUS____DATA_READ[AXI_BUS_CAPACITY] = {0U};
uint32_t GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[AXI_BUS_CAPACITY] = {0U};

#define CANFD____TRANSFER_PACKET____SIZE							(uint8_t)32U



typedef enum {
	FW_FLASH_MEM = 0x00, DATA_FLASH_MEM = 0x01
} FLASH_MEM_TypeDef;

typedef struct {
	uint32_t ExtID;
	uint32_t IDE;
	uint32_t RTR;
	uint32_t DLC;
	uint8_t Data[8];
} CANFD_Packet_Struct;

typedef struct {
	uint32_t NID;

	uint8_t Type;
	uint32_t Serial;

	uint16_t MEMORY_SIZE;

	uint16_t Write_Data[25];
	uint16_t Read_Data[25];

	uint16_t Cycle_Need;
	uint16_t Write_Cycle;
	uint16_t Read_Cycle;
	uint16_t Max_Cycle;

	uint16_t Cycle_Start;

	uint32_t FW_Version;

	bool FW_Exist;

	uint16_t FLASH_ID;

	uint8_t Factory_Data[4096];
	uint8_t Calibration_Data[4096];

	XST_StatusTypeDef Factory_Data_Read_Status;
	XST_StatusTypeDef Calibration_Data_Read_Status;

	XST_StatusTypeDef FW_Flash_Status;

} CARD_DATA_STRUCT;

typedef enum {
	SB____Bootloader____CARDS_BOOT = (uint8_t) 0U,  // SB -> System Boots , BL -> Bootloader , MN -> MAIN
	SB____Bootloader____ID_QUERY = (uint8_t) 1U,
	SB____Bootloader____READ_VERSION = (uint8_t) 2U,
	SB____Bootloader____UPDATE_FIRMWARE = (uint8_t) 3U,
	SB____Main____CARDS_BOOT = (uint8_t) 4U,
	SB____Main____ID_QUERY = (uint8_t) 5U,
	SB____Main____READ_VERSION = (uint8_t) 6U,
	SB____Main____TIME_CYCLE_CALCULATION = (uint8_t) 7U,
	SB____Main____SET_TIME_CYCLE = (uint8_t) 8U,
	SB____Main____READ_4KB_CARDS_FLASH = (uint8_t) 9U,
	SB____Main____TIMING_START = (uint8_t) 10U,
	SB____Main____START = (uint8_t) 11U,

} SYSTEM_BOOTS_STATUS;

extern uint32_t CANFD_NET____LOOKUP_ID____COUNT;
extern SYSTEM_BOOTS_STATUS System_Boots____Flag;
extern uint32_t CANFD_NET____LOOKUP_ID____COUNT;

#define W25Q80 												0xEF13
#define W25Q16 												0xEF14
#define W25Q32 												0xEF15
#define W25Q64 												0xEF16

uint32_t CANFD_NET____LOOKUP_ID____COUNT = 0U;
CARD_DATA_STRUCT Device_DB[CARD_Specifications____Max_Slot_Card_Capacity] = { 0 };


uint8_t Data_Packet____4KB[4096] = { 0U }, FW_Data____4KB____Temp[4096] = { 0U };
uint32_t FW_Data____4KB____Counter = 0U;

struct c {
	uint32_t NID;
	uint32_t ANS;
} Answer_Pack;

struct f {
	uint8_t ID;
	uint32_t Size;
	uint32_t Counter;
} FWDescriptor;

SYSTEM_BOOTS_STATUS System_Boots____Flag = SB____Bootloader____CARDS_BOOT;

extern XCanFd canfd0_i;
extern XCanFd canfd1_i;

uint64_t uwTick_500us = 0U;

#if(1) // Variables
extern uint8_t GLB_mmc_write_buffer[512 * 4];
extern uint8_t GLB_mmc_read_buffer[512 * 4];
uint32_t VFC_Conter = 0;
void Simulation(void);
int32_t Simulation__Cards_ID[MAX_NUM_OF_UNITS * NUM_OF_UNIT_CARDS];
bool  Calib____Reverse_Winding = false;
int32_t  Calib____Reverse_Winding___CTPT_Index = 0;
int8_t Loading_Percent = 0;
int8_t Loading_Percent_Part_1 = 0;
int8_t TEMP_FLAG___Close_MessageBox = 0;
//int32_t GLB__VMA__Size;
int32_t GLB__Blocks_Settings_Adress_And_Value_In_MHA___Size;
int32_t GLB__HF_Vriables__INFO___Size;
bool Send_Message__Permision = true;
bool VFC_Data_Is_Empty = false;
enum {
	PROGRESS_BAR = 10,
};
int8_t PROGRESS_BAR_Mode = PROGRESS_BAR;
int8_t SaeedFlag = 0;
#define  		CSharpVMAVersion      		1200990923
#define   	CSharpKeilVersion         1200990923
#define  		RelayControllerVersion    1200990923
#define   	RelayUIVersion            1200990923
#define   	EnumVersion            		1200990923

int32_t Setting___MHA_Adr___Value[2];
int32_t Methods_Current_Value = 0;
int32_t Methods_MHA_Adr = 0;
bool Disp_CLK_CLB = false;
int32_t LED_Run_Counter = 0;
extern bool VMA_Invalid_Next_Block;
extern bool VMA_Invalid_Block_Type;
extern int32_t GLB__VFC__BLK_Sequense;
bool TRFA_And_TSFA_Ready = false;
bool VFC_Bypassed__Flag = false;
extern int32_t VMA_PNT_Old;
//bool     Empty__VFC_Data = false;
//int8_t     CLK_CALIB_DONE = 0;
int8_t Calibration_Stage = 0;
int32_t GLB_Mismatch_Cards____Data[MAX_NUM_OF_UNITS * NUM_OF_UNIT_CARDS * 2 + 1];
int32_t GLB_Mismatch_Cards____Counter = 0;
int8_t GLB_Mismatch_Cards____Flag = 0;

//int8_t Repeat_Calib = 0;
#define Send_Message_to_FP____Max_Num_Of_Messages 100
char Send_Message_to_FP____Str[GLB____LCD____Max_Num_Of_Char_In_a_Lines * Send_Message_to_FP____Max_Num_Of_Messages];
uint32_t Send_Message_to_FP____Counter = 0;

void CFC__Check(int32_t *VMA_PNT, int32_t Type);
void Var_Init__Menu_Data____Read_From_uSD(void);


void Var_Init__Write_Password(void);
void Reset_ANALOG__Samples__AND__FFT_VALS__In_MHA(int8_t Reset_Samples, int8_t Reset_FFT_VALs, int32_t First_Analog_Index, int32_t Last_Analog_Index);
uint32_t One = 1;
void APLY_CMTRD(void);
void CFC_BLK__SIG_PROC____RMS(int32_t *MHA_PNT);
int64_t TEMP_Timer[100];
int32_t TEMP_Timer_Index = 0;
//#define EL_Num_Of_Bytes_For_Date_Time 9
#define EL_Code_For_MMCBLK_That_Is_Filling 0x1010101
int8_t TEMP__CFC_Run = 1;
//int32_t TEMP__VMA_WRITE=1;
//int32_t TEMP____TRSHA_TRSFA___WRITE=1;
int32_t TEMP__VMA_SIZE = 1;
int32_t GLB_Number_Of_Digitals_Assigned_to_Comtrade;
int32_t CFC__HF_IO____Signal_Index = 0;
int32_t CFC____Measurement_BLK____Exist = En_NO;
int32_t CFC____Measurement_BLK____Num_Of_Analog_Inputs = 0U;
int32_t Measure_BLK____Num_Of_Analogs = 0U;
int32_t GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA = 0U;
int32_t Measure_BLK____Num_Of_Analogs_Determined = 0U;
int8_t GLB____Calib____Reset_Calib_Factors_On_4th_Kard = 0;

#define CFC____Measurement_BLK____Ofset  4
#define CFC____Measure____LABEL__Start  	VFC____SIGNAL_NAME__Size
#define CFC____Measure____Sec_Val____Start  40
#define CFC____Measure____PhaseVal____Start 47
#define CFC____Measure____Unit_1____Start   53
#define CFC____Measure____Prim_Val____Start 57
#define CFC____Measure____Unit_2____Start   62
#define CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog (VFC____SIGNAL_LABEL_AND_NAME__Size+26)
extern int32_t CFC____FFT_Memory____Num_Of_Analogs;

//extern int32_t CPU____TSHA____FRST_PNT____IN_MHA;
//extern int32_t CPU____TRFA____FRST_PNT____IN_MHA;
extern int32_t CPU____TSFA____FRST_PNT____IN_MHA;

extern uint16_t TSHA__SIZE, TRHA__SIZE;
extern uint16_t TSFA__SIZE, TRFA__SIZE;
extern int16_t RHA[SPI1_DMA_Number_Data_To_Transfer], SHA[SPI1_DMA_Number_Data_To_Transfer];
extern uint16_t RFA[SPI2_DMA_Number_Data_To_Transfer], SFA[SPI2_DMA_Number_Data_To_Transfer];
//extern int32_t TRHA[TRHA__SIZE];
//extern int32_t TSHA[TSHA_Size];
//extern int32_t TRFA[TRFA_Size];
//extern int32_t TSFA[TSFA_Size];
//extern int32_t VMA[VMA_Size];
int32_t CPU____VMA____Filled_Size;
void Disp__Fault_Info_On_LCD(void);
void CFC_BLK__SIG_PROC____FFT_MAIN(int32_t *VMA_PNT, int8_t Harm_Num);
void CFC_BLK__RECORD___CMTRD____Perfault____Analog(int32_t *VMA_PNT);
//void CFC____BLK_FUNCEL__RECORD___EVENT_LOG(void);
void CFC(void);
void CFC__Blocks_Main_Settings(void);
void Copy_STG_And_VI_to_MHA_TEMP(void);
void Copy_RHA_to_MHA(void);
void Copy_MHA_to_SHA(void);
void Copy_RFA_to_MHA(void);
void Copy_MHA_to_SFA(void);
//void CFC_BLK__Copy_MHA_to_CMTRD____PreFault(void);
void Protection__Analog_Signal_Connection_Processing(void);
void CFC__While(int32_t *VMA_PNT, int32_t Mode);
//void Fill_Samples_Matrix(void);
void TEMPPPP___Fill__CTPTs_Index_In_MHA(void);
void FFT_Main(int8_t Harm_Num, uint8_t CTPT__Index);

extern uint8_t VFC_Is_Bypassed;
uint8_t VMA_Is_Bypassed_OLD = 0;

int8_t TEMPFLAG = 0;

int8_t CPU____Initializing = Yes_1;


uint16_t MHA_Col = 0;
enum {
	EN__VMA, EN__TRHA, EN__TSHA, EN__TRFA, EN__TSFA, MHA_SETTING,
};
enum {
	Read, Write
};

int32_t Recive_Menu_Data____Index = 0;
int32_t VMA_Index = 0;
int32_t PACKET____DATA_SIZE____TOTAL = 0;
int32_t PACKET____DATA_SIZE = 0;
int32_t MHA_SETTING_FRST_PNT = 0;
int32_t MHA_SETTING_PNT = 0;
int32_t MHA_SETTING_COUNT;
//int8_t Write_Compact_Menu_Data = Yes_1;
//int8_t   At_LEAST_ONE_ANALOG_MODULES_IS_CONFIGURED=No_0;

//uint8_t Calib_Refrence_Relay=0;
uint16_t Parpaei_Counter = 0;
uint8_t GLB_TPS1[8] = { 0 };
uint8_t GLB_TPS2[8] = { 0 };
uint8_t Write_Flag = 0;
//int32_t FW_Version_On_uSD = 0;
//int32_t FW_Version_On_uSD_Is_Valid = 0;
//int32_t GLB_Old_Total_Rows_Of_Setting_Matrix_Read_From_uSD;
//int32_t GLB_Old_Number_Of_Total_Signal_Of_Input_Output;
int8_t GLB_TEMP = 0;
int8_t GLB_TEMP2 = 0;
//int8_t GLB_TEMP_Conter = 0;
int8_t FP_STATUS____0_DISATTACHED____1_ATTACHED____2_PROCCESSED = 0;

//int32_t Max__Row_Of_Sett_Mat__For_Save_On_USD;
//int32_t Min__Row_Of_Sett_Mat__For_Save_On_USD;

//----------S: BOOTLOADER ----------
uint8_t CPU_MODE____FROM_MMP____0_STARTUP____1_BOOTLOADER____2_MAIN = 0, CPU_MODE____FROM_FP____0_STARTUP____1_BOOTLOADER____2_MAIN = 0;
uint8_t MP_TRANSFER_FW____0_NA____1_FINISH____2_VERIFIED____3_CORRUPTED = 0, FP_TRANSFER_FW____0_NA____1_FINISH____2_VERIFIED____3_CORRUPTED = 0;
uint8_t MP_BOOTLOADER_MODE_READY = 0, FP_BOOTLOADER_MODE_READY = 0;
uint32_t MP_Firmware_Counter_for_Send_by_SPI = 0, FP_Firmware_Counter_for_Send_by_SPI = 0;
uint32_t Firmware_Byte_Recieve_Counter_CPU = 0, Firmware_Byte_Recieve_Counter_MP = 0, Firmware_Byte_Recieve_Counter_FP = 0;
uint32_t MP_BOOTLOADER_MODE_READY_Counter = 0;
int32_t Delay_Counter_to_MP_be_Ready_in_ms = (-1), Delay_Counter_to_FP_be_Ready_in_ms = (-1);
uint32_t FP_FW_VERSION = 0, FP_FW_VERSION_Check = 0, MP_FW_VERSION = 0, MP_FW_VERSION_Check = 0;
uint32_t MP_SYNC_PULSE_EN_Delay_Counter = 0;
uint8_t CPU_PERMISSION_TO_STRT_WORK_Event = 0;
//----------E: BOOTLOADER ----------

uint8_t MP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG = 0U, MP____FLASH_MODE____0_NA____1_READ____2_WRITE = 0;
uint8_t FP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG = 0U, FP____FLASH_MODE____0_NA____1_READ____2_WRITE = 0;
uint8_t MP____MAIN_APP____FIRST_BOOT____0_YES____1_NO = 0U;

uint8_t FP_HW_VERSION____0_NA____1_MATCH____2_MISMATCK = 0U;

uint32_t MP_Flash_Data_Total_Size = 0;
uint32_t Flash_Data_Counter = 0;
uint16_t Download_Packet_Size_in_Byte = 0;
uint8_t MP____Flash_Data_Download____0_NA____1_RECIEVED____2_VERIFIED____3_PROCESSED = 0;

uint32_t MP_FLASH_DATA_Counter_for_Send_by_SPI = 0;
uint32_t MP____DMA_TRANSFER_FLASH_DATA____0_NA____1_START____2_FINISH = 0;

#define Number_of_Data_to_Send_in_Byte			60U
#define MP_FLASH_DATA_Byte_Recieve_Counter  4U*4096U*9U
uint32_t Flash_Data_Is_Valid = Yes_1;
SYS_Status MP_SYS_STATUS = SYS_OK, FP_SYS_STATUS = SYS_OK;
//----------------S: Tranfer/Recieve Setting/Config
uint8_t GLB__FORMAT_RECORDs__EL_0__TL_1__OSC_2;
enum {
	Fundumental = 0x0001, RMS, H2, Symetric, VLL,
};

uint8_t New_Packet_Data_Recieved = 0;
#define Max_Size_of_Packet_Data_in_Byte 200U

//uint32_t *Transmit_Data_Array_Address[80], *Recieve_Data_Array_Address[80];
//uint32_t Transmit_Data_Length = 0U, Recieve_Data_Length = 0U;

uint16_t Recieve_ID = 0U;
uint32_t Recieve_START_INDEX = 0U, Recieve_SIZE = 0U;
uint16_t Packet_Byte_Counter_for_Recieve_by_SPI = 0U;
uint32_t DATE_AND_TIME__Disply[6];
uint32_t DATE_AND_TIME__SET[7];
uint8_t Different_Cards_COnter = 0;
int32_t GLB__TLOsc_Date_For_Menu__Adr_Of_RAM_Last_TLOsc_Enter_For_Disp_On_Menu[2];
//----------------E: Tranfer/Recieve Setting/Config
uint16_t MP____System_Status = 0U, MP____System_Error_Status = 0U, MP____System_Error_Status_Descriptor = 0U;
uint16_t FP____System_Status = 0U, FP____System_Error_Status = 0U, FP____System_Error_Status_Descriptor = 0U;

uint8_t MP____RUN_LED____0_OFF____1_ON = 0U, MP____ERR_LED____0_OFF____1_ON = 0U;
uint8_t FP____RUN_LED____0_OFF____1_ON = 0U, FP____ERR_LED____0_OFF____1_ON = 0U;

uint8_t CPU_CHANGE_SPI_MODE____0_SLAVE____1_MASTER____FLAG____Temp = 2U;

uint32_t My_Counter = 0;
uint8_t FP_ETHERNET_Recive_Ready = 0U;

void Send_Recieve_Data(void);

//uint32_t temp = 0;

//uint32_t Temp_Output_Config[GLB_Number_Of_Outputs]={0,1,2,3,4,5};
//#define Calc_Time_Consume(i)   MyTime[i] = (TIM5->CNT)*250/27;	if(MyTime[i] > MyTime_Max[i])	MyTime_Max[i] = MyTime[i];

//#define Data_ID_MidPlates_for_CPU_Length			8U
//#define Data_ID_Cards_for_CPU_Length					32U		
//#define Data_Start__12_5us__CPU_Length				8U
//#define Data_All_Cards_Length									36U
//#define Data_ID_Card_Code_Length							4U
//#define Data_Other_Card_Array_Length					76U

//-------------S: Card Configs--------------

#define MMP_SYNC_PULSE_SET								GPIOJ->BSRR = GPIO_BSRR_BS_14;
#define MMP_SYNC_PULSE_RESET							GPIOJ->BSRR = GPIO_BSRR_BR_14;

#define SYNC_FP_PULSE_SET								GPIOI->BSRR = GPIO_BSRR_BS_12;
#define SYNC_FP_PULSE_RESET							GPIOI->BSRR = GPIO_BSRR_BR_12;

uint32_t MyTime[30], MyTime_Max[30];

uint32_t SinWave_Counter = 0;
uint32_t Counter_1ms_dma = 0, Counter_ms_mp = 0;

uint32_t Error_Matrix_Counter = 0, Error_Matrix_Counter_Temp = 0;
uint8_t GLB_Counter_ms = 0;
uint32_t Time_Sample[5];

uint16_t DMA_Counter = 0;
uint32_t DMA1_COUNTER_ERROR = 0, DMA2_COUNTER_ERROR = 0, DMA2_COUNTER_ERROR_2 = 0;

uint16_t Delay_For_Send_LCD_Buffer = 0;
uint32_t SPI1_DMA_TRANSFER_DATA = 0, SPI2_DMA_TRANSFER_DATA = 0;
uint32_t MP____LED_Status_Blink = 0, FP____LED_Status_Blink = 0;
//--------S: CHECK THIS-----------
//uint8_t Flash_Memory_Buffer[5000];
//#define CARD_TYPE_BUFFER 			(uint32_t)(*(uint32_t *)(Flash_Memory_Buffer+0))
//#define CARD_SERIAL_BUFFER			(uint32_t)(*(uint32_t *)(Flash_Memory_Buffer+4))
//int32_t GMem_Volt_Abs[3];
//int32_t GMem_Volt_Ang[3];

uint32_t Sample_Time[30] = { 0 };

//sprintf((char *)RAM_UART_BUFF,"GLB_Counter_Samples_Total_New=%d\n",GLB_Counter_Samples_Total_New); Panel_Komaki_UARTX_For_Sprintf();
//--------E: CHECK THIS-----------
//#define MMC_Start_Adr_For_CTPT_Flash_TEMPP 13000000U
//#define MMC_Total_Block_For_Any_CTPT_Flash 100U
//#define GLB_Cards_Flash_Data____MMC____FST_BLK____CPU 13000000U

int8_t GLB_1ms_Busy = 0;

//uint32_t RAM_IO_Signals_LastVal_Array[GLB_Number_Of_Total_Signal_Of_Input_Output+1] __attribute__ ((at(DTCM_RAM_START_ADDRESS+(uint32_t)sizeof(GLB_mmc_write_buffer)+(uint32_t)sizeof(GLB_mmc_read_buffer))));
//IO_Signal_Val__typedef_struct RAM_IO_Signals_val_Struct[GLB_Number_Of_Total_Signal_Of_Input_Output+1] __attribute__ ((at(DTCM_RAM_START_ADDRESS+(uint32_t)sizeof(GLB_mmc_write_buffer)+(uint32_t)sizeof(GLB_mmc_read_buffer)+(uint32_t)sizeof(RAM_IO_Signals_LastVal_Array))));

//int32_t Temp_a[1000], cc = 0, addad = 4;
int32_t GLB_KeyPad_EXTI_speed;
int64_t counter_for_speed;
uint16_t GLB_Key_Temp_SideSync = 0;
int8_t Flag_For_Software = 0;
int32_t GLB_Num_Of_Available_Outputs = 0;
//int32_t  GLB_Num_Of_Available_Outputs_Calculated=No_0;
//int32_t  GLB_Num_Of_Available_Inputs_Calculated=No_0;
//int32_t  GLB_Num_Of_Analog_Inputs_that_are_avalable_Calculated=No_0;
//uint16_t LEDs_Array[(GLB_Number_Of_LEDs-1)/16+1]={0};
//int8_t Measure_UpDownKey_Conter = 0;
//int8_t Measure_RightLeftKey_Conter = 0;
//int8_t Binary_Check = 0;
//int8_t Calib_Magnitude_Done = No_0;
//int32_t Calib_Magnitude_Analog_Module_Counter = 0;
//int8_t  Calib_Phase_Done=No_0;
//int32_t Calib_CTPT_Counter=0;

uint8_t Meas_Active_Analog_Inputs = 0;

//uint32_t LED_Counter = 0;

//#define GLB_Analog_Modules_App____MMC____BLK_NUM____CPU 11999999U
//#define GLB_Available_And_Used_Analog_Modules____MMC____BLK_NUM____CPU 12000000U
//#define MMC_Adr_For_Save_IP_Port_Serial 12000001U
//#define GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU 12000002U
//#define MMC_Adr_For_Save_CalibData_Backup 12000003U

//int8_t Mismatch_AnalogMOdule_Type_App=0;
int8_t Calibration____Stage_1____Finished = 0;
int8_t Calibration____Stage_2____Finished = 0;
//int32_t  Glb_Counter_For_49OL=0;

//int8_t GLB_Calib_Mode2_fft_calib_H1_done = 0;
//uint8_t Exti_KeyPad_Flag=0;
//int32_t Temp_Date_COnter = 0;
//int32_t Temp_Date_COnter_TL = 0;
//int32_t Temp_Date_COnter_EL = 0;
//int32_t Thermal_Time;

//int32_t Conter_For_Sprintf_In_While = 0;
//int32_t TOr;
//int32_t Step_Time;
//int8_t GLB_num_Of_Analogs_Shown_Always_In_Osc__that_are_Active = 0;
//char App_Str[6];

#endif
#if(1) // INFO
//	sprintf((char *)RAM_UART_BUFF,"GLB_Counter_Samples_Total_New=%d\n",GLB_Counter_Samples_Total_New); Panel_Komaki_UARTX_For_Sprintf();
//  ZI+RW-Data= ram dakheli 380k
//  RO-Data= Constant ha
//  RO-Data+Code= hafezeh flash 2Mb
//  NVIC_SystemReset();
//  CTPT Flash--> 1Block=4096 byte=4kb= 1024*4byte ----  16 Mbit=512 block 

//tedade kolle blockhaye 512 bayti:	16777216	
//1-279995				-->Address{
//			40000-59996--> فيلدهای IO
//			60000-63996--> آدرس تريپ‌لاگ‌ها
//			64000-67996--> آدرس اسيلوگراف‌ها
//}	
//280000-319997		 --> Type				
//320000-359997		 --> Menu		
//360001 to... 		 used to save adress of all menus which are together in similar layer				
//399988 to 400001 	 used for SigGroup in IO Sheet				
//400008 to…450000	 used for Signals in IO Sheet
//450004 to 499999	 زیر منو ها و اینویزیبل منوها
// 500000 to …			 baraye monhanihaye IEC ANSI , ...

//1000000 ta 1840000	 Setting Groups				
//2015000		       GLB_Osc_First_Address_For_Saving_Address_Of_Osc_Record				
//2030000		       GLB_Osc_Address_For_Save_Osc_Setting				
//2030004		       GLB_Osc_Address_For_Save_Osc_Setting_Default				
//3000000	3008000	 GLB_Trip_Log_First_Addr_For_Save				

//700004-700007		 GLB_Adr_For_Tanjant_Array				
//700009-700012		 GLB_Calibration_Addr_For_Save_Calib_Factors				
//700013-700016		 GLB_Freq_Calc_First_Adr_For_Save_Coeff				
//700017-700024		 GLB_Loading_First_Adr_For_Loading_Imag				
//700030-7000199		 Home Screen (Multi-Dist_Diff)				
//4000000	4000000	 GLB_FN_Shortcut_Address_For_Save				
//4000004	4000004	 GLB_FN_Shortcut_Address_For_Save_Defaults				
//5000000	5000100	 GLB_First_Addr_That_Shows_MMC_Has_Written_Already			GLB_Total_Number_Of_Setting_Group	4
//7000200	7008200	 GLB_EL_First_Addr_For_Save_Record				
//8000001	10050049	 GLB_Osc_First_Addr_For_Save_Osc_Analog			GLB_Osc____Total_Num_Of_Osc_Can_Record	1000
//11000000	11000000	 GLB_CFC_First_Addr_For_Save_CFC			GLB_Osc____Total_Num_Of_uSDBlocks___For_Any_Osc	2048
//11999999	11999999	 MMC_Adr_For_Save_Analog_Modules_App				
//12000000	12000000	 MMC_Adr_For_Save_Available_Analog_Modules			GLB_TL_Max_Numb_Of_TL_Can_Save	2000
//						
//12000002		MMC_Adr_For_Save_TestModStatus_WatchDogActivationStatus			GLB_EL____NUM_OF_BLKs____For_Save_EL	2000
//12000003	12000091	MMC_Adr_For_Save_CalibData_Backup				
//12200000	12202056	SigRout__First_Adr_For_Write_User_Def_Sig			GLB_Total_Number_Of_Setting_Group	
//12300000	12300000	Write_Compact_Menu_Data__First_Adr				
//13000000	13000288	MMC__First_Adr__For_Save_Cards_Flash_Data			GLB_Num_Of_Analog_Inputs	11
//					SigRout__Max_Num_Of_User_Def_Sig	512
//					NUM_OF_UNIT_CARDS	4
//	15000013	GLB_Adr_For_Save_Password			MAX_NUM_OF_UNITS	9
//	15000014	MMC_BLOCK_NUMBER_FOR_TIM2_TIMING_CORRECTION
//15000015	15000015-15010772 	اختصاصی برای سعید

#endif
#if(1) // LCD Functions
void T6963_240_128_Write_String(char *string, uint32_t GB_X, uint32_t GB_Y, int color, int32_t Clear_Last_Messages__Yes_1___No_0){
	int32_t i;
	int8_t String_Size = strlen(string);
//	char My_Str[40];
	
	for(i=0; i<String_Size; i++)
		Send_Message_to_FP____Str[GLB____LCD____Max_Num_Of_Char_In_a_Lines*Send_Message_to_FP____Counter + i] = string[i];
	
	for(i=String_Size; i<GLB____LCD____Max_Num_Of_Char_In_a_Lines-1; i++)
		Send_Message_to_FP____Str[GLB____LCD____Max_Num_Of_Char_In_a_Lines*Send_Message_to_FP____Counter + i] = ' ';
	
	Send_Message_to_FP____Str[GLB____LCD____Max_Num_Of_Char_In_a_Lines*Send_Message_to_FP____Counter + GLB____LCD____Max_Num_Of_Char_In_a_Lines -1] = Clear_Last_Messages__Yes_1___No_0;
	
	while(CPU____QTL____ADD_ITEM(FP_CPU____Error_Warning, GLB____LCD____Max_Num_Of_Char_In_a_Lines*Send_Message_to_FP____Counter, GLB____LCD____Max_Num_Of_Char_In_a_Lines, 1, (uint32_t) &Send_Message_to_FP____Str) != 1U);
	
//	LL_mDelay(500);
	Send_Message_to_FP____Counter++; 
	if(Send_Message_to_FP____Counter==Send_Message_to_FP____Max_Num_Of_Messages)
		Send_Message_to_FP____Counter =0;
}
void T6963_240_128_Write_String_WO_CLEAR_LCD_In_2_Column(char *string, uint32_t GB_X, uint32_t GB_Y, int color){
	while(CPU____QTL____ADD_ITEM(FP_CPU____Error_Warning_WO_CLR_LCD__In_2_Column, 0, GLB____LCD____Max_Num_Of_Char_In_a_Lines, 1, ((uint32_t) string)) != 1U);
}
void T6963_240_128_Write_String_Komaki(int32_t High_Light_Line_Number){
	while(CPU____QTL____ADD_ITEM(FP_CPU____DISPLAY_LCD_ARRAY_WO_CLR_LCD__In_1_Column, 0, GLB____LCD____Max_Num_Of_Lines*GLB____LCD____Max_Num_Of_Char_In_a_Lines, 1, GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD)!= 1U);
}
void Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD(char Str[], int32_t row, int32_t col){
	int32_t n;
//if((GLB_Ask_For_Saving==0 && !(GLB_Method_Menu_Is_Open==1 && GLB_Method==GLB_Meth_Range) && !(GLB_menu_current_position[0]==GLB_Measure_MP_0 && GLB_menu_current_position[1]==GLB_Measure_MP_1 && GLB_menu_current_position[2]!=0  && GLB_menu_current_position[3]!=0)) && GLB_IOTLELOsc__HighLight_Is_Done==0){
	for(n=col; n<MIN(GLB____LCD____Max_Num_Of_Char_In_a_Lines-1, strlen(Str)+col); n++){
		SDRAM____New_LCD_Chars_Show_On_LCD[row * GLB____LCD____Max_Num_Of_Char_In_a_Lines + n] = Str[n - col];
	}
//}
//else{
//	for(n=col; n<MIN(GLB____LCD____Max_Num_Of_Char_In_a_Lines-1, strlen(Str)+col); n++){
//		SDRAM____New_LCD_Chars_Show_On_LCD[(row+1) *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ n]=Str[n-col];
//	}
//}
}
#endif
#if(1) // Saeed Check konad
void WWDG_IRQHandler(void) {
//	LL_WWDG_ClearFlag_EWKUP(WWDG);
//	LL_RCC_ClearResetFlags();

//	if(HW_RESET____1_ENABLE____0_DISABLE!=1){
//		LL_WWDG_SetCounter(WWDG, GLB_WWDG_Value);
//	}
//
//	HW_RESET____COUNTER++;
}
#endif
#if(1) // HW
uint64_t HAL_GetTick(void) {
	return (uwTick_500us/2);
}
void GPS_IRQHandler(void *CallBackRef) {
//	uint32_t GPS_TIME=0;

//	LL_EXTI_ClearFlag_0_31(LL_EXTI_LINE_13);

//	GPS_TIME = TIM5->CNT;
//	TIM5->CNT=0;
//
//	GPS_SAMPLE_TIME[0] = GPS_TIME;
//	if((GPS_SAMPLE_TIME[0] > GPS_SAMPLE_TIME[1]))
//		GPS_SAMPLE_TIME[1] = GPS_SAMPLE_TIME[0];

}
void HW__EEPROMWriteConfig(void) {

//	ReadMyCfg.Serial=1000136;
//	WriteMyCfg.writeMode=WriteMode_Serial;
//	sprintf((char *)RAM_UART_BUFF,"ReadMyCfg.Serial=%d\n",ReadMyCfg.Serial); Panel_Komaki_UARTX_For_Sprintf();
//	sprintf((char *)RAM_UART_BUFF,"WriteMyCfg.writeMode=%d\n",WriteMyCfg.writeMode); Panel_Komaki_UARTX_For_Sprintf();

	switch (WriteMyCfg.readwriteMode) {
	case WriteMode_Serial:
		EEPROM_Write(0, 0, (void *) &(WriteMyCfg.Serial), MODE_8_BIT, 4);
		break;
	case WriteMode_ClockCalibration:
		EEPROM_Write(0, 1, (void *) &(WriteMyCfg.ClockCalibration), MODE_8_BIT, 4);
		break;
	case WriteMode_IP:
		EEPROM_Write(0, 2, (void *) &(WriteMyCfg.IPConfig), MODE_8_BIT, 16);
		break;
	case WriteMode_Port:
		EEPROM_Write(0, 3, (void *) &(WriteMyCfg.Port), MODE_8_BIT, 2);
		break;
	case WriteMode_CalibData:
		break;
	}
}
void HW__EEPROMReadConfig(void) {
//	uint32_t i;
	EEPROM_Read(0, 0, (void *) &(ReadMyCfg.Serial), MODE_8_BIT, 4);
	EEPROM_Read(0, 1, (void *) &(ReadMyCfg.ClockCalibration), MODE_8_BIT, 4);
	EEPROM_Read(0, 2, (void *) &(ReadMyCfg.IPConfig[0]), MODE_8_BIT, 16);
	EEPROM_Read(0, 3, (void *) &(ReadMyCfg.Port), MODE_8_BIT, 2);
}
uint32_t HW__Check__CARD_TYPE(uint16_t Card_Type) {
//	if (Card_Type == CARD_TYPE____CPU || Card_Type == CARD_TYPE____IO_16BIT || Card_Type == CARD_TYPE____PS || Card_Type == CARD_TYPE____CT || Card_Type == CARD_TYPE____PT
//			|| Card_Type == CARD_TYPE____4_CT__6_BI || Card_Type == CARD_TYPE____4_PT__6_BO || Card_Type == CARD_TYPE____E1 || Card_Type == CARD_TYPE____12_CT
//			|| Card_Type == CARD_TYPE____9_BI__9_BO) {
//		return Card_Type;
//	}
//	else {
//		return RESPOND_UNKNOWN ;
//	}
}
uint32_t HW__Check__CARD_SERIAL(uint32_t Card_Serial) {
	if (Card_Serial > 0xA1111111 && Card_Serial < 0xAFFFFFFF) {
		return Card_Serial;
	}
	else {
		return RESPOND_UNKNOWN ;
	}
}
uint32_t HW__Check__CARD_MEMORY_SIZE(uint32_t CARD_MEMORY_SIZE) {

	switch (CARD_MEMORY_SIZE) {
	case W25Q80:
		return 0x00000008;
		break;
	case W25Q16:
		return 0x00000010;
		break;
	case W25Q32:
		return 0x00000020;
		break;
	case W25Q64:
		return 0x00000040;
		break;

	default: {
		return RESPOND_UNKNOWN ;
		break;
	}
	}
}
uint32_t HW__Check__Number_of_12_5uSec_Need(uint32_t Number_of_12_5uSec_Need) {
	if (Number_of_12_5uSec_Need > 0x00 && Number_of_12_5uSec_Need < 0x00000014) {
		return Number_of_12_5uSec_Need;
	}
	else {
		return RESPOND_UNKNOWN ;
	}
}
uint16_t CARD____Cylce_Calculation(CARD_CYCLE_MODE CYCLE_MODE, uint8_t CARD_ID) {

	for(uint8_t i=0; i<CARD_Specifications____Max_Card_Type; i++){
		if(CARD_Specifications[i][0] == CARD_ID){
			switch (CYCLE_MODE) {
				case CARD_READ_CYCLE:
					return CARD_Specifications[i][1];
				break;
				case CARD_WRITE_CYCLE:
					return CARD_Specifications[i][2];
				break;
				case CARD_MAX_CYCLE:
					return MAX(CARD_Specifications[i][1], CARD_Specifications[i][2]);
				break;
			}
		}

		if(CARD_Specifications[i][0] == 0)
			break;
	}

	return 0U;
}
uint32_t CANFD_NET____SendByte(XCanFd *canfd_p, uint32_t NodeID, uint8_t Byte) {
	u32 raw_buf[18];

	u32 id_ext = NodeID & 0x0003FFFF;
	u32 id_std = (NodeID >> 18) & 0x07FF;

	raw_buf[0] = XCanFd_CreateIdValue(id_std, 0, 1, id_ext, 0);
	raw_buf[1] = XCanFd_Create_CanFD_Dlc_BrsValue(XCanFd_GetLen2Dlc(1));
	raw_buf[2] = Byte;

	return XCanFd_Send(canfd_p, raw_buf, NULL);
}
uint32_t CANFD_NET____SendBytes(XCanFd *canfd_p, uint32_t NodeID, uint8_t *Buffer, uint32_t BufferSize) {
	u32 raw_buf[18];

	u32 id_ext = NodeID & 0x0003FFFF;
	u32 id_std = (NodeID >> 18) & 0x07FF;

	raw_buf[0] = XCanFd_CreateIdValue(id_std, 0, 1, id_ext, 0);
	raw_buf[1] = XCanFd_Create_CanFD_Dlc_BrsValue(XCanFd_GetLen2Dlc(BufferSize));
	memcpy(&raw_buf[2], Buffer, BufferSize);

	return XCanFd_Send(canfd_p, raw_buf, NULL);
}
XST_StatusTypeDef CANFD_NET____Wait_for_Respond(uint32_t NID, uint32_t Respond_Byte, uint32_t timeout) {
	uint32_t tickstart = HAL_GetTick();

	Answer_Pack.NID = 0U;
	Answer_Pack.ANS = 0U;

	switch (timeout) {
		case 0U: { // no timeout!
			while (true) {
				if ((NID == Answer_Pack.NID) && (Respond_Byte == Answer_Pack.ANS)) {
					return XST_OK;
				}
			}
		}
		break;

		default: {
			while ((HAL_GetTick() - tickstart) < timeout) {
				if ((NID == Answer_Pack.NID) && (Respond_Byte == Answer_Pack.ANS)) {
					return XST_OK;
				}
			}
		}
		break;
	}

	return XST_TIMEOUT;
}
void CANFD_NET____Node_ID_Query(XCanFd *CANFD_Ptr) {

	CANFD_NET____SendByte(CANFD_Ptr, CARD____GID, (CANFD_CMD____ID_QUERY | CANFD_ANS____READ ));
}
void CANFD_NET____Node_Reset(XCanFd *CANFD_Ptr, uint32_t NodeID) {

	CANFD_NET____SendByte(CANFD_Ptr, NodeID, (CANFD_CMD____SYS_RST | CANFD_ANS____WRITE ));
}
XST_StatusTypeDef CANFD_NET____Node_Set_Cycle(XCanFd *CANFD_Ptr, uint32_t NodeID, uint32_t Timing) {
	uint8_t CANFD_TxData[64] = { 0 };

	CANFD_TxData[0] = CANFD_CMD____SET_CYCLE | CANFD_ANS____WRITE;
	*(uint32_t *) (CANFD_TxData + 1U) = Timing;
	CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 5);
	if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 10) != XST_OK) {
		return XST_ERROR;
	}
	return XST_OK;
}
void CANFD_NET____Node_Read_Version(XCanFd *CANFD_Ptr, uint32_t NodeID) {

	CANFD_NET____SendByte(CANFD_Ptr, NodeID, (CANFD_CMD____VERSION | CANFD_ANS____READ ));
}
void CANFD_NET____Node_Set_Mode(XCanFd *CANFD_Ptr, uint32_t NodeID, uint8_t Mode) {
	uint8_t CANFD_TxData[64] = { 0U };

	CANFD_TxData[0] = CANFD_CMD____SET_MODE | CANFD_ANS____WRITE;
	CANFD_TxData[1] = Mode;
	CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 2);
}
XST_StatusTypeDef CANFD_NET____Node_FW_File_Transfer(XCanFd *CANFD_Ptr, uint32_t NodeID, uint8_t File_Name, uint8_t *File, uint32_t File_Size) {
	uint8_t CANFD_TxData[64] = { 0 };
	uint32_t i = 0U, File_Size_Temp = 0U, File_Packet_Count = 0U;

	//--------S: Start CMD --------
	CANFD_TxData[0] = CANFD_CMD____FILE_TRANSFER____START | CANFD_ANS____WRITE;
	CANFD_TxData[1] = File_Name;
	*(uint32_t *) (CANFD_TxData + 2U) = File_Size;

	CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 6);
	if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 10) != XST_OK) {
		return XST_ERROR;
	}
	//--------E: Start CMD --------

	//--------S: FW Transfer --------
	CANFD_TxData[0] = CANFD_CMD____FILE_TRANSFER____DATA | CANFD_ANS____WRITE;

	File_Size_Temp = File_Size;

	while (File_Size_Temp != 0U) {
		// Packet Number
		*(uint32_t *) (CANFD_TxData + 1) = File_Packet_Count;
		// Packet Size
		CANFD_TxData[5] = ((((File_Size - File_Packet_Count * CANFD____TRANSFER_PACKET____SIZE ) / CANFD____TRANSFER_PACKET____SIZE ) > 0U) ?\
						CANFD____TRANSFER_PACKET____SIZE : ((File_Size - File_Packet_Count * CANFD____TRANSFER_PACKET____SIZE ) % CANFD____TRANSFER_PACKET____SIZE )); // Packet Size  [1 Byte]

		// Fill Packet
		for (i = 0U; i < CANFD_TxData[5U]; i++) {
			CANFD_TxData[i + 6U] = File[File_Packet_Count * CANFD____TRANSFER_PACKET____SIZE + i];
		}

		CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 64);
		File_Packet_Count += 1U;

		if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 50) != XST_OK) {
			return XST_ERROR;
		}

		if ((File_Packet_Count % 128U) == 0U) {
			CANFD_NET____SendByte(CANFD_Ptr, NodeID, (CANFD_CMD____FW_FLASH_WRITE | CANFD_ANS____WRITE ));
			if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 500) != XST_OK) {
				return XST_ERROR;
			}
		}

		File_Size_Temp -= CANFD_TxData[5];
	}

	// Send Last Packet Remained
	if ((File_Packet_Count % 128U) != 0U) {
		CANFD_NET____SendByte(CANFD_Ptr, NodeID, (CANFD_CMD____FW_FLASH_WRITE | CANFD_ANS____WRITE ));
		if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 500) != XST_OK) {
			return XST_ERROR;
		}
	}
	//--------E: FW Transfer --------

	//--------S: Execute From Flash --------
	CANFD_NET____SendByte(CANFD_Ptr, NodeID, (CANFD_CMD____FW_FLASH_EXECUTE | CANFD_ANS____WRITE ));
	if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 300) != XST_OK) {
		return XST_ERROR;
	}
	//--------E: Execute From Flash --------

	return XST_OK;
}
XST_StatusTypeDef CANFD_NET____Node_Read_Data_Flash(XCanFd *CANFD_Ptr, uint32_t NodeID, uint32_t Block_Number_start, uint32_t Block_Count, uint8_t *Data_4K_Base) {
	uint8_t CANFD_TxData[64] = { 0U };
	uint32_t j = 0U;

	for(j=0; j<Block_Count; j++){
		CANFD_TxData[0] = CANFD_CMD____DATA_FLASH_READ | CANFD_ANS____READ;
		*(uint32_t *) (CANFD_TxData + 1) = Block_Number_start+j;
		CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 5);
		if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 10) != XST_OK) {
			return XST_ERROR;
		}

		if (CANFD_NET____Wait_for_Respond(NodeID, (CANFD_CMD____DATA_FLASH_LOAD | CANFD_ANS____WRITE), 500) != XST_OK) {
			return XST_ERROR;
		}

		for(int i=0; i<4096; i++){
			Data_4K_Base[j*4096+i] = Data_Packet____4KB[i];
		}
	}

	return XST_OK;
}
XST_StatusTypeDef CANFD_NET____Node_Write_Data_Flash(XCanFd *CANFD_Ptr, uint32_t NodeID, uint32_t Block_Number_start, uint32_t Block_Count, uint8_t *Data_4K_Base) {
	uint8_t CANFD_TxData[64] = { 0U };
	uint32_t i = 0U, j = 0U, File_Size_Temp = 0U, File_Packet_Count = 0U;

	for(j=0; j<Block_Count; j++){
		//--------S: Start CMD --------
		CANFD_TxData[0] = CANFD_CMD____FILE_TRANSFER____START | CANFD_ANS____WRITE;
		CANFD_TxData[1] = 0U; // reserved for data flash
		*(uint32_t *) (CANFD_TxData + 2U) = 4096U;

		CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 6);
		if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 10) != XST_OK) {
			return XST_ERROR;
		}
		//--------E: Start CMD --------

		//--------S: FW Transfer --------
		CANFD_TxData[0] = CANFD_CMD____FILE_TRANSFER____DATA | CANFD_ANS____WRITE;

		File_Size_Temp = 4096U;

		while (File_Size_Temp != 0U) {
			// Packet Number
			*(uint32_t *) (CANFD_TxData + 1U) = File_Packet_Count;
			// Packet Size
			CANFD_TxData[5] = CANFD____TRANSFER_PACKET____SIZE;
			// Fill Packet (32B)
			for (i = 0U; i < CANFD____TRANSFER_PACKET____SIZE ; i++) {
				CANFD_TxData[i + 6U] = Data_4K_Base[File_Packet_Count * CANFD____TRANSFER_PACKET____SIZE + i];
			}

			CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 64);
			File_Packet_Count += 1U;

			if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 50) != XST_OK) {
				return XST_ERROR;
			}

			File_Size_Temp -= CANFD____TRANSFER_PACKET____SIZE;
		}

		CANFD_TxData[0] = CANFD_CMD____DATA_FLASH_WRITE | CANFD_ANS____WRITE;
		*(uint32_t *) (CANFD_TxData + 1) = Block_Number_start+j;
		CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 5);

		if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 500U) != XST_OK) {
			return XST_ERROR;
		}
		//--------E: FW Transfer --------
	}

	return XST_OK;
}
XST_StatusTypeDef CANFD_NET____Node_Enable_SPI_BUS_Trancieve(XCanFd *CANFD_Ptr, uint32_t NodeID){
	uint8_t CANFD_TxData[64] = { 0U };

	CANFD_TxData[0] = CANFD_CMD____SPI_BUS_ACTIVITY | CANFD_ANS____WRITE;
	CANFD_TxData[1] =  0xAAU;
	CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 2);
	if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 10) != XST_OK) {
		return XST_ERROR;
	}

	return XST_OK;
}
XST_StatusTypeDef CANFD_NET____Node_Disable_SPI_BUS_Trancieve(XCanFd *CANFD_Ptr, uint32_t NodeID){
	uint8_t CANFD_TxData[64] = { 0U };

	CANFD_TxData[0] = CANFD_CMD____SPI_BUS_ACTIVITY | CANFD_ANS____WRITE;
	CANFD_TxData[1] =  0xBBU;
	CANFD_NET____SendBytes(CANFD_Ptr, NodeID, CANFD_TxData, 2);
	if (CANFD_NET____Wait_for_Respond(NodeID, CANFD_CMD____ACK_BYTE, 10) != XST_OK) {
		return XST_ERROR;
	}

	return XST_OK;
}
void CANFD_NET____CARDS____Handle_Recieve_Packet(CanardCANFrame *p_frame) {
	static uint32_t i;
	uint8_t CANFD_TxData[64] = { 0 };
	static uint32_t FT____Packet_Number, FT____Packet_Size;

	p_frame->id &= 0x1FFFFFFF;

	switch (p_frame->id) {
	case CARD____MID : {

	}
		break;

	case CARD____GID : {

	}
		break;

	default: { // Check all answers here
		switch (p_frame->data[0]) {
			case (CANFD_CMD____ID_QUERY | CANFD_ANS____READ ): {
				Device_DB[CANFD_NET____LOOKUP_ID____COUNT].NID = p_frame->id;
				Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Type = (uint8_t) ((p_frame->id >> 21U) & CARD_TYPE____MASK);
				Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Serial = (uint32_t) (p_frame->id & CARD_SERIAL____MASK);
				Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Read_Cycle = CARD____Cylce_Calculation(CARD_READ_CYCLE, Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Type);
				Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Write_Cycle = CARD____Cylce_Calculation(CARD_WRITE_CYCLE, Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Type);
				Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Max_Cycle = CARD____Cylce_Calculation(CARD_MAX_CYCLE, Device_DB[CANFD_NET____LOOKUP_ID____COUNT].Type);

				CANFD_NET____LOOKUP_ID____COUNT += 1U;
			}
				break;

			case (CANFD_CMD____SET_CYCLE | CANFD_ANS____WRITE ): {

			}
				break;

			case (CANFD_CMD____VERSION | CANFD_ANS____READ ): {
				CANFD_TxData[0] = (CANFD_CMD____VERSION | CANFD_ANS____WRITE );
				*(uint32_t *) (CANFD_TxData + 1U) = FW____VERSION;

				CANFD_NET____SendBytes(&canfd0_i, CARD____EID, CANFD_TxData, 5);
			}
				break;

			case (CANFD_CMD____VERSION | CANFD_ANS____WRITE ): {
				for (i = 0; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					if (Device_DB[i].NID == p_frame->id) {
						Device_DB[i].FW_Version = *(uint32_t *) (p_frame->data + 1U);
						break;
					}
				}
			}
				break;

			case (CANFD_CMD____FILE_TRANSFER____START | CANFD_ANS____WRITE ): {
				FWDescriptor.ID = p_frame->data[1];
				FWDescriptor.Size = *(uint32_t *) (p_frame->data + 2);
				FWDescriptor.Counter = 0U;

				memset(Data_Packet____4KB, 0U, sizeof(Data_Packet____4KB));
				FW_Data____4KB____Counter = 0U;

				CANFD_NET____SendByte(&canfd0_i, p_frame->id, CANFD_CMD____ACK_BYTE);
			}
			break;

			case (CANFD_CMD____FILE_TRANSFER____STOP | CANFD_ANS____WRITE ): {
				CANFD_NET____SendByte(&canfd0_i, p_frame->id, CANFD_CMD____ACK_BYTE);
			}
			break;

			case (CANFD_CMD____FILE_TRANSFER____DATA | CANFD_ANS____WRITE ): {
				FT____Packet_Number = (*(uint32_t *) (p_frame->data + 1U)) % 4096U;
				FT____Packet_Size = p_frame->data[5];

				for (i = 0U; i < FT____Packet_Size; i++) {
					Data_Packet____4KB[FT____Packet_Number * 32 + i] = p_frame->data[6 + i];
				}

				CANFD_NET____SendByte(&canfd0_i, p_frame->id, CANFD_CMD____ACK_BYTE);
			}
			break;

			case (CANFD_CMD____FILE_TRANSFER____VERIFY | CANFD_ANS____READ ): {

			}
			break;

			case (CANFD_CMD____DATA_FLASH_LOAD | CANFD_ANS____WRITE):{
				Answer_Pack.NID = p_frame->id;
				Answer_Pack.ANS = (CANFD_CMD____DATA_FLASH_LOAD | CANFD_ANS____WRITE);
			}
			break;

			case CANFD_CMD____ACK_BYTE : {
				Answer_Pack.NID = p_frame->id;
				Answer_Pack.ANS = CANFD_CMD____ACK_BYTE;
			}
			break;

			case CANFD_CMD____NACK_BYTE : {
				Answer_Pack.NID = p_frame->id;
				Answer_Pack.ANS = CANFD_CMD____NACK_BYTE;
			}
			break;

			case CANFD_CMD____BUSY_BYTE : {
				Answer_Pack.NID = p_frame->id;
				Answer_Pack.ANS = CANFD_CMD____BUSY_BYTE;
			}
			break;

			case CANFD_CMD____SYNC_BYTE : {
				Answer_Pack.NID = p_frame->id;
				Answer_Pack.ANS = CANFD_CMD____SYNC_BYTE;
			}
			break;

			default: {

			}
			break;
		}
	}
		break;
	}
}
void CANFD_NET____FP____Handle_Recieve_Packet(CanardCANFrame *p_frame) {

// &canfd1_i

}
#endif
#if(1) // Math Function
uint32_t Math_isqrt(uint32_t num) {
	uint32_t res = 0;
	uint32_t bit = 1 << 30; // The second-to-top bit is set: 1L<<30 for long
	// "bit" starts at the highest power of four <= the argument.

	while (bit > num) {
		bit >>= 2;
	}
	while (bit != 0) {
		if (num >= res + bit) {
			num -= res + bit;
			res = (res >> 1) + bit;
		}
		else
			res >>= 1;
		bit >>= 2;
	}
	return res;
}
int32_t Math_sqrt_x(int32_t Input) {
	int32_t x3, x3new;

	if (Input > 1073741824) {
		Input = 1073741824;
	}
	if(Input==0)
		return 0;
	else{
		x3 = 2000;
		x3new = 1000; 
		while(x3new - x3 > 1 || x3new - x3 < -1){
			x3 = x3new >= 46341? 46340 : x3new;			
			x3new = (x3 * x3 + Input) / (2*x3);
		}
		return My_ABS(x3);
	}
}
int32_t Math_sqrt_64_x(int32_t Input){
	int32_t  x3, x3new;
	int64_t  x3_64;
	
	if(Input> 1073741824){
		//Input=1073741824;
	}
	if(Input==0)
		return 0;
	else{
		x3=2000;
		x3new=1000; 

		while(x3new-x3>1 || x3new-x3<-1){
			x3=x3new;
			x3_64=x3;
			x3new=(int32_t)((x3_64*x3_64+(int64_t)Input)/((int64_t)(2*x3)));
		}
		return x3;
	}
}
int32_t Math_Radikal_a2_b2(int32_t a , int32_t b){
	int32_t  xstart, xend, xout;
	int64_t  a_64,b_64,a2b2_64,xout_64,xout2_64;
	
	if(a<0)
		a=-a;
	if(b<0)
		b=-b;
	xend=a+b;
	if(a>b)
		xstart=a;
	else 
		xstart=b;
	xout=(xstart+xend)>>1;
	a_64=a;
	b_64=b;
	a2b2_64=a_64*a_64+b_64*b_64; 

	while(xstart-xend>1 || xstart-xend<-1){
		xout_64=xout;
		xout2_64=xout_64*xout_64;
		if(xout2_64<a2b2_64)
			xstart=xout;
		else
			xend=xout;
		xout=(xstart+xend)>>1;
	}
	
	return xout;
}
int32_t Math_Arctan_Function_Using_Ram(int32_t Signed_Real, int32_t Signed_Imag){
	int32_t   result=0;
	uint32_t  Unsigned_Real;
	uint32_t  Unsigend_Imag;
	int32_t  Satr_Arctan=0;
	int32_t  Satr_daghigh_Arctan_Multyply_10=0;
	int32_t zarib;
	int32_t max_Imag;
	
	
	//---------- S: ????? ?? ??? ?????? ----------
	if(Signed_Real<0)
		Unsigned_Real=~Signed_Real+1;
	else
		Unsigned_Real=Signed_Real;
	if(Signed_Imag<0)
		Unsigend_Imag=~Signed_Imag+1;
	else
		Unsigend_Imag=Signed_Imag;	
	//----------E: ????? ?? ??? ?????? ----------
	if(Unsigend_Imag==0){
		if(Signed_Real>=0)
			return 0;		
		else
			return (18000);
	}
	else if (Unsigned_Real==0){
		if(Signed_Imag>=0)
			return (9000);
		else
			return (-9000);
	}
	else{	
		max_Imag=1073741824/1000;
		max_Imag=1073741;
		if(Unsigend_Imag> max_Imag){
			zarib=Unsigend_Imag/max_Imag+1;
			Unsigend_Imag/=zarib;
			Unsigned_Real/=zarib;
		}		
		
		Satr_Arctan=Unsigend_Imag*100/Unsigned_Real;
		Satr_daghigh_Arctan_Multyply_10=Unsigend_Imag*1000/Unsigned_Real;
		if(Satr_Arctan>=GLB_Number_Of_Row_For_Atan_Array-1)
			result=SDRAM____Atan[GLB_Number_Of_Row_For_Atan_Array-1];
		else
			result = SDRAM____Atan[Satr_Arctan] + (SDRAM____Atan[Satr_Arctan+1]-SDRAM____Atan[Satr_Arctan]) * (Satr_daghigh_Arctan_Multyply_10 - 10 * Satr_Arctan)/10;
	
		if(Signed_Real<0 && Signed_Imag<0)
			result=result-18000;
		else if(Signed_Real<0 && Signed_Imag>0)
			result=18000-result;
		else if(Signed_Real>0 && Signed_Imag<0)
			result=-result;		

		return result;
	}
}
int32_t Math_Sin_Using_RAM(int32_t Input_Angle_Degree_Multiply_100){
	int32_t  Sign_Of_Angle;
// 	for(i=0;i<360;i++){
// 		sprintf((char *)RAM_UART_BUFF,"10000*sin(%d/100 degree)= %d\n", (i*100), Math_Sin_Using_RAM(i*100)); Panel_Komaki_UARTX_For_Sprintf();
// 	}
	
	Sign_Of_Angle=1;
	if(Input_Angle_Degree_Multiply_100<0){
		Input_Angle_Degree_Multiply_100=-1*Input_Angle_Degree_Multiply_100;
		Sign_Of_Angle=-1;
	}
	Input_Angle_Degree_Multiply_100=Input_Angle_Degree_Multiply_100%36000;
	
// 	return (Sign_Of_Angle*(*((int32_t *)(SDRAM____Sine + Input_Angle_Degree_Multiply_100*4))));
	return (Sign_Of_Angle* SDRAM____Sine[Input_Angle_Degree_Multiply_100]);
}
int32_t Math_Cos_Using_RAM(int32_t Input_Angle_Degree_Multiply_100){
	return Math_Sin_Using_RAM(9000-Input_Angle_Degree_Multiply_100);
}
int32_t Math_Order_Of_High_Bitt(int32_t Input){
		int32_t		Order_Of_High_Bit;
		int32_t		Komak_Input;
	
		Order_Of_High_Bit = 0;
		Komak_Input =Input>>16;
		if (Komak_Input != 0){
			Input = Komak_Input;
			Order_Of_High_Bit = Order_Of_High_Bit + 16;
		}
		Komak_Input = Input >> 8;
		if (Komak_Input != 0){
			Input = Komak_Input;
			Order_Of_High_Bit = Order_Of_High_Bit + 8;
		}
		Komak_Input = Input >> 4;
		if (Komak_Input != 0){
			Input = Komak_Input;
			Order_Of_High_Bit = Order_Of_High_Bit + 4;
		}
		Komak_Input = Input >> 2;
		if (Komak_Input != 0){
			Input = Komak_Input;
			Order_Of_High_Bit = Order_Of_High_Bit + 2;
		}
		Komak_Input = Input >> 1;
		if (Komak_Input != 0){
			Input = Komak_Input;
			Order_Of_High_Bit = Order_Of_High_Bit + 1;
		}
		
		return Order_Of_High_Bit;
}
#endif
#if(1) // Init
void Init__RAM_Address_Print(void){
//				netTCP____Transmit_Packet____Length
//				netTCP____Recieve_Packet____Length
//				netTCP____Recieve_Packet
//				netTCP____Transmit_Packet
	
	sprintf((char *)RAM_UART_BUFF,"  ---------- Arrays ADDRESS IN SDRAM ---------- \n"); Panel_Komaki_UARTX_For_Sprintf();	            
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Firmware                               = %8d \n",     	GLB__SDRM_START_BYTE____Firmware	                            - SDRAM_Base_Address    ); Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____RS232_U0000_Recieve                    = %8d  %8d\n", 	GLB__SDRM_START_BYTE____RS232_U0000_Recieve	                  - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____RS232_U0000_Recieve                    -    GLB__SDRM_START_BYTE____Firmware);                           			Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____RS485_U3333_Recieve                    = %8d  %8d\n", 	GLB__SDRM_START_BYTE____RS485_U3333_Recieve	                  - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____RS485_U3333_Recieve                    -    GLB__SDRM_START_BYTE____RS232_U0000_Recieve);                           Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____CMTRD____Analog_Digital                = %8d  %8d\n", 	GLB__SDRM_START_BYTE____CMTRD____Analog_Digital	              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____CMTRD____Analog_Digital                -    GLB__SDRM_START_BYTE____RS485_U3333_Recieve);                           Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____EL                                     = %8d  %8d\n", 	GLB__SDRM_START_BYTE____EL	                                  - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____EL                                     -    GLB__SDRM_START_BYTE____CMTRD____Analog_Digital);                 Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Arctan                                 = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Arctan	                              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Arctan                                 -    GLB__SDRM_START_BYTE____EL);                                      Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Trip_Curve____Norm_Inverse         = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Trip_Curve____Norm_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Trip_Curve____Norm_Inverse         -    GLB__SDRM_START_BYTE____Arctan);                                  Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Trip_Curve____Very_Inverse         = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Trip_Curve____Very_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Trip_Curve____Very_Inverse         -    GLB__SDRM_START_BYTE____IEC_Trip_Curve____Norm_Inverse);          Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Trip_Curve____Extr_Inverse         = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Trip_Curve____Extr_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Trip_Curve____Extr_Inverse         -    GLB__SDRM_START_BYTE____IEC_Trip_Curve____Very_Inverse);          Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Trip_Curve____Long_Inverse         = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Trip_Curve____Long_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Trip_Curve____Long_Inverse         -    GLB__SDRM_START_BYTE____IEC_Trip_Curve____Extr_Inverse);          Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Norm_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Norm_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Norm_Inverse        -    GLB__SDRM_START_BYTE____IEC_Trip_Curve____Long_Inverse);          Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Very_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Very_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Very_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Norm_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Extr_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Extr_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Extr_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Very_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Mode_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Mode_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Mode_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Extr_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Shor_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Shor_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Shor_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Mode_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Long_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Long_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Long_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Shor_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Defi_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Defi_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Defi_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Long_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Reset_Curve____Norm_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Reset_Curve____Norm_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Reset_Curve____Norm_Inverse        -    GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Defi_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Reset_Curve____Very_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Reset_Curve____Very_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Reset_Curve____Very_Inverse        -    GLB__SDRM_START_BYTE____IEC_Reset_Curve____Norm_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Reset_Curve____Extr_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Reset_Curve____Extr_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Reset_Curve____Extr_Inverse        -    GLB__SDRM_START_BYTE____IEC_Reset_Curve____Very_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____IEC_Reset_Curve____Long_Inverse        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____IEC_Reset_Curve____Long_Inverse	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____IEC_Reset_Curve____Long_Inverse        -    GLB__SDRM_START_BYTE____IEC_Reset_Curve____Extr_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Norm_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Norm_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Norm_Inverse       -    GLB__SDRM_START_BYTE____IEC_Reset_Curve____Long_Inverse);         Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Very_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Very_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Very_Inverse       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Norm_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Extr_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Extr_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Extr_Inverse       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Very_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Mode_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Mode_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Mode_Inverse       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Extr_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Shor_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Shor_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Shor_Inverse       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Mode_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Long_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Long_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Long_Inverse       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Shor_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Defi_Inverse       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Defi_Inverse	    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Defi_Inverse       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Long_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____48_Inverse_Curve                       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____48_Inverse_Curve	                    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____48_Inverse_Curve                       -    GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Defi_Inverse);        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____TL                                     = %8d  %8d\n", 	GLB__SDRM_START_BYTE____TL	                                  - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____TL                                     -    GLB__SDRM_START_BYTE____48_Inverse_Curve);                        Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____TL_DateTime____For_Menu                = %8d  %8d\n", 	GLB__SDRM_START_BYTE____TL_DateTime____For_Menu	              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____TL_DateTime____For_Menu                -    GLB__SDRM_START_BYTE____TL);                                      Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Sine                                   = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Sine	                                - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Sine                                   -    GLB__SDRM_START_BYTE____TL_DateTime____For_Menu);                 Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu               = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu	            - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu               -    GLB__SDRM_START_BYTE____Sine);                                    Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Cosfft_Sinfft                          = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Cosfft_Sinfft	                        - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Cosfft_Sinfft                          -    GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu);                Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____FFT_H2                                 = %8d  %8d\n", 	GLB__SDRM_START_BYTE____FFT_H2	                              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____FFT_H2                                 -    GLB__SDRM_START_BYTE____Cosfft_Sinfft);                         Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____FFTMemory_H1                           = %8d  %8d\n", 	GLB__SDRM_START_BYTE____FFTMemory_H1	                  			- SDRAM_Base_Address,   GLB__SDRM_START_BYTE____FFTMemory_H1                           -    GLB__SDRM_START_BYTE____FFT_H2);                                  Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____RMS_Memory                             = %8d  %8d\n", 	GLB__SDRM_START_BYTE____RMS_Memory                      			- SDRAM_Base_Address,   GLB__SDRM_START_BYTE____RMS_Memory                             -    GLB__SDRM_START_BYTE____FFTMemory_H1);                                  Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib                   = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib	                - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib                   -    GLB__SDRM_START_BYTE____RMS_Memory);                                  Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Magn_CTPT_Calib_Max_Last               = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last	          - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last             -    GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib);                    Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Magn_CTPT_Calib_Max                    = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max	                - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max                  -    GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last);              Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Magn_CTPT_Calib_Min_Last               = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last	          - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last             -    GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max);                   Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Magn_CTPT_Calib_Min                    = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min	                - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min                  -    GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last);              Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Phase_Angle_Calibration                = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Phase_Angle_Calibration	              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Phase_Angle_Calibration                -    GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib);                    Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Tanjant                                = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Tanjant	                              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Tanjant                                -    GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min);                   Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC              = %8d  %8d\n", 	GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC	            - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC              -    GLB__SDRM_START_BYTE____Tanjant);            Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC              = %8d  %8d\n", 	GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC	            - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC              -    GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC);               Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____UART2_Recieve_Buff                     = %8d  %8d\n", 	GLB__SDRM_START_BYTE____UART2_Recieve_Buff	                  - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____UART2_Recieve_Buff                     -    GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC);               Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____UART_IrqBuf2                           = %8d  %8d\n", 	GLB__SDRM_START_BYTE____UART_IrqBuf2	                        - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____UART_IrqBuf2                           -    GLB__SDRM_START_BYTE____UART2_Recieve_Buff);                      Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD              = %8d  %8d\n", 	GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD	            - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD              -    GLB__SDRM_START_BYTE____UART_IrqBuf2);                            Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER          = %8d  %8d\n", 	GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER         - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER          -    GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD);               Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER          = %8d  %8d\n", 	GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER         - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER          -    GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER);           Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER        -    GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER);           Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER        = %8d  %8d\n", 	GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER	      - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER        -    GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER);         Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Measurem_RECORD_string                 = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Measurem_RECORD_string	              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Measurem_RECORD_string                 -    GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER);         Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____String_Komaki                          = %8d  %8d\n", 	GLB__SDRM_START_BYTE____String_Komaki	                        - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____String_Komaki                          -    GLB__SDRM_START_BYTE____Measurem_RECORD_string);                  Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Str_Koma_For_Doub_t_Char_0             = %8d  %8d\n", 	GLB__SDRM_START_BYTE____MyStr_0	  														- SDRAM_Base_Address,   		GLB__SDRM_START_BYTE____MyStr_0     												-    GLB__SDRM_START_BYTE____String_Komaki);                           Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Str_Koma_For_Doub_t_Char_1             = %8d  %8d\n", 	GLB__SDRM_START_BYTE____MyStr_1	  														- SDRAM_Base_Address,   GLB__SDRM_START_BYTE____MyStr_1     														-    GLB__SDRM_START_BYTE____MyStr_0);      Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device          = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device	        - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device          -    GLB__SDRM_START_BYTE____MyStr_1);      Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle           = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle	        - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle           -    GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device);      			Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____CARDS_FLASH_DATA                       = %8d  %8d\n", 	GLB__SDRM_START_BYTE____CARDS_FLASH_DATA	                    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____CARDS_FLASH_DATA                       -    GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle);           	Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA= %8d  %8d\n", 	GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA- SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA	-    GLB__SDRM_START_BYTE____CARDS_FLASH_DATA);          Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____HF_Vriables__INFO                      = %8d  %8d\n", 	GLB__SDRM_START_BYTE____HF_Vriables__INFO	                    - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____HF_Vriables__INFO                      -    GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA);                      Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  GLB__SDRM_START_BYTE____Adr_Start_Timer0_Calib                 = %8d  %8d\n", 	GLB__SDRM_START_BYTE____Adr_Start_Timer0_Calib	              - SDRAM_Base_Address,   GLB__SDRM_START_BYTE____Adr_Start_Timer0_Calib                 -    GLB__SDRM_START_BYTE____HF_Vriables__INFO);                       Panel_Komaki_UARTX_For_Sprintf();	
	sprintf((char *)RAM_UART_BUFF,"  ------------------\n"); Panel_Komaki_UARTX_For_Sprintf();	
}
void Init__RAM_Adress_Initialize(void){
	int32_t  a1, a2, a3;
	int32_t FFT_Mem_Max_Num_Of_Samp3;
				
	GLB_Calib__VI_Max_Steps_Count_With_MidPoints												= MAX(GLB_Calib__V_Steps[GLB_Calib__V_Steps_Count-1], GLB_Calib__I_Steps[GLB_Calib__I_Steps_Count-1]);

	if(Calib_Mode!=0){
		GLB_FFT_Memory____Max_Num_Of_FFT_Samples            						= GLB_FFT_Memory____Max_Num_Of_FFT_Samples_1 * GLB_Number_of_Sample_per_Cycle/20;
		RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure									= GLB_FFT_Memory____Max_Num_Of_FFT_Samples_1 * GLB_Number_of_Sample_per_Cycle/20/2;
	}						
	else{
		GLB_FFT_Memory____Max_Num_Of_FFT_Samples            						= GLB_FFT_Memory____Max_Num_Of_FFT_Samples_2 * GLB_Number_of_Sample_per_Cycle/20;
		RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure						=	GLB_FFT_Memory____Max_Num_Of_FFT_Samples_2 * GLB_Number_of_Sample_per_Cycle/20/2;
	}
	
	FFT_Mem_Max_Num_Of_Samp3													= MAX(GLB_FFT_Memory____Max_Num_Of_FFT_Samples_1, GLB_FFT_Memory____Max_Num_Of_FFT_Samples_2)*GLB_Number_of_Sample_per_Cycle/20;
	
	GLB_DIR_Memory_Length														= GLB_FFT_Memory____Max_Num_Of_FFT_Samples-5*GLB_Number_of_Sample_per_Cycle;
	
	GLB__SDRM_START_BYTE____FFTMemory_H1										= (GLB__SDRM_START_BYTE____FFT_H2 + GLB_Max_Num_Of_Analog_For_FFTMemory* 4* 4* FFT_Mem_Max_Num_Of_Samp3);
	SDRAM____FFTMemory_H1														= (uint32_t *)(GLB__SDRM_START_BYTE____FFTMemory_H1);

	GLB__SDRM_START_BYTE____RMS_Memory											= (GLB__SDRM_START_BYTE____FFTMemory_H1 + GLB_Max_Num_Of_Analog_For_FFTMemory* 4* 4* FFT_Mem_Max_Num_Of_Samp3);
	SDRAM____RMS_Memory															= (uint32_t *)(GLB__SDRM_START_BYTE____RMS_Memory);
	
	GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib								= (GLB__SDRM_START_BYTE____RMS_Memory + GLB_Max_Num_Of_Analog_For_FFTMemory* 4* 4* FFT_Mem_Max_Num_Of_Samp3);
	SDRAM____Magnitude_CTPT_Calib												= (uint32_t *)(GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib);
	//----------S:  ----------                          							
	GLB__SDRM_START_BYTE____Phase_Angle_Calibration								= (GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib +  GLB_4_Byte *GLB_Max_Num_Of_CTPT__On_A_Card *Calib_Num_Of_Steps_For_Any_CTPT_With_midpoints+4);
	SDRAM____Phase_Angle_Calibration 							      							= (int32_t *)(GLB__SDRM_START_BYTE____Phase_Angle_Calibration);
	//----------S: ----------							
	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last 								= (GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib+  				GLB_4_Byte*(GLB_Max_Num_Of_CTPT__On_A_Card *Calib_Num_Of_Steps_For_Any_CTPT_With_midpoints)+4);
	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max	    								= (GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last+  	GLB_2_Byte*(GLB_Max_Num_Of_CTPT__On_A_Card *GLB_Calib__VI_Max_Steps_Count)+4);
	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last 								= (GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max+  				GLB_2_Byte*(GLB_Max_Num_Of_CTPT__On_A_Card *GLB_Calib__VI_Max_Steps_Count)+4);
	GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min	    								= (GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last+  	GLB_2_Byte*(GLB_Max_Num_Of_CTPT__On_A_Card *GLB_Calib__VI_Max_Steps_Count)+4);
								
	SDRAM____Magnitude_CTPT_Calib_Max_Last					    							= (int16_t *)(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last);
	SDRAM____Magnitude_CTPT_Calib_Max							      							= (int16_t *)(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max);
	SDRAM____Magnitude_CTPT_Calib_Min_Last					    							= (int16_t *)(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last);
	SDRAM____Magnitude_CTPT_Calib_Min							      							= (int16_t *)(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min);
//	//----------S: ----------
//	//----------S: ----------
	a1= GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min+ 		GLB_2_Byte * GLB_Max_Num_Of_CTPT__On_A_Card *GLB_Calib__VI_Max_Steps_Count-SDRAM_Base_Address;
	a2=(GLB__SDRM_START_BYTE____Phase_Angle_Calibration+  GLB_4_Byte *(GLB_Max_Num_Of_CTPT__On_A_Card *GLB_Calib__VI_Max_Steps_Count_With_MidPoints)+4 )-SDRAM_Base_Address;
	GLB__SDRM_START_BYTE____Tanjant																		= SDRAM_Base_Address + MAX(a1, a2);
	SDRAM____Tanjant 																									= (uint32_t *)(GLB__SDRM_START_BYTE____Tanjant);
	//----------S: ----------
							
	GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC	  							=	(GLB__SDRM_START_BYTE____Tanjant + GLB_4_Byte*900+4);
	SDRAM____4_Block_MMC        			        							= (uint8_t *)(GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC);
	GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC									= (GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC + (1<<(DATA_BLOCK_LEN+2))+4);
	SDRAM____1_Block_MMC       			          							= (uint8_t *)(GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC);
	GLB__SDRM_START_BYTE____UART2_Recieve_Buff		      							=	(GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC + (1<<(DATA_BLOCK_LEN))+4);
	SDRAM____UART2_Recieve_Buff							            							= (uint8_t *)(GLB__SDRM_START_BYTE____UART2_Recieve_Buff);
	GLB__SDRM_START_BYTE____UART_IrqBuf2				        							=	(GLB__SDRM_START_BYTE____UART2_Recieve_Buff + U2_R_Len_Max+4);
	GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD	  							=	(GLB__SDRM_START_BYTE____UART_IrqBuf2 + U2_S_Len_Max+4);
	SDRAM____New_LCD_Chars_Show_On_LCD					        							= (uint8_t *)(GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD);
							
	GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER 						=	(GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD + (GLB____LCD____Max_Num_Of_Lines+1)*GLB____LCD____Max_Num_Of_Char_In_a_Lines+4);
	SDRAM____SERIAL____FP_TO_CPU____BUFFER														= (uint8_t *)(GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER);		
	GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER 						=	(GLB__SDRM_START_BYTE____SERIAL____FP_TO_CPU____BUFFER + SERIAL____FP_TO_CPU____BUFFER____SIZE+4);
	SDRAM____SERIAL____CPU_TO_FP____BUFFER														= (uint8_t *)(GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER);		
							
	GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER 					=	(GLB__SDRM_START_BYTE____SERIAL____CPU_TO_FP____BUFFER + SERIAL____CPU_TO_FP____BUFFER____SIZE+4);
	SDRAM____ETHERNET____FP_TO_CPU____BUFFER							  					= (uint8_t *)(GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER);
	GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER 					=	(GLB__SDRM_START_BYTE____ETHERNET____FP_TO_CPU____BUFFER + ETHERNET____FP_TO_CPU____BUFFER____SIZE+4);
	SDRAM____ETHERNET____CPU_TO_FP____BUFFER													= (uint8_t *)(GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER);		
			
	GLB__SDRM_START_BYTE____Measurem_RECORD_string										= (GLB__SDRM_START_BYTE____ETHERNET____CPU_TO_FP____BUFFER + ETHERNET____CPU_TO_FP____BUFFER____SIZE+4);
	SDRAM____Measurem_RECORDs_string																	= (char *)(GLB__SDRM_START_BYTE____Measurem_RECORD_string);
	GLB__SDRM_START_BYTE____String_Komaki															= (GLB__SDRM_START_BYTE____Measurem_RECORD_string + MAX(GLB____LCD____Max_Num_Of_Lines*GLB____LCD____Max_Num_Of_Char_In_a_Lines, 15000)+4);
	SDRAM____String_Komaki																						= (char *)(GLB__SDRM_START_BYTE____String_Komaki);
	GLB__SDRM_START_BYTE____MyStr_0												= (GLB__SDRM_START_BYTE____String_Komaki + GLB____LCD____Max_Num_Of_Char_In_a_Lines+4);
	SDRAM____MyStr_0																		= (char *)(GLB__SDRM_START_BYTE____MyStr_0);
	GLB__SDRM_START_BYTE____MyStr_1													= (GLB__SDRM_START_BYTE____MyStr_0 + GLB____LCD____Max_Num_Of_Char_In_a_Lines+4);
	SDRAM____MyStr_1																				= (char *)(GLB__SDRM_START_BYTE____MyStr_1);
	GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device 						= (GLB__SDRM_START_BYTE____MyStr_1 + GLB____LCD____Max_Num_Of_Char_In_a_Lines+4);
	SDRAM____Apply_AMR_State_Seq_To_Device														= (uint8_t *)(GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device);
	
	
	GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle 							= (GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device + 100*24*GLB_4_Byte +4);
	SDRAM____Measre_In_While____Abs_Angle 														= (int32_t *)(GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle);
	
	GLB__SDRM_START_BYTE____CARDS_FLASH_DATA													= (GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle + GLB_Max_Num_Of_CTPTs__In_All_Units * 4 * GLB_4_Byte * GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts);
	SDRAM____CARDS_FLASH_DATA 																				= (uint16_t *)GLB__SDRM_START_BYTE____CARDS_FLASH_DATA;
//GLB__SDRM_START_BYTE____Addresses_In_MHA_For_Log_In_EL										= (GLB__SDRM_START_BYTE____CARDS_FLASH_DATA + MAX_NUM_OF_UNITS*NUM_OF_UNIT_CARDS*4096);
//SDRAM____Blocks_Settings_Adress_And_Value_In_MHA												= (int32_t*)GLB__SDRM_START_BYTE____Addresses_In_MHA_For_Log_In_EL; 
	GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA								= (GLB__SDRM_START_BYTE____CARDS_FLASH_DATA + MAX_NUM_OF_UNITS*NUM_OF_UNIT_CARDS*4096);
	SDRAM____Blocks_Settings_Adress_And_Value_In_MHA												= (int32_t*)GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA; 
				
	GLB__SDRM_START_BYTE____Menu____Line_Address_Array 											= (GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA         + GLB_4_Byte* GLB_Max_Num_Of_Byte_for_VFC_Setting_In_MHA);
	SDRAM____Menu____Line_Address_Array 							 											= (int32_t *)GLB__SDRM_START_BYTE____Menu____Line_Address_Array;
	GLB__SDRM_START_BYTE____Menu____String_Array       											= (GLB__SDRM_START_BYTE____Menu____Line_Address_Array + Menu____Line_Address_Array___Max_Size);
	SDRAM____Menu____String_Array                      											= (char *)GLB__SDRM_START_BYTE____Menu____String_Array;
	GLB__SDRM_START_BYTE____Menu____Disp_Array         											= (GLB__SDRM_START_BYTE____Menu____String_Array       + Menu____String_Array___Max_Size);
	SDRAM____Menu____Disp_Array                        											= (int32_t *)GLB__SDRM_START_BYTE____Menu____Disp_Array;
									
	GLB__SDRM_START_BYTE____Menu____Method_ComboBox		 										= (GLB__SDRM_START_BYTE____Menu____Disp_Array + Menu____Disp_Array___Max_Size);
	SDRAM____Menu____Method_ComboBox									 								= (char *)GLB__SDRM_START_BYTE____Menu____Method_ComboBox;
	GLB__SDRM_START_BYTE____Menu____Method_Range			 									= (GLB__SDRM_START_BYTE____Menu____Method_ComboBox + Menu____Method_ComboBox___Max_Size);
	SDRAM____Menu____Method_Range											 								= (char *)GLB__SDRM_START_BYTE____Menu____Method_Range;
				
	GLB__SDRM_START_BYTE____Settings_Index_In_MHASettArray		  								= (GLB__SDRM_START_BYTE____Menu____Method_Range + Menu____Method_Range___Max_Size);
	SDRAM____Settings_Index_In_MHASettArray		 												= (int32_t *)GLB__SDRM_START_BYTE____Settings_Index_In_MHASettArray;
	
	GLB__SDRM_START_BYTE____Apply_Cmtrd_1														= (GLB__SDRM_START_BYTE____Settings_Index_In_MHASettArray + Settings_Index_In_MHASettArray___Max_Size);
	SDRAM____Apply_Cmtrd_1																		= (int32_t *)GLB__SDRM_START_BYTE____Apply_Cmtrd_1;
									
	GLB__SDRM_START_BYTE____Apply_Cmtrd_2														= (GLB__SDRM_START_BYTE____Apply_Cmtrd_1 + GLB_4_Byte * APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part);
	SDRAM____Apply_Cmtrd_2																		= (int32_t *)GLB__SDRM_START_BYTE____Apply_Cmtrd_2;
	
	GLB__SDRM_START_BYTE____Simulation__Cards_ID       											= (GLB__SDRM_START_BYTE____Apply_Cmtrd_2 + GLB_4_Byte * APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part);
	SDRAM____Simulation__Cards_ID						           								= (int32_t *)GLB__SDRM_START_BYTE____Simulation__Cards_ID; 


	GLB__SDRM_START_BYTE____HF_Vriables__INFO		       										= (GLB__SDRM_START_BYTE____Simulation__Cards_ID + GLB_4_Byte * MAX_NUM_OF_UNITS * NUM_OF_UNIT_CARDS);
	SDRAM____HF_Vriables__INFO							           								= (char *)GLB__SDRM_START_BYTE____HF_Vriables__INFO; 
	
	if(GLB__SDRM_START_BYTE____HF_Vriables__INFO -SDRAM_Base_Address > 30 * 1024*1024)
			GLB____Hardware_Fault__Message[1]|=(One<<Err____SDRAM____Invalid_Adrs);
	else if((GLB__SDRM_START_BYTE____RS232_U0000_Recieve														-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____RS485_U3333_Recieve 														-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____CMTRD____Analog_Digital                				-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____EL                                   					-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Arctan                                      		-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Trip_Curve____Norm_Inverse                 -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Trip_Curve____Very_Inverse                 -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Trip_Curve____Extr_Inverse                 -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Trip_Curve____Long_Inverse                 -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Norm_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Very_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Extr_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Mode_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Shor_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Long_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Defi_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Reset_Curve____Norm_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Reset_Curve____Very_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Reset_Curve____Extr_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____IEC_Reset_Curve____Long_Inverse                -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Norm_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Very_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Extr_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Mode_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Shor_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Long_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Defi_Inverse               -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____48_Inverse_Curve                            -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____TL                                          -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____TL_DateTime____For_Menu            		-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Sine                                        -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu                 -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Cosfft_Sinfft                           -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____FFT_H2                           -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____FFTMemory_H1                          -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____RMS_Memory                          -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Magnitude_CTPT_Calib                    -SDRAM_Base_Address)%4!=0	|| \
																			   
		(GLB__SDRM_START_BYTE____Phase_Angle_Calibration                 -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Tanjant                           -SDRAM_Base_Address)%4!=0	|| \
																			   
		(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max_Last              -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Max                   -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min_Last              -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Magnit_CTPT_Calib_Min                   -SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Tanjant                           -SDRAM_Base_Address)%4!=0	|| \
			
		(GLB__SDRM_START_BYTE____For_Read_4_Block_From_MMC            	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____For_Read_1_Block_From_MMC           	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____UART2_Recieve_Buff                   	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____New_LCD_Chars_Show_On_LCD            	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Measurem_RECORD_string                 	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____String_Komaki                        	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____MyStr_0   	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____MyStr_1   	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Apply_AMR_State_Seq_To_Device    	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Measre_In_While____Abs_Angle     	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____CARDS_FLASH_DATA                 	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Blocks_Settings_Adress_And_Value_In_MHA               	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____HF_Vriables__INFO                	-SDRAM_Base_Address)%4!=0	|| \
		(GLB__SDRM_START_BYTE____Adr_Start_Timer0_Calib               	-SDRAM_Base_Address)%4!=0){
			GLB____Hardware_Fault__Message[1]|=(One<<Err____SDRAM____Invalid_Adrs);
	}	
}

void Init____WriteConfig(void){
	int32_t i;	
//	ReadMyCfg.Serial=1000136;
//	WriteMyCfg.readwriteMode=WriteMode_Serial;
//	sprintf((char *)RAM_UART_BUFF,"ReadMyCfg.Serial=%d\n",ReadMyCfg.Serial); Panel_Komaki_UARTX_For_Sprintf();
//	sprintf((char *)RAM_UART_BUFF,"WriteMyCfg.readwriteMode=%d\n",WriteMyCfg.readwriteMode); Panel_Komaki_UARTX_For_Sprintf();

	switch(WriteMyCfg.readwriteMode){
		case WriteMode_IP:{
			read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			for(i=0;i<20;i++)
				SDRAM____1_Block_MMC[4+i]=WriteMyCfg.IPConfig[i];
			Write_to_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			break;
		}
		case WriteMode_MAC:{
			read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			for(i=0;i<6;i++)
				SDRAM____1_Block_MMC[24+i]=WriteMyCfg.MAC[i];
			Write_to_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			break;
		}
		case WriteMode_Port:{
			read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			*(uint16_t*)(SDRAM____1_Block_MMC+30)=WriteMyCfg.Port;
			Write_to_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			break;
		}
		case WriteMode_Serial:{
			read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			*(uint64_t*)(SDRAM____1_Block_MMC+32)=WriteMyCfg.Serial;
			Write_to_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
			break;
		}
		case WriteMode_WatchDog_Active_Or_Deactive:{
//			EEPROM_Write(0,5,(void *)&(WatchDog_Code_In_E2PROM),MODE_8_BIT,4);
//			read_from_MMC(SDRAM____1_Block_MMC, GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU, 1);
//			*(uint32_t*)(SDRAM____1_Block_MMC)=WatchDog_Code_In_E2PROM;
//			Write_to_MMC(SDRAM____1_Block_MMC, GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU, 1);
			break;
		}
		case WriteMode_Test_Mode:{
//			EEPROM_Write(0,4,(void *)&(Test_Mode_Cod),MODE_8_BIT,4);
//			read_from_MMC(SDRAM____1_Block_MMC, GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU, 1);
//			*(uint32_t*)(SDRAM____1_Block_MMC+4)=Test_Mode_Cod;
//			Write_to_MMC(SDRAM____1_Block_MMC, GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU, 1);
			break;
		}
		case WriteMode_ClockCalibration:
//			EEPROM_Write(0,1,(void *)&(WriteMyCfg.ClockCalibration),MODE_8_BIT,4);
			break;
		case WriteMode_CalibData: 
			break;
		default:
			break;
	}
}
void Init____ReadConfig(void){
	int i;

	read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____ETH_IF, 1);
	
	if(*(uint32_t *)(SDRAM____1_Block_MMC+0) !=  0xABCD1234){
		// 1E-30-6C-A2-45-5F
		ReadMyCfg.MAC[0] = 0x1E;
		ReadMyCfg.MAC[1] = 0x30;
		ReadMyCfg.MAC[2] = 0x6C;
		ReadMyCfg.MAC[3] = 0xA2;
		ReadMyCfg.MAC[4] = 0x45;
		ReadMyCfg.MAC[5] = 0x6F;
			
		ReadMyCfg.IPConfig[0]  = 192;
		ReadMyCfg.IPConfig[1]  = 168;
		ReadMyCfg.IPConfig[2]  = 1;
		ReadMyCfg.IPConfig[3]  = 199;
		ReadMyCfg.IPConfig[4]  = 192;
		ReadMyCfg.IPConfig[5]  = 168;
		ReadMyCfg.IPConfig[6]  = 1;
		ReadMyCfg.IPConfig[7]  = 1;
		ReadMyCfg.IPConfig[8]  = 255;
		ReadMyCfg.IPConfig[9]  = 255;
		ReadMyCfg.IPConfig[10] = 255;
		ReadMyCfg.IPConfig[11] = 0;
		ReadMyCfg.IPConfig[12] = 8;
		ReadMyCfg.IPConfig[13] = 8;
		ReadMyCfg.IPConfig[14] = 8;
		ReadMyCfg.IPConfig[15] = 8;
		ReadMyCfg.IPConfig[16] = 8;
		ReadMyCfg.IPConfig[17] = 8;
		ReadMyCfg.IPConfig[18] = 4;
		ReadMyCfg.IPConfig[19] = 4;
		
		ReadMyCfg.Port=1001;
//		ReadMyCfg.Serial = 1981000001UL;
	}
	else{		
		for(i=0;i<4;i++)
			ReadMyCfg.IPConfig[i] = SDRAM____1_Block_MMC[4+i]; // IP
		for(i=0;i<4;i++)
			ReadMyCfg.IPConfig[i+4] = SDRAM____1_Block_MMC[8+i]; // GATEWAY
		for(i=0;i<4;i++)
			ReadMyCfg.IPConfig[i+8] = SDRAM____1_Block_MMC[12+i]; // SUBNET
		for(i=0;i<4;i++)
			ReadMyCfg.IPConfig[i+12] = SDRAM____1_Block_MMC[16+i]; // PRIDNS
		for(i=0;i<4;i++)
			ReadMyCfg.IPConfig[i+16] = SDRAM____1_Block_MMC[20+i]; // SECDNS
		for(i=0;i<6;i++)
			ReadMyCfg.MAC[i]=SDRAM____1_Block_MMC[24+i]; 					 // MAC
		ReadMyCfg.Port = *(uint16_t *)(SDRAM____1_Block_MMC + 30);
		ReadMyCfg.Serial = *(uint64_t *)(SDRAM____1_Block_MMC + 32);
	}
}
void Init__EEPROMRead_For_Test_Mode(void){
//	EEPROM_Read(0,4,(void *)&(),MODE_8_BIT,4);
//	read_from_MMC(SDRAM____1_Block_MMC, GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU, 1);
//	ReadMyCfg.Test_Status=*(uint32_t*)(SDRAM____1_Block_MMC+4);
}
void Init__EEPROMRead_For_WriteMode_WatchDog_Activation_Status(void){
//	EEPROM_Read(0,5,(void *)&(ReadMyCfg.WatchDog_Activation_Status),MODE_8_BIT,4);
//	read_from_MMC(SDRAM____1_Block_MMC, GLB_TestModStatus_WatchDogActivationStatus____MMC____BLK_NUM____CPU, 1);
//	ReadMyCfg.WatchDog_Activation_Status=*(uint32_t*)(SDRAM____1_Block_MMC);
}
void Xtal__CalibRation_Pre_Requiesit(uint32_t ClockCalibration){
  //----when negative Dev>0
  ClockCalibration-=1;
  if(ClockCalibration<Number_Of_Clock_For_Micro_For_1s){
    Glb_Xtal_Calib_Timer0.a=Number_Of_Clock_For_Micro_For_1s-ClockCalibration;
    Glb_Xtal_Calib_Timer0.sign_a=1;  
  }
  else{
    Glb_Xtal_Calib_Timer0.a=ClockCalibration-Number_Of_Clock_For_Micro_For_1s;
    Glb_Xtal_Calib_Timer0.sign_a=0;  
  }
  Glb_Xtal_Calib_Timer0.b=Timer_Clock_For_1_Of_12_5us_Timer/Glb_Xtal_Calib_Timer0.a;
  Glb_Xtal_Calib_Timer0.c=Glb_Xtal_Calib_Timer0.b+1;
  Glb_Xtal_Calib_Timer0.c1=Xtal_Calib_Timer_0_Power_Of_10-(Timer_Clock_For_1_Of_12_5us_Timer*Xtal_Calib_Timer_0_Power_Of_10/Glb_Xtal_Calib_Timer0.a-Glb_Xtal_Calib_Timer0.b*Xtal_Calib_Timer_0_Power_Of_10);
  Glb_Xtal_Calib_Timer0.m=0;
  Glb_Xtal_Calib_Timer0.k=0;
}
void Init__relay_init__Sub_Tasks(int8_t Task){
	int32_t i=0;
	int32_t Unit_Index, Card_Index;
	
	switch(Task){
		case Init_Stage__Check_Calib_Mode__Simulation_Mode:{
			switch(*(uint8_t *)(SDRAM_Base_Address+100)){
				case 125:
					Calib_Mode=1;
				break;
				case 200:
					i=0;
					for(Unit_Index = 0; Unit_Index <= MAX_NUM_OF_UNITS; Unit_Index++){
						for(Card_Index = 0; Card_Index <= NUM_OF_UNIT_CARDS; Card_Index++){
							Simulation__Cards_ID[i] = SDRAM____Simulation__Cards_ID[i];
							i++;
						}
					}
					
					Simulation_Flag = true;
				break;
				}
			break;
		}
		case Init_Stage__Clock_Calibration:{
			if(ReadMyCfg.ClockCalibration < 59000000 || ReadMyCfg.ClockCalibration > 61000000){
				WriteMyCfg.ClockCalibration=60000000;
				WriteMyCfg.readwriteMode=WriteMode_ClockCalibration;
				Init____WriteConfig();
				Init____ReadConfig();
				if(WriteMyCfg.ClockCalibration != ReadMyCfg.ClockCalibration){
//					LED_ERROR_ON;
				}
				else{
				
					NVIC_SystemReset();
				}
			}
			Xtal__CalibRation_Pre_Requiesit(ReadMyCfg.ClockCalibration);	
			break;
		}
		case Init_Stage__Setting_And_Configs:{
			Var_Init__Show_Records_On_LCD__Init();
			Loading_Percent_Part_1++;
			Loading_Percent = Loading_Percent_Part_1;
			Var_Init();
			break;
		}
		case Init_Stage__Reset_RAM:{
			for (i=0U; i<(uint32_t)(500/4); i++){
				*((uint32_t *)(SDRAM_Base_Address+4*i))=0;
			}
			
			for (i=(uint32_t)((500+GLB_Firmware_Size)/4); i<(uint32_t)(32*1024*1024)/4U; i++){
				*((uint32_t *)(SDRAM_Base_Address+4*i))=0;
			}
			break;
		}
	}
}
void Init__relay_init(void){
	Init__RAM_Adress_Initialize();			
	HW__Init();
	Loading_Percent_Part_1 +=5;
	Loading_Percent = Loading_Percent_Part_1;
//	Init__Set_Network();

	if(GLB____Hardware_Fault__Message[1]==0){
		Init__relay_init__Sub_Tasks(Init_Stage__Check_Calib_Mode__Simulation_Mode);
		if(Calib_Mode==0)
			Init__EEPROMRead_For_WriteMode_WatchDog_Activation_Status();

		if(ReadMyCfg.WatchDog_Activation_Status==0 || GLB_Live_Status==0){
			if(Calib_Mode==0){
//			Init__RAM_Address_Print();
				read_from_MMC(SDRAM____1_Block_MMC, MMC_TIM2_TIMING_CORRECTION____BLK_NUM____CPU, 1);	
				GLB__CLK_CALIB____TIM2_TIMING_CORRECTION=*(int32_t *)(SDRAM____1_Block_MMC);
			}
			Init__relay_init__Sub_Tasks(Init_Stage__Reset_RAM);
			sprintf((char *)RAM_UART_BUFF,"Reset RAM Done.\n"); Panel_Komaki_UARTX_For_Sprintf();
			sprintf((char *)RAM_UART_BUFF,"Clock Calibration...\n"); Panel_Komaki_UARTX_For_Sprintf();	
			Init__relay_init__Sub_Tasks(Init_Stage__Clock_Calibration);
			sprintf((char *)RAM_UART_BUFF,"Setting And Configs...\n"); Panel_Komaki_UARTX_For_Sprintf();	
			Loading_Percent_Part_1 +=5;
			Loading_Percent = Loading_Percent_Part_1;
			Init__relay_init__Sub_Tasks(Init_Stage__Setting_And_Configs);
			
			Allow_Timer_1ms_Routine_Execute=1;
			HW_RESET____1_ENABLE____0_DISABLE=1;
		}
		else{
//			T6963_240_128_Write_String("device malfunction!",0,30,0);						
//			sprintf((char *)RAM_UART_BUFF,"WatchDog_Count = %d\n", WatchDog_Count); Panel_Komaki_UARTX_For_Sprintf();
//			sprintf((char *)RAM_UART_BUFF,"WatchDog_Time  = %d\n",WatchDog_Time); Panel_Komaki_UARTX_For_Sprintf();
		}
	}
//	else{
//		T6963_240_128_Write_String("       Invalid RAM Address!",0,90,0);
//		sprintf((char *)RAM_UART_BUFF,"Invalid RAM Address!!!!\n"); Panel_Komaki_UARTX_For_Sprintf();
//		Init__RAM_Address_Print();
//		sprintf((char *)RAM_UART_BUFF,"Invalid RAM Address!!!!\n"); Panel_Komaki_UARTX_For_Sprintf();
//	}
	CPU____Initializing=No_0;
}
#endif
#if(1) // Tranfer/Recieve Setting/Config/Data
void Process_Recieve_Data_in_Queue(void){
	uint32_t i=0, k=0, j=0, row=0, ADR, Current_Setting, IOLED_Start, IOLED_End, Field_Start, Field_END;
	int32_t MHA_Adr;
//if(GLB_TEMP==1){
	
	
	if(CPU____QRL____SIZE != 0U){
//	sprintf((char *)RAM_UART_BUFF,"CPU:S: P%d:%lld\n",CPU____QRL[i].ID,GLB_Counter_Samples_Total_New); Panel_Komaki_UARTX_For_Sprintf();
		
		switch(CPU____QRL[CPU____QRL____FRONT____COUNTER].ID){
			case FP_CPU____Setting_Mat:{
				/*
				Max__Row_Of_Sett_Mat__For_Save_On_USD= (CPU____QRL[i].START_INDEX + CPU____QRL[i].SIZE)/4;
				Min__Row_Of_Sett_Mat__For_Save_On_USD= CPU____QRL[i].START_INDEX/4;
				Var_Init__COMPACT__Setting__Write_A_Part_Of_Setting_Matrix_On_uSD();
				
				if(Max__Row_Of_Sett_Mat__For_Save_On_USD>=Row____Setting____Change_Setting_Group____1162 && Min__Row_Of_Sett_Mat__For_Save_On_USD<=Row____Setting____Change_Setting_Group____1162){
					*(uint32_t*)(SDRAM____1_Block_MMC)=My_INF;
					SDRAM____1_Block_MMC[4]=RAM_Setting_Matrix[Row____Setting____Change_Setting_Group____1162];
					Write_to_MMC(SDRAM____1_Block_MMC, GLB__Adr_for_Save_Active_SetGrp, 1);
				}
				*/
			}
			break;
			case FP_CPU____OSC_Mat:{
			}
			break;
			case FP_CPU____EL_Mat:{
			}
			break;
			case FP_CPU____TL_Mat:{
//				GLB_TL_Num_Of_Signals_Are_Assigned=0;
//				for(row=0; row<GLB_Number_Of_Total_Signal_Of_Input_Output-2; row++){
//					if(row>0 && *(uint32_t*)(RAM_TL_Setting_Matrix+ row* 5)==0)
//						break;
//					else
//						GLB_TL_Num_Of_Signals_Are_Assigned++;
//				}
//				Var_Init__COMPACT__ELTL__Write__RAM_ELTL_Setting_Matrix__On__uSD(TL);

			}
			break;
			case FP_CPU____INPUT_Mat:{
				/*
				IOLED_Start=CPU____QRL[i].START_INDEX/8/GLB_Number_Of_Fields_For_Any_Input;
				IOLED_End=(CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8/GLB_Number_Of_Fields_For_Any_Input;
				for(j=IOLED_Start; j<IOLED_End+1; j++){
					Field_Start=(j*GLB_Number_Of_Fields_For_Any_Input<CPU____QRL[i].START_INDEX/8? CPU____QRL[i].START_INDEX/8-j*GLB_Number_Of_Fields_For_Any_Input: 0);
					Field_END  =((j+1)*GLB_Number_Of_Fields_For_Any_Input<(CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8? GLB_Number_Of_Fields_For_Any_Input: (CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8-j*GLB_Number_Of_Fields_For_Any_Input);
					for(k=Field_Start; k<Field_END; k++)
						Var_Init__COMPACT__IOLED__Write__One__IOLED_Assigned_Signals__On__uSD(j, k, Input);
				}
				*/
			}
			break;
			case FP_CPU____OUTPUT_Mat:{
				/*
				IOLED_Start=CPU____QRL[i].START_INDEX/8/GLB_Number_Of_Fields_For_Any_Output;
				IOLED_End=(CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8/GLB_Number_Of_Fields_For_Any_Output;
				for(j=IOLED_Start; j<IOLED_End+1; j++){
					Field_Start=(j*GLB_Number_Of_Fields_For_Any_Output<CPU____QRL[i].START_INDEX/8? CPU____QRL[i].START_INDEX/8-j*GLB_Number_Of_Fields_For_Any_Output: 0);
					Field_END  =((j+1)*GLB_Number_Of_Fields_For_Any_Output<(CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8? GLB_Number_Of_Fields_For_Any_Output: (CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8-j*GLB_Number_Of_Fields_For_Any_Output);
					for(k=Field_Start; k<Field_END; k++)
						Var_Init__COMPACT__IOLED__Write__One__IOLED_Assigned_Signals__On__uSD(j, k, Output );
				}
				*/
			}
			break;
			case FP_CPU____LED_Mat:{
				/*
				IOLED_Start=CPU____QRL[i].START_INDEX/8/GLB_Number_Of_Fields_For_Any_LED;
				IOLED_End=(CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8/GLB_Number_Of_Fields_For_Any_LED;
				for(j=IOLED_Start; j<IOLED_End+1; j++){
					Field_Start=(j*GLB_Number_Of_Fields_For_Any_LED<CPU____QRL[i].START_INDEX/8? CPU____QRL[i].START_INDEX/8-j*GLB_Number_Of_Fields_For_Any_LED: 0);
					Field_END  =((j+1)*GLB_Number_Of_Fields_For_Any_LED<(CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8? GLB_Number_Of_Fields_For_Any_LED: (CPU____QRL[i].START_INDEX+ CPU____QRL[i].SIZE)/8-j*GLB_Number_Of_Fields_For_Any_LED);
					for(k=Field_Start; k<Field_END; k++)
						Var_Init__COMPACT__IOLED__Write__One__IOLED_Assigned_Signals__On__uSD(j, k, LED );
				}
			*/
			}

			break;
			case FP_CPU____Measurement__Fundumental:{
				Measure_Request = Fundumental;
			}
			break;
			case FP_CPU____Measurement__Symetric:{
				Measure_Request = Symetric;
			}
			break;
			case FP_CPU____Measurement__H2:{
				Measure_Request=H2;
			}
			break;
			case FP_CPU____Measurement__VLL:{
				Measure_Request = VLL;
			}
			break;
			case FP_CPU____Disp_Record__TL:{
				Panel_Komaki__TL__Compelete_TL_Indication(TL_Osc_Record_Request_From_FP);
			}
			break;
			case FP_CPU____Disp_Record__Osc:{
				GLB_Osc_Plot_Left_Right=Osc__Load_From_CPU[1];
				GLB_Osc_Horiz_Zoom_Factor=Osc__Load_From_CPU[2];
				GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C=Osc__Load_From_CPU[3];
				Panel_Komaki__Osc__Disp_On_LCD(Osc__Load_From_CPU[0]);
			}
			break;
//			case FP_Ready:{
//				FP_Is_Ready=Yes_1;
//			}
//			break;
			case FP_CPU____FORMAT_RECORDs:{
				switch(GLB__FORMAT_RECORDs__EL_0__TL_1__OSC_2){
					case 0:
						Panel_Komaki__EL__Format_MMC_EL_Part();
					break;
					case 1:
						Panel_Komaki__TL__Format_MMC_TL_Part();
					break;
					case 2:
						Panel_Komaki__Osc__Format_MMC_Osc_Log_Part();
					break;						
				}
			}
			break;
			case FP_CPU____SERIAL:{
				Set____NetIF();
				
				for(k=0; k<20; k++)
					WriteMyCfg.IPConfig[k]=ReadMyCfg.IPConfig[k];
				WriteMyCfg.Port  = ReadMyCfg.Port;
				WriteMyCfg.Serial= ReadMyCfg.Serial;
				
				WriteMyCfg.readwriteMode=WriteMode_IP;
				Init____WriteConfig();
				WriteMyCfg.readwriteMode=WriteMode_Port;
				Init____WriteConfig();
				if(WriteMyCfg.Serial!=0){
					WriteMyCfg.readwriteMode=WriteMode_Serial;
					Init____WriteConfig();
				}
								
//				GLB_Main__CheckBool=1;
//				for(GLB_Main_j=0;GLB_Main_j<16;GLB_Main_j++)
//					if(netTCP____Recieve_Packet[GLB_Main_j+4] != ReadMyCfg.IPConfig[GLB_Main_j])
//						GLB_Main__CheckBool=2;
//				if(*(uint16_t *)(netTCP____Recieve_Packet+20) != ReadMyCfg.Port)
//					GLB_Main__CheckBool=3;
//				if(*(uint64_t *)(netTCP____Recieve_Packet+22)!= ReadMyCfg.Serial)
//					GLB_Main__CheckBool=4;
//				NVIC_SystemReset();
			}
			break;
			case FP_CPU____DATE_TIME__Disply:{
				DATE_AND_TIME__Disply[0]=RTC_GET_YEAR;
				DATE_AND_TIME__Disply[1]=RTC_GET_MONTH;
				DATE_AND_TIME__Disply[2]=RTC_GET_DOM;
				DATE_AND_TIME__Disply[3]=RTC_GET_HOUR;
				DATE_AND_TIME__Disply[4]=RTC_GET_MIN;
				DATE_AND_TIME__Disply[5]=RTC_GET_SEC;
				while(CPU____QTL____ADD_ITEM(FP_CPU____DATE_TIME__Disply, 0,6, 4, (uint32_t) &(DATE_AND_TIME__Disply[0])) != 1U);
			}
			break;
			case FP_CPU____DATE_TIME__Set:{
				DATE_AND_TIME__SET[6]=1;
				SET_RTC_TIME_DATE(DATE_AND_TIME__SET[3],DATE_AND_TIME__SET[4], DATE_AND_TIME__SET[5],\
													DATE_AND_TIME__SET[6], DATE_AND_TIME__SET[2], DATE_AND_TIME__SET[1], DATE_AND_TIME__SET[0], LL_RTC_TIME_FORMAT_AM_OR_24);
			}
			break;
			case FP_CPU____Osc_Date_For_Menu:{
				while(CPU____QTL____ADD_ITEM(FP_CPU____Osc_Date_For_Menu, 0, GLB_number_Of_Oscillograph_For_Display_On_LCD, 28, GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu) != 1U);
			}
			break;
			case FP_CPU____TL_Date_For_Menu:{
				while(CPU____QTL____ADD_ITEM(FP_CPU____TL_Date_For_Menu, 0, GLB_TL__Num_Of_TLs_For_Display_On_LCD, 28, GLB__SDRM_START_BYTE____TL_DateTime____For_Menu) != 1U);
			}
			break;
			case FP_CPU____TL_Osc_Date_For_Menu__Get__Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu:{
				GLB__TLOsc_Date_For_Menu__Adr_Of_RAM_Last_TLOsc_Enter_For_Disp_On_Menu[0]=GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu;
				GLB__TLOsc_Date_For_Menu__Adr_Of_RAM_Last_TLOsc_Enter_For_Disp_On_Menu[1]=TL___Adr_Of_Last_TLs_Name;
				while(CPU____QTL____ADD_ITEM(FP_CPU____TL_Osc_Date_For_Menu__Get__Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu, 0, 2, 4, (uint32_t) &GLB__TLOsc_Date_For_Menu__Adr_Of_RAM_Last_TLOsc_Enter_For_Disp_On_Menu[0]) != 1U);
			}
			break;
			case FP_CPU____Pasword:{
				GLB_Password_For_Parameter_Set[0]=GLB_New_Password_Entered_By_User[0];
				GLB_Password_For_Parameter_Set[1]=GLB_New_Password_Entered_By_User[1];
				
				Var_Init__Write_Password();
			}
			break;
			case FP_CPU____Serial____FP_TO_CPU:{
				while(CPU____QRL[CPU____QRL____FRONT____COUNTER].SIZE != 0U){
//					while (!LL_USART_IsActiveFlag_TXE(UART5)); /* Wait for TXE flag to be raised */
//					LL_USART_TransmitData8(UART5, (uint8_t)SDRAM____SERIAL____FP_TO_CPU____BUFFER[CPU____QRL____SERIAL____FRONT____COUNTER]);
//					while (!LL_USART_IsActiveFlag_TC(UART5)); /* Wait for TC flag to be raised for last char */
					
					CPU____QRL____SERIAL____FRONT____COUNTER = (CPU____QRL____SERIAL____FRONT____COUNTER + 1U) % CPU____QRL____SERIAL____MAX_CAPACITY;
					CPU____QRL[CPU____QRL____FRONT____COUNTER].SIZE -= 1U;
					CPU____QRL____SERIAL____SIZE -= 1U;
				}
				
				if(CPU____QRL____SERIAL____SIZE == 0U){
					CPU____QRL____SERIAL____REAR____COUNTER = 0U;
					CPU____QRL____SERIAL____FRONT____COUNTER = 0U;
				}
			}
			break;
			case FP_CPU____Ethernet____FP_TO_CPU:{				
				GLB_Main__Reciv_Len = CPU____QRL[CPU____QRL____FRONT____COUNTER].SIZE;
				
				while(CPU____QRL[CPU____QRL____FRONT____COUNTER].SIZE != 0U){
					Connection____Recieve_Packet[i] = SDRAM____ETHERNET____FP_TO_CPU____BUFFER[CPU____QRL____ETHERNET____FRONT____COUNTER];	
					
					CPU____QRL____ETHERNET____FRONT____COUNTER = (CPU____QRL____ETHERNET____FRONT____COUNTER + 1U) % CPU____QRL____ETHERNET____MAX_CAPACITY;
					CPU____QRL[CPU____QRL____FRONT____COUNTER].SIZE -= 1U;
					CPU____QRL____ETHERNET____SIZE -= 1U;
					i+=1U;
				}
				
				if(CPU____QRL____ETHERNET____SIZE == 0U){
					CPU____QRL____ETHERNET____REAR____COUNTER = 0U;
					CPU____QRL____ETHERNET____FRONT____COUNTER = 0U;
				}
					
				FP_ETHERNET_Recive_Ready = 1U;
			}
			break;
			case FP_CPU____Menu____Refresh:{
				k=0;
				MHA_Adr = SDRAM____Menu____MHA_Adr[k];
				while(MHA_Adr != 0x7FFFFFFF){
					if(MHA_Adr!=-1){
						switch(MHA[MHA_Adr]){
							case PatternModel_0:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_0____Index_Of____Value];
								SDRAM____Menu____MHA_VAL[2*k +1] =1;
							break;
							case PatternModel_1:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_1____First_Index____FFT + 2];
								SDRAM____Menu____MHA_VAL[2*k+1] = MHA[MHA_Adr + PatternModel_1____Index_Of____AmpDivider];
							break;
							case PatternModel_2:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_2____First_Index_For____Insert_FFT_in_MHA + 2];
								SDRAM____Menu____MHA_VAL[2*k+1] = MHA[MHA_Adr + PatternModel_2____Index_Of____AmpDivider];
							break;
							case PatternModel_3:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_3____Index_Of____Value];
								SDRAM____Menu____MHA_VAL[2*k+1] = MHA[MHA_Adr + PatternModel_3____Index_Of____Divider];
							break;
							case PatternModel_4:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_4____Index_Of____Value];
								SDRAM____Menu____MHA_VAL[2*k+1] = 1;
							break;
							case PatternModel_5:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_5____Index_Of____Value];
								SDRAM____Menu____MHA_VAL[2*k+1] = MHA[MHA_Adr + PatternModel_5____Index_Of____Divider];
							break;
							case PatternModel_6:
								SDRAM____Menu____MHA_VAL[2*k] = MHA[MHA_Adr + PatternModel_6____Index_Of____Value];
								SDRAM____Menu____MHA_VAL[2*k+1] = 1;
							break;
						}
					}
					k++;
					MHA_Adr = SDRAM____Menu____MHA_Adr[k];
				}
				while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____Refresh,	0, 2*k,	4, GLB__SDRM_START_BYTE____Menu____MHA_VAL) != 1U);
			}
			break;
			case(FP_CPU____Get__Setting_Current_Val_From_CPU):{
				switch(MHA[Methods_MHA_Adr]){
					case PatternModel_5:
						Methods_Current_Value = *(MHA + Methods_MHA_Adr + PatternModel_5____Index_Of____Value);
					break;
					case PatternModel_6:
						Methods_Current_Value = *(MHA + Methods_MHA_Adr + PatternModel_6____Index_Of____Value);
					break;
				}				
				while(CPU____QTL____ADD_ITEM(FP_CPU____Get__Setting_Current_Val_From_CPU,	0, 1,	4, (uint32_t)&Methods_Current_Value) != 1U);
			}
			break;
			case(FP_CPU____Save_Setting_On_CPU_uSD):{
				switch(MHA[Setting___MHA_Adr___Value[0]]){
					case PatternModel_5:
						*(MHA + Setting___MHA_Adr___Value[0] + PatternModel_5____Index_Of____Value) = Setting___MHA_Adr___Value[1];
					break;
					case PatternModel_6:
						*(MHA + Setting___MHA_Adr___Value[0] + PatternModel_6____Index_Of____Value) = Setting___MHA_Adr___Value[1];
					break;
				}
				i=0;
				while(SDRAM____Settings_Index_In_MHASettArray[3*i] != Setting___MHA_Adr___Value[0])
					i++;
				
				read_from_MMC(SDRAM____4_Block_MMC, GLB__MHA_SETTING____MMC____FST_BLK____CPU + 4*SDRAM____Settings_Index_In_MHASettArray[3*i+1], 4);
				*(uint32_t*)(SDRAM____4_Block_MMC + SDRAM____Settings_Index_In_MHASettArray[3*i+2]) = Setting___MHA_Adr___Value[1];
				Write_to_MMC(SDRAM____4_Block_MMC, GLB__MHA_SETTING____MMC____FST_BLK____CPU + 4*SDRAM____Settings_Index_In_MHASettArray[3*i+1], 4);
			}
			break;
		}
//			sprintf((char *)RAM_UART_BUFF,"CPU:E: P%d:%lld\n",CPU____QRL[i].ID,GLB_Counter_Samples_Total_New); Panel_Komaki_UARTX_For_Sprintf();
			
//			LED_ALARM_LABLE_2_OFF;
		CPU____QRL____FRONT____COUNTER = (CPU____QRL____FRONT____COUNTER + 1U) % CPU____QRL____MAX_CAPACITY;
		CPU____QRL____SIZE -= 1U;
	}
	else{
		CPU____QRL____REAR____COUNTER = 0U;
		CPU____QRL____FRONT____COUNTER = 0U;
	}
//GLB_TEMP=0;
//}
}
int32_t CPU____QTL____ADD_ITEM(uint16_t ID, uint32_t START_INDEX, uint32_t SIZE, uint8_t Array_Unit_Size, uint32_t MEM_START_ADDR){
//	CPU____QTL____ADD_ITEM(Setting_Mat, 0, 200, 4, GLB__SDRM_START_BYTE____Setting_MatrixA); 																//setting 0 jh 200
//	CPU____QTL____ADD_ITEM(OSC_Mat, 0, (GLB_Number_Of_Total_Signal_Of_Input_Output-2), 4, GLB_Osc_start_byte_For_Osc_Setting_Matrix);	//OSC_Mat kamel send shavad
//CPU____QTL____ADD_ITEM(EL_Mat, 0*5, (GLB_Number_Of_Total_Signal_Of_Input_Output-2)*5, 1, GLB_EL_start_byte_For_EL_Setting_Matr);		//TL_Mat kamel send shavad
//CPU____QTL____ADD_ITEM(TL_Mat, 0*5, (GLB_Number_Of_Total_Signal_Of_Input_Output-2)*5, 1, GLB_TL_start_byte_For_TL_Setting_Matr);		//EL_Mat kamel send shavad
//CPU____QTL____ADD_ITEM(INPUT_Mat, 4*2, 10*2, 4, (uint32_t) &GLB_Inputs_Assigned_Signals_Matrix[0][0]);										//field 4 ta 14 
//CPU____QTL____ADD_ITEM(INPUT_Mat, 20*2, 40*2, 4, (uint32_t) &GLB_Inputs_Assigned_Signals_Matrix[0][0]);										//field 20 ta 60 
//CPU____QTL____ADD_ITEM(OUTPUT_Mat, 30*2, 40*2, 4, (uint32_t) &GLB_Outputs_Assigned_Signals_Matrix[0][0]);									//field 30 ta 70 
//CPU____QTL____ADD_ITEM(LED_Mat, 15*2, 20*2, 4, (uint32_t) &GLB_LEDs_Assigned_Signals_Matrix[0][0]);											//field 15 ta 35 
	
	if(CPU____QTL____SIZE == CPU____QTL____MAX_CAPACITY){
		return -1;
	}
	
	CPU____QTL[CPU____QTL____REAR____COUNTER].ID = ID;
	CPU____QTL[CPU____QTL____REAR____COUNTER].START_INDEX = Array_Unit_Size * START_INDEX;
	CPU____QTL[CPU____QTL____REAR____COUNTER].SIZE = Array_Unit_Size * SIZE;
	CPU____QTL[CPU____QTL____REAR____COUNTER].MEM_START_ADDR = MEM_START_ADDR + Array_Unit_Size * START_INDEX;
	
	CPU____QTL____REAR____COUNTER = (CPU____QTL____REAR____COUNTER + 1U) % CPU____QTL____MAX_CAPACITY;
	CPU____QTL____SIZE += 1U;
	
	return 1;
}

int32_t CPU____QRL____ADD_ITEM(uint16_t ID, uint32_t START_INDEX, uint32_t SIZE){
//	uint32_t i=0;
	
	
	if(CPU____QRL____SIZE == CPU____QRL____MAX_CAPACITY){
		return -1;
	}
	
	CPU____QRL[CPU____QRL____REAR____COUNTER].ID = ID;
	CPU____QRL[CPU____QRL____REAR____COUNTER].START_INDEX = START_INDEX;
	CPU____QRL[CPU____QRL____REAR____COUNTER].SIZE = SIZE;
	
	CPU____QRL____REAR____COUNTER = (CPU____QRL____REAR____COUNTER + 1U) % CPU____QRL____MAX_CAPACITY;
	CPU____QRL____SIZE += 1U;
	
	return 1;
	
	
//	for(i=0;i<CPU____QTL____MAX_CAPACITY; i++){
//		if(CPU____QRL[i].ID==0U){
//			CPU____QRL[i].ID = ID;
//			CPU____QRL[i].START_INDEX = START_INDEX;
//			CPU____QRL[i].SIZE = SIZE;
//			break;
//		}
//	}
}
void 		CPU____QRL____RECIEVE(uint32_t *ByteCounter_Rx){
	uint16_t Download_Packet_Size_in_Byte=0U;
	uint32_t i=0U, j=0U;
	uint16_t *pData;
	
	/* 
		[START] 
		[TOTAL_SIZE] 
		[CURRENT_PACKET_NUMBER] 
		[DOWNLOAD_SIZE] 
		[ID] 
		[START_INDEX] 
		[DATA] 
	*/
	
	// [START] 
	if(SPI2_Rx_BUFFER[(*ByteCounter_Rx)] == CMD____TRANSFER_START){
		(*ByteCounter_Rx)+=1U;
		
		// [TOTAL_SIZE] 
		Recieve_SIZE = SPI2_Rx_BUFFER[(*ByteCounter_Rx)]; (*ByteCounter_Rx)+=1U;
		
		// [CURRENT_PACKET_NUMBER] 
		Packet_Byte_Counter_for_Recieve_by_SPI = SPI2_Rx_BUFFER[(*ByteCounter_Rx)]; (*ByteCounter_Rx)+=1U;
		
		// [DOWNLOAD_SIZE] 
		Download_Packet_Size_in_Byte  = SPI2_Rx_BUFFER[(*ByteCounter_Rx)];	(*ByteCounter_Rx)+=1U;
		
		// [ID]
		Recieve_ID = SPI2_Rx_BUFFER[(*ByteCounter_Rx)];	(*ByteCounter_Rx)+=1U;
		
		// [START_INDEX] 
		Recieve_START_INDEX = SPI2_Rx_BUFFER[(*ByteCounter_Rx)];	(*ByteCounter_Rx)+=1U;

		switch(Recieve_ID){
			case(FP_CPU____Save_Setting_On_CPU_uSD):
				pData = (uint16_t *)((uint32_t) &Setting___MHA_Adr___Value + Recieve_START_INDEX);
			break;
			case(FP_CPU____Menu____Refresh): 
				pData = (uint16_t *)(GLB__SDRM_START_BYTE____Menu____MHA_Adr + Recieve_START_INDEX);
			break;
			case(FP_CPU____Get__Setting_Current_Val_From_CPU):
				pData = (uint16_t *)((uint32_t) &Methods_MHA_Adr + Recieve_START_INDEX);
			break;
			case(FP_CPU____Setting_Mat):
				//pData = (uint16_t *)(GLB__SDRM_START_BYTE_____Active_Setting_Group + Recieve_START_INDEX);
			break;
			case(FP_CPU____OSC_Mat):
//				pData = (uint16_t *)((uint32_t) &RAM_Osc_Setting_Matrix[0] + Recieve_START_INDEX);
			break;
			case(FP_CPU____EL_Mat):
//				pData = (uint16_t *)((uint32_t) &RAM_EL_Setting_Matrix[0] + Recieve_START_INDEX);
			break;
			case(FP_CPU____TL_Mat):
//				pData = (uint16_t *)((uint32_t) &RAM_TL_Setting_Matrix[0] + Recieve_START_INDEX);
			break;
			case(FP_CPU____INPUT_Mat):
//				pData = (uint16_t *)((uint32_t) &GLB_Inputs_Assigned_Signals_Matrix[0][0] + Recieve_START_INDEX);
			break;
			case(FP_CPU____OUTPUT_Mat):
//				pData = (uint16_t *)( (uint32_t) &GLB_Outputs_Assigned_Signals_Matrix[0][0] + Recieve_START_INDEX);
			break;
			case(FP_CPU____LED_Mat):
//				pData = (uint16_t *)( (uint32_t) &GLB_LEDs_Assigned_Signals_Matrix[0][0] + Recieve_START_INDEX);
			break;
			case(FP_CPU____FP_Ready):
//					FP_Is_Ready=Yes_1;
			break;
			case(FP_CPU____Measurement__Fundumental):
			case(FP_CPU____Measurement__Symetric):
			case(FP_CPU____Measurement__H2):
			case(FP_CPU____Measurement__VLL):
				pData = (uint16_t *)( (uint32_t) &Measure_Request_From_FP + Recieve_START_INDEX);
			break;
			case(FP_CPU____Disp_Record__TL):
				pData = (uint16_t *)( (uint32_t) &TL_Osc_Record_Request_From_FP + Recieve_START_INDEX);
			break;
			case(FP_CPU____Disp_Record__Osc):
				pData = (uint16_t *)( (uint32_t) &Osc__Load_From_CPU + Recieve_START_INDEX);
			break;
			case(FP_CPU____FORMAT_RECORDs):
				pData = (uint16_t *)( (uint32_t) &GLB__FORMAT_RECORDs__EL_0__TL_1__OSC_2 + Recieve_START_INDEX);
			break;
			case(FP_CPU____IP):
				pData = (uint16_t *)( (uint32_t) &(ReadMyCfg.IPConfig[0]) + Recieve_START_INDEX);
			break;
			case(FP_CPU____PORT):
				pData = (uint16_t *)( (uint32_t) &(ReadMyCfg.Port) + Recieve_START_INDEX);
			break;
			case(FP_CPU____SERIAL):
				pData = (uint16_t *)( (uint32_t) &(ReadMyCfg.Serial) + Recieve_START_INDEX);
			break;
			case(FP_CPU____DATE_TIME__Set):
				pData = (uint16_t *)( (uint32_t) &(DATE_AND_TIME__SET[0]) + Recieve_START_INDEX);
			break;
			case(FP_CPU____Pasword):
				pData = (uint16_t *)( (uint32_t) &(GLB_New_Password_Entered_By_User) + Recieve_START_INDEX);
			break;
			case(FP_CPU____CMTRD____Keypad_Triger):
				pData = (uint16_t *)( (uint32_t) &(CMTRD____Keypad_Triger_Start) + Recieve_START_INDEX);
			break;
			case FP_CPU____Serial____FP_TO_CPU:{
				pData = (uint16_t *)( (uint32_t) &SDRAM____SERIAL____FP_TO_CPU____BUFFER[CPU____QRL____SERIAL____REAR____COUNTER]);
				
				CPU____QRL____SERIAL____REAR____COUNTER = (CPU____QRL____SERIAL____REAR____COUNTER + Download_Packet_Size_in_Byte) % CPU____QRL____SERIAL____MAX_CAPACITY;
				CPU____QRL____SERIAL____SIZE += Download_Packet_Size_in_Byte;
			}
			break;
			case FP_CPU____Ethernet____FP_TO_CPU:{
				pData = (uint16_t *)( (uint32_t) &SDRAM____ETHERNET____FP_TO_CPU____BUFFER[CPU____QRL____ETHERNET____REAR____COUNTER]);
				
				CPU____QRL____ETHERNET____REAR____COUNTER = (CPU____QRL____ETHERNET____REAR____COUNTER + Download_Packet_Size_in_Byte) % CPU____QRL____ETHERNET____MAX_CAPACITY;
				CPU____QRL____ETHERNET____SIZE += Download_Packet_Size_in_Byte;
			}
			break;
		}
		
		// [DATA]
		for(i=0; i<Download_Packet_Size_in_Byte/2U; i++){
			pData[Packet_Byte_Counter_for_Recieve_by_SPI] = SPI2_Rx_BUFFER[(*ByteCounter_Rx)] ;
			Packet_Byte_Counter_for_Recieve_by_SPI+=1U;
			(*ByteCounter_Rx)+=1U;
		}
		
		if(Packet_Byte_Counter_for_Recieve_by_SPI*2U >= Recieve_SIZE){
			New_Packet_Data_Recieved=1U;
		}
	}
	else if(SPI2_Rx_BUFFER[(*ByteCounter_Rx)] == CMD____TRANSFER_FINISH){
		if(New_Packet_Data_Recieved==1U){
			// Record Changes
			New_Packet_Data_Recieved=0U;
			CPU____QRL____ADD_ITEM(Recieve_ID, Recieve_START_INDEX, Recieve_SIZE);
		}
		else{
			// corrupt
		}
		Recieve_ID=0U;
		Packet_Byte_Counter_for_Recieve_by_SPI=0U;
		Recieve_START_INDEX=0U;
		Recieve_SIZE=0U;
	}
	else if(SPI2_Rx_BUFFER[(*ByteCounter_Rx)] == CMD____START_OVER){
	}
}

void 		CPU____QTL____TRANSMIT(uint32_t *ByteCounter_Tx){
	uint16_t Upload_Packet_Size_in_Byte=0U;
	uint32_t i=0U, j=0U;
	uint16_t *pData;
	
	/* 
		[START] 
		[TOTAL_SIZE] 
		[CURRENT_PACKET_NUMBER] 
		[UPLOAD_SIZE] 
		[ID] 
		[START_INDEX] 
		[DATA] 
	*/
	
	if(CPU____QTL____0_READY____1_BUSY == 0U){
		if(CPU____QTL____SIZE != 0){
			CPU____QTL____ROW_INDEX_INUSE   = CPU____QTL____FRONT____COUNTER;
			
			CPU____QTL____ID 								= CPU____QTL[CPU____QTL____FRONT____COUNTER].ID;
			CPU____QTL____START_INDEX 			= CPU____QTL[CPU____QTL____FRONT____COUNTER].START_INDEX;
			CPU____QTL____DATA_SIZE 				= CPU____QTL[CPU____QTL____FRONT____COUNTER].SIZE;
			CPU____QTL____MEM_ADDR 					= CPU____QTL[CPU____QTL____FRONT____COUNTER].MEM_START_ADDR;
						
			CPU____QTL____FRONT____COUNTER = (CPU____QTL____FRONT____COUNTER + 1U) % CPU____QTL____MAX_CAPACITY;
			
			CPU____QTL____SIZE -= 1U;
			
			CPU____QTL____0_READY____1_BUSY = 1U;
		}
		else{
			CPU____QTL____REAR____COUNTER = 0U;
			CPU____QTL____FRONT____COUNTER = 0U;
			CPU____QTL____ID = 0U;
		}
	}
	if(CPU____QTL____ID!=0U){
		if(CPU____QTL____SPI_BYTE_COUNTER*2U < CPU____QTL____DATA_SIZE){
		
			// [START] 
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = CMD____TRANSFER_START;	(*ByteCounter_Tx)+=1U;
			
			// [TOTAL_SIZE] 
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = CPU____QTL____DATA_SIZE;	(*ByteCounter_Tx)+=1U;
			
			// [CURRENT_PACKET_NUMBER] 
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = CPU____QTL____SPI_BYTE_COUNTER;	(*ByteCounter_Tx)+=1U;
			
			// [UPLOAD_SIZE] 
			Upload_Packet_Size_in_Byte = ((CPU____QTL____DATA_SIZE-CPU____QTL____SPI_BYTE_COUNTER*2U) / Max_Size_of_Packet_Data_in_Byte > 0)? Max_Size_of_Packet_Data_in_Byte :((CPU____QTL____DATA_SIZE-CPU____QTL____SPI_BYTE_COUNTER*2U)%Max_Size_of_Packet_Data_in_Byte);
			Upload_Packet_Size_in_Byte = (Upload_Packet_Size_in_Byte%2==0)?Upload_Packet_Size_in_Byte:(Upload_Packet_Size_in_Byte+1);
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = Upload_Packet_Size_in_Byte;	(*ByteCounter_Tx)+=1U;
			
			// [ID]
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = CPU____QTL____ID;					(*ByteCounter_Tx)+=1U;
			
			// [START_INDEX] 
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = CPU____QTL____START_INDEX;		(*ByteCounter_Tx)+=1U;
			
			// [DATA]
			pData = (uint16_t *)(CPU____QTL____MEM_ADDR);
			for(j=0U; j<Upload_Packet_Size_in_Byte/2U; j++){
				SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = pData[CPU____QTL____SPI_BYTE_COUNTER];	(*ByteCounter_Tx)+=1U;
				CPU____QTL____SPI_BYTE_COUNTER+=1U;
			}
		}
		else{
			SPI2_Tx_BUFFER[(*ByteCounter_Tx)] = CMD____TRANSFER_FINISH;	(*ByteCounter_Tx)+=1U;

			CPU____QTL____SPI_BYTE_COUNTER=0U;
			CPU____QTL____0_READY____1_BUSY=0U;
			CPU____QTL____MEM_ADDR=0U;
			CPU____QTL____ID=0U;
			CPU____QTL____START_INDEX=0U;
			CPU____QTL____DATA_SIZE=0U;
			CPU____QTL[CPU____QTL____ROW_INDEX_INUSE].ID=0U;
			CPU____QTL____ROW_INDEX_INUSE=0U;
		}
	}
	else{
		for(i=(*ByteCounter_Tx); i<(*ByteCounter_Tx)+5U; i++){
			SPI2_Tx_BUFFER[i] = CMD____DUMMY;
		}
	}

}
#endif
#if(1) // Variable Init
void Var_Init__Write_Password(void){
	*((uint32_t*) (SDRAM____1_Block_MMC   )) = My_INF;
	*((uint32_t*) (SDRAM____1_Block_MMC+ 4)) = My_INF-1;
	*((uint32_t*) (SDRAM____1_Block_MMC+ 8)) = GLB_Password_For_Parameter_Set[0];
	*((uint32_t*) (SDRAM____1_Block_MMC+ 12))= GLB_Password_For_Parameter_Set[1];
	Write_to_MMC(SDRAM____1_Block_MMC, GLB_Password____MMC____BLK_NUM____Adr_For_Save_Pass__CPU, 1);
}
void Var_Init__Menu_Data____Read_From_uSD(void){
	int32_t  i=0, BLK_INDEX=0, j, Byte_Index=0;
	//----------S: Read Menu____Line_Address_Array on uSD ----------
	read_from_MMC((char*)SDRAM____Menu____Line_Address_Array, GLB__Menu____Line_Address____MMC____FST_BLK____CPU, 4); 
	Menu____Line_Address_Array___Size = *(uint32_t*)(SDRAM____Menu____Line_Address_Array); 
	for(BLK_INDEX=1; BLK_INDEX<Menu____Line_Address_Array___Size/2048+1; BLK_INDEX++)
		read_from_MMC((char*)SDRAM____Menu____Line_Address_Array+2048*BLK_INDEX, GLB__Menu____Line_Address____MMC____FST_BLK____CPU+ 4*BLK_INDEX, 4); 	
	//----------E: Read Menu____Line_Address_Array on uSD ----------
	//----------S: Read Menu____Display_Array on uSD ----------
	read_from_MMC((char*)SDRAM____Menu____Disp_Array, GLB__Menu____Display_Array____MMC____FST_BLK____CPU, 4);
	Menu____Disp_Array___Size = *(uint32_t*)(SDRAM____Menu____Disp_Array); 
	for(BLK_INDEX=1; BLK_INDEX<Menu____Disp_Array___Size/2048+1; BLK_INDEX++)
		read_from_MMC((char*)SDRAM____Menu____Disp_Array+2048*BLK_INDEX, GLB__Menu____Display_Array____MMC____FST_BLK____CPU+ 4*BLK_INDEX, 4); 	
	//----------E: Read Menu____Display_Array on uSD ----------
	//----------S: Read Menu____String_Array on uSD ----------
	read_from_MMC((char*)SDRAM____Menu____String_Array, GLB__Menu____String_Array____MMC____FST_BLK____CPU, 4);
	Menu____String_Array___Size = *(uint32_t*)(SDRAM____Menu____String_Array); 
	for(BLK_INDEX=1; BLK_INDEX<Menu____String_Array___Size/2048+1; BLK_INDEX++)
		read_from_MMC((char*)SDRAM____Menu____String_Array+2048*BLK_INDEX, GLB__Menu____String_Array____MMC____FST_BLK____CPU+ 4*BLK_INDEX,4); 	
	//----------E: Read Menu____String_Array on uSD ----------
	//----------S: Read Menu____Method_ComboBox on uSD ----------
	read_from_MMC((char*)SDRAM____Menu____Method_ComboBox, GLB__Menu____Method_ComboBox____MMC____FST_BLK____CPU, 4);
	Menu____Method_ComboBox___Size = *(uint32_t*)(SDRAM____Menu____Method_ComboBox); 
	for(BLK_INDEX=1; BLK_INDEX<Menu____Method_ComboBox___Size/2048+1; BLK_INDEX++)
		read_from_MMC((char*)SDRAM____Menu____Method_ComboBox+2048*BLK_INDEX, GLB__Menu____Method_ComboBox____MMC____FST_BLK____CPU+ 4*BLK_INDEX,4); 	
	//----------E: Read Menu____Method_ComboBox on uSD ----------
	//----------S: Read Menu____Method_Range on uSD ----------
	read_from_MMC((char*)SDRAM____Menu____Method_Range, GLB__Menu____Method_Range____MMC____FST_BLK____CPU, 4);
	Menu____Method_Range___Size = *(uint32_t*)(SDRAM____Menu____Method_Range); 
	for(BLK_INDEX=1; BLK_INDEX<Menu____Method_Range___Size/2048+1; BLK_INDEX++)
		read_from_MMC((char*)SDRAM____Menu____Method_Range+2048*BLK_INDEX, GLB__Menu____Method_Range____MMC____FST_BLK____CPU+ 4*BLK_INDEX,4); 	
	//----------E: Read Menu____Method_Range on uSD ----------
}
void Var_Init__Menu_Data____Write_On_uSD(void){
	int32_t i;
	
	for(i=0; i<Menu____Line_Address_Array___Size/2048+1; i++)
		Write_to_MMC((char*)SDRAM____Menu____Line_Address_Array +2048*i, GLB__Menu____Line_Address____MMC____FST_BLK____CPU+ 4*i,4); 
	
	for(i=0; i<Menu____Disp_Array___Size/2048+1; i++)
		Write_to_MMC((char*)SDRAM____Menu____Disp_Array +2048*i, GLB__Menu____Display_Array____MMC____FST_BLK____CPU+ 4*i,4); 
	
	for(i=0; i<Menu____String_Array___Size/2048+1; i++)
		Write_to_MMC(SDRAM____Menu____String_Array+2048*i, GLB__Menu____String_Array____MMC____FST_BLK____CPU+ 4*i,4); 

	for(i=0; i<Menu____Method_ComboBox___Size/2048+1; i++)
		Write_to_MMC(SDRAM____Menu____Method_ComboBox+2048*i, GLB__Menu____Method_ComboBox____MMC____FST_BLK____CPU+ 4*i,4); 

	for(i=0; i<Menu____Method_Range___Size/2048+1; i++)
		Write_to_MMC(SDRAM____Menu____Method_Range+2048*i, GLB__Menu____Method_Range____MMC____FST_BLK____CPU+ 4*i,4); 
}
void Var_Init__Menu_Data____Send_to_FP(void){
	SDRAM____Menu____Line_Address_Array[0] = Menu____Line_Address_Array___Size;
	*(uint32_t*)SDRAM____Menu____String_Array = Menu____String_Array___Size;
	SDRAM____Menu____Disp_Array[0] = Menu____Disp_Array___Size;
	SDRAM____Menu____Line_Address_Array[0] = Menu____Line_Address_Array___Size;
	*(uint32_t*)SDRAM____Menu____Method_ComboBox = Menu____Method_ComboBox___Size;
	*(uint32_t*)SDRAM____Menu____Method_Range = Menu____Method_Range___Size;
	
	while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____Line_Address_Array, 0, Menu____Line_Address_Array___Size, 1, GLB__SDRM_START_BYTE____Menu____Line_Address_Array) != 1U);
	while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____String_Array, 0, Menu____String_Array___Size, 1, GLB__SDRM_START_BYTE____Menu____String_Array) != 1U);
	while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____Disp_Array, 0, Menu____Disp_Array___Size, 4, GLB__SDRM_START_BYTE____Menu____Disp_Array) != 1U);
	while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____Method_ComboBox, 0, Menu____Method_ComboBox___Size, 1, GLB__SDRM_START_BYTE____Menu____Method_ComboBox) != 1U);
	while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____Method_Range, 0, Menu____Method_Range___Size, 1, GLB__SDRM_START_BYTE____Menu____Method_Range) != 1U);
	while(CPU____QTL____ADD_ITEM(FP_CPU____Menu____FINISH, 0, 1, 1, GLB__SDRM_START_BYTE____Menu____Disp_Array) != 1U);
}
void Var_Init__Find_Sett_Index_In_MHA_Setting(void){
	int32_t  Type=1, i=0;
	int32_t  *VMA_PNT = VMA;
	
	VMA___Start_Index_Of_ActiveSettGrp = 0;
	VMA_PNT___End_PNT_Of_ActiveSettGrp = VMA + VMA_Size;
	VMA_PNT_Old = 0;
	Setting_Index = 0;
	MHA_Setting_Index = 0;
	VMA_Index_1 = 0;
	
	CFC__While(VMA_PNT, 4);
}
int32_t Var_Init__Calculate_Operating_Resetting_Time(int32_t Nesbate_Jaryan_Be_Jaryane_Tanzimi, int32_t Trip_Or_Reset){
	int32_t  First, End, n=0, Result=0, Part2=0;
	int32_t  First_Point;
	int32_t  End_Point;
	int32_t  zarib; 
	int8_t   H=0;
	int32_t  Delta_t_Between_Two_Point;	
	
	if(GLB_Curve_Number<OC_User_Def){
		if(GLB_Curve_Number==IEC_Norm_Inverse) { // normal inverse
			if(Trip_Or_Reset==1){
				First_Point=0;
				End_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[0];
			}
			else{
				First_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[0]+1;
				End_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[1];
			}
		}
		else {
			if(Trip_Or_Reset==1){
				First_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[2*GLB_Curve_Number-1]+1;
				End_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[2*GLB_Curve_Number];
			}
			else{
				First_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[2*GLB_Curve_Number]+1;
				End_Point=GLB_Trip_Reset_Curves_Firs_And_End_Points[2*GLB_Curve_Number+1];
			}
		}
		First=First_Point;
		End=End_Point;
		
		if(Nesbate_Jaryan_Be_Jaryane_Tanzimi>GLB_IEC_ANSI_Curve_Table[First_Point][0])
			End=First_Point;	
		else if(Nesbate_Jaryan_Be_Jaryane_Tanzimi<GLB_IEC_ANSI_Curve_Table[End_Point][0])
			End=End_Point;
		else{
			while(End!=First+1){
				n=(First+End)/2;
				if(Nesbate_Jaryan_Be_Jaryane_Tanzimi<GLB_IEC_ANSI_Curve_Table[n][0])
					First=n;
				else if(Nesbate_Jaryan_Be_Jaryane_Tanzimi>GLB_IEC_ANSI_Curve_Table[n][0])
					End=n;
				else{
					End=n;
					break;
				}
			}
		}
		if((GLB_IEC_ANSI_Curve_Table[End-1][1]-GLB_IEC_ANSI_Curve_Table[End][1])> My_INF/(Nesbate_Jaryan_Be_Jaryane_Tanzimi-GLB_IEC_ANSI_Curve_Table[End][0])){
			zarib=My_INF/(GLB_IEC_ANSI_Curve_Table[End-1][1]-GLB_IEC_ANSI_Curve_Table[End][1]);
			return (GLB_IEC_ANSI_Curve_Table[End][1]+(GLB_IEC_ANSI_Curve_Table[End-1][1]-GLB_IEC_ANSI_Curve_Table[End][1])*zarib/(GLB_IEC_ANSI_Curve_Table[End-1][0]-GLB_IEC_ANSI_Curve_Table[End][0])*(Nesbate_Jaryan_Be_Jaryane_Tanzimi-GLB_IEC_ANSI_Curve_Table[End][0])/zarib);
		}
		else
			return (GLB_IEC_ANSI_Curve_Table[End][1]+(GLB_IEC_ANSI_Curve_Table[End-1][1]-GLB_IEC_ANSI_Curve_Table[End][1])*(Nesbate_Jaryan_Be_Jaryane_Tanzimi-GLB_IEC_ANSI_Curve_Table[End][0])/(GLB_IEC_ANSI_Curve_Table[End-1][0]-GLB_IEC_ANSI_Curve_Table[End][0]));		
	}
	else{
		/*
		//----------S: ????? ???? ----------
		if(Trip_Or_Reset==1){
			if(GLB_Curve_Number==OC_User_Def)
				First_Point=Row____Setting____Current_Setting_Group_A_____50_51_Ph_Gnd_OC____51_user_def__pickup_____point_1____Value_1____184;
			//----------E: 51----------
			//----------S: 51N ???? ?????? ----------
			else if(GLB_Curve_Number==EF_User_Def)
				First_Point=Row____Setting____Current_Setting_Group_A_____50_51_Ph_Gnd_OC____51N_user_def__pickup____point_1____Value_1____288;
			//----------E: 51N ???? ?????? ----------
			//----------S: 67 ???? ?????? ----------
			else if(GLB_Curve_Number==DOC_User_Def)
				First_Point=Row____Setting____Current_Setting_Group_A_____67_Direct__ph_Gnd_OC____67_TOC_user_def__pickup_____point_1____Value_1____406;
			//----------S: 67 ???? ?????? ----------
			//----------S: 67N ???? ?????? ----------
			else
				First_Point=Row____Setting____Current_Setting_Group_A_____67_Direct__ph_Gnd_OC____67N_TOC_user_def__pickup_____point_1____Value_1____503;
			//----------S: 67N ???? ?????? ----------GLB_Number_Of_Points_Is_Enterd_In_This_Row
			End_Point=First_Point+2*GLB_User_Define_Functions_Number_Of_Enterd_Points[GLB_Number_Of_Points_Is_Enterd_In_This_Row];

			First=First_Point;
			End=End_Point;
						

			if(Nesbate_Jaryan_Be_Jaryane_Tanzimi<=(RAM_Setting_Matrix[First_Point]<<20)/100)
				H=1;
			else if(Nesbate_Jaryan_Be_Jaryane_Tanzimi>=(RAM_Setting_Matrix[End_Point]<<20)/100)
				H=2;
			else{
				while(End!=First+2){
					n=(End-First)/2;
					if(((n>>1)<<1)!=n)
						n++;
					n=First+n;
					if(Nesbate_Jaryan_Be_Jaryane_Tanzimi>(RAM_Setting_Matrix[n]<<20)/100)
						First=n;
					else if(Nesbate_Jaryan_Be_Jaryane_Tanzimi<(RAM_Setting_Matrix[n]<<20)/100)
						End=n;
					else{
						End=n;
						break;
					}
				}
			}

			if(H==1)
				return (10*RAM_Setting_Matrix[First_Point+1]);
			else if(H==2)
				return (10*RAM_Setting_Matrix[End_Point+1]);
			else{
				Delta_t_Between_Two_Point=(10*RAM_Setting_Matrix[End+1]-10*RAM_Setting_Matrix[End-1]);
				if(Delta_t_Between_Two_Point<0)
					Delta_t_Between_Two_Point=-Delta_t_Between_Two_Point;
				if(Delta_t_Between_Two_Point > My_INF/((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)){
					zarib=My_INF/(10*RAM_Setting_Matrix[End-1]-10*RAM_Setting_Matrix[End+1]);
					Part2=My_INF/((RAM_Setting_Matrix[End]<<20)/100-(RAM_Setting_Matrix[End-2]<<20)/100);
					if(-Part2<=My_INF/((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)  &&  Part2<=My_INF/((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi) )
						Result=10*RAM_Setting_Matrix[End+1]+ Part2 *((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)/zarib;
					else
						Result=10*RAM_Setting_Matrix[End+1]+ Part2 /zarib * ((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi);
					return Result;
				}
				else{
					Result=10*RAM_Setting_Matrix[End+1]+(10*RAM_Setting_Matrix[End-1]-10*RAM_Setting_Matrix[End+1])*((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)/((RAM_Setting_Matrix[End]<<20)/100-(RAM_Setting_Matrix[End-2]<<20)/100);
					return Result;	
				}
			}
		}
		//----------E: ????? ???? ----------
		//----------S: ????? ???? ----------
		else{
			if(GLB_Curve_Number==OC_User_Def)
				First_Point=Row____Setting____Current_Setting_Group_A_____50_51_Ph_Gnd_OC____51_user_def__pickup_____point_1____Value_1____184+40;
			else if(GLB_Curve_Number==EF_User_Def)
				First_Point=Row____Setting____Current_Setting_Group_A_____50_51_Ph_Gnd_OC____51N_user_def__pickup____point_1____Value_1____288+40;
			else if(GLB_Curve_Number==DOC_User_Def)
				First_Point=Row____Setting____Current_Setting_Group_A_____67_Direct__ph_Gnd_OC____67_TOC_user_def__pickup_____point_1____Value_1____406+40;
			else
				First_Point=Row____Setting____Current_Setting_Group_A_____67_Direct__ph_Gnd_OC____67N_TOC_user_def__pickup_____point_1____Value_1____503+40;

			End_Point=First_Point+2*GLB_User_Define_Functions_Number_Of_Enterd_Points[GLB_Number_Of_Points_Is_Enterd_In_This_Row+1];
			First=First_Point;
			End=End_Point;
			
			if(Nesbate_Jaryan_Be_Jaryane_Tanzimi>=(RAM_Setting_Matrix[First_Point]<<20)/100)
				H=1;
			else if(Nesbate_Jaryan_Be_Jaryane_Tanzimi<=(RAM_Setting_Matrix[End_Point]<<20)/100)
				H=2;
			else{
				while(End!=First+2){
					n=(End-First)/2;
					if(((n>>1)<<1)!=n)
						n++;
					n=First+n;
					if(Nesbate_Jaryan_Be_Jaryane_Tanzimi<(RAM_Setting_Matrix[n]<<20)/100)
						First=n;
					else if(Nesbate_Jaryan_Be_Jaryane_Tanzimi>(RAM_Setting_Matrix[n]<<20)/100)
						End=n;
					else{
						End=n;
						break;
					}
				}
			}

			if(H==1)
				return (10*RAM_Setting_Matrix[First_Point+1]);
			else if(H==2)
				return (10*RAM_Setting_Matrix[End_Point+1]);
			else{
				Delta_t_Between_Two_Point=(10*RAM_Setting_Matrix[End+1]-10*RAM_Setting_Matrix[End-1]);
				if(Delta_t_Between_Two_Point<0)
					Delta_t_Between_Two_Point=-Delta_t_Between_Two_Point;
				if(Delta_t_Between_Two_Point > My_INF/((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)){
					zarib=My_INF/(10*RAM_Setting_Matrix[End-1]-10*RAM_Setting_Matrix[End+1]);
					Part2=-(My_INF/((RAM_Setting_Matrix[End]<<20)/100-(RAM_Setting_Matrix[End-2]<<20)/100));
					if(Part2<=-(My_INF/((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)) )
						Result=10*RAM_Setting_Matrix[End+1]- Part2 *((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)/zarib;
					else
						Result=10*RAM_Setting_Matrix[End+1]- Part2 /zarib * ((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi);
					return Result;
				}
				else{
					Result=10*RAM_Setting_Matrix[End+1]+(10*RAM_Setting_Matrix[End-1]-10*RAM_Setting_Matrix[End+1])*((RAM_Setting_Matrix[End]<<20)/100-Nesbate_Jaryan_Be_Jaryane_Tanzimi)/((RAM_Setting_Matrix[End]<<20)/100-(RAM_Setting_Matrix[End-2]<<20)/100);
					return Result;	
				}
			}
		}
		//----------E: ????? ???? ----------
		*/
	}
}
void Var_Init__WatchDogStatus(int8_t Write_Or_Read, int8_t Status){
	switch(Write_Or_Read){
		case Write:{
			if(Status>1){
				sprintf((char *)RAM_UART_BUFF,"Invalid WatchDog Status(%d)\n", Status);
				T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
				sprintf((char *)RAM_UART_BUFF,"New WatchDog Status Not Set\n");
				T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0);
			}
			else{
				IWDG_FLAG____0_DISABLE____1_ENABLE = Status;
				GLB_mmc_write_buffer[0] = IWDG_FLAG____0_DISABLE____1_ENABLE;
				Write_to_MMC(GLB_mmc_write_buffer, GLB__WatchDogStatus____MMC____FST_BLK____CPU, 4); 
			}
		}
		break;
		case Read:{
			read_from_MMC(GLB_mmc_read_buffer, GLB__WatchDogStatus____MMC____FST_BLK____CPU, 4); 
			if(GLB_mmc_read_buffer[0]>1){
				sprintf((char *)RAM_UART_BUFF,"Invalid WatchDog Status(%d)\n", GLB_mmc_read_buffer[0]);
				T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
				sprintf((char *)RAM_UART_BUFF,"WatchDog Set as Enable\n");
				T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
				IWDG_FLAG____0_DISABLE____1_ENABLE = 1;
			}
			else
				IWDG_FLAG____0_DISABLE____1_ENABLE = GLB_mmc_read_buffer[0];
		}
		break;
	}
}
void Var_Init__Show_Records_On_LCD__Init(void){
	int32_t  i, j;
	int32_t  k, m, n, Address;
	int32_t  Adr_Of_First_Blk_Of_VI_Data_Osc_In_Any_Event;
	int32_t  Addr_For_Save_End_7_Rows_Of_CFG;
	int32_t  Day_Of_Month0;
	int32_t  Month0;
	int32_t  Year0;
	int32_t  Hour0;
	int32_t  Minute0;
	int32_t  Sec0;
	int32_t  Mili_Sec0;			

	//----------S: SDRAM____TLs_Name
	{	
		k = -1;
//		for(i=0; i < GLB_TL_Max_Numb_Of_TL_Can_Save; i++){
//			read_from_MMC(SDRAM____1_Block_MMC, GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + i * GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);
//			if(*(uint32_t*)SDRAM____1_Block_MMC == My_INF){
//				TL___Counter = *(uint32_t*)(SDRAM____1_Block_MMC + 4);
//				TL___Adr_For_Save = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + (i+1) * GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU;
//				if(TL___Adr_For_Save >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU * GLB_TL_Max_Numb_Of_TL_Can_Save)
//					TL___Adr_For_Save = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU;
//				k=0;
//				break;
//			}
//		}

		if(k==-1){
			TL___Has_Any_Log = No_0;
			TL___Adr_For_Save = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU;
			for(m=0;m<GLB_TL__Num_Of_TLs_For_Display_On_LCD;m++){
				*((uint32_t *)(SDRAM____TLs_Name + m*28+ 0 ))=0;
				*((uint32_t *)(SDRAM____TLs_Name + m*28+ 4 ))=0;
				*((uint32_t *)(SDRAM____TLs_Name + m*28+ 8 ))=0;
				*((uint32_t *)(SDRAM____TLs_Name + m*28+ 12))=0;
				*((uint32_t *)(SDRAM____TLs_Name + m*28+ 16))=0;
				*((uint32_t *)(SDRAM____TLs_Name + m*28+ 20))=0;
	// 		*((uint32_t *)(SDRAM____TLs_Name + m*28+ 24))=0;
			}
			TL___Adr_Of_Last_TLs_Name = 0;
		}
		else{
			TL___Has_Any_Log = Yes_1;
			for(m=0; m<GLB_TL__Num_Of_TLs_For_Display_On_LCD; m++){
				
				Address = TL___Adr_For_Save-GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU*(GLB_TL__Num_Of_TLs_For_Display_On_LCD-m);
				if(Address < GLB_TL__MMC____FST_BLK____SAVE_TL____CPU)
					Address = Address + GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU * GLB_TL_Max_Numb_Of_TL_Can_Save;	
				if(Address >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU){
					read_from_MMC(SDRAM____1_Block_MMC, Address, 1);
							
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 0 ))=*(uint16_t *)(SDRAM____1_Block_MMC +8);
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 4 ))=SDRAM____1_Block_MMC[10];
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 8 ))=SDRAM____1_Block_MMC[11];
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 12))=SDRAM____1_Block_MMC[12];
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 16))=SDRAM____1_Block_MMC[13];
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 20))=SDRAM____1_Block_MMC[14];
					*((uint32_t *)(SDRAM____TLs_Name + m*28+ 24))=*(uint16_t *)(SDRAM____1_Block_MMC +15);
				}
				else{
					sprintf((char *)RAM_UART_BUFF,"!!!!! invalid Address =%d\n",  Address); Panel_Komaki_UARTX_For_Sprintf();
				}
			}
			TL___Adr_Of_Last_TLs_Name = 0;
		}
	}
	//----------E: SDRAM____TLs_Name
	//----------S: SDRAM____Array_For_Osc_Date_For_Menu
	{
		k=0;
//		for(i=0;i<GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record;i++){
//			read_from_MMC(SDRAM____1_Block_MMC, GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU+i, 1);
//			if((*(uint32_t*)(SDRAM____1_Block_MMC+5))==My_INF){
//				k=1;
//				GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU+i+1;
//				if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record)
//					GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU;
//				if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
//					read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
//				else
//					read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);
//				GLB_CMTRD____Num_Of_Total_Saved_CMTRD=*((uint32_t*)(SDRAM____1_Block_MMC));
//				break;
//			}
//		}
		GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu=0;
		if(k==0){
			for(m=0;m<GLB_number_Of_Oscillograph_For_Display_On_LCD;m++){
				*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + m*28+ 0 ))=0;
				*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + m*28+ 4 ))=0;
				*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + m*28+ 8 ))=0;
				*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + m*28+ 12))=0;
				*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + m*28+ 16))=0;
				*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + m*28+ 20))=0;
	// 			*((uint32_t *)(SDRAM____TLs_Name + m*28+ 24))=0;
			}
		}
		else{
			for(m=0;m<GLB_number_Of_Oscillograph_For_Display_On_LCD;m++){
				
				if(m<GLB_CMTRD____Num_Of_Total_Saved_CMTRD){
					n=GLB_CMTRD____Num_Of_Total_Saved_CMTRD-m-1;
					if(n<0)
						n+=GLB_Osc____Total_Num_Of_Osc_Can_Record;

					Adr_Of_First_Blk_Of_VI_Data_Osc_In_Any_Event= GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU+ n* GLB_Osc____Total_Num_Of_uSDBlocks___For_Any_Osc+4;
				
					read_from_MMC(SDRAM____4_Block_MMC, Adr_Of_First_Blk_Of_VI_Data_Osc_In_Any_Event-4, 4);											
					Addr_For_Save_End_7_Rows_Of_CFG=	*((int32_t*)(SDRAM____4_Block_MMC+12));
					
						if(Addr_For_Save_End_7_Rows_Of_CFG>15000000)
						Address=1;
					
					read_from_MMC(SDRAM____4_Block_MMC, Addr_For_Save_End_7_Rows_Of_CFG, 4);
					
					Year0=*((uint16_t*)(SDRAM____4_Block_MMC+23));
					Month0=SDRAM____4_Block_MMC[22];
					Day_Of_Month0=SDRAM____4_Block_MMC[21];
					Hour0=SDRAM____4_Block_MMC[25];
					Minute0=SDRAM____4_Block_MMC[26];
					Sec0=SDRAM____4_Block_MMC[27];
					Mili_Sec0=*((uint32_t*)(SDRAM____4_Block_MMC+28));
						
	// 				sprintf((char *)RAM_UART_BUFF,"O_m=%d (%d/%d/%d  %d:%d:%d.%d)\n", (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28, Year0, Month0, Day_Of_Month0, Hour0, Minute0, Sec0, Mili_Sec0) ; Panel_Komaki_UARTX_For_Sprintf();

					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 0 ))=Year0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 4 ))=Month0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 8 ))=Day_Of_Month0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 12))=Hour0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 16))=Minute0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 20))=Sec0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 24))=Mili_Sec0;
				}
				else{
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 0 ))=0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 4 ))=0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 8 ))=0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 12))=0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 16))=0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 20))=0;
					*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + (GLB_number_Of_Oscillograph_For_Display_On_LCD-m-1)*28+ 24))=0;
				}
			}
		}

		GLB_Osc_First_Adr_For_Save_Adr_In_Serialy_Osc=GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD;	
	}
	//----------E: SDRAM____Array_For_Osc_Date_For_Menu
	//----------S: EL Adr For_Save
//	for(i=0; i<EL__MMC____NUM_OF_BLKs____FOR_SAVE_EL; i++){
//		read_from_MMC(SDRAM____1_Block_MMC, EL__MMC____FST_BLK____SAVE_EL__CPU+i, 1);
//		if(*((uint32_t*)(SDRAM____1_Block_MMC)) == EL_Code_For_MMCBLK_That_Is_Filling){
////		GLB_EL_Total_Count=*(uint32_t*)(SDRAM____1_Block_MMC+4);
//			EL__Adr_For_Save = EL__MMC____FST_BLK____SAVE_EL__CPU + i;
//			break;
//		}
//	}
	//----------E: EL Adr For_Save
}
void Var_Init__VFC__HF_VAR____Read_Write_uSD(int8_t Read_0__Write_1, int32_t Info_Count){
	int32_t Info_Index=0, Byte_Index=4, i, BLK_INDEX=0;
	int32_t Index_Of_MMC_Buffer = 24;
	GLB__HF_Vriables__INFO___Size = 0;
	
	switch(Read_0__Write_1){
		case Write:{
			*(int32_t *)(GLB_mmc_write_buffer) = Info_Count;
			for(Info_Index=0; Info_Index < Info_Count; Info_Index++){
				for(i=0; i<VFC____SIGNAL_INFO__Total_Size; i++){
					GLB_mmc_write_buffer[Byte_Index] = SDRAM____HF_Vriables__INFO[Info_Index*VFC____SIGNAL_INFO__Total_Size+i];
					Byte_Index++;
					GLB__HF_Vriables__INFO___Size++;
					if(Byte_Index==2048){
						Write_to_MMC(GLB_mmc_write_buffer, GLB__VFC____HF_VARIABLE_INFO____MMC____FST_BLK____CPU + BLK_INDEX,4);
						BLK_INDEX+=4;
						Byte_Index=0;
					}
				}
			}
			
			if(Byte_Index>0)
				Write_to_MMC(GLB_mmc_write_buffer, GLB__VFC____HF_VARIABLE_INFO____MMC____FST_BLK____CPU + BLK_INDEX,4);
			
			read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____VFC_Data_Has_Written_Flag, 1);
			*(uint32_t*)(SDRAM____1_Block_MMC + Index_Of_MMC_Buffer)=0x7FFFFFFF;
			Write_to_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____VFC_Data_Has_Written_Flag, 1);
			
		}
		break;
		case Read:{
			read_from_MMC(GLB_mmc_read_buffer,GLB__VFC____HF_VARIABLE_INFO____MMC____FST_BLK____CPU + BLK_INDEX,4);
			Info_Count = *(int32_t *)(GLB_mmc_read_buffer);
			for(i=0; i < Info_Count*VFC____SIGNAL_INFO__Total_Size; i++){
				SDRAM____HF_Vriables__INFO[i] = GLB_mmc_read_buffer[Byte_Index];
				Byte_Index++;
				GLB__HF_Vriables__INFO___Size++;
				if(Byte_Index == 2048){
					BLK_INDEX+=4;
					read_from_MMC(GLB_mmc_read_buffer, GLB__VFC____HF_VARIABLE_INFO____MMC____FST_BLK____CPU + BLK_INDEX,4);
					Byte_Index=0;
				}
			}
		}
		break;
	}
	
}
void Var_Init__VFC__Blocks_Settings_Adress_And_Value_In_MHA__Fill(void){
	int32_t i=0;
	//SDRAM____Blocks_Settings_Adress_And_Value_In_MHA[2*i] = 0x7FFFFFFF;
	while(SDRAM____Blocks_Settings_Adress_And_Value_In_MHA[2*i] != 0x7FFFFFFF){
		MHA[SDRAM____Blocks_Settings_Adress_And_Value_In_MHA[2*i]] = SDRAM____Blocks_Settings_Adress_And_Value_In_MHA[2*i+1];
		i++;
	}
	GLB__Blocks_Settings_Adress_And_Value_In_MHA___Size = 2 *i + 1;
}
void Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(int8_t Case, int8_t Read_0__Write_1, int32_t Array_Size){
	int32_t i=0, k=0, BLK_INDEX=0, Adr, TEMP_For_MHA_Setting=0;
	int32_t Index_Of_MMC_Buffer;
	int32_t *Array;
	switch(Case){
		case EN__VMA : 				Adr = GLB__VMA____MMC____FST_BLK____CPU;  							Index_Of_MMC_Buffer = 0;					Array = VMA; 			if(CPU____Initializing == Yes_1 && Calib_Mode == 0) VMA[0] = 0x7FFFFFFF;		break;
		case MHA_SETTING:			Adr = GLB__MHA_SETTING____MMC____FST_BLK____CPU;  			Index_Of_MMC_Buffer = 4;					Array = SDRAM____Blocks_Settings_Adress_And_Value_In_MHA;		break;
		case EN__TRHA:				Adr = GLB__TRHA____MMC____FST_BLK;  										Index_Of_MMC_Buffer = 8;					Array = TRHA;				break;
		case EN__TSHA:				Adr = GLB__TSHA____MMC____FST_BLK;  										Index_Of_MMC_Buffer = 12;					Array = TSHA;				break;
		case EN__TRFA:				Adr = GLB__TRFA____MMC____FST_BLK;  										Index_Of_MMC_Buffer = 16;					Array = TRFA;				break;
		case EN__TSFA:				Adr = GLB__TSFA____MMC____FST_BLK;  										Index_Of_MMC_Buffer = 20;					Array = TSFA;				break;
	}
	switch(Read_0__Write_1){
		case Read:{
			while(1){
				read_from_MMC(SDRAM____4_Block_MMC, Adr + BLK_INDEX,4);
				 
				for(k = 0; k < 2048; k += 4){
					Array[i] = *(int32_t*)(SDRAM____4_Block_MMC+k);

					if(Array[i] == 0x7FFFFFFF){
						Array_Size = i;
						break;
					}
					i++;
				}
				if(Array[i] == 0x7FFFFFFF)
					break;
				BLK_INDEX += 4;
				if(BLK_INDEX > 1000)
					return;
			}
		}
		break;
			
		case Write:{
			for(i = 0; i < Array_Size; i++){
				*(uint32_t*)(GLB_mmc_write_buffer + 4 * k) = Array[i];
				if(k == 511 || Array[i] == 0x7FFFFFFF){
					Write_to_MMC(GLB_mmc_write_buffer, Adr + BLK_INDEX,4);
					if(Array[i] == 0x7FFFFFFF){
						Array_Size = i;
						break;
					}
					BLK_INDEX += 4;
					k = 0;
				}
				else
					k++;
			}
			read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____VFC_Data_Has_Written_Flag, 1);
			*(uint32_t*)(SDRAM____1_Block_MMC + Index_Of_MMC_Buffer) = 0x7FFFFFFF;
			Write_to_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____VFC_Data_Has_Written_Flag, 1);
		}
		break;
	}
	switch(Case){
		case MHA_SETTING:				Var_Init__VFC__Blocks_Settings_Adress_And_Value_In_MHA__Fill(); 	break;
		case EN__VMA:						CPU____VMA____Filled_Size = i; 																		break;
		case EN__TRHA:					TRHA__SIZE = i;																										break;
		case EN__TSHA:					TSHA__SIZE = i;																										break;
		case EN__TRFA:					TRFA__SIZE = i;																										break;
		case EN__TSFA:					TSFA__SIZE = i;																										break;
	}

}
void Var_Init__HW__Read_Write_uSD__init(bool read){
	int32_t  Unit_Index, Card_Index;
	bool     Write_Flag = false;
	
	read_from_MMC(SDRAM____4_Block_MMC, GLB__HW____HWData____MMC____FST_BLK____CPU, 4);
	for(Unit_Index=MP_MASTER; Unit_Index<=MAX_NUM_OF_UNITS; Unit_Index++){
		for(Card_Index = CARD_SLOT_1; Card_Index < NUM_OF_UNIT_CARDS; Card_Index++){
			if(*(uint16_t*)(SDRAM____4_Block_MMC + 2* (Unit_Index * NUM_OF_UNIT_CARDS + Card_Index)) != MP_UNIT[Unit_Index][Card_Index].TYPE){
				if(read){
					sprintf((char *)RAM_UART_BUFF,"Mismatch HW with HW Info on uSD"); 
					T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
					sprintf((char *)RAM_UART_BUFF,"UNIT: %d  CARD: %d", Unit_Index, Card_Index); 
					T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
					VFC_Is_Bypassed = 1;
					VFC_Is_Bypassed__Reason = HW_Mismatch;
					return;
				}
				else{
					*(uint16_t*)(SDRAM____4_Block_MMC + 2* (Unit_Index * NUM_OF_UNIT_CARDS + Card_Index)) = MP_UNIT[Unit_Index][Card_Index].TYPE;
					Write_Flag = true;
				}
			}
		}
	}

	if(Write_Flag)
		Write_to_MMC(SDRAM____4_Block_MMC, GLB__HW____HWData____MMC____FST_BLK____CPU, 4);
}
void Var_Init(void){
	int32_t  i=0, j=0, Unit_Index, Card_Index;
	uint32_t *SDRAM____IEC_ANSI_Trip_Reset_Curve;

	GLB_Integrator_Limit = 5000000*GLB_Number_of_Sample_per_Cycle;
	GLB_Rated_Frequency = 50;
	
	SDRAM____Menu____MHA_Adr[0] = 0x7FFFFFFF;
	
	Var_Init__Menu_Data____Read_From_uSD();
	Var_Init__WatchDogStatus(Read,111);
//Var_Init__Menu_Data____Send_to_FP();


//	Var_Init__Determine_Active_Set_Group();
	//----------S: Check VFC Validation On uSD ----------
	read_from_MMC(SDRAM____1_Block_MMC, MMC____BLK_NUM____VFC_Data_Has_Written_Flag, 1);
	for(i=0; i<6; i++){
		if(*(uint32_t*)(SDRAM____1_Block_MMC + 4*i) != 0x7FFFFFFF){
			VFC_Is_Bypassed=1;
			VFC_Is_Bypassed__Reason = Empty_VFC_Data;
			VFC_Data_Is_Empty = true;
			break;
		}
	}
	//----------E: Check VFC Validation On uSD ----------
	Loading_Percent_Part_1++;
	Loading_Percent = Loading_Percent_Part_1;
	if(Calib_Mode==0){
		//----------S: Password ----------
		read_from_MMC(SDRAM____1_Block_MMC, GLB_Password____MMC____BLK_NUM____Adr_For_Save_Pass__CPU, 1);
		GLB_Password_For_Parameter_Set[1]=6;
		if(*(int32_t *) SDRAM____1_Block_MMC== My_INF && *(int32_t *) (SDRAM____1_Block_MMC+ 4)== My_INF-1)
			GLB_Password_For_Parameter_Set[0]=*(int32_t *) (SDRAM____1_Block_MMC+ 8);
		else{
			GLB_Password_For_Parameter_Set[0]=0;
			Var_Init__Write_Password();
		}
		//----------E: Password ----------
		//----------S: Load VFC Data ----------		
		if(VFC_Is_Bypassed==0){
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__VMA,  Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TRHA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TSHA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TRFA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TSFA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING, Read, 0);
			Var_Init__VFC__HF_VAR____Read_Write_uSD(Read, 0);
			TRFA_And_TSFA_Ready = true;
		}
		//----------E: Load VFC Data ----------
	}
	else{
		//----------S: Load VFC Data ----------
		if(VFC_Is_Bypassed==0){
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__VMA,  Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TRHA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TSHA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TRFA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TSFA, Read, 0);
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING, Read, 0);
			Var_Init__VFC__HF_VAR____Read_Write_uSD(Read, 0);
			
			VMA[CPU____VMA____Filled_Size-2] = 0x7FFFFFFF;
			VMA[CPU____VMA____Filled_Size-1] = 0;
			Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__VMA,  Write, CPU____VMA____Filled_Size);
			TRFA_And_TSFA_Ready = true;
		}
		//----------E: Load VFC Data ----------
	}
	//----------S: Atan ----------
	Loading_Percent_Part_1++;
	Loading_Percent = Loading_Percent_Part_1;
	for(i=0;i<GLB_Number_Of_Row_For_Atan_Array;i++){
		SDRAM____Atan[i]=(int16_t)(atan2((double)i,100.0)*18000.0/3.141592653589793);
//		sprintf((char *)RAM_UART_BUFF,"SDRAM____Atan[%d]=%d\n",i,SDRAM____Atan[i]); Panel_Komaki_UARTX_For_Sprintf();
	}
	//----------E: Atan ----------
	//----------S: tan ----------
	for(i=0;i<900;i++){
		SDRAM____Tanjant[i]=(int32_t)(0.5+1000.0*tan((double)i/10.0*3.141592653589793/180.0));
//		sprintf((char *)RAM_UART_BUFF,"i=%d SDRAM____Atan[i]=%4d\n",i, SDRAM____Atan[i]); Panel_Komaki_UARTX_For_Sprintf();
	}
	//----------E: tan ----------
	//----------S: Sine ----------
	for(i=0;i<360;i++){
		for(j=0;j<100;j++)
			SDRAM____Sine[i*100+j] = (int32_t)((10000*sin(((double)i+(double)j/100.0)*3.141592653589793/180))+0.5);
	}
	//----------E: Sine ----------
	//----------S: Cosfft_Sinfft ----------
	for(i=0;i<GLB_Number_of_Sample_per_Cycle;i++){
		j=(int)(0.5 + 1000.0*cosl(2.0 * (double)(i+1) * 3.14159/(double)GLB_Number_of_Sample_per_Cycle));
		j=(j<0?j-1:j);
		SDRAM____Cosfft_Sinfft[2*i] = j;
// 		sprintf((char *)RAM_UART_BUFF,"%d   %4d  ", i, j); Panel_Komaki_UARTX_For_Sprintf();
		
		j=(int)(0.5+1000.0*sinl(2.0*(double)(i+1)*3.14159/(double)GLB_Number_of_Sample_per_Cycle));
		j=(j<0?j-1:j);
		SDRAM____Cosfft_Sinfft[2*i+1] = -j;
// 		sprintf((char *)RAM_UART_BUFF,"%4d\n", -j); Panel_Komaki_UARTX_For_Sprintf();
	}
	//----------E: Cosfft_Sinfft ----------
	//----------E: IEC ANSI Curves----------
	Loading_Percent_Part_1++;
	Loading_Percent = Loading_Percent_Part_1;
	if(Calib_Mode==0){
		sprintf((char *)RAM_UART_BUFF,"Init Inverse Curves Data...\n"); Panel_Komaki_UARTX_For_Sprintf();	
		for(j=0; j<12; j++){
			GLB_Curve_Number=j;
			switch(j){
				case IEC_Norm_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Trip_Curve____Norm_Inverse  ); break;
				case IEC_Very_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Trip_Curve____Very_Inverse  ); break;
				case IEC_Extr_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Trip_Curve____Extr_Inverse  ); break;
				case IEC_Long_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Trip_Curve____Long_Inverse  ); break;
				case ANSI_Norm_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Norm_Inverse ); break;
				case ANSI_Very_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Very_Inverse ); break;
				case ANSI_Extr_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Extr_Inverse ); break;
				case ANSI_Mode_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Mode_Inverse ); break;
				case ANSI_Shor_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Shor_Inverse ); break;
				case ANSI_Long_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Long_Inverse ); break;
				case ANSI_Defi_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Trip_Curve____Defi_Inverse ); break;
				case Motor_48_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____48_Inverse_Curve 			  ); break;
			}
			
			if(j==Motor_48_Inverse){
				for(i=0;i<GLB_Number_Of_Row_For_48_Trip_Array;i++){
					if((i+100)<=(1<<14))
						SDRAM____IEC_ANSI_Trip_Reset_Curve[i]=Var_Init__Calculate_Operating_Resetting_Time((((i+100)<<17)/125)  , 1);
					else
						SDRAM____IEC_ANSI_Trip_Reset_Curve[i]=Var_Init__Calculate_Operating_Resetting_Time(((((i+100)<<16)/5)<<1)/25 , 1);
				}
			}
			else{
				for(i=0; i<GLB_Number_Of_Row_For_IEC_ANSI_Trip_Array; i++){
					if((i+1100)<=(1<<14))
						SDRAM____IEC_ANSI_Trip_Reset_Curve[i]=Var_Init__Calculate_Operating_Resetting_Time((((i+1100)<<17)/125)  , 1);
					else
						SDRAM____IEC_ANSI_Trip_Reset_Curve[i]=Var_Init__Calculate_Operating_Resetting_Time(((((i+1100)<<16)/5)<<1)/25 , 1);
				}
			}

			if(j<11){
				switch(j){
					case IEC_Norm_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Reset_Curve____Norm_Inverse  ); break;
					case IEC_Very_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Reset_Curve____Very_Inverse  ); break;
					case IEC_Extr_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Reset_Curve____Extr_Inverse  ); break;
					case IEC_Long_Inverse :  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____IEC_Reset_Curve____Long_Inverse  ); break;
					case ANSI_Norm_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Norm_Inverse ); break;
					case ANSI_Very_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Very_Inverse ); break;
					case ANSI_Extr_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Extr_Inverse ); break;
					case ANSI_Mode_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Mode_Inverse ); break;
					case ANSI_Shor_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Shor_Inverse ); break;
					case ANSI_Long_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Long_Inverse ); break;
					case ANSI_Defi_Inverse:  SDRAM____IEC_ANSI_Trip_Reset_Curve= (uint32_t *)( GLB__SDRM_START_BYTE____ANSI_Reset_Curve____Defi_Inverse ); break;
				}
				for(i=0;i<GLB_Number_Of_Row_For_IEC_ANSI_Reset_Array;i++)
					SDRAM____IEC_ANSI_Trip_Reset_Curve[i]=Var_Init__Calculate_Operating_Resetting_Time((i<<17)/125  , 0);
			}
		}
	}
	//----------E: IEC ANSI Curves----------
	Loading_Percent_Part_1++;
	Loading_Percent = Loading_Percent_Part_1;
}
#endif
#if(1) // Records(Write uSD)
void Records__EL(void){
	int32_t  i, n, k;
	int32_t  SIGNAL___Parrent_Address__Index_IN_MHA;
	int32_t  EL__Writing_Part__First_Point_Of_INFO;
	int32_t  EL__Writing_Part__First_Point_Of_Data;
	int32_t  Writing_Part__Total_Used_Bytes;
//int32_t  Num_Of_Total_Bytes_Saved_In_MMC;
	int32_t  byte_of__This_MMC_BLK__Filed_In_Last_EL=0;
	int32_t  New_Date_Time__Bytes;
	int32_t  NAME_LABLE__Adr;
	uint32_t Year ;
	uint32_t MONTH;
	uint32_t DOM  ;
	uint32_t HOUR ;
	uint32_t MIN  ;
	uint32_t SEC  ;
	uint32_t mSEC  ;
	uint32_t Value  ;
	uint8_t  Num_Of_Event_In_This_MMCBLK;
	uint16_t Num_Of_MMCBLKs___Filld_For_EL;
	


	if(EL__Status[EL__Writing_Part]==1){		
		read_from_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
		Num_Of_Event_In_This_MMCBLK = SDRAM____1_Block_MMC[11];
		Num_Of_MMCBLKs___Filld_For_EL = *(uint16_t *)(SDRAM____1_Block_MMC + 4);
		
		EL__Writing_Part__First_Point_Of_INFO	= EL__Writing_Part * EL__Lenth_Of_Any_Part;
		EL__Writing_Part__First_Point_Of_Data	= EL__Writing_Part__First_Point_Of_INFO + EL__Info_Length__At_First_Of_Any_Part;
		Writing_Part__Total_Used_Bytes	= *((uint16_t*)(SDRAM____EL + EL__Writing_Part__First_Point_Of_INFO));
//	Num_Of_Total_Bytes_Saved_In_MMC		= *((uint32_t*)(SDRAM____EL + EL__Writing_Part__First_Point_Of_INFO +2));
		
		i=0;
		while(i<Writing_Part__Total_Used_Bytes - EL__Info_Length__At_First_Of_Any_Part){
			i+=4;//My_INF
			i+=2;//hazf shavad
			Year = *(uint16_t *)(SDRAM____EL + EL__Writing_Part__First_Point_Of_Data + i);
			i+=2;
			MONTH= SDRAM____EL[ EL__Writing_Part__First_Point_Of_Data + i++];
			DOM  = SDRAM____EL[ EL__Writing_Part__First_Point_Of_Data + i++];
			HOUR = SDRAM____EL[ EL__Writing_Part__First_Point_Of_Data + i++];
			MIN  = SDRAM____EL[ EL__Writing_Part__First_Point_Of_Data + i++];
			SEC  = SDRAM____EL[ EL__Writing_Part__First_Point_Of_Data + i++];
			mSEC = *(uint16_t *)(SDRAM____EL + EL__Writing_Part__First_Point_Of_Data + i);
			i+=2;
			
			while(*(uint32_t*)(SDRAM____EL + EL__Writing_Part__First_Point_Of_Data + i) != My_INF && i< Writing_Part__Total_Used_Bytes - EL__Info_Length__At_First_Of_Any_Part){
				SIGNAL___Parrent_Address__Index_IN_MHA = *(uint32_t*)(SDRAM____EL + EL__Writing_Part__First_Point_Of_Data + i);
				NAME_LABLE__Adr = *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA + PatternModels____INFO____From_Parrent_PNT);
				i+=4;
				Value = SDRAM____EL[EL__Writing_Part__First_Point_Of_Data + i++];
				

				*(uint16_t *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD) = Year ;
				SDRAM____1_Block_MMC[12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 2]	=	MONTH;
				SDRAM____1_Block_MMC[12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 3]	=	DOM  ;
				SDRAM____1_Block_MMC[12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 4]	=	HOUR ;
				SDRAM____1_Block_MMC[12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 5]	=	MIN  ;
				SDRAM____1_Block_MMC[12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 6]	=	SEC  ;
				*(uint16_t *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 7)	=	mSEC ;

				if(*(MHA + *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA)) == PatternModel_1){
				}
				else{
					sprintf((char *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 9), "%s", (SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr));
					sprintf((char *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 9 + VFC____SIGNAL_NAME__Size), "%s", (SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr + VFC____SIGNAL_NAME__Size));
					if(Value == 0) 
						sprintf((char *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 9 + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size), "OFF"); //Value Unit
					else
						sprintf((char *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 9 + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size), "ON"); //Value Unit
				}
//			sprintf((char *)(SDRAM____1_Block_MMC + 12 + Num_Of_Event_In_This_MMCBLK * EL__DATA_LEN_OF_ANY_EVENT_On_uSD + 9 + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size), "   "); //Prim. Value
				
				
				Num_Of_Event_In_This_MMCBLK++;
				if(Num_Of_Event_In_This_MMCBLK == 5){
					Num_Of_Event_In_This_MMCBLK = 0;
					
					if(Num_Of_MMCBLKs___Filld_For_EL < EL__MMC____NUM_OF_BLKs____FOR_SAVE_EL - 1)
						Num_Of_MMCBLKs___Filld_For_EL++;
					*(uint32_t *)(SDRAM____1_Block_MMC)=0;
					*(uint16_t *)(SDRAM____1_Block_MMC+4)=0;
					SDRAM____1_Block_MMC[11] = 5;                                        //??????????
					Write_to_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
					
					*(uint32_t *)(SDRAM____1_Block_MMC) = EL_Code_For_MMCBLK_That_Is_Filling;
					*(uint32_t *)(SDRAM____1_Block_MMC + 4) = Num_Of_MMCBLKs___Filld_For_EL;
					
					EL__Adr_For_Save++;
					if(EL__Adr_For_Save >= EL__MMC____FST_BLK____SAVE_EL__CPU + EL__MMC____NUM_OF_BLKs____FOR_SAVE_EL )
						EL__Adr_For_Save = EL__MMC____FST_BLK____SAVE_EL__CPU;
				}
			}
		}
		
		if(Num_Of_Event_In_This_MMCBLK == 0){
			*(uint16_t *)(SDRAM____1_Block_MMC+4) = Num_Of_MMCBLKs___Filld_For_EL;
			SDRAM____1_Block_MMC[11] =0;
		}
		else{
			*(uint32_t *)(SDRAM____1_Block_MMC) = EL_Code_For_MMCBLK_That_Is_Filling;
			SDRAM____1_Block_MMC[11] = Num_Of_Event_In_This_MMCBLK;
		}
		Write_to_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
		
		EL__Status[EL__Writing_Part]=0;
		EL__Writing_Part++;
		if(EL__Writing_Part>= EL__Num_Of_Part_Consid_On_RAM)
			EL__Writing_Part=0;
 		//sprintf((char *)RAM_UART_BUFF,"----------------------------------E: Main: Main_Save_Event_Log\n" ); Panel_Komaki_UARTX_For_Sprintf();
	}
}
void Records__TL(void){
	int32_t  EVENT_COUNT_IN_THIS_TL, NAME_LABLE__Adr, SIGNAL___Parrent_Address__Index_IN_MHA, BLK_PNT, First_Point_Of_Writing_Part;
	int32_t  Data_Length;
	int32_t  Event_Index;
	int32_t  SDRAM_TL_PNT;
	int32_t  BLK__Byte_Index=0;
	int32_t  ms=0;
	int32_t  Value_H1;
	int32_t  Value_H2;
	int32_t  Value_H3;
	int32_t  Value_H5;
	int32_t  Value_rms;
	int32_t  BLK_Index;
	int32_t  Prim;
	int32_t  Sec ;
	int32_t  Divider ;
	char     Unit_Str[2];
	
	if(GLB_TL_Status[0][TL__Writing_Part]==1){
		GLB_TL_Status[0][TL__Writing_Part]=0;
			
		First_Point_Of_Writing_Part = TL__Writing_Part * TL___Any_Part_Length; 
		Data_Length = *(uint32_t*)(SDRAM____TL + First_Point_Of_Writing_Part + 4);
		EVENT_COUNT_IN_THIS_TL = Data_Length / TL___DATA_LENGTH_OF_ANY_EVENT_On_SDRAM;
				
		TL__Writing_Part = (++TL__Writing_Part >= TL___Num_Of_Parts_On_SDRAM? 0: TL__Writing_Part);		
		TL___Counter = (++TL___Counter >= GLB_TL_Max_Numb_Of_TL_Can_Save? 0: TL___Counter);		

		BLK_PNT = 0;
		*(uint32_t*)(SDRAM____1_Block_MMC + BLK_PNT) = My_INF; 		
		BLK_PNT+=4;
		*(uint32_t*)(SDRAM____1_Block_MMC + BLK_PNT) = TL___Counter; 		
		BLK_PNT+=4;
		*(uint32_t*)(SDRAM____1_Block_MMC + BLK_PNT) = EVENT_COUNT_IN_THIS_TL; 
		BLK_PNT+=4;
		*(uint16_t*)(SDRAM____1_Block_MMC + BLK_PNT) = *(uint16_t *)(SDRAM____TL + First_Point_Of_Writing_Part + TL__INFO_LENGTH);  //Year
		BLK_PNT+=2;
		SDRAM____1_Block_MMC[BLK_PNT++] = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 2]; //Month
		SDRAM____1_Block_MMC[BLK_PNT++] = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 3]; //DOM
		SDRAM____1_Block_MMC[BLK_PNT++] = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 4]; //Hour
		SDRAM____1_Block_MMC[BLK_PNT++] = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 5]; //Min
		SDRAM____1_Block_MMC[BLK_PNT++] = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 6]; //Sec
		*(uint16_t*)(SDRAM____1_Block_MMC + BLK_PNT) = *(uint16_t *)(SDRAM____TL + First_Point_Of_Writing_Part + TL__INFO_LENGTH + 7 ); //mS
		BLK_PNT+=2;
		
		Write_to_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save, 1);
		BLK_Index = 1;
		
		SDRAM_TL_PNT = TL__INFO_LENGTH + TL__DATE_TIME_LENGTH;

		memset(SDRAM____1_Block_MMC, 0, 512); 
		for(Event_Index=0; Event_Index < EVENT_COUNT_IN_THIS_TL; Event_Index++){
			BLK__Byte_Index = (Event_Index%TL___Max_Event_Count_At_Any_uSD_BLK) * TL___DATA_LENGTH_OF_ANY_EVENT_On_uSD;

			SIGNAL___Parrent_Address__Index_IN_MHA = *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			ms = *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			Value_H1 = *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			Value_H2 = *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			Value_H3 = *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			Value_H5 = *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			Value_rms= *(uint32_t *)(SDRAM____TL + First_Point_Of_Writing_Part + SDRAM_TL_PNT);
			SDRAM_TL_PNT+=4;
			
			NAME_LABLE__Adr = *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA + PatternModels____INFO____From_Parrent_PNT);
			
			sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "%s", SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr); //Name
			BLK__Byte_Index += VFC____SIGNAL_NAME__Size;
			
			if(*(MHA + *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA)) == PatternModel_1){
					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "%s", SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr + VFC____SIGNAL_NAME__Size); // LABEL
					BLK__Byte_Index += VFC____SIGNAL_LABEL__Size;
					*(uint32_t*)(SDRAM____1_Block_MMC + BLK__Byte_Index) = ms;
					BLK__Byte_Index += 4;
				
//				if(ms<0){
//					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "  "); // Value Unit
//					BLK__Byte_Index += VFC____SIGNAL_LABEL__Size;
//					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "  "); // Value Unit
//					BLK__Byte_Index += VFC____SIGNAL_LABEL__Size;
//					
//				}
//				else{
					Divider = *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA + PatternModels____AmpDivider____From_Parrent_PNT);
					sprintf__Double_as_string(Value_H1, 1, 1 ,Divider ,3 ,3, SDRAM____MyStr_1);
					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "%s %s", SDRAM____MyStr_1 , SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size); // Secondary Value Unit
					BLK__Byte_Index += VFC____SIGNAL_LABEL__Size;
					Prim = *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA + PatternModels____Primary____From_Parrent_PNT);
					Sec  = *(MHA + SIGNAL___Parrent_Address__Index_IN_MHA + PatternModels____Secondary____From_Parrent_PNT);
					sprintf__Double_as_string(Value_H1, Prim, Sec ,Divider ,1 ,1, SDRAM____MyStr_1);
					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "%s %s", SDRAM____MyStr_1 , SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size); // Primary Value Unit
					BLK__Byte_Index += VFC____SIGNAL_LABEL__Size;
//				}
			}
			else{
				sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "%s", SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr + VFC____SIGNAL_NAME__Size); // LABEL
				BLK__Byte_Index += VFC____SIGNAL_LABEL__Size;
				*(uint32_t*)(SDRAM____1_Block_MMC + BLK__Byte_Index) = ms;
				BLK__Byte_Index += 4;
				
				if(Value_H1 == 0)
					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "OFF"); //Value Unit
				else
					sprintf((char *)(SDRAM____1_Block_MMC + BLK__Byte_Index), "ON"); //Value Unit
				BLK__Byte_Index += (2*VFC____SIGNAL_LABEL__Size);
			}
			

			if(Event_Index % TL___Max_Event_Count_At_Any_uSD_BLK == (TL___Max_Event_Count_At_Any_uSD_BLK -1)){
				Write_to_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save + BLK_Index, 1);
				memset(SDRAM____1_Block_MMC, 0, 512);
				BLK_Index++;
				if(BLK_Index == GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU)
					break;
			}
		}
			
		if((Event_Index-1) % TL___Max_Event_Count_At_Any_uSD_BLK != (TL___Max_Event_Count_At_Any_uSD_BLK - 1) && BLK_Index < GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU){
			Write_to_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save + BLK_Index, 1);
			memset(SDRAM____1_Block_MMC, 0, 512);
		}
				
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name     ) = *(uint16_t *)(SDRAM____TL + First_Point_Of_Writing_Part + TL__INFO_LENGTH);  //Year
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name + 4 ) = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 2]; //Month
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name + 8 ) = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 3]; //DOM
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name + 12) = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 4]; //Hour
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name + 16) = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 5]; //Min
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name + 20) = SDRAM____TL[First_Point_Of_Writing_Part + TL__INFO_LENGTH + 6]; //Sec
		*(uint32_t *)(SDRAM____TLs_Name + TL___Adr_Of_Last_TLs_Name + 24) = *(uint16_t *)(SDRAM____TL + First_Point_Of_Writing_Part + TL__INFO_LENGTH + 7 ); //mS
		
		TL___Has_Any_Log = Yes_1;
		
		if(TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU){
			read_from_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);
			*((uint32_t*)(SDRAM____1_Block_MMC))=0;
			Write_to_MMC (SDRAM____1_Block_MMC, TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);
		}
		else{
			read_from_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save + (GLB_TL_Max_Numb_Of_TL_Can_Save-1)*GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);
			*((uint32_t*)(SDRAM____1_Block_MMC))=0;
			Write_to_MMC (SDRAM____1_Block_MMC, TL___Adr_For_Save + (GLB_TL_Max_Numb_Of_TL_Can_Save-1)*GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);
		}
		
		TL___Adr_For_Save += GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU;
		if(TL___Adr_For_Save >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU * GLB_TL_Max_Numb_Of_TL_Can_Save)
			TL___Adr_For_Save = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU;
		
		TL___Adr_Of_Last_TLs_Name+=28;
		if(TL___Adr_Of_Last_TLs_Name == 28*GLB_TL__Num_Of_TLs_For_Display_On_LCD)
			TL___Adr_Of_Last_TLs_Name=0;		
	}
} 
void Records__Comtrade_Calc_PerFault_DateTime(void){
//	int32_t Pre__Trig__Time;
	
	Pre__Trig_StartTime1.Year		=		GLB_Osc_Status[3][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre__Trig_StartTime1.Month	=		GLB_Osc_Status[4][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre__Trig_StartTime1.Day		=		GLB_Osc_Status[5][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre__Trig_StartTime1.Hour		=		GLB_Osc_Status[6][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre__Trig_StartTime1.Minute	=		GLB_Osc_Status[7][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre__Trig_StartTime1.Second	=		GLB_Osc_Status[8][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre__Trig_StartTime1.ms			=		GLB_Osc_Status[9][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]-10*GLB_Prefault_Time;
	
	if(Pre__Trig_StartTime1.ms<0){
		Pre__Trig_StartTime1.ms+=1000;
		Pre__Trig_StartTime1.Second--;
		if(Pre__Trig_StartTime1.Second<0){
			Pre__Trig_StartTime1.Second+=60;
			Pre__Trig_StartTime1.Minute--;
			if(Pre__Trig_StartTime1.Minute<0){
				Pre__Trig_StartTime1.Minute+=60;
				Pre__Trig_StartTime1.Hour--;
				if(Pre__Trig_StartTime1.Hour<0){
					Pre__Trig_StartTime1.Hour+=24;
					Pre__Trig_StartTime1.Day--;
					if(Pre__Trig_StartTime1.Day<1){
						if(Pre__Trig_StartTime1.Month==1 || Pre__Trig_StartTime1.Month==2 || Pre__Trig_StartTime1.Month==4 || Pre__Trig_StartTime1.Month==6 ||  Pre__Trig_StartTime1.Month==8 || Pre__Trig_StartTime1.Month==9 || Pre__Trig_StartTime1.Month==11)
							Pre__Trig_StartTime1.Day=31;
						else if(Pre__Trig_StartTime1.Month!=3)
							Pre__Trig_StartTime1.Day=30;
						else{
							if(Pre__Trig_StartTime1.Year%4==0)
								Pre__Trig_StartTime1.Day=29;
							else
								Pre__Trig_StartTime1.Day=28;
						}
						Pre__Trig_StartTime1.Month--;
						
						if(Pre__Trig_StartTime1.Month<1){
							Pre__Trig_StartTime1.Month+=12;
							Pre__Trig_StartTime1.Year--;
						}
					}
				}
			}
		}
	}
}
void Records__Comtrade_Main(void){
	int32_t		p, i, H=0, DIGITAL_Index, k, j, n, NAME_LABLE__Adr, ANALOG_Index, h;
	int16_t		a0=0, a1=0, Factor_a;
	int32_t		ANALOG___Secondary;
	int32_t		ANALOG___Primary;
	char   		Unit_Str[2];
	uint8_t		Type;
	int32_t		During_And_Post_Fault_Total_Samples, First_Poin_Of__During_Fault_Data___In_This_OSC_RAM_Part, First_Poin_Of__Pre_Fault_Data___In_This_OSC_RAM_Part;
	int32_t		First_Sample_Index_Of___Pre_Fault;
	int32_t		Last_Sample_Index_Of___Pre_Fault;
	int32_t		Pre_Fault_Total_Samples;
	int32_t		Index_Of_This_RAM_Part___For_Save_Max_VI;
	int32_t		uSD_Block____Byte_Index=-1;
	int32_t		Analogs__SigPackage__MHA_Index = *(VMA + GLB____CMTRD____Frst_Adr_Of_ANALOGs_In_VMA);
	int32_t		*Analogs__SigPackage__MHA_PNT  = MHA + Analogs__SigPackage__MHA_Index;
	int32_t		Digitals__SigPackage__MHA_Index = *(VMA + GLB____CMTRD____Frst_Adr_Of_DIGITALs_In_VMA);
	int32_t		*Digitals__SigPackage__MHA_PNT  = MHA + Digitals__SigPackage__MHA_Index;

	int32_t		*SigType;
	int32_t		*FFT__MHA_PNT_Adr;
	int32_t		*DigitalValue__MHA_PNT_Adr;
	
	GLB_Cmtrd_Main__Sig_Adr=0;
	GLB_Cmtrd_Main__Row=0;
	GLB_Cmtrd_Main__Total_Num_Of_Sample_Recorded=0;

	//sprintf((char *)RAM_UART_BUFF," .............................................S:  Osc_Analog\n"); Panel_Komaki_UARTX_For_Sprintf();	
	//----------S: Adrese zakhire bakhshhaye matrise jaryanVoltag moshakhas mishavad ----------
	GLB_Cmtrd_Main__Osc_Firs_Adr_For_Save_Osc_Analog_Parts = GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU+GLB_CMTRD____Num_Of_Total_Saved_CMTRD*GLB_Osc____Total_Num_Of_uSDBlocks___For_Any_Osc;
	GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts = GLB_Cmtrd_Main__Osc_Firs_Adr_For_Save_Osc_Analog_Parts+4;
	//----------E: Adrese zakhire bakhshhaye matrise jaryanVoltag moshakhas mishavad ----------
	//----------S: bakhshi az matrise nemounehaye jaryan voltag zakhire mishavad ----------
	During_And_Post_Fault_Total_Samples = GLB_Osc_Status[2][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
		
	First_Poin_Of__During_Fault_Data___In_This_OSC_RAM_Part = GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC * GLB_Osc____Total_Num_Of_Sample_Can_Be_Saved + GLB_Osc____Pre_fault_Max_Num_Of_Sample;
	First_Poin_Of__Pre_Fault_Data___In_This_OSC_RAM_Part    = GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC * GLB_Osc____Total_Num_Of_Sample_Can_Be_Saved;
		
	Last_Sample_Index_Of___Pre_Fault = GLB_Osc_Status[1 ][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Pre_Fault_Total_Samples          = GLB_Osc_Status[18][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC] * GLB_Rated_Frequency * GLB_Number_of_Sample_per_Cycle/100;	
		
	First_Sample_Index_Of___Pre_Fault = Last_Sample_Index_Of___Pre_Fault - Pre_Fault_Total_Samples+1;
	if(First_Sample_Index_Of___Pre_Fault<0)
		First_Sample_Index_Of___Pre_Fault += GLB_Osc____Pre_fault_Max_Num_Of_Sample;
	
	Index_Of_This_RAM_Part___For_Save_Max_VI = (GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC+1) * GLB_Osc____Total_Num_Of_Sample_Can_Be_Saved-1;
	for(j=0; j<GLB__CMTRD____Max_Num_OF_Analogs_Can_Assigned; j++){
		*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI* (GLB_4_Byte*GLB__CMTRD____Max_Num_OF_Analogs_Can_Assigned+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*j))=0; //hhhh
		GLB_Cmtrd_Main__min[j] =  My_INF;
		GLB_Cmtrd_Main__max[j] = -My_INF;
	}
//sprintf((char *)RAM_UART_BUFF,"GLB_Cmtrd_Main__Pre_Fault_Total_Row_For_Save=%d\n",GLB_Cmtrd_Main__Pre_Fault_Total_Row_For_Save); Panel_Komaki_UARTX_For_Sprintf();	
	//----------S: maghadire ghabl az khata az ram dar MMC rikhte mishavad ----------
	for(k=0; k<Pre_Fault_Total_Samples; k++){
		n = First_Sample_Index_Of___Pre_Fault+ k;
		if(n>= GLB_Osc____Pre_fault_Max_Num_Of_Sample)
			n -= GLB_Osc____Pre_fault_Max_Num_Of_Sample;
		//----------S: ??? 2048  ----------
		if(uSD_Block____Byte_Index+ (GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+ (GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) >= 2048){
			//sprintf((char *)RAM_UART_BUFF," 11-Add_Of_Comt=  %3d  \n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
			if(GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts >= GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU){
				Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
//			sprintf((char *)RAM_UART_BUFF,"!!!!11-  Adr: =%d\n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
				GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
				uSD_Block____Byte_Index=-1;
			}
			else{
				sprintf((char *)RAM_UART_BUFF,"!!!!11-  GLB_Osc_Adress_For_Save_Oscillograph_Current_And_Voltage_Parts: =%d\n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
			}
		}
		//----------E: ??? 2048  ----------
		ANALOG_Index=0;
		for(j = 0; j < GLB_4_Byte * GLB__CMTRD____Num_Of_Assigned_Analog + (GLB__CMTRD____Num_Of_Assigned_Digital>>3) + 1; j++){
			GLB_Cmtrd_Main__Row = First_Poin_Of__Pre_Fault_Data___In_This_OSC_RAM_Part + n;
			uSD_Block____Byte_Index++;
			
			if(j>=GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog){
				SDRAM____4_Block_MMC[uSD_Block____Byte_Index] = SDRAM____Analog_Digital_Comtrade[GLB_Cmtrd_Main__Row*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + j];
//			sprintf((char *)RAM_UART_BUFF,"%d\n", SDRAM____4_Block_MMC[uSD_Block____Byte_Index]); Panel_Komaki_UARTX_For_Sprintf();
			}
			else if((j%GLB_4_Byte)==0){
					h=j/GLB_4_Byte;
//				sprintf((char *)RAM_UART_BUFF,"=%2d  %d  %d\n", h, Any_Module_Asigned_To_This_VI_For_Osc[h][1], uSD_Block____Byte_Index); Panel_Komaki_UARTX_For_Sprintf();
					FFT__MHA_PNT_Adr = 	Analogs__SigPackage__MHA_PNT + PatternModels____CommonPart_Size + ANALOG_Index * PatternModels____Repetition_Part____Size;
					SigType = MHA + *FFT__MHA_PNT_Adr + PatternModels____SigType__From_FFT_PNT;
				
					if(*SigType != -1){ //Sig Assigned
						*((int16_t*)(SDRAM____4_Block_MMC + uSD_Block____Byte_Index ))            =(int16_t)(*((int16_t *)(SDRAM____Analog_Digital_Comtrade + GLB_Cmtrd_Main__Row* (GLB_4_Byte* GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1)+ j)));
						*((int16_t*)(SDRAM____4_Block_MMC + uSD_Block____Byte_Index + GLB_2_Byte))=(int16_t)(*((int16_t *)(SDRAM____Analog_Digital_Comtrade + GLB_Cmtrd_Main__Row* (GLB_4_Byte* GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1)+ j+GLB_2_Byte)));
//					sprintf((char *)RAM_UART_BUFF,"%6d %d\n",uSD_Block____Byte_Index, *((uint32_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index))); Panel_Komaki_UARTX_For_Sprintf();
					}
					else{
						*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index))           =0;
						*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index+GLB_2_Byte))=0;
					}
					ANALOG_Index++;
					//----------S: ?????? ??????? ? ?????? ???? ???? ?? ??????? ?????? ????? ?????? ----------
					a0= *((int16_t *)(SDRAM____Analog_Digital_Comtrade + GLB_Cmtrd_Main__Row                     *(GLB_4_Byte* GLB__CMTRD____Num_Of_Assigned_Analog+ (GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte* h)); 
					a1= *((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte* GLB__CMTRD____Num_Of_Assigned_Analog+ (GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte* h)); 
					if(a0>a1)
						*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*h))=a0; 
					if(-a0>a1)
						*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*h))=-a0; 
					if(GLB_Cmtrd_Main__min[h]>a0)
						GLB_Cmtrd_Main__min[h]=a0;
					if(GLB_Cmtrd_Main__max[h]<a0)
						GLB_Cmtrd_Main__max[h]=a0;
					//----------E: ?????? ??????? ? ?????? ???? ???? ?? ??????? ?????? ????? ?????? ----------
//				}
//				else			
//					uSD_Block____Byte_Index-=4;
				if(h==0){
					GLB_Cmtrd_Main__Total_Num_Of_Sample_Recorded++;
//				sprintf((char *)RAM_UART_BUFF,"%4d \n",*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index))); Panel_Komaki_UARTX_For_Sprintf();
				}
			}
		}
	}
	//----------E: maghadire ghabl az khata az ram dar MMC rikhte mishavad ----------
	//----------S: maghadire doreye khata va bad az khata az ram dar MMC rikhte mishavad ----------
	for(k=0; k<During_And_Post_Fault_Total_Samples; k++){
		//----------S: agar 2048 byte por shode va ya dar in marhale sarriz khahad shod write anjam mishavad ----------
		if(uSD_Block____Byte_Index+ (GLB_4_Byte* GLB__CMTRD____Num_Of_Assigned_Analog+ (GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) >= 2048){
			//sprintf((char *)RAM_UART_BUFF," 22-Add_Of_Comt=  %3d  \n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
			if(GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts>=GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU){
				Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
				GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
				uSD_Block____Byte_Index=-1;
			}
			else{
				sprintf((char *)RAM_UART_BUFF,"!!!!22-  GLB_Osc_Adress_For_Save_Oscillograph_Current_And_Voltage_Parts: =%d\n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
			}
		}
		//----------E: agar 2048 byte por shode va ya dar in marhale sarriz khahad shod write anjam mishavad ----------
		ANALOG_Index=0;
		for(j=0; j<GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1; j++){			
			GLB_Cmtrd_Main__Row = First_Poin_Of__During_Fault_Data___In_This_OSC_RAM_Part+k;
			uSD_Block____Byte_Index++;
			
			if(j>=GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog){
				SDRAM____4_Block_MMC[uSD_Block____Byte_Index]=SDRAM____Analog_Digital_Comtrade[GLB_Cmtrd_Main__Row*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + j];
//sprintf((char *)RAM_UART_BUFF,"%d\n", SDRAM____4_Block_MMC[uSD_Block____Byte_Index]); Panel_Komaki_UARTX_For_Sprintf();

			}
			else if((j%GLB_4_Byte)==0){
				h=j/GLB_4_Byte;
//sprintf((char *)RAM_UART_BUFF,"=%2d  %d  %d\n", h, Any_Module_Asigned_To_This_VI_For_Osc[h][1], uSD_Block____Byte_Index); Panel_Komaki_UARTX_For_Sprintf();
					FFT__MHA_PNT_Adr = 	Analogs__SigPackage__MHA_PNT + PatternModels____CommonPart_Size + ANALOG_Index * PatternModels____Repetition_Part____Size;
					SigType = MHA + *FFT__MHA_PNT_Adr + PatternModels____SigType__From_FFT_PNT;
				
					if(*SigType != -1){ //Sig Assigned
						*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index))						 =(int16_t)(*((int16_t *)(SDRAM____Analog_Digital_Comtrade + GLB_Cmtrd_Main__Row*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1)+ j))); //hhhh
						*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index+ GLB_2_Byte))=(int16_t)(*((int16_t *)(SDRAM____Analog_Digital_Comtrade + GLB_Cmtrd_Main__Row*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1)+ j+ GLB_2_Byte))); //hhhh
					}
					else{
						*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index))						 =0;
						*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index+ GLB_2_Byte))=0;
					}
					ANALOG_Index++;
					//----------S: maghadire max va min baraye haryek az kamiathaye analog taeen mishavad ----------
					a0= *((int16_t *)(SDRAM____Analog_Digital_Comtrade + GLB_Cmtrd_Main__Row*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*h)); //hhhh
					a1= *((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*h)); //hhhh
					if(a0>a1)
						*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*h))=a0; //hhhh
					if(-a0>a1)
						*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*h))=-a0; //hhhh
					
					if(GLB_Cmtrd_Main__min[h]>a0)
						GLB_Cmtrd_Main__min[h]=a0;
					if(GLB_Cmtrd_Main__max[h]<a0)
						GLB_Cmtrd_Main__max[h]=a0;
					//----------E: maghadire max va min baraye haryek az kamiathaye analog taeen mishavad ----------
//				}
//				else
//					uSD_Block____Byte_Index-=4;
				if(h==0){
					GLB_Cmtrd_Main__Total_Num_Of_Sample_Recorded++;
//					sprintf((char *)RAM_UART_BUFF,"%4d \n",*((int16_t*)(SDRAM____4_Block_MMC+uSD_Block____Byte_Index))); Panel_Komaki_UARTX_For_Sprintf();
				}
			}
		}
	}
	//----------E: maghadire doreye khata va bad az khata az ram dar MMC rikhte mishavad ----------
	//----------S: edameye akharin araye 2048 byte sefr va bad write mishavad ----------
	for(k=uSD_Block____Byte_Index+1;k<2048;k++)
		SDRAM____4_Block_MMC[k]=0;
// 	sprintf((char *)RAM_UART_BUFF," 33-Add_Of_Comt=  %3d \n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
	if(GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts>=GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU){
		Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
		GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
	}
	else{
		sprintf((char *)RAM_UART_BUFF,"!!!!33-  GLB_Osc_Adress_For_Save_Oscillograph_Current_And_Voltage_Parts: =%d\n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
	}
	//----------E: edameye akharin araye 2048 byte sefr va bad write mishavad ----------
	//----------S: دو سطر اول فايل سي‌اف جي در ام‌ام‌سي‌ رايت مي‌شود ----------
	{
		strncpy((char*)(SDRAM____4_Block_MMC), "Vebko",50);
		*((uint32_t*)(SDRAM____4_Block_MMC+50))=105;
		*((uint16_t*)(SDRAM____4_Block_MMC+54))=1999;
		SDRAM____4_Block_MMC[56]=GLB__CMTRD____Num_Of_Assigned_Analog;
		SDRAM____4_Block_MMC[57]=GLB__CMTRD____Num_Of_Assigned_Digital;
		*(uint32_t*)(SDRAM____4_Block_MMC+ 58)=GLB____CMTRD____Byte_Count_For_Any_Analog____In_CFG;
		*(uint32_t*)(SDRAM____4_Block_MMC+ 62)=GLB____CMTRD____Byte_Count_For_Any_DIGITAL____In_CFG;
		
		GLB_Cmtrd_Main__Adr_For_Save_First_Two_Rows_Of_CFG=GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts;
		//sprintf((char *)RAM_UART_BUFF," 44-Add_Of_Comt=  %3d \n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
		Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
		GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
	}
	//----------E: 2 satre avvale file CFG dar MMC write mishavad ----------
	//----------S: CFG/ANALOG INFO ----------
	{
		H=0; 
		for(ANALOG_Index = 0; ANALOG_Index < GLB__CMTRD____Num_Of_Assigned_Analog; ANALOG_Index++){
			FFT__MHA_PNT_Adr = 	Analogs__SigPackage__MHA_PNT + PatternModels____CommonPart_Size + ANALOG_Index * PatternModels____Repetition_Part____Size;
			SigType = MHA + *FFT__MHA_PNT_Adr + PatternModels____SigType__From_FFT_PNT;
		
			if(*SigType != -1){ //Sig Assigned
				Type = CFC____Signal__Type____PT;
				ANALOG___Primary   = 1000;
				ANALOG___Secondary = 10;
				Factor_a = 1000;
				
				strncpy((char *)(SDRAM____4_Block_MMC  + H    ),"No Signal", VFC____SIGNAL_NAME__Size);
				strncpy((char *)(SDRAM____4_Block_MMC  + H + VFC____SIGNAL_NAME__Size  ),"No Signal", VFC____SIGNAL_LABEL__Size);
				*((uint32_t*)(SDRAM____4_Block_MMC 		 + H + VFC____SIGNAL_LABEL_AND_NAME__Size     ))= ANALOG_Index+1;
				strncpy((char *)(SDRAM____4_Block_MMC  + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 4 ), "-", 1);
				*((uint32_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 5 ))= Factor_a ;
				*((uint32_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 9 ))= 0;
				*((uint32_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 13))= 0;
				*((uint32_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 17))= 10;
				*((uint32_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 21))= 100;
				*((uint32_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 25))= ANALOG___Primary  ;
				*((uint16_t*)(SDRAM____4_Block_MMC  	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 29))= ANALOG___Secondary;
				strncpy((char*)(SDRAM____4_Block_MMC	 + H + VFC____SIGNAL_LABEL_AND_NAME__Size + 31), "S",1);
				SDRAM____4_Block_MMC[H + VFC____SIGNAL_LABEL_AND_NAME__Size + 32]=Type;
			}
			else{
				NAME_LABLE__Adr = *(MHA + *FFT__MHA_PNT_Adr + PatternModels____INFO__From_FFT_PNT);  
				Type = *(MHA + *FFT__MHA_PNT_Adr + PatternModels____SigType__From_FFT_PNT);
				ANALOG___Primary   = *(MHA + *FFT__MHA_PNT_Adr + PatternModels____Primary__From_FFT_PNT);  
				ANALOG___Secondary = *(MHA + *FFT__MHA_PNT_Adr + PatternModels____Secondary__From_FFT_PNT);  
				Factor_a = CALIB_DATA__Magni__Part1[0][*(MHA + *FFT__MHA_PNT_Adr + PatternModels____ColibCol__From_FFT_PNT)];
		//	sprintf((char *)RAM_UART_BUFF,"%2d, %5s  %d  %2s    0.0  0.0  %5d  %5d   %5d   %5d S\n",ANALOG_Index, SDRAM____String_Komaki, 100002+GLB_Rows_Of_Analogs_that_Shown_Always_In_Osc[ANALOG_Index],GLB_Cmtrd_Main__Unit_Str, GLB_Cmtrd_Main__minn, GLB_Cmtrd_Main__maxx, Primary, GLB_Cmtrd_Main__Secondary); Panel_Komaki_UARTX_For_Sprintf();
				
				strncpy((char *)(SDRAM____4_Block_MMC  + H    ),(SDRAM____HF_Vriables__INFO+NAME_LABLE__Adr), VFC____SIGNAL_NAME__Size);
				strncpy((char *)(SDRAM____4_Block_MMC  + H + VFC____SIGNAL_NAME__Size  ),(SDRAM____HF_Vriables__INFO+NAME_LABLE__Adr + VFC____SIGNAL_NAME__Size), VFC____SIGNAL_LABEL__Size);
				*((uint32_t*)(SDRAM____4_Block_MMC 		+ H + VFC____SIGNAL_LABEL_AND_NAME__Size     ))= ANALOG_Index+1;
				strncpy((char *)(SDRAM____4_Block_MMC 	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 4 ),(SDRAM____HF_Vriables__INFO+NAME_LABLE__Adr + VFC____SIGNAL_LABEL_AND_NAME__Size), 1);
				*((uint32_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 5 ))= Factor_a ;
				*((uint32_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 9 ))= 0;
				*((uint32_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 13))= 0;
				*((uint32_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 17))= GLB_Cmtrd_Main__min[ANALOG_Index];
				*((uint32_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 21))= GLB_Cmtrd_Main__max[ANALOG_Index];
				*((uint32_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 25))= ANALOG___Primary  ;
				*((uint16_t*)(SDRAM____4_Block_MMC  	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 29))= ANALOG___Secondary;
				strncpy((char*)(SDRAM____4_Block_MMC	+ H + VFC____SIGNAL_LABEL_AND_NAME__Size + 31), "S",1);
				SDRAM____4_Block_MMC[H + VFC____SIGNAL_LABEL_AND_NAME__Size + 32]=Type;
			}
			
			H += GLB____CMTRD____Byte_Count_For_Any_Analog____In_CFG;
			if(H+ GLB____CMTRD____Byte_Count_For_Any_Analog____In_CFG>2048){
				Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
				GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
				H=0;
			}
		}
		if(H!=0){
			Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
			GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
		}	
	}
	//----------E: CFG/ANALOG INFO ----------
	//----------S: CFG/DIGITAL INFO ----------
	{
		GLB_Cmtrd_Main__Firs_Adr_of_Digital_Inf_in_CFG=GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts;
		H=0; 
		for(DIGITAL_Index=0; DIGITAL_Index<GLB__CMTRD____Num_Of_Assigned_Digital; DIGITAL_Index++){
			DigitalValue__MHA_PNT_Adr = Digitals__SigPackage__MHA_PNT + PatternModels____CommonPart_Size + DIGITAL_Index * PatternModels____Repetition_Part____Size;
			SigType = MHA + *DigitalValue__MHA_PNT_Adr + PatternModels____SigType__From_Value_Pattern0_PNT;
		
			if(*SigType != -1){ //Sig Assigned
				strncpy((char *)(SDRAM____4_Block_MMC + H ), "No Signal", VFC____SIGNAL_LABEL__Size);
				strncpy((char *)(SDRAM____4_Block_MMC + H + VFC____SIGNAL_LABEL__Size), "No Signal", VFC____SIGNAL_NAME__Size);
				*((uint32_t*)(   SDRAM____4_Block_MMC + H + VFC____SIGNAL_LABEL_AND_NAME__Size))= DIGITAL_Index;
				*((uint32_t*)(   SDRAM____4_Block_MMC + H + VFC____SIGNAL_LABEL_AND_NAME__Size +4))= 0;
			}
			else{
				NAME_LABLE__Adr = *(MHA + *DigitalValue__MHA_PNT_Adr + PatternModels____INFO__From_Value_Pattern0_PNT);  

				strncpy((char *)(SDRAM____4_Block_MMC + H ),(SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr+ VFC____SIGNAL_NAME__Size), VFC____SIGNAL_LABEL__Size);
				strncpy((char *)(SDRAM____4_Block_MMC + H + VFC____SIGNAL_LABEL__Size),(SDRAM____HF_Vriables__INFO + NAME_LABLE__Adr), VFC____SIGNAL_NAME__Size);
				*((uint32_t*)(   SDRAM____4_Block_MMC + H + VFC____SIGNAL_LABEL_AND_NAME__Size))= DIGITAL_Index;
				*((uint32_t*)(   SDRAM____4_Block_MMC + H + VFC____SIGNAL_LABEL_AND_NAME__Size +4))= 0;
			}
			
			H += GLB____CMTRD____Byte_Count_For_Any_DIGITAL____In_CFG;
	
			if(H+ GLB____CMTRD____Byte_Count_For_Any_DIGITAL____In_CFG>2048){
				Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
				GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
				H=0;
			}				
		}
		if(H!=0){
			Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
			GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;
		}
	}
	//----------E: CFG/DIGITAL INFO ----------
	SDRAM____4_Block_MMC[0]= GLB_Rated_Frequency;
	SDRAM____4_Block_MMC[1]= 1; //nrates Number of sampling rates in the data file;
	*((uint32_t*)(SDRAM____4_Block_MMC+2))=GLB_Rated_Frequency*GLB_Number_of_Sample_per_Cycle;
	
	*((uint32_t*)(SDRAM____4_Block_MMC+6))=GLB_Cmtrd_Main__Total_Num_Of_Sample_Recorded;
//	SDRAM____4_Block_MMC[10]=GLB_Osc_Status[5][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
//	SDRAM____4_Block_MMC[11]=GLB_Osc_Status[4][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
//	*((uint16_t*)(SDRAM____4_Block_MMC+12))=GLB_Osc_Status[3][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
//	SDRAM____4_Block_MMC[14]=GLB_Osc_Status[6][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
//	SDRAM____4_Block_MMC[15]=GLB_Osc_Status[7][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
//	SDRAM____4_Block_MMC[16]=GLB_Osc_Status[8][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
//	*((uint32_t*)(SDRAM____4_Block_MMC+17))=GLB_Osc_Status[9][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	Records__Comtrade_Calc_PerFault_DateTime();
	SDRAM____4_Block_MMC[10]= Pre__Trig_StartTime1.Day;
	SDRAM____4_Block_MMC[11]= Pre__Trig_StartTime1.Month;
	*((uint16_t*)(SDRAM____4_Block_MMC+12))= Pre__Trig_StartTime1.Year;
	SDRAM____4_Block_MMC[14]= Pre__Trig_StartTime1.Hour;
	SDRAM____4_Block_MMC[15]= Pre__Trig_StartTime1.Minute;
	SDRAM____4_Block_MMC[16]= Pre__Trig_StartTime1.Second;
	*((uint32_t*)(SDRAM____4_Block_MMC+17))= Pre__Trig_StartTime1.ms;

	SDRAM____4_Block_MMC[21]=GLB_Osc_Status[5][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	SDRAM____4_Block_MMC[22]=GLB_Osc_Status[4][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	*((uint16_t*)(SDRAM____4_Block_MMC+23))=GLB_Osc_Status[3][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	SDRAM____4_Block_MMC[25]=GLB_Osc_Status[6][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	SDRAM____4_Block_MMC[26]=GLB_Osc_Status[7][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	SDRAM____4_Block_MMC[27]=GLB_Osc_Status[8][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	*((uint32_t*)(SDRAM____4_Block_MMC+28))=GLB_Osc_Status[9][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	
// 	sprintf((char *)RAM_UART_BUFF,"%d.%d.%d.%3d   ",GLB_Osc_Status[6][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC], GLB_Osc_Status[7][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC],GLB_Osc_Status[8][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC], GLB_Osc_Status[9][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]); Panel_Komaki_UARTX_For_Sprintf();
	
	*((uint32_t*)(SDRAM____4_Block_MMC+32))=1;
	
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu      ))=GLB_Osc_Status[3][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu + 4  ))=GLB_Osc_Status[4][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC] ;
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu + 8  ))=GLB_Osc_Status[5][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC] ;
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu + 12 ))=GLB_Osc_Status[6][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu + 16 ))=GLB_Osc_Status[7][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu + 20 ))=GLB_Osc_Status[8][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu + 24 ))=GLB_Osc_Status[9][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC];
	
	//sprintf((char *)RAM_UART_BUFF," 99-Add_Of_Comt=  %3d \n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
	GLB_Cmtrd_Main__Adr_For_Save_End_7_Rows_Of_CFG=GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts;
	Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
	GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts+=4;

	for(j=0; j<GLB__CMTRD____Num_Of_Assigned_Analog; j++){
//	if(Any_Module_Asigned_To_This_VI_For_Osc[j][1]==1){
			*((uint32_t*)(SDRAM____4_Block_MMC+j*4))= *((int16_t *)(SDRAM____Analog_Digital_Comtrade + Index_Of_This_RAM_Part___For_Save_Max_VI*(GLB_4_Byte*GLB__CMTRD____Num_Of_Assigned_Analog+(GLB__CMTRD____Num_Of_Assigned_Digital>>3)+1) + GLB_4_Byte*j)); //hhhh
//	}
	} 
	//sprintf((char *)RAM_UART_BUFF," 100Add_Of_Comt=  %3d \n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
	if(GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts>=GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU)
		Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts, 4);
	else{
		sprintf((char *)RAM_UART_BUFF,"!!!!100  GLB_Osc_Adress_For_Save_Oscillograph_Current_And_Voltage_Parts: =%d\n", GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts); Panel_Komaki_UARTX_For_Sprintf();
	}
	read_from_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Osc_Firs_Adr_For_Save_Osc_Analog_Parts, 4);
	*((uint32_t*)(SDRAM____4_Block_MMC))= 		GLB_Cmtrd_Main__Adr_For_Save_Cmtrd_Parts; // Adress_Of_Last_Block_Of_VI_Data_Osc_Event_In_Any_Event
	*((uint32_t*)(SDRAM____4_Block_MMC+4))= 	GLB_Cmtrd_Main__Total_Num_Of_Sample_Recorded;
	*((uint32_t*)(SDRAM____4_Block_MMC+8))= 	GLB_Cmtrd_Main__Adr_For_Save_First_Two_Rows_Of_CFG;
	*((uint32_t*)(SDRAM____4_Block_MMC+12))= 	GLB_Cmtrd_Main__Adr_For_Save_End_7_Rows_Of_CFG;
	*((uint32_t*)(SDRAM____4_Block_MMC+16))= 	GLB_Cmtrd_Main__Firs_Adr_of_Digital_Inf_in_CFG;
	Write_to_MMC(SDRAM____4_Block_MMC, GLB_Cmtrd_Main__Osc_Firs_Adr_For_Save_Osc_Analog_Parts, 4);
	//sprintf((char *)RAM_UART_BUFF," Osc_Analog_Num_Of_Sample= %3d \n", GLB_Cmtrd_Main__Total_Num_Of_Sample_Recorded); Panel_Komaki_UARTX_For_Sprintf();	
	//sprintf((char *)RAM_UART_BUFF," .............................................E:  Osc_Analog\n"); Panel_Komaki_UARTX_For_Sprintf();
}
void Records__Comtrade(void){
	if(GLB_Osc_Status[0][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]==1){
		GLB_Osc_Recording_Is_On=1;
// 		sprintf((char *)RAM_UART_BUFF,"---------------------------------------------- Osc-S\n" ); Panel_Komaki_UARTX_For_Sprintf();
		
		//sprintf((char *)RAM_UART_BUFF,"%8lld %d= [%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d]\n", GLB_Counter_Samples_Total_New ,GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC ,GLB_Osc_Status[0][0] ,GLB_Osc_Status[0][1] ,GLB_Osc_Status[0][2] ,GLB_Osc_Status[0][3] ,GLB_Osc_Status[0][4] ,GLB_Osc_Status[0][5] ,GLB_Osc_Status[0][6] ,GLB_Osc_Status[0][7] ,GLB_Osc_Status[0][8] ,GLB_Osc_Status[0][9] ,GLB_Osc_Status[0][10] ,GLB_Osc_Status[0][11] ,GLB_Osc_Status[0][12] ,GLB_Osc_Status[0][13] ,GLB_Osc_Status[0][14]); Panel_Komaki_UARTX_For_Sprintf();
		GLB_Osc_Status[0][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]=0;
		
		Records__Comtrade_Main();
		{
			if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
				read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
			else
				read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);
			GLB_CMTRD____Num_Of_Total_Saved_CMTRD=*((uint32_t*)(SDRAM____1_Block_MMC));
			
			GLB_CMTRD____Num_Of_Total_Saved_CMTRD++;
			if(GLB_CMTRD____Num_Of_Total_Saved_CMTRD==GLB_Osc____Total_Num_Of_Osc_Can_Record+1){
				GLB_CMTRD____Num_Of_Total_Saved_CMTRD=1;
				SDRAM____1_Block_MMC[4]=1;
			}
			
			*((uint32_t*)(SDRAM____1_Block_MMC))=GLB_CMTRD____Num_Of_Total_Saved_CMTRD;
			*((uint32_t*)(SDRAM____1_Block_MMC+5))=My_INF;
			if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD >= GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
				Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD, 1);
			else{
				sprintf((char *)RAM_UART_BUFF,"!!!!1-  Invalid Address For Osc_Addres: =%d\n", GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD); Panel_Komaki_UARTX_For_Sprintf();
			}
			//----------E: ????? ???????????? ?? ???? ???? ????? ?????? ----------
			//----------S: ???? ???? ?? ????? ??????????? ?? ?? ????? ????? ???? ?????? ----------
			for(GLB_Comtrade_i=0;GLB_Comtrade_i<512;GLB_Comtrade_i++)
				SDRAM____1_Block_MMC[GLB_Comtrade_i]=0;					
			if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
				Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
			else
				Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);
			//----------E: ???? ???? ?? ????? ??????????? ?? ?? ????? ????? ???? ?????? ----------
			
			//--//--//--//--//--//--//--//
			if(GLB_Osc_Status[17][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]==2)
				GLB_Osc_Counter_For_Serial_Osc=0;
			else if(GLB_Osc_Status[17][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]==0){
				GLB_Osc_Counter_For_Serial_Osc++;
				if(GLB_Osc_Counter_For_Serial_Osc==1)
					GLB_Osc_First_Adr_For_Save_Adr_In_Serialy_Osc=GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD;
			}
			//--//--//--//--//--//--//--//
			
			GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD++;
			if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record)
				GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU;
			
			GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu+=28;
			if(GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu==28*GLB_number_Of_Oscillograph_For_Display_On_LCD)
				GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu=0;
			
			//----------S: ??? "????? ?? ????" ?????? ??? ? ???? ?? ?????? ????? ????? ??? ???? ??? ???????(???? ????? ????????
			if(GLB_Osc_Status[17][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC]==3){
				GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD=GLB_Osc_First_Adr_For_Save_Adr_In_Serialy_Osc;
				if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
					read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
				else
					read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);
				
				GLB_CMTRD____Num_Of_Total_Saved_CMTRD-=(GLB_Osc_Counter_For_Serial_Osc+1);
				
				if(GLB_CMTRD____Num_Of_Total_Saved_CMTRD==GLB_Osc____Total_Num_Of_Osc_Can_Record+1)
					SDRAM____1_Block_MMC[4]=1;
				else
					SDRAM____1_Block_MMC[4]=0;
				
				*((uint32_t*)(SDRAM____1_Block_MMC))=GLB_CMTRD____Num_Of_Total_Saved_CMTRD;
				*((uint32_t*)(SDRAM____1_Block_MMC+5))=My_INF;
				
				if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
					Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
				else
					Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);

				GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu-=((GLB_Osc_Counter_For_Serial_Osc+1)*28);
				
				GLB_Osc_Counter_For_Serial_Osc=0;
			}
			//----------E: ??? "????? ?? ????" ?????? ??? ? ???? ?? ?????? ????? ????? ??? ???? ??? ???????(???? ????? ????????

			//sprintf((char *)RAM_UART_BUFF,"%d  %d  %d  %d  %d\n",GLB_Osc_Status[17][GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC], GLB_Osc_First_Adr_For_Save_Adr_In_Serialy_Osc, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD, GLB_Osc_Counter_For_Serial_Osc, GLB_CMTRD____Num_Of_Total_Saved_CMTRD); Panel_Komaki_UARTX_For_Sprintf();
		}
		GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC++;
		if(GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC>=GLB_Osc____Num_Of_Osc_Part_Considered_On_RAM)
			GLB_Counter_Osc_Part_Of_RAM_That_Is_Writing_On_MMC=0;
		
// 		sprintf((char *)RAM_UART_BUFF,"---------------------------------------------- Osc-E  counter=%d\n", GLB_CMTRD____Num_Of_Total_Saved_CMTRD ); Panel_Komaki_UARTX_For_Sprintf();
		GLB_Osc_Recording_Is_On=0;
	}
}
#endif
#if(1) // Panel_Komaki
void Panel_Komaki_Get_Date_For_Osc_From_RAM_To_Display_On_LCD(int32_t address){
	
// sprintf((char *)RAM_UART_BUFF,"adres=%d\n",address); Panel_Komaki_UARTX_For_Sprintf();
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Year			=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 0 ));
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Month			=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 4 ));
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Day_Of_Month	=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 8 ));
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Hour			=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 12));
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Minute		=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 16));
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Second		=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 20));
	GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Mili_Second	=*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + address+ 24));
	if(GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Year==0 && GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Month==0 && GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Day_Of_Month==0 && GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Hour==0 && GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Minute==0 && GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Second==0){
		sprintf(SDRAM____String_Komaki,"%s","Not Saved.");
	}
	else{
		sprintf(SDRAM____String_Komaki,"%4d/%2d/%2d %2d:%2d:%2d.%3d",GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Year, GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Day_Of_Month, GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Month, GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Hour, GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Minute, GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Second, GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Mili_Second);
	}
}
void Panel_Komaki_UARTX_For_Sprintf(void){
	uint32_t j=0, MEM_ADDR=0;
	
	xil_printf(RAM_UART_BUFF);
	
//	MEM_ADDR = (uint32_t) &SDRAM____SERIAL____CPU_TO_FP____BUFFER[SERIAL____CPU_TO_FP____CELL_FILLED____Counter];
//
//	while(RAM_UART_BUFF[j] != 0x00){
//		SDRAM____SERIAL____CPU_TO_FP____BUFFER[SERIAL____CPU_TO_FP____CELL_FILLED____Counter] = RAM_UART_BUFF[j];
//		j+=1U;
//		SERIAL____CPU_TO_FP____CELL_FILLED____Counter = (SERIAL____CPU_TO_FP____CELL_FILLED____Counter + 1U) % SERIAL____CPU_TO_FP____BUFFER____SIZE;
//	}
//
//	if(j%2 != 0){
//		SDRAM____SERIAL____CPU_TO_FP____BUFFER[SERIAL____CPU_TO_FP____CELL_FILLED____Counter-1] = 0x20;
//		SDRAM____SERIAL____CPU_TO_FP____BUFFER[SERIAL____CPU_TO_FP____CELL_FILLED____Counter  ] = 0x0A;
//		SERIAL____CPU_TO_FP____CELL_FILLED____Counter = (SERIAL____CPU_TO_FP____CELL_FILLED____Counter + 1U) % SERIAL____CPU_TO_FP____BUFFER____SIZE;
//		j+=1U;
//	}
	
//	while(CPU____QTL____ADD_ITEM(FP_CPU____Serial____CPU_TO_FP,	0, j/2,	2, MEM_ADDR) != 1U);
}
void Panel_Komaki__TL__Format_MMC_TL_Part(void){
	int32_t i;
	
	memset(SDRAM____1_Block_MMC, 0, 512);	
	
	if(TL___Has_Any_Log == Yes_1){
		if(TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU)
			Write_to_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);	
		else
			Write_to_MMC(SDRAM____1_Block_MMC, TL___Adr_For_Save + (GLB_TL_Max_Numb_Of_TL_Can_Save-1) * GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);	
	}

	TL___Adr_For_Save = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU;
	
	for(i=0; i<GLB_TL__Num_Of_TLs_For_Display_On_LCD; i++){
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 0 ))=0;
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 4 ))=0;
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 8 ))=0;
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 12))=0;
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 16))=0;
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 20))=0;
		*((uint32_t *)(SDRAM____TLs_Name + i*28+ 24))=0;
	}
	
//	TL__Filling_Part=0;
//	TL__Writing_Part=0;
	
//	for(i=0; i<TL__Num_Of_Part_Consid_On_RAM; i++)
//		TL__Status[i]=0;

	TL___Adr_Of_Last_TLs_Name = 0;
	TL___Has_Any_Log = No_0;
	TL___Counter = 0;
}
void Panel_Komaki__EL__Format_MMC_EL_Part(void){
		
	read_from_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
	*(uint32_t*)(SDRAM____1_Block_MMC  )=0;
	*(uint32_t*)(SDRAM____1_Block_MMC+4)=0;
	*(uint32_t*)(SDRAM____1_Block_MMC+8)=0;
	Write_to_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
	
	EL__Adr_For_Save = EL__MMC____FST_BLK____SAVE_EL__CPU;
	
	*(uint32_t*)(SDRAM____1_Block_MMC  ) = EL_Code_For_MMCBLK_That_Is_Filling;
	*(uint32_t*)(SDRAM____1_Block_MMC+4)=0;
	*(uint32_t*)(SDRAM____1_Block_MMC+8)=0;
	Write_to_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
	
//	EL__Filling_Part=0;
//	EL__Writing_Part=0;

//	for(i=0; i<EL__Num_Of_Part_Consid_On_RAM; i++)
//		EL__Status[i]=0;
	
//	GLB_Number_Of_Total_EL_Has_Saved=0;
//	GLB_EL_Number_Of_Events_Line=0;
	
//	GLB_EL_Total_Count=0;
}
void Panel_Komaki__Osc__Format_MMC_Osc_Log_Part(void){	
//	sprintf((char *)RAM_UART_BUFF," Panel_Komaki__Osc__Format_MMC_Osc_Log_Part.......\n"); Panel_Komaki_UARTX_For_Sprintf();
	for(GLB_Format_Osc__i=0;GLB_Format_Osc__i<512;GLB_Format_Osc__i++)
		SDRAM____1_Block_MMC[GLB_Format_Osc__i]=0;

		if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
			Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
		else
			Write_to_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);

	
//	for(GLB_Format_Osc__i=0;GLB_Format_Osc__i<GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record;GLB_Format_Osc__i++){
//		Write_to_MMC(SDRAM____1_Block_MMC, GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU +GLB_Format_Osc__i, 1);
//	}
	
	for(GLB_Format_Osc__i=0;GLB_Format_Osc__i<GLB_number_Of_Oscillograph_For_Display_On_LCD;GLB_Format_Osc__i++){
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 0 ))=0;
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 4 ))=0;
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 8 ))=0;
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 12))=0;
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 16))=0;
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 20))=0;
		*((uint32_t *)(SDRAM____Array_For_Osc_Date_For_Menu + GLB_Format_Osc__i*28+ 24))=0;
	}
	GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu=0;
		
	GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD = GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU;
	GLB_CMTRD____Num_Of_Total_Saved_CMTRD=0;
//	sprintf((char *)RAM_UART_BUFF," Panel_Komaki__Osc__Format_MMC_Osc_Log_Part  Finished\n"); Panel_Komaki_UARTX_For_Sprintf();
}
void Panel_Komaki__TL__Compelete_TL_Indication(int TL_Index){
	int32_t k, i, j, h, Conter; 
	/*
	GLB_TL_Indication__Num_komaki=0;
	GLB_TL_Indication__Adr_For_Save_TL=0;

	k=-1;
	for(i=0; i<GLB_TL_Max_Numb_Of_TL_Can_Save; i++){
		read_from_MMC(SDRAM____1_Block_MMC, GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + i* GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU, 1);
		GLB_TL_Indication__Num_komaki=*((uint32_t*)(SDRAM____1_Block_MMC));
		if(GLB_TL_Indication__Num_komaki==My_INF){
			GLB_TL_Indication__Adr_For_Save_TL = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU*i;
			if(GLB_TL_Indication__Adr_For_Save_TL >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU + GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU*GLB_TL_Max_Numb_Of_TL_Can_Save)
				GLB_TL_Indication__Adr_For_Save_TL = GLB_TL__MMC____FST_BLK____SAVE_TL____CPU;
			k=0;
			break;
		}
	}

	if(k==-1){
		*(uint32_t*)(SDRAM____Measurem_RECORDs_string)=0xFFFFFFFF;
		while(CPU____QTL____ADD_ITEM(FP_CPU____Disp_Record__TL, 0, 4, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string)!= 1U);
	}
	else{
		i=TL_Index-1;
		GLB_TL_Indication__Adr=GLB_TL_Indication__Adr_For_Save_TL-GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU*i;

		if(GLB_TL_Indication__Adr<GLB_TL__MMC____FST_BLK____SAVE_TL____CPU)
			GLB_TL_Indication__Adr=GLB_TL_Indication__Adr+ GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU* GLB_TL_Max_Numb_Of_TL_Can_Save;
		read_from_MMC(SDRAM____4_Block_MMC, GLB_TL_Indication__Adr , 4);
		
		GLB_TL_Indication__TL_Count_Of_Event_In_This_PU=*((uint32_t*)(SDRAM____4_Block_MMC+4));			

		if(GLB_TL_Indication__TL_Count_Of_Event_In_This_PU<15 || SDRAM____4_Block_MMC[10]==0 || SDRAM____4_Block_MMC[10]==0){
			*(uint32_t*)(SDRAM____Measurem_RECORDs_string)=0xFFFFFFFF;
			while(CPU____QTL____ADD_ITEM(FP_CPU____Disp_Record__TL, 0, 4, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string)!= 1U);
		}
		else{
			Conter=0;
			sprintf(SDRAM____Measurem_RECORDs_string,"(%d/%d/%d %d:%d:%d.%d)\n",*(uint16_t *)(SDRAM____4_Block_MMC +8), SDRAM____4_Block_MMC[11], SDRAM____4_Block_MMC[10], SDRAM____4_Block_MMC[12], SDRAM____4_Block_MMC[13], SDRAM____4_Block_MMC[14], *((uint16_t *)(SDRAM____4_Block_MMC+ 15 )) ) ;
			sprintf(SDRAM____Measurem_RECORDs_string+GLB____LCD____Max_Num_Of_Char_In_a_Lines,"%d", (GLB_TL_Indication__TL_Count_Of_Event_In_This_PU-GLB_TL__Num_Of_Bytes_for_Analog_and_DtaeTime)/7) ; 
			
			read_from_MMC(SDRAM____4_Block_MMC, GLB_TL_Indication__Adr+ 4, 4);
			j=0;
			h=2;
			for(k=0; k<(GLB_TL_Indication__TL_Count_Of_Event_In_This_PU-GLB_TL__Num_Of_Bytes_for_Analog_and_DtaeTime)/7; k++){
				
				if(j*(VFC____SIGNAL_LABEL_AND_NAME__Size+5)>=2048){
					h++;
					read_from_MMC(SDRAM____4_Block_MMC, GLB_TL_Indication__Adr+4*h , 4);
					j=0;
				}
				
				sprintf(SDRAM____Measurem_RECORDs_string+ (Conter+2)*GLB____LCD____Max_Num_Of_Char_In_a_Lines ," %s", (char *)(SDRAM____4_Block_MMC + (VFC____SIGNAL_LABEL_AND_NAME__Size+5)* j + VFC____SIGNAL_LABEL__Size));
				//sprintf(SDRAM____Measurem_RECORDs_string+ (Conter+2)*GLB____LCD____Max_Num_Of_Char_In_a_Lines ,"%s%d", " ", *((uint16_t *)(SDRAM____4_Block_MMC+ GLB_TL__Num_Of_Bytes_for_Analog_and_DtaeTime+ 7*k)));
				if(SDRAM____4_Block_MMC[(VFC____SIGNAL_LABEL_AND_NAME__Size+5)* j + VFC____SIGNAL_LABEL__Size +VFC____SIGNAL_NAME__Size +4]==0)
					sprintf(SDRAM____Measurem_RECORDs_string+ (Conter+2)*GLB____LCD____Max_Num_Of_Char_In_a_Lines +25,"%s","OFF");
				else
					sprintf(SDRAM____Measurem_RECORDs_string+ (Conter+2)*GLB____LCD____Max_Num_Of_Char_In_a_Lines +25,"%s","ON");
				sprintf(SDRAM____Measurem_RECORDs_string+ (Conter+2)*GLB____LCD____Max_Num_Of_Char_In_a_Lines +29,"%d ms",(*((uint32_t *)(SDRAM____4_Block_MMC+ (VFC____SIGNAL_LABEL_AND_NAME__Size+5)* j + VFC____SIGNAL_LABEL__Size +VFC____SIGNAL_NAME__Size)))/1000);
				
				Conter++;
				j++;
			}
			
			while(CPU____QTL____ADD_ITEM(FP_CPU____Disp_Record__TL, 0,GLB____LCD____Max_Num_Of_Lines* GLB____LCD____Max_Num_Of_Char_In_a_Lines, 4, GLB__SDRM_START_BYTE____Measurem_RECORD_string)!= 1U);
		}
	}	
	*/
}
void Panel_Komaki__Osc__Disp_On_LCD(int Osc_Index){
	/*
	int32_t Point_Conter=0, Start, i, n, j, S=0, H=0, k;
	int32_t x1=0;
	int32_t x2=0;
	int32_t Mid_Point=0;
	int32_t Last_Sample_Num=0;
	int32_t Last_VI=0;
	int32_t New_VI=0;	
	int32_t Num_ADs_Read_For_1A_Or_1V=0;
	int32_t Num_Of_Total_Saved_Osc=0;
	int32_t Exceed_From_Max_Num_Of_Osc=0;
	int32_t Adr_Of_Firs_Blk_Of_VI_Data_Osc=0;

	if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==0)     { Num_ADs_Read_For_1A_Or_1V= GLB_Number_ADs_Read_For_100V_PT1;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==1){ Num_ADs_Read_For_1A_Or_1V= GLB_Number_ADs_Read_For_100V_PT2;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==2){ Num_ADs_Read_For_1A_Or_1V= GLB_Number_ADs_Read_For_100V_PT3;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==3){ Num_ADs_Read_For_1A_Or_1V= GLB_Number_ADs_Read_For_100V_PT4;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==4){ Num_ADs_Read_For_1A_Or_1V= GLB_Num_ADs_Read_For_CT1_At_Rated_Current;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==5){ Num_ADs_Read_For_1A_Or_1V= GLB_Num_ADs_Read_For_CT2_At_Rated_Current;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==6){ Num_ADs_Read_For_1A_Or_1V= GLB_Num_ADs_Read_For_CT3_At_Rated_Current;} 
	else if(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C==7){ Num_ADs_Read_For_1A_Or_1V= GLB_Num_ADs_Read_For_CT4_At_Rated_Current;} 
	//----------E: ???? ?????? ?? ???? ???? ??? ?????? ----------	
	
//	sprintf(RAM_UART_BUFF," Oscillograph:\n"); Panel_Komaki_UARTX_For_Sprintf();	
//	sprintf(RAM_UART_BUFF," GLB_Osc_Print__Num_ADs_Read_For_1A_Or_1V=%d\n", GLB_Osc_Print__Num_ADs_Read_For_1A_Or_1V); Panel_Komaki_UARTX_For_Sprintf();	
	
	//----------S: ???? ????? ?? ???? ??? ????????? ?? ???? ????? ??? ???? ?????? ----------	
	for(i=0; i<GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record; i++){
		read_from_MMC(SDRAM____1_Block_MMC, GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU+i, 1);
		Num_Of_Total_Saved_Osc=(*(uint32_t*)(SDRAM____1_Block_MMC)); 
		Exceed_From_Max_Num_Of_Osc=SDRAM____1_Block_MMC[4];
		if(Num_Of_Total_Saved_Osc!=0){
			break;
		}
	}
	//----------E: ???? ????? ?? ???? ??? ????????? ?? ???? ????? ??? ???? ?????? ----------	
	if(Num_Of_Total_Saved_Osc==0){
		*(uint32_t*)(SDRAM____Measurem_RECORDs_string)=0xFFFFFFFF;
		while(CPU____QTL____ADD_ITEM(FP_CPU____Disp_Record__Osc, 0, 4, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string)!= 1U);
	}
	else{
		//----------S: ??? ??? ????????? ????? ??? ???? ----------	
		if(Exceed_From_Max_Num_Of_Osc==1 || Osc_Index-1<Num_Of_Total_Saved_Osc){
			//----------S: ???? ????? ? ????? ????? ?? ??? ????????? ?? ???? ????? ??? ???? ?????? ----------	
			n=(Num_Of_Total_Saved_Osc-Osc_Index);
			if(n<0)
				n+=GLB_Osc____Total_Num_Of_Osc_Can_Record;
	
			Adr_Of_Firs_Blk_Of_VI_Data_Osc= GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU+ n* GLB_Osc____Total_Num_Of_uSDBlocks___For_Any_Osc+4;
			read_from_MMC(SDRAM____4_Block_MMC, Adr_Of_Firs_Blk_Of_VI_Data_Osc-4, 4);
			GLB_Osc_Print__Adr_Of_Last_Blk_Of_VI_Data_Osc=*((uint32_t*)(SDRAM____4_Block_MMC));
			Last_Sample_Num=	*((uint32_t*)(SDRAM____4_Block_MMC+4));
			GLB_Osc_Print__Adr_For_Save_First_Two_Rows_Of_CFG=*((uint32_t*)(SDRAM____4_Block_MMC+8));
			GLB_Osc_Print__Adr_For_Save_End_7_Rows_Of_CFG=	*((uint32_t*)(SDRAM____4_Block_MMC+12));	
			GLB_Osc_Print__First_Adr_of_Digital_Inf_in_CFG=	*((uint32_t*)(SDRAM____4_Block_MMC+16));	
			//----------E: ???? ????? ? ????? ????? ?? ??? ????????? ?? ???? ????? ??? ???? ?????? ----------	
			read_from_MMC(SDRAM____4_Block_MMC, GLB_Osc_Print__Adr_Of_Last_Blk_Of_VI_Data_Osc, 4);
			GLB_Osc_Print__max=(*((uint32_t*)(SDRAM____4_Block_MMC+(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C<<2))));
			//sprintf(RAM_UART_BUFF," GLB_Osc_Print__max= %3d \n\n", GLB_Osc_Print__max); Panel_Komaki_UARTX_For_Sprintf();
			//----------S: ???????? ??? ?? ????? ?????? ? ??? ?????? ??? ??????? ----------	
//			{
//				for(i=0;i<GLB____LCD____Max_Num_Of_Char_In_a_Lines; i++){
////					SDRAM____New_LCD_Chars_Show_On_LCD[0 *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ i]=' ';
////					RAM_Old_LCD_Chars_Show_On_LCD[1 *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ i]=' ';
//				}
//				for(i=0;i<GLB____LCD____Max_Num_Of_Char_In_a_Lines; i++){
////					SDRAM____New_LCD_Chars_Show_On_LCD[15 *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ i]=' ';
////					RAM_Old_LCD_Chars_Show_On_LCD[15 *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ i]=' ';
//				}
//				for(j=0;j<15; j++){
//					for(i=0; i<5; i++){
////						SDRAM____New_LCD_Chars_Show_On_LCD[j *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ i]=' ';
////						RAM_Old_LCD_Chars_Show_On_LCD[j *GLB____LCD____Max_Num_Of_Char_In_a_Lines+ i]=' ';
//					}
//				}
//			}

			GLB_Osc_Zoom_Factor=GLB_Osc_Print__max/54+1;
			if(GLB_Osc_Zoom_Factor==0)
				GLB_Osc_Zoom_Factor=15; 

			read_from_MMC(SDRAM____4_Block_MMC, GLB_Osc_Print__Adr_For_Save_First_Two_Rows_Of_CFG, 4);
			GLB_Osc_Print__Num_of_Analog_channels =SDRAM____4_Block_MMC[56];
			GLB_Osc_Print__Num_of_Digital_chanels=SDRAM____4_Block_MMC[57];
			strncpy(SDRAM____String_Komaki,(char*)(SDRAM____4_Block_MMC), GLB____LCD____Max_Num_Of_Char_In_a_Lines);

//			sprintf(RAM_UART_BUFF,"GLB_Osc_Print__Last_Sample_Num=%d\n", GLB_Osc_Print__Last_Sample_Num); Panel_Komaki_UARTX_For_Sprintf();
			
			Mid_Point=105 + GLB_Osc_Plot_Left_Right;
			Start=10;
//		sprintf(RAM_UART_BUFF,"adr=%d\n", GLB_Osc_Print__Adr_Of_Firs_Blk_Of_VI_Data_Osc); Panel_Komaki_UARTX_For_Sprintf();
			for(i=Adr_Of_Firs_Blk_Of_VI_Data_Osc; i<GLB_Osc_Print__Adr_For_Save_First_Two_Rows_Of_CFG; i+=4){
				read_from_MMC(SDRAM____4_Block_MMC, i, 4);
				//sprintf(RAM_UART_BUFF,"GLB_Osc_Print__i=%d\n", GLB_Osc_Print__i); Panel_Komaki_UARTX_For_Sprintf();
//	sprintf(RAM_UART_BUFF," Adr=%8d\n", GLB_Osc_Print__i); Panel_Komaki_UARTX_For_Sprintf();

				for(j=0; j<(2048/(GLB_Osc_Print__Num_of_Analog_channels*GLB_4_Byte+(GLB_Osc_Print__Num_of_Digital_chanels>>3)+1)); j++){
					for(k=0; k<GLB_Osc_Print__Num_of_Analog_channels; k++){
						
						GLB_Osc_Print__VI=*((int16_t*)(SDRAM____4_Block_MMC + j* (GLB_Osc_Print__Num_of_Analog_channels*GLB_4_Byte+(GLB_Osc_Print__Num_of_Digital_chanels>>3)+1) +GLB_4_Byte*k));
						if(k==GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C){
//sprintf(RAM_UART_BUFF,"%6d %6d\n", GLB_Osc_Print__VI, j* (GLB_Osc_Print__Num_of_Analog_channels*GLB_4_Byte+(GLB_Osc_Print__Num_of_Digital_chanels>>1)+1) +GLB_4_Byte*k); Panel_Komaki_UARTX_For_Sprintf();
							S++;
														
							//if(S > Mid_Point-105/GLB_Osc_Horiz_Zoom_Factor   &&   S<Mid_Point+105/GLB_Osc_Horiz_Zoom_Factor && (105 +31 - GLB_Osc_Horiz_Zoom_Factor*(Mid_Point- S))<240){
								if(H==1){
									New_VI=59 -GLB_Osc_Print__VI/GLB_Osc_Zoom_Factor;
									if(Last_VI>=0 && Last_VI<128 && New_VI>=0 && New_VI<128){
//										if(GLB_ENTER_KEY_Is_Select==1 && GLB_Ready_For_Save_User_Setting==0){
// 										sprintf(RAM_UART_BUFF,"%5d   j=%4d  H=%4d  S=%4d  Panel_Komaki_AAA=%d\n", GLB_Osc_Print__VI, j, H, S, GLB_Osc_Print__i); Panel_Komaki_UARTX_For_Sprintf();
//										}
										
										x1= 105 +31 - GLB_Osc_Horiz_Zoom_Factor*(Mid_Point- (S-1));
										x2= 105 +31 - GLB_Osc_Horiz_Zoom_Factor*(Mid_Point- S);
//										T6963_240_128_Line( GLB_Osc_Print__x1, GLB_Osc_Print__Last_VI , GLB_Osc_Print__x2, GLB_Osc_Print__New_VI);
										//*(uint16_t*)(SDRAM____Measurem_RECORDs_string+Start+8*Point_Conter)=x1;
										//*(uint16_t*)(SDRAM____Measurem_RECORDs_string+Start+8*Point_Conter+2)=Last_VI;
										//*(uint16_t*)(SDRAM____Measurem_RECORDs_string+Start+8*Point_Conter+4)=x2;
										*(uint16_t*)(SDRAM____Measurem_RECORDs_string+Start+2*Point_Conter)=New_VI;
										Point_Conter++;
//sprintf(RAM_UART_BUFF,"%6d\n",  New_VI); Panel_Komaki_UARTX_For_Sprintf();
									}
								}
								if(H==0)  H++;
								Last_VI=59-GLB_Osc_Print__VI/GLB_Osc_Zoom_Factor;
							//}
							if(S>=Last_Sample_Num)
								break;
						}
					}
					if(S>=Last_Sample_Num)
						break;
				}
				if(S>=Last_Sample_Num)
					break;
			}
			
			*(uint16_t*)(SDRAM____Measurem_RECORDs_string)=Point_Conter;
			*(uint32_t*)(SDRAM____Measurem_RECORDs_string+2)=Num_ADs_Read_For_1A_Or_1V;
			*(uint32_t*)(SDRAM____Measurem_RECORDs_string+6)=GLB_Osc_Print__max;
			while(CPU____QTL____ADD_ITEM(FP_CPU____Disp_Record__Osc, 0, 5+Point_Conter*4, 2, GLB__SDRM_START_BYTE____Measurem_RECORD_string)!= 1U);
		}
		else{
			*(uint32_t*)(SDRAM____Measurem_RECORDs_string)=0xFFFFFFFF;
			while(CPU____QTL____ADD_ITEM(FP_CPU____Disp_Record__Osc, 0, 4, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string)!= 1U);
		}
	}
	GLB_Ready_For_Save_User_Setting=1;
	*/
}
void sprintf__Double_as_string(int32_t A32, int32_t B32, int32_t C32, int32_t D32, int32_t Zarib_baraye_taghsime_Integer, int32_t Num_Of_Decimal_Digit, char *extern_String){
	// A*B/C/D  -->  A*B*10^Zarib_baraye_taghsime_Integer/C/D
	// Number_Of_Decimal_Digit_To_Show: ????? ??????? ????? ?? ???? ???? ????
	
	int64_t A;
	int64_t B;
	int64_t C;
	int64_t D;
	int64_t Result;
	int32_t n= 1;
	int32_t  sign = 1;
	char     LCL_String_Komaki[10] = { "\0" };
	
	sprintf(LCL_String_Komaki, "%s", "\0");
	GLB_Int_to_Double_To_Char_Resulu_Is_Zero = 0;

	if (A32 >= 0){
		A = (int64_t)A32;
	sign = 1;
	}
	else{
		A = (int64_t)(-A32);
		sign = -1;
	}
		
	B = (int64_t)B32;
	C = (int64_t)C32;
	D = (int64_t)D32;

	Result = A *POWER_10_64bit[Zarib_baraye_taghsime_Integer] * B / C / D;
	GLB_Int32_Result_From_sprintf_Into_Double_To_Char = sign*(int32_t)(A *POWER_10_64bit[Zarib_baraye_taghsime_Integer] * B / C / D/POWER_10_64bit[Zarib_baraye_taghsime_Integer]);

	if(GLB_Int32_Result_From_sprintf_Into_Double_To_Char<((1<<29)/10))
		GLB_Int32_Result_From_sprintf_Into_Double_To_Char_Multip_10=sign*(int32_t)(A *POWER_10_64bit[Zarib_baraye_taghsime_Integer] * B*10 / C / D/POWER_10_64bit[Zarib_baraye_taghsime_Integer]);
	else
		GLB_Int32_Result_From_sprintf_Into_Double_To_Char_Multip_10=0;
	
	sprintf(extern_String, "%s", "\0");
	Integer_part_64bit = Result / (POWER_10_64bit[Zarib_baraye_taghsime_Integer]);
	Decimal_part_64bit = (Result - Integer_part_64bit * POWER_10_64bit[Zarib_baraye_taghsime_Integer]) / POWER_10_64bit[Zarib_baraye_taghsime_Integer - Num_Of_Decimal_Digit];
	if (Decimal_part_64bit<0)
		Decimal_part_64bit *= (-1);
	if (Integer_part_64bit==0 && Decimal_part_64bit==0){
		GLB_Int_to_Double_To_Char_Resulu_Is_Zero = 1;
		sign = 1;
	}


	if (sign==1){
		if (Num_Of_Decimal_Digit != 0)
			sprintf(extern_String, "%llu.", Integer_part_64bit);
		else
			sprintf(extern_String, "%llu", Integer_part_64bit);
	}
	else{
		if (Num_Of_Decimal_Digit != 0)
			sprintf(extern_String, "-%llu.", Integer_part_64bit);
		else
			sprintf(extern_String, "-%llu", Integer_part_64bit);
	}
	if (Decimal_part_64bit==0){
		for (n = 0; n<Num_Of_Decimal_Digit; n++)
			strcat(extern_String, "0");
	}
	else{
		while (Decimal_part_64bit*POWER_10[n] < POWER_10[Num_Of_Decimal_Digit]){ 
			n++;
			strcat(extern_String, "0");
		}
		sprintf(LCL_String_Komaki, "%llu", Decimal_part_64bit);
		strcat(extern_String, LCL_String_Komaki);
	}
}
#endif
#if(1) // AD
void AD_CalculateDate(void){
	if(Glb_nmea_msg.utc.hour>23){
		Glb_nmea_msg.utc.hour-=24;
		Glb_nmea_msg.utc.date++;
		if((Glb_nmea_msg.utc.month==1 && Glb_nmea_msg.utc.date==31)|| \
		(Glb_nmea_msg.utc.month==2 && Glb_nmea_msg.utc.date==29 && Glb_nmea_msg.utc.year%4==0)|| \
		(Glb_nmea_msg.utc.month==2 && Glb_nmea_msg.utc.date==30 && Glb_nmea_msg.utc.year%4!=0)|| \
		(Glb_nmea_msg.utc.month==3 && Glb_nmea_msg.utc.date==31)|| \
		(Glb_nmea_msg.utc.month==4 && Glb_nmea_msg.utc.date==30)|| \
		(Glb_nmea_msg.utc.month==5 && Glb_nmea_msg.utc.date==31)|| \
		(Glb_nmea_msg.utc.month==6 && Glb_nmea_msg.utc.date==30)|| \
		(Glb_nmea_msg.utc.month==7 && Glb_nmea_msg.utc.date==31)|| \
		(Glb_nmea_msg.utc.month==8 && Glb_nmea_msg.utc.date==31)|| \
		(Glb_nmea_msg.utc.month==9 && Glb_nmea_msg.utc.date==30)|| \
		(Glb_nmea_msg.utc.month==10 && Glb_nmea_msg.utc.date==31)|| \
		(Glb_nmea_msg.utc.month==11 && Glb_nmea_msg.utc.date==30)|| \
		(Glb_nmea_msg.utc.month==12 && Glb_nmea_msg.utc.date==31)){
			Glb_nmea_msg.utc.date=1;
			Glb_nmea_msg.utc.month++;
			if(Glb_nmea_msg.utc.month==13){
				Glb_nmea_msg.utc.month=1;
				Glb_nmea_msg.utc.year++;
			}
		}
	}
}

void Irq_500us(void *CallBackRef) {

	Xil_EnableNestedInterrupts();
	uwTick_500us += 1U;

	uint32_t i = 0;

	for(i=0; i<AXI_BUS_SPI_DATA_COUNT; i++){
		GPS_SYNCHRONIZER____AXI_BUS____DATA_READ[i] = GPS_SYNCHRONIZER____AXI_BUS[i];
		GPS_SYNCHRONIZER____AXI_BUS[i] = GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[i];
	}



//	for(i=0; i<TRHA__SIZE; i++){
//		RHA[i] = GPS_SYNCHRONIZER____AXI_BUS[i];
//	}
//
//	for(i=0; i<TSHA__SIZE; i++){
//		GPS_SYNCHRONIZER____AXI_BUS[i] = SHA[i];
//	}



	Xil_DisableNestedInterrupts();
}
#endif
#if(1) // Calibration
void Check_Validation_Of_FFT_Scale_Factors(int32_t First_CTPT_Index){
	int32_t CTPT_Index;
	int32_t H1__Max;
	int32_t H1__Min;
	int32_t H2__Max;
	int32_t H2__Min;
	
	for(CTPT_Index = First_CTPT_Index; CTPT_Index < GLB_Num_Of_Available_CTPT ; CTPT_Index++){
		//----------S: H1 CLB FACTORs ----------
		switch(CALIB_DATA__Magni__Part1[4][CTPT_Index]){
			case PT:{
				H1__Max	= PT_Calib___H1_ScaleFactor___Max;			
				H1__Min	= PT_Calib___H1_ScaleFactor___Min;			
				H2__Max	= PT_Calib___H2_ScaleFactor___Max;			
				H2__Min	= PT_Calib___H2_ScaleFactor___Min;			
			}
			break;
			case CT:{
				H1__Max	= CT_Calib___H1_ScaleFactor___Max;			
				H1__Min	= CT_Calib___H1_ScaleFactor___Min;			
				H2__Max	= CT_Calib___H2_ScaleFactor___Max;			
				H2__Min	= CT_Calib___H2_ScaleFactor___Min;			
			}
			break;
		}
		if(CALIB_DATA__Magni__Part1[2][CTPT_Index] > H1__Max || CALIB_DATA__Magni__Part1[2][CTPT_Index] < H1__Min || \
			 CALIB_DATA__Magni__Part1[3][CTPT_Index] > H2__Max || CALIB_DATA__Magni__Part1[3][CTPT_Index] < H2__Min)
				GLB____Hardware_Fault__Message[1] |= (One<<Err____Calib____FFT_Factors);
		//----------E: H1 CLB FACTORs ----------
	}
}
void Check__Ref_Calib_Factor_Validation_For_Disp(void){
	int32_t CTPT_Index;
	
	for(CTPT_Index=0; CTPT_Index<GLB_Num_Of_Available_CTPT ; CTPT_Index++){
		if(CALIB_DATA__Magni__Part1[4][CTPT_Index]==PT){
			if(CALIB_DATA__Magni__Part1[0][CTPT_Index]<PT_Calib_Ref_Min){
				sprintf((char *)RAM_UART_BUFF, "M#%3d Ref < %d\n", CTPT_Index+1, PT_Calib_Ref_Min); Panel_Komaki_UARTX_For_Sprintf();
			}
			else if(CALIB_DATA__Magni__Part1[0][CTPT_Index]>PT_Calib_Ref_Max){
				sprintf((char *)RAM_UART_BUFF, "M#%3d Ref > %d\n", CTPT_Index+1, PT_Calib_Ref_Max); Panel_Komaki_UARTX_For_Sprintf();
			}
		}
		else{
			if(CALIB_DATA__Magni__Part1[0][CTPT_Index]<CT_Calib_Ref_Min){
				sprintf((char *)RAM_UART_BUFF, "M#%3d Ref < %d\n", CTPT_Index+1, CT_Calib_Ref_Min); Panel_Komaki_UARTX_For_Sprintf();
			}
			else if(CALIB_DATA__Magni__Part1[0][CTPT_Index]>CT_Calib_Ref_Max){
				sprintf((char *)RAM_UART_BUFF, "M#%3d Ref > %d\n", CTPT_Index+1, CT_Calib_Ref_Max); Panel_Komaki_UARTX_For_Sprintf();
			}
		}
	}
}
void FILL_RAM_CARDS_FLASH_DATA__Komaki(int32_t CTPT_Cont_In_This_Card, int32_t POINT, int32_t CTPTs__In_All_Cards__Conter, int8_t Reset_0____Else_1){
	int32_t   CTPT_Conter, Card_Conter=-1, i;
	
	for(CTPT_Conter=0; CTPT_Conter<CTPT_Cont_In_This_Card; CTPT_Conter++){
		for(i=0; i<6; i++){
			SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Conter*(2*GLB_Calib__VI_Max_Steps_Count+12)+2*i  ]=Reset_0____Else_1* CALIB_DATA__Magni__Part1[i][CTPTs__In_All_Cards__Conter+ CTPT_Conter];
			SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Conter*(2*GLB_Calib__VI_Max_Steps_Count+12)+2*i+1]=Reset_0____Else_1* CALIB_DATA__Magni__Part1[i][CTPTs__In_All_Cards__Conter+ CTPT_Conter]>>16;
		}
		for(i=0; i<GLB_Calib__VI_Max_Steps_Count; i++)
			SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Conter*(2*GLB_Calib__VI_Max_Steps_Count+12)+12+i]=Reset_0____Else_1* CALIB_DATA__Magni__Part2[i][CTPTs__In_All_Cards__Conter+ CTPT_Conter];
		for(i=0; i<GLB_Calib__VI_Max_Steps_Count; i++)
			SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Conter*(2*GLB_Calib__VI_Max_Steps_Count+12)+12+GLB_Calib__VI_Max_Steps_Count+i]=Reset_0____Else_1* CALIB_DATA__Phase_Angle[i][CTPTs__In_All_Cards__Conter+ CTPT_Conter];
	}
}
void FILL_RAM_CARDS_FLASH_DATA(int8_t Reset_0____Else_1){
	int32_t   Card_Conter=-1;
	int32_t   POINT=0, Unit_Index, Card_Index, CTPTs__In_All_Cards__Conter=0;
	uint32_t i = 0U;

	while(Device_DB[i].NID != 0U){

		MP_UNIT[Unit_Index][Card_Index].TYPE = Device_DB[i].NID;
		Card_Conter++;
		POINT=(4096* Card_Conter)/2;

		for(uint32_t j=0; j<CARD_Specifications____Max_Card_Type; j++){
			if(CARD_Specifications[j][0] == 0U) break;

			 if(Device_DB[i].NID == CARD_Specifications[j][0]){

				// [CARD_ID]		[READ_CYCLE]	[WRITE_CYCLE]	[NUM_OF_PTS]	[NUM_OF_CTS]	[NUM_OF_INPUTS]		[NUM_OF_OUTPUTS]	[REF_CALIB_CHANNEL]		[CARD_NAME]

				switch(MP_UNIT[Unit_Index][Card_Index].TYPE){
					case 0xA1:{ // PS

					}
					break;

					case 0xA2:{ // 4_CT__6_BI
						if(Calib_Mode==0 || (Unit_Index==MP_MASTER && Card_Index==CARD_SLOT_4))
							FILL_RAM_CARDS_FLASH_DATA__Komaki(CARD_Specifications[j][4], POINT, CTPTs__In_All_Cards__Conter, Card_Index==CARD_SLOT_4?Reset_0____Else_1:1);
						CTPTs__In_All_Cards__Conter+=CARD_Specifications[j][4];
					}
					break;

					case 0xA4:{ // 4_PT__4_BO
						if(Calib_Mode==0 || (Unit_Index==MP_MASTER && Card_Index==CARD_SLOT_4))
							FILL_RAM_CARDS_FLASH_DATA__Komaki(CARD_Specifications[j][3], POINT, CTPTs__In_All_Cards__Conter, Card_Index==CARD_SLOT_4?Reset_0____Else_1:1);
						CTPTs__In_All_Cards__Conter+=CARD_Specifications[j][3];
					}
					break;
		//			case CARD_TYPE____E1:{
		//			}
		//			break;
		//			case CARD_TYPE____12_CT:{
		//				if(Calib_Mode==0 || (Unit_Index==MP_MASTER && Card_Index==CARD_SLOT_4))
		//					FILL_RAM_CARDS_FLASH_DATA__Komaki(CARD_TYPE____12_CT____NUM_OF_CTS, POINT, CTPTs__In_All_Cards__Conter, Card_Index==CARD_SLOT_4?Reset_0____Else_1:1);
		//				CTPTs__In_All_Cards__Conter+=CARD_TYPE____12_CT____NUM_OF_CTS;
		//			}
		//			break;
		//			case CARD_TYPE____9_BI__9_BO:{
		//			}
		//			break;
				}


				// Device_DB[i].Calibration_Data_Read_Status  -> 4KB



				break;
			 }
		}

		i += 1U;
	}








//
//
//	for(Unit_Index=MP_MASTER; Unit_Index<=MP_SLAVE_8; Unit_Index++){
//		for(Card_Index=CARD_SLOT_1; Card_Index<=CARD_SLOT_4; Card_Index++){
//			MP_UNIT[Unit_Index][Card_Index].TYPE = HW__Check__CARD_TYPE(SDRAM____CARDS_FLASH_DATA[(Unit_Index* NUM_OF_UNIT_CARDS+ Card_Index)* 2048]);  // Array "SDRAM____CARDS_FLASH_DATA" is 16bit
//			Card_Conter++;
//			if(MP_UNIT[Unit_Index][Card_Index].TYPE != RESPOND_UNKNOWN){
//				POINT=(4096* Card_Conter+ GLB_CPU_MP__Calib_Data__Start_Byte)/2;
//				switch(MP_UNIT[Unit_Index][Card_Index].TYPE){
//					case CARD_TYPE____PS:{
//					}
//					break;
//					case CARD_TYPE____4_CT__6_BI:{
//						if(Calib_Mode==0 || (Unit_Index==MP_MASTER && Card_Index==CARD_SLOT_4))
//							FILL_RAM_CARDS_FLASH_DATA__Komaki(CARD_TYPE____4_CT__6_BI____NUM_OF_CTS, POINT, CTPTs__In_All_Cards__Conter, Card_Index==CARD_SLOT_4?Reset_0____Else_1:1);
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____4_CT__6_BI____NUM_OF_CTS;
//					}
//					break;
//					case CARD_TYPE____4_PT__6_BO:{
//						if(Calib_Mode==0 || (Unit_Index==MP_MASTER && Card_Index==CARD_SLOT_4))
//							FILL_RAM_CARDS_FLASH_DATA__Komaki(CARD_TYPE____4_PT__6_BO____NUM_OF_PTS, POINT, CTPTs__In_All_Cards__Conter, Card_Index==CARD_SLOT_4?Reset_0____Else_1:1);
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____4_PT__6_BO____NUM_OF_PTS;
//					}
//					break;
//					case CARD_TYPE____E1:{
//					}
//					break;
//					case CARD_TYPE____12_CT:{
//						if(Calib_Mode==0 || (Unit_Index==MP_MASTER && Card_Index==CARD_SLOT_4))
//							FILL_RAM_CARDS_FLASH_DATA__Komaki(CARD_TYPE____12_CT____NUM_OF_CTS, POINT, CTPTs__In_All_Cards__Conter, Card_Index==CARD_SLOT_4?Reset_0____Else_1:1);
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____12_CT____NUM_OF_CTS;
//					}
//					break;
//					case CARD_TYPE____9_BI__9_BO:{
//					}
//					break;
//				}
//			}
//		}
//	}
}
void READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(int32_t CTPT_Cont_In_This_Card, int32_t POINT, int32_t CTPTs__In_All_Cards__Conter){
	int32_t   CTPT_Index, i;

	if(Calib_Mode==0 && !Simulation_Flag){
		for(CTPT_Index=0; CTPT_Index<CTPT_Cont_In_This_Card; CTPT_Index++){
			for(i=0; i<6; i++)
				CALIB_DATA__Magni__Part1[i][CTPTs__In_All_Cards__Conter+ CTPT_Index]=((SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Index*(2*GLB_Calib__VI_Max_Steps_Count+12)+2*i  ])) + ((SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Index*(2*GLB_Calib__VI_Max_Steps_Count+12)+2*i+1])<<16);
			for(i=0; i<GLB_Calib__VI_Max_Steps_Count; i++)
				CALIB_DATA__Magni__Part2[i][CTPTs__In_All_Cards__Conter+ CTPT_Index] = SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Index*(2*GLB_Calib__VI_Max_Steps_Count+12)+12+i];
			for(i=0; i<GLB_Calib__VI_Max_Steps_Count; i++)
				CALIB_DATA__Phase_Angle[i][CTPTs__In_All_Cards__Conter+ CTPT_Index] = SDRAM____CARDS_FLASH_DATA[POINT + CTPT_Index*(2*GLB_Calib__VI_Max_Steps_Count+12)+12+GLB_Calib__VI_Max_Steps_Count+i];
		}
	}
}
void READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA(void){
	int32_t   CTPT_Cont, Card_Conter=-1, CTPT_Index;
	int32_t   POINT=0, Unit_Index, Card_Index, CTPTs__In_All_Cards__Conter=0, i=0;

	while(Device_DB[i].NID != 0U){

		MP_UNIT[Unit_Index][Card_Index].TYPE = Device_DB[i].NID;
		Card_Conter++;
		POINT=(4096* Card_Conter)/2;

		for(uint32_t j=0; j<CARD_Specifications____Max_Card_Type; j++){
			if(CARD_Specifications[j][0] == 0U) break;

			 if(Device_DB[i].NID == CARD_Specifications[j][0]){

				// [CARD_ID]		[READ_CYCLE]	[WRITE_CYCLE]	[NUM_OF_PTS]	[NUM_OF_CTS]	[NUM_OF_INPUTS]		[NUM_OF_OUTPUTS]	[REF_CALIB_CHANNEL]		[CARD_NAME]

				switch(MP_UNIT[Unit_Index][Card_Index].TYPE){
//					case CARD_TYPE____PS:{
//					}
//					break;
//					case CARD_TYPE____CPU:{
//					}
//					break;
					case 0xA2:{ //CARD_TYPE____4_CT__6_BI
						READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(CARD_Specifications[j][4], POINT, CTPTs__In_All_Cards__Conter);

//						if(Unit_Index == MP_MASTER && Calib_Mode != 0){
//							if(Card_Index == CARD_SLOT_4){
//								Calib____Num_Of_CTPTs_On_4th_Card_For_Calib = CARD_TYPE____4_CT__6_BI____NUM_OF_CTS;
//								for(CTPT_Index = 0; CTPT_Index < CARD_TYPE____4_CT__6_BI____NUM_OF_CTS; CTPT_Index++)
//									CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter + CTPT_Index] = CT;
//							}
//							else if(Card_Index==CARD_SLOT_3)
//								Calib____Ref_Phase_Angle____CTPT_Index = CARD_TYPE____4_CT__6_BI____REF_CALIB_CHANNEL;
//						}

						CTPTs__In_All_Cards__Conter+=CARD_Specifications[j][4];
						GLB_Num_Of_Available_CTPT+=CARD_Specifications[j][4];
						GLB_Num_Of_Available_Inputs+=CARD_Specifications[j][5];
					}
					break;
					case 0xA4:{ //CARD_TYPE____4_PT__6_BO
						READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(CARD_Specifications[j][3], POINT, CTPTs__In_All_Cards__Conter);

//						if(Unit_Index==MP_MASTER && Calib_Mode != 0){
//							if(Card_Index==CARD_SLOT_4){
//								Calib____Num_Of_CTPTs_On_4th_Card_For_Calib = CARD_TYPE____4_PT__6_BO____NUM_OF_PTS;
//								for(CTPT_Index=0; CTPT_Index<CARD_TYPE____4_PT__6_BO____NUM_OF_PTS; CTPT_Index++)
//									CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter + CTPT_Index] = PT;
//							}
//							else if(Card_Index==CARD_SLOT_3)
//								Calib____Ref_Phase_Angle____CTPT_Index = CARD_TYPE____4_PT__6_BO____REF_CALIB_CHANNEL;
//						}

						CTPTs__In_All_Cards__Conter+=CARD_Specifications[j][3];
						GLB_Num_Of_Available_CTPT+=CARD_Specifications[j][3];
						GLB_Num_Of_Available_Outputs+=CARD_Specifications[j][6];

					}
					break;
//					case CARD_TYPE____E1:{
//					}
//					break;
//					case CARD_TYPE____12_CT:{
//						READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(CARD_TYPE____12_CT____NUM_OF_CTS, POINT, CTPTs__In_All_Cards__Conter);
//
//						if(Unit_Index==MP_MASTER && Calib_Mode != 0){
//							if(Card_Index==CARD_SLOT_4){
//								Calib____Num_Of_CTPTs_On_4th_Card_For_Calib = CARD_TYPE____12_CT____NUM_OF_CTS;
//								for(CTPT_Index=0; CTPT_Index<CARD_TYPE____12_CT____NUM_OF_CTS; CTPT_Index++)
//									CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter + CTPT_Index] = CT;
//							}
//							else if(Card_Index==CARD_SLOT_3)
//								Calib____Ref_Phase_Angle____CTPT_Index = CARD_TYPE____12_CT____REF_CALIB_CHANNEL;
//						}
//
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____12_CT____NUM_OF_CTS;
//						GLB_Num_Of_Available_CTPT+=CARD_TYPE____12_CT____NUM_OF_CTS;
//						GLB_Num_Of_Available_Inputs+=CARD_TYPE____12_CT____NUM_OF_INPUTS;
//					}
//					break;
//					case CARD_TYPE____9_BI__9_BO:{
//					}
//					break;
				}
				// Device_DB[i].Calibration_Data_Read_Status  -> 4KB



				break;
			 }
		}

		i += 1U;
	}







//
//	for(Unit_Index=MP_MASTER; Unit_Index<=MP_SLAVE_8; Unit_Index++){
//		for(Card_Index=CARD_SLOT_1; Card_Index<=CARD_SLOT_4; Card_Index++){
//			MP_UNIT[Unit_Index][Card_Index].TYPE = HW__Check__CARD_TYPE(SDRAM____CARDS_FLASH_DATA[(Unit_Index* NUM_OF_UNIT_CARDS+ Card_Index)* 2048]);  // Array "SDRAM____CARDS_FLASH_DATA" is 16bit
//			Card_Conter++;
//			if(MP_UNIT[Unit_Index][Card_Index].TYPE != RESPOND_UNKNOWN){
//				POINT=(4096* Card_Conter+ GLB_CPU_MP__Calib_Data__Start_Byte)/2;
//
//				switch(MP_UNIT[Unit_Index][Card_Index].TYPE){
//					case CARD_TYPE____PS:{
//					}
//					break;
//					case CARD_TYPE____CPU:{
//					}
//					break;
//					case CARD_TYPE____4_CT__6_BI:{
//						READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(CARD_TYPE____4_CT__6_BI____NUM_OF_CTS, POINT, CTPTs__In_All_Cards__Conter);
//
//						if(Unit_Index == MP_MASTER && Calib_Mode != 0){
//							if(Card_Index == CARD_SLOT_4){
//								Calib____Num_Of_CTPTs_On_4th_Card_For_Calib = CARD_TYPE____4_CT__6_BI____NUM_OF_CTS;
//								for(CTPT_Index = 0; CTPT_Index < CARD_TYPE____4_CT__6_BI____NUM_OF_CTS; CTPT_Index++)
//									CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter + CTPT_Index] = CT;
//							}
//							else if(Card_Index==CARD_SLOT_3)
//								Calib____Ref_Phase_Angle____CTPT_Index = CARD_TYPE____4_CT__6_BI____REF_CALIB_CHANNEL;
//						}
//
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____4_CT__6_BI____NUM_OF_CTS;
//						GLB_Num_Of_Available_CTPT+=CARD_TYPE____4_CT__6_BI____NUM_OF_CTS;
//						GLB_Num_Of_Available_Inputs+=CARD_TYPE____4_CT__6_BI____NUM_OF_INPUTS;
//					}
//					break;
//					case CARD_TYPE____4_PT__6_BO:{
//						READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(CARD_TYPE____4_PT__6_BO____NUM_OF_PTS, POINT, CTPTs__In_All_Cards__Conter);
//
//						if(Unit_Index==MP_MASTER && Calib_Mode != 0){
//							if(Card_Index==CARD_SLOT_4){
//								Calib____Num_Of_CTPTs_On_4th_Card_For_Calib = CARD_TYPE____4_PT__6_BO____NUM_OF_PTS;
//								for(CTPT_Index=0; CTPT_Index<CARD_TYPE____4_PT__6_BO____NUM_OF_PTS; CTPT_Index++)
//									CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter + CTPT_Index] = PT;
//							}
//							else if(Card_Index==CARD_SLOT_3)
//								Calib____Ref_Phase_Angle____CTPT_Index = CARD_TYPE____4_PT__6_BO____REF_CALIB_CHANNEL;
//						}
//
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____4_PT__6_BO____NUM_OF_PTS;
//						GLB_Num_Of_Available_CTPT+=CARD_TYPE____4_PT__6_BO____NUM_OF_PTS;
//						GLB_Num_Of_Available_Outputs+=CARD_TYPE____4_PT__6_BO____NUM_OF_OUTPUTS;
//
//					}
//					break;
//					case CARD_TYPE____E1:{
//					}
//					break;
//					case CARD_TYPE____12_CT:{
//						READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA__KOmaki(CARD_TYPE____12_CT____NUM_OF_CTS, POINT, CTPTs__In_All_Cards__Conter);
//
//						if(Unit_Index==MP_MASTER && Calib_Mode != 0){
//							if(Card_Index==CARD_SLOT_4){
//								Calib____Num_Of_CTPTs_On_4th_Card_For_Calib = CARD_TYPE____12_CT____NUM_OF_CTS;
//								for(CTPT_Index=0; CTPT_Index<CARD_TYPE____12_CT____NUM_OF_CTS; CTPT_Index++)
//									CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter + CTPT_Index] = CT;
//							}
//							else if(Card_Index==CARD_SLOT_3)
//								Calib____Ref_Phase_Angle____CTPT_Index = CARD_TYPE____12_CT____REF_CALIB_CHANNEL;
//						}
//
//						CTPTs__In_All_Cards__Conter+=CARD_TYPE____12_CT____NUM_OF_CTS;
//						GLB_Num_Of_Available_CTPT+=CARD_TYPE____12_CT____NUM_OF_CTS;
//						GLB_Num_Of_Available_Inputs+=CARD_TYPE____12_CT____NUM_OF_INPUTS;
//					}
//					break;
//					case CARD_TYPE____9_BI__9_BO:{
//					}
//					break;
//				}
//			}
//		}
//	}

}
void TEMP_CALIB_DATA(void){
	int32_t   CTPT_Cont;
	int32_t i;
	int32_t TEMP_Magnitude_Calib_Data2[6][8]={
		{	8830	,	8949	,	8840	,	8930	,	478	,	466	,	476	,	487	},
		{	1400	,	1401	,	1402	,	1403	,	2800	,	2801	,	28002	,2803		},
		{	62362	,	63212	,	62456	,	63069	,	3376	,	3286	,	3361	,	3433	},
		{	63000	,	64001 	,	63002 	,	64000 	,	3516	,	3424	,	3505	,	3568	},
		{	0		,	0		,	0		,	0		,	1		,	1		,	1		,	1		},
		{	0		,	0		,	0		,	0		,	0		,	0		,	0		,	0		}};

	int16_t TEMP_Magnitude_Calib_Data1[GLB_Calib__VI_Max_Steps_Count][8]={
		{	78		,	77		,	79		,	80		,	49		,	52		,	48		,	50		},
		{	160		,	157		,	160		,	165		,	243		,	245		,	239		,	236		},
		{	241		,	239		,	244		,	249		,	483		,	487		,	476		,	470		},
		{	324		,	319		,	328		,	335		,	963		,	973		,	951		,	937		},
		{	406		,	402		,	412		,	421		,	1447	,	1460	,	1429	,	1407	},
		{	490		,	482		,	496		,	507		,	1928	,	1947	,	1905	,	1876	},
		{	572		,	566		,	580		,	595		,	2409	,	2433	,	2379	,	2345	},
		{	824		,	812		,	835		,	853		,	2890	,	2922	,	2857	,	2814	},
		{	1666	,	1642	,	1692	,	1729	,	3370	,	3407	,	3330	,	3281	},
		{	2519	,	2483	,	2561	,	2613	,	3851	,	3894	,	3807	,	3749	},
		{	3378	,	3330	,	3436	,	3504	,	4094	,	4139	,	4047	,	3987	},
		{	4241	,	4180	,	4316	,	4399	,	4338	,	4386	,	4286	,	4222	},
		{	5107	,	5034	,	5199	,	5298	,	4578	,	4629	,	4525	,	4458	},
		{	5974	,	5889	,	6084	,	6198	,	4818	,	4873	,	4762	,	4692	},
		{	6842	,	6746	,	6971	,	7101	,	5061	,	5116	,	5002	,	4926	},
		{	7712	,	7603	,	7858	,	8003	,	5301	,	5359	,	5238	,	5158	},
		{	8582	,	8462	,	8745	,	8905	,	7232	,	7312	,	7146	,	7038	},
		{	10320	,	10177	,	10520	,	10712	,	9653	,	9758	,	9538	,	9393	},
		{	10754	,	10606	,	10965	,	11162	,	12073	,	12205	,	11922	,	11750	},
		{	11190	,	11035	,	11408	,	11616	,	14492	,	14645	,	14304	,	14100	},
		{	11625	,	11464	,	11852	,	12067	,	16909	,	17089	,	16688	,	16456	},
		{	12061	,	11893	,	12297	,	12519	,	20787	,	21007	,	20502	,	20228	}};
	int16_t TEMP_PhaseAngle_Calib_Data[GLB_Calib__VI_Max_Steps_Count][8]={
		{	-1303	,	-1303	,	-1303	,	-1303	,	-1895	,	-2048	,	-1860	,	-1989	},
		{	-1077	,	-1161	,	-1161	,	-1245	,	-1897	,	-2049	,	-1881	,	-1984	},
		{	-898	,	-897	,	-1029	,	-1029	,	-1893	,	-2039	,	-1876	,	-1978	},
		{	-858	,	-905	,	-1011	,	-1117	,	-1889	,	-2036	,	-1877	,	-1977	},
		{	-772	,	-860	,	-860	,	-860	,	-1877	,	-2023	,	-1870	,	-1970	},
		{	-678	,	-785	,	-785	,	-816	,	-1866	,	-2013	,	-1864	,	-1959	},
		{	-547	,	-620	,	-620	,	-693	,	-1866	,	-2016	,	-1873	,	-1960	},
		{	-293	,	-330	,	-348	,	-376	,	-1855	,	-2005	,	-1868	,	-1949	},
		{	-194	,	-218	,	-230	,	-266	,	-1854	,	-2003	,	-1870	,	-1945	},
		{	-146	,	-177	,	-173	,	-186	,	-1858	,	-2006	,	-1874	,	-1948	},
		{	-117	,	-146	,	-143	,	-154	,	-1847	,	-1997	,	-1867	,	-1939	},
		{	-120	,	-144	,	-139	,	-149	,	-1848	,	-1996	,	-1869	,	-1940	},
		{	-119	,	-150	,	-145	,	-152	,	-1848	,	-1998	,	-1871	,	-1940	},
		{	-126	,	-152	,	-148	,	-152	,	-1839	,	-1987	,	-1864	,	-1931	},
		{	-141	,	-179	,	-166	,	-170	,	-1843	,	-1991	,	-1867	,	-1933	},
		{	-163	,	-198	,	-187	,	-190	,	-1852	,	-1995	,	-1882	,	-1939	},
		{	-227	,	-262	,	-245	,	-239	,	-1861	,	-1997	,	-1897	,	-1944	},
		{	-245	,	-282	,	-268	,	-261	,	-1866	,	-1997	,	-1902	,	-1948	},
		{	-267	,	-304	,	-290	,	-283	,	-1864	,	-1994	,	-1902	,	-1945	},
		{	-295	,	-334	,	-317	,	-303	,	-1870	,	-1994	,	-1906	,	-1948	},
		{	-321	,	-359	,	-342	,	-327	,	-1866	,	-1987	,	-1902	,	-1941	},
		{	-341	,	-379	,	-362	,	-347	,	-1876	,	-1997	,	-1912	,	-1951	}};





////	int32_t TEMP_Magnitude_Calib_Data2[6][8]={
////		{0X0000221C	 ,	0X000021CE	, 0X0000212E	 , 0X000021F9,	0X000001D8,		0X000001D4,		 0X000001D8,		0X000001E7},
////		{0X00000000  ,  0X00000000 ,  0X00000000   , 0X00000000,	0X0       ,    0X0       ,    0X0       ,    0X1       },
////		{0X0000EFF5  ,  0X0000ED5A ,  0X0000E970   , 0X0000EEA8,	0X00000D11,    0X00000CE8,    0X00000D09,    0X00000D6F},
////		{0X00000000  ,  0X00000000 ,  0X00000000   , 0X00000000,	0X00000D9B,    0X00000D90,    0X00000D99,    0X00000E01},
////		{0X00000000  ,  0X00000000 ,  0X00000000   , 0X00000000,	0X1       ,    0X1       ,    0X1       ,    0X1       },
////		{0X00000000  ,  0X00000000 ,  0X00000000   , 0X00000000,	0X0       ,    0X0       ,    0X0       ,    0X0       }};
////		
////	int16_t TEMP_Magnitude_Calib_Data1[GLB_Calib__VI_Max_Steps_Count][8]={
////		{0X0050,        0X004E,        0X400E,        0X0050,		0X0030    ,    0X0030		,    0X002F   ,     0X0031    },
////		{0X00A0,        0X009F,        0X900C,        0X00A4,		0X00EA    ,    0X00E9    ,    0X00EB    ,    0X00F3    },
////		{0X00F3,        0X00EF,        0XE00C,        0X00F5,		0X01D8    ,    0X01D4    ,    0X01D8    ,    0X01E7    },
////		{0X0147,        0X0144,        0X301F,        0X014C,		0X03B1    ,    0X03A6    ,    0X03B1    ,    0X03CD    },
////		{0X019A,        0X0196,        0X801F,        0X019F,		0X058C    ,    0X057A    ,    0X058B    ,    0X05B5    },
////		{0X01EF,        0X01E9,        0XE011,        0X01F5,		0X0767    ,    0X074D    ,    0X0765    ,    0X079C    },
////		{0X0245,        0X023F,        0X3025,        0X0248,		0X0942    ,    0X091F    ,    0X093F    ,    0X0983    },
////		{0X0343,        0X033A,        0X203C,        0X0346,		0X0B1B    ,    0X0AF4    ,    0X0B19    ,    0X0B6A    },
////		{0X0699,        0X0689,        0X606A,        0X069F,		0X0CF6    ,    0X0CC8    ,    0X0CF4    ,    0X0D52    },
////		{0X09FB,        0X09E4,        0XB095,        0X0A00,		0X0ED1    ,    0X0E9C    ,    0X0ECE    ,    0X0F38    },
////		{0X0D66,        0X0D46,        0X00D7,        0X0D64,		0X0FC0    ,    0X0F88    ,    0X0FBD    ,    0X102C    },
////		{0X10D5,        0X10AE,        0X510F,        0X10D0,		0X10AF    ,    0X1073    ,    0X10AA    ,    0X1121    },
////		{0X1445,        0X1417,        0XB138,        0X143B,		0X119C    ,    0X115F    ,    0X119A    ,    0X1216    },
////		{0X17BA,        0X1782,        0X1173,        0X17A9,		0X128A    ,    0X1249    ,    0X1286    ,    0X130A    },
////		{0X1B2F,        0X1AF1,        0X61AF,        0X1B19,		0X1378    ,    0X1333    ,    0X1374    ,    0X13FE    },
////		{0X1EA6,        0X1E5F,        0XC1DF,        0X1E87,		0X1466    ,    0X141E    ,    0X1460    ,    0X14F3    },
////		{0X221C,        0X21CE,        0X221E,        0X21F9,		0X1BD5    ,    0X1B73    ,    0X1BD0    ,    0X1C95    },
////		{0X290A,        0X28AC,        0XE27D,        0X28DA,		0X2519    ,    0X2492    ,    0X2511    ,    0X2616    },
////		{0X2AC8,        0X2A65,        0X929C,        0X2A93,		0X2E5F    ,    0X2DAF    ,    0X2E53    ,    0X2F97    },
////		{0X2C85,        0X2C1F,        0X42BF,        0X2C4D,		0X37A6    ,    0X36CA    ,    0X3795    ,    0X3917    },
////		{0X2E42,        0X2DD8,        0X02D0,        0X2E06,		0X40EE    ,    0X3FE9    ,    0X40DA    ,    0X4298    },
////		{0X2FFF,        0X2F94,        0XB2E3,        0X2FC0,		0X4FCB    ,    0X4E85    ,    0X4FB3    ,    0X51D0    }};
////		
////		
////	int16_t TEMP_PhaseAngle_Calib_Data[GLB_Calib__VI_Max_Steps_Count][8]={
////{-104	,	156		,	-104	,	-104	,-1970		,	-2019		,	-1953		,	-1752},
////{-101	,	294		,	-101	,	-101	,-2016		,	-2074		,	-2016		,	-1763},
////{-101	,	333		,	-101	,	-101	,-1998		,	-2062		,	-1998		,	-1758},
////{-99	,	426		,	-99		,	-99		,-1988		,	-2043		,	-1977		,	-1753},
////{-96	,	426		,	-96		,	-96		,-1974		,	-2027		,	-1964		,	-1739},
////{-93	,	426		,	-5		,	-93		,-1964		,	-2015		,	-1954		,	-1728},
////{-17	,	425		,	-51		,	-85		,-1957		,	-2014		,	-1949		,	-1724},
////{-38	,	452		,	-9		,	-9		,-1956		,	-2012		,	-1946		,	-1719},
////{7		,	546		,	20		,	7			,-1949		,	-2006		,	-1936		,	-1713},
////{45		,	559		,	37		,	29		,-1949		,	-2008		,	-1935		,	-1714},
////{54		,	568		,	55		,	55		,-1947		,	-2006		,	-1932		,	-1711},
////{64		,	586		,	59		,	53		,-1943		,	-2003		,	-1928		,	-1707},
////{63		,	583		,	63		,	63		,-1942		,	-2003		,	-1928		,	-1707},
////{69		,	589		,	66		,	66		,-1942		,	-2002		,	-1925		,	-1706},
////{68		,	594		,	63		,	53		,-1938		,	-1999		,	-1922		,	-1703},
////{62		,	586		,	57		,	48		,-1940		,	-2000		,	-1922		,	-1704},
////{52		,	574		,	47		,	41		,-1947		,	-2005		,	-1925		,	-1703},
////{35		,	550		,	23		,	17		,-1951		,	-2008		,	-1925		,	-1705},
////{27		,	540		,	16		,	6			,-1956		,	-2012		,	-1929		,	-1709},
////{17		,	525		,	4			,	-6		,-1960		,	-2015		,	-1931		,	-1712},
////{3		,	504		,	-8		,	-20		,-1961		,	-2015		,	-1932		,	-1714},
////{-26	,	469		,	-33		,	-53		,-1966		,	-2019		,	-1937		,	-1719}};

	GLB_Num_Of_Available_Inputs=6;
	GLB_Num_Of_Available_Outputs=6;
	GLB_Num_Of_Available_CTPT=8;

	for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
//		Modules_Type[CTPT_Cont]=TEMP_Magnitude_Calib_Data2[4][CTPT_Cont];
//		GLB__CALIB_DATA___FFT_Calib_Factor[GLB_Num_Of_Available_CTPT+CTPT_Cont  ]=TEMP_Magnitude_Calib_Data2[2][CTPT_Cont];
//		GLB__CALIB_DATA___FFT_Calib_Factor[2*GLB_Num_Of_Available_CTPT+CTPT_Cont]=TEMP_Magnitude_Calib_Data2[3][CTPT_Cont];

		for(i=0; i<6; i++)
			CALIB_DATA__Magni__Part1[i][CTPT_Cont]=TEMP_Magnitude_Calib_Data2[i][CTPT_Cont];
		for(i=0; i<GLB_Calib__VI_Max_Steps_Count; i++)
			CALIB_DATA__Magni__Part2[i][CTPT_Cont]=TEMP_Magnitude_Calib_Data1[i][CTPT_Cont];
		for(i=0; i<GLB_Calib__VI_Max_Steps_Count; i++)
			CALIB_DATA__Phase_Angle[i][CTPT_Cont]=TEMP_PhaseAngle_Calib_Data[i][CTPT_Cont];
	}
}
int32_t Get_Calib__VI_Steps(int8_t CT_or_PT, int32_t i){
	if(CT_or_PT==PT)
		return GLB_Calib__V_Steps[i];
	else
		return GLB_Calib__I_Steps[i];
}
void    Calibration____Disp_Messages_On_LCD(void){
	int32_t CTPT_Index;

	switch(Calibration_Stage){
		case 1: 
			Calibration_Stage=100; 
			T6963_240_128_Write_String("CLB STG 1 Started(CLK CLB)",75,50,0, 0); 
		break;
		case 2: 
			Calibration_Stage=100; 
			sprintf((char *)RAM_UART_BUFF, "CLK CLB VALUE: %d",GLB__CLK_CALIB____TIM2_TIMING_CORRECTION);
			T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0);
			T6963_240_128_Write_String("CLB STG 2 Started(Magn)",75,50,0, 0); 
		break;
		case 3: 
			Calibration_Stage=100; 
			T6963_240_128_Write_String("CLB STG 3 Started(FFT Calib)",75,50,0, 0); 
		break;		
		case 4: 
			Calibration_Stage=100; 
			T6963_240_128_Write_String("CLB STG 4 Started(PhaseAngle)",75,50,0, 0); 
		break;		
	}
	
	if(Calib____Reverse_Winding){
		sprintf((char *)RAM_UART_BUFF, "REV. WIND.(");
		for(CTPT_Index = GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index < GLB_Num_Of_Available_CTPT; CTPT_Index++){
			if((Calib____Reverse_Winding___CTPT_Index & (One<<CTPT_Index)) != 0){
				sprintf((char *)SDRAM____String_Komaki, "M%d,", CTPT_Index + 1);
				strcat((char *)RAM_UART_BUFF, SDRAM____String_Komaki);
			}
		}
		strcat((char *)RAM_UART_BUFF, ")");
		T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0);
		Calib____Reverse_Winding = false;
	}	
}
void    Calibration____Load_Calib_Data____Magnit(int32_t CTPT_Cont){
	int32_t   i;
	int32_t   Real_Value ,Linear_Value;
	double    mA_dV_Value;
	int32_t   StepsCount;
	int32_t   Ref_Min;
	int32_t   Ref_Max;
	int8_t    type;
	int8_t    Invalid_Ref=0;
	
//	sprintf((char *)RAM_UART_BUFF,"M#%3d  ",Analog_Modules_Application[CTPT_Cont]+1); Panel_Komaki_UARTX_For_Sprintf();

	type = CALIB_DATA__Magni__Part1[4][CTPT_Cont];
//Print_Modules_App(type, Analog_Modules_Application[CTPT_Cont], CTPT_Cont);

	StepsCount=(type==PT? GLB_Calib__V_Steps_Count: GLB_Calib__I_Steps_Count);
	Ref_Min=(Simulation_Flag ? 0 : (type==PT? PT_Calib_Ref_Min: CT_Calib_Ref_Min));
	Ref_Max=(Simulation_Flag ? 10000000 : (type==PT? PT_Calib_Ref_Max: CT_Calib_Ref_Max));
	for(i=0; i<StepsCount+6; i++){
		if(i<6){
			if(i==0){
				sprintf((char *)RAM_UART_BUFF,"ref=%6d  ",CALIB_DATA__Magni__Part1[0][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
				if(CALIB_DATA__Magni__Part1[0][CTPT_Cont]<Ref_Min){
					GLB____Hardware_Fault__Message[1] |= (One<<Err____Calib____Ref_Val);
					sprintf((char *)RAM_UART_BUFF,"Invalid Ref. "); Panel_Komaki_UARTX_For_Sprintf();
					Invalid_Ref=1;
				}
				else if(CALIB_DATA__Magni__Part1[0][CTPT_Cont]>Ref_Max){
					GLB____Hardware_Fault__Message[1]|=(One<<Err____Calib____Ref_Val);
					sprintf((char *)RAM_UART_BUFF,"Invalid Ref. "); Panel_Komaki_UARTX_For_Sprintf();
					Invalid_Ref=1;
				}
				
			}
			if(Invalid_Ref!=0){
				sprintf((char *)RAM_UART_BUFF,"!!\n"); Panel_Komaki_UARTX_For_Sprintf();
				break;
			}
		}
		else{
			if(i==StepsCount+5)
				Calib_Max_Num_AD_Read[CTPT_Cont]=CALIB_DATA__Magni__Part2[i-6][CTPT_Cont];
			
			if(i==6){
				for(Real_Value=0; Real_Value<=CALIB_DATA__Magni__Part2[i-6][CTPT_Cont]; Real_Value++)
					SDRAM____Magnitude_CTPT_Calib[CTPT_Cont*Calib_Num_Of_Steps_For_Any_CTPT_With_midpoints + Real_Value]=0;
			}
			else{
				for(Real_Value=CALIB_DATA__Magni__Part2[i-7][CTPT_Cont]+1; Real_Value<=CALIB_DATA__Magni__Part2[i-6][CTPT_Cont]; Real_Value++){
					if(type==PT)
						mA_dV_Value=(double)GLB_Calib__V_Steps[i-7]+ ((double)Real_Value- (double)CALIB_DATA__Magni__Part2[i-7][CTPT_Cont])*((double)GLB_Calib__V_Steps[i-6] - (double)GLB_Calib__V_Steps[i-7])/((double)CALIB_DATA__Magni__Part2[i-6][CTPT_Cont]-(double)CALIB_DATA__Magni__Part2[i-7][CTPT_Cont]);
					else
						mA_dV_Value=(double)GLB_Calib__I_Steps[i-7]+ ((double)Real_Value- (double)CALIB_DATA__Magni__Part2[i-7][CTPT_Cont])*((double)GLB_Calib__I_Steps[i-6] - (double)GLB_Calib__I_Steps[i-7])/((double)CALIB_DATA__Magni__Part2[i-6][CTPT_Cont]-(double)CALIB_DATA__Magni__Part2[i-7][CTPT_Cont]);

					Linear_Value=(int)(mA_dV_Value*(double)CALIB_DATA__Magni__Part1[0][CTPT_Cont]/(double)(type==PT?Scan_PTs_Ref_Voltage_mV_Peak:Scan_CTs_Ref_Current_mA_Peak_CT)+0.5);
					
					SDRAM____Magnitude_CTPT_Calib[CTPT_Cont*Calib_Num_Of_Steps_For_Any_CTPT_With_midpoints + Real_Value]=Linear_Value-Real_Value;
//					/*if(CTPT_Cont==0)*/{sprintf((char *)RAM_UART_BUFF,"%5d %5.2f dV %6d %6d %6d\n",CTPT_Cont*Calib_Num_Of_Steps_For_Any_CTPT_With_midpoints + Real_Value, mA_dV_Value, Real_Value, Linear_Value, Linear_Value-Real_Value); Panel_Komaki_UARTX_For_Sprintf();}
//					/*if(CTPT_Cont>6)*/{sprintf((char *)RAM_UART_BUFF,"%5d %5.2f mA mA %6d %6d %6d\n", CTPT_Cont *Calib_Num_Of_Steps_For_Any_CTPT_With_midpoints + Real_Value, mA_dV_Value, Real_Value, Linear_Value, Linear_Value-Real_Value ); Panel_Komaki_UARTX_For_Sprintf();}
				}
			}
//			sprintf((char *)RAM_UART_BUFF,"**%6d  %6d\n", GLB_Calib__V_Steps[i-6], CALIB_DATA__Magni__Part2[i-6][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
//			sprintf((char *)RAM_UART_BUFF,"**%6d  %6d\n", GLB_Calib__I_Steps[i-6], CALIB_DATA__Magni__Part2[i-6][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
	}
	
//	for(i=0; i<9; i++){
//		sprintf((char *)RAM_UART_BUFF,"...**%6d \n", Calib_Max_Num_AD_Read[i]); Panel_Komaki_UARTX_For_Sprintf();
//	}
}
void    Calibration____Load_Calib_Data____Phase_Anglet(int32_t CTPT_Cont){
	int32_t   i, j, Steps;
	int8_t    Type = CALIB_DATA__Magni__Part1[4][CTPT_Cont];
	
	sprintf((char *)RAM_UART_BUFF,"M#%d\n",CTPT_Cont+1); Panel_Komaki_UARTX_For_Sprintf();

	Steps=(Type==PT?GLB_Calib__V_Steps_Count:GLB_Calib__I_Steps_Count);
	for(i=0; i<Steps; i++){
		//sprintf((char *)RAM_UART_BUFF,"%7d %s  	 	%7d\n", Type==PT?GLB_Calib__V_Steps[i]: GLB_Calib__I_Steps[i],Type==PT?"mV":"mA", RAM_Calib_For_Read_From_Flash[i]); Panel_Komaki_UARTX_For_Sprintf();
		if(i==0){
			for(j=0; j<Get_Calib__VI_Steps(Type,0); j++){
				SDRAM____Phase_Angle_Calibration[CTPT_Cont *GLB_Calib__VI_Max_Steps_Count_With_MidPoints+ j] =((int32_t)(CALIB_DATA__Phase_Angle[i][CTPT_Cont])*100* j/Get_Calib__VI_Steps(Type,0))/100;
			}
		}
		else{
      if(CALIB_DATA__Phase_Angle[i-1][CTPT_Cont]>15000 && CALIB_DATA__Phase_Angle[i][CTPT_Cont]<-15000)
        CALIB_DATA__Phase_Angle[i][CTPT_Cont]+=36000;
      else if(CALIB_DATA__Phase_Angle[i-1][CTPT_Cont]<-15000 && CALIB_DATA__Phase_Angle[i][CTPT_Cont]>15000)
        CALIB_DATA__Phase_Angle[i-1][CTPT_Cont]+=36000;
			for(j=Get_Calib__VI_Steps(Type,i-1); j<Get_Calib__VI_Steps(Type,i); j++){
				SDRAM____Phase_Angle_Calibration[CTPT_Cont *GLB_Calib__VI_Max_Steps_Count_With_MidPoints+ j] =((int32_t)(CALIB_DATA__Phase_Angle[i-1][CTPT_Cont])*100 + (j-Get_Calib__VI_Steps(Type,i-1))*((int32_t)CALIB_DATA__Phase_Angle[i][CTPT_Cont]-(int32_t)CALIB_DATA__Phase_Angle[i-1][CTPT_Cont])*100/(Get_Calib__VI_Steps(Type,i)-Get_Calib__VI_Steps(Type,i-1)))/100;
			}
		}
	}
}
void    Calibration____Mode_0_____Load_Calib_Data___Magnit_And_Phase(void){
	int32_t   i;
	int32_t   CTPT_Cont;
	int32_t   POINT=0;
	
//	TEMP_CALIB_DATA();
	
	sprintf((char *)RAM_UART_BUFF,"---------------------------------------\n"); Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"CALIB TEST RESULTS:\n"); Panel_Komaki_UARTX_For_Sprintf();

	for(i=0; i<6; i++){	
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
			sprintf((char *)RAM_UART_BUFF,"%6i ",CALIB_DATA__Magni__Part1[i][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
		sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	}
	sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	for(i=0; i<22; i++){	
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
			sprintf((char *)RAM_UART_BUFF,"%6i ",CALIB_DATA__Magni__Part2[i][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
		sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	}
	sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	for(i=0; i<22; i++){	
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
			sprintf((char *)RAM_UART_BUFF,"%6i ", (int16_t)CALIB_DATA__Phase_Angle[i][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
		sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	}
	sprintf((char *)RAM_UART_BUFF,"---------------------------------------\n"); Panel_Komaki_UARTX_For_Sprintf();

	sprintf((char *)RAM_UART_BUFF,"----------------------------------------Magnitude\n"); Panel_Komaki_UARTX_For_Sprintf();
	for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++)
		Calibration____Load_Calib_Data____Magnit(CTPT_Cont);
	
	sprintf((char *)RAM_UART_BUFF,"----------------------------------------Phase Angle\n"); Panel_Komaki_UARTX_For_Sprintf();
	sprintf((char *)RAM_UART_BUFF,"Phase Angle Calib Loading...\n"); Panel_Komaki_UARTX_For_Sprintf();
	if(GLB____Hardware_Fault__Message[1]==0){
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
//		if(Modules_List_For_SaveOrLoad_Calib_uSD[CTPT_Cont]==1)
			Calibration____Load_Calib_Data____Phase_Anglet(CTPT_Cont);
		}
	}

	
}
void    Calibration____Stage_2____Save_Result(void){
	int32_t   Block_Couter;
	int32_t   CTPT_Cont;
	int32_t   i;
	
	if(GLB____Hardware_Fault__Message[1] == 0){
		FILL_RAM_CARDS_FLASH_DATA(1);
		MP____FLASH_MODE____0_NA____1_READ____2_WRITE=2U;		
		MP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG=2U;
	}
	GLB_Calib__Count=0;
		
	for(i=0; i<6; i++){	
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
			sprintf((char *)RAM_UART_BUFF,"%6d ",CALIB_DATA__Magni__Part1[i][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
		sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	}
	sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	for(i=0; i<22; i++){	
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
			sprintf((char *)RAM_UART_BUFF,"%6d ",CALIB_DATA__Magni__Part2[i][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
		sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	}
	sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	for(i=0; i<22; i++){	
		for(CTPT_Cont=0; CTPT_Cont<GLB_Num_Of_Available_CTPT; CTPT_Cont++){
			sprintf((char *)RAM_UART_BUFF,"%6d ", CALIB_DATA__Phase_Angle[i][CTPT_Cont]); Panel_Komaki_UARTX_For_Sprintf();
		}
		sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
	}
}
int32_t Calibration____Stage_2____Calc_Meas_Phi(int32_t int_phase, int32_t Ref_Angle){
	int32_t Meas_Phi;
	if(int_phase-Ref_Angle>18000)
		Meas_Phi=int_phase-Ref_Angle-36000;
	else if(int_phase-Ref_Angle<-18000)
		Meas_Phi=int_phase-Ref_Angle+36000;
	else
		Meas_Phi=int_phase-Ref_Angle;
	
	return(Meas_Phi);
}
void    Calibration____Stage_2____Phase_Angles(void){
	int32_t   i=0;
	int32_t   Phi;
	int32_t   CTPT_Index;
	int32_t   phase_Angle;
	int32_t   m = FFT_BLK____First_Analog____Index_In_VMA;
	int32_t 	Ref_Angle; 
	int32_t 	Ref_Abs; 
	
	if(GLB_Counter_Samples_Total_New==1)
		MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=1;

	if(GLB_Counter_Samples_Total_New>2 && (GLB_Counter_Samples_Total_New % Scan_CTPTs_Any_ms)==(Scan_CTPTs_Any_ms/2) && GLB_Calib__Count<GLB_Calib__VI_Max_Steps_Count){
		Ref_Angle = MHA[VMA[m+(Calib____Ref_Phase_Angle____CTPT_Index-1)] + PatternModel_1____First_Index____FFT+3];
		Ref_Abs   = MHA[VMA[m+(Calib____Ref_Phase_Angle____CTPT_Index-1)] + PatternModel_1____First_Index____FFT+2];
		if(Ref_Abs < RefAngle___Min_Abs_Value)
			GLB____Hardware_Fault__Message[1]|=(One<<Err____Calib____RefAngle___Low_Abs);

		
		for(CTPT_Index = GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index < GLB_Num_Of_Available_CTPT; CTPT_Index++){
			phase_Angle = MHA[VMA[m + CTPT_Index] + PatternModel_1____First_Index____FFT + 3];
			Phi= Calibration____Stage_2____Calc_Meas_Phi(phase_Angle,  Ref_Angle);	
			if(GLB_Calib__Count == 3 && (Phi > 15000 || Phi < -15000)){
				Calib____Reverse_Winding = true;
				Calib____Reverse_Winding___CTPT_Index |= (One<<CTPT_Index);
			}
				
			CALIB_DATA__Phase_Angle[GLB_Calib__Count][CTPT_Index]=(int16_t)(-Phi);
		}
		GLB_Calib__Count++;
	}
	
	if(GLB_Calib__Count == GLB_Calib__VI_Max_Steps_Count){
		MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=0;
		GLB_Calib__Count++;
		Calibration____Stage_2____Finished=1;
	}
	
}
void    Calibration____Stage_2____FFTCalibVal____FFT(void){
	int32_t	*CTPT_Adr_In_MHA = MHA + 2000;
	int32_t	 i;
	int32_t	 m = FFT_BLK____First_Analog____Index_In_VMA;
	
	//----------S:   H1, CTPT ----------
	for(i=0; i<GLB_Num_Of_Available_CTPT; i++){
		*CTPT_Adr_In_MHA = VMA[m];			
		CFC_BLK__SIG_PROC____FFT_MAIN(CTPT_Adr_In_MHA, 0);
		CFC_BLK__SIG_PROC____RMS(CTPT_Adr_In_MHA);
		if(Measure_Request == H2){
			*CTPT_Adr_In_MHA = VMA[m];		
			CFC_BLK__SIG_PROC____FFT_MAIN(CTPT_Adr_In_MHA, 1);
		}
		 m++;
	}
	//----------S:   H1, CTPT ----------
}
void    Calibration____Stage_2____FFTCalibVal____Init(void){
	
	GLB_Counter_Samples_Total_New=0;	
	Measure_Request = Fundumental;
	TEMP__CFC_Run = 1;
	Calibration_Stage = 3;
}
void    Calibration____Stage_2____Load_Calibration_CT_PT_Magnit(void){
	int32_t   CTPT_Index;
	
	sprintf((char *)RAM_UART_BUFF,"Load Magnitude Factors:\n"); Panel_Komaki_UARTX_For_Sprintf();
	
	for(CTPT_Index=GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index<GLB_Num_Of_Available_CTPT; CTPT_Index++)
			Calibration____Load_Calib_Data____Magnit(CTPT_Index);
	//----------S: init For Stage 2 ----------
	{
		for(CTPT_Index = GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index < GLB_Num_Of_Available_CTPT; CTPT_Index++){
			if(CALIB_DATA__Magni__Part1[4][CTPT_Index] == PT){
				CALIB_DATA__Magni__Part1[1][CTPT_Index] = PT_Calib___RMS_Default_ScaleFactor;
				CALIB_DATA__Magni__Part1[2][CTPT_Index] = PT_Calib___H1_Default_ScaleFactor;
				CALIB_DATA__Magni__Part1[3][CTPT_Index] = PT_Calib___H2_Default_ScaleFactor;
			}
			else{
				CALIB_DATA__Magni__Part1[1][CTPT_Index] = CT_Calib___RMS_Default_ScaleFactor;
				CALIB_DATA__Magni__Part1[2][CTPT_Index] = CT_Calib___H1_Default_ScaleFactor;
				CALIB_DATA__Magni__Part1[3][CTPT_Index] = CT_Calib___H2_Default_ScaleFactor;
			}
		}
	}
	//----------E: init For Stage 2 ----------
}

int32_t Calibration____Stage_1____Calculate_Signal_Peak_Value_Komaki(int8_t Pos_0_Or_Neg_1, int8_t N, int16_t Point1, int16_t Point2){
	uint32_t Point11=abs(Point1);
	uint32_t Point22=abs(Point2);
	double Peak;
	double Part1;

	if(GLB_Number_of_Sample_per_Cycle==10){
		Part1=Point22-Point11* 0.809017;	
		Peak=sqrt((Part1*Part1)*2.894427191+ (Point11*Point11))+0.5;
	}
	else if(GLB_Number_of_Sample_per_Cycle==20){
		Part1=Point22-Point11* 0.9510565;	
		Peak=sqrt((Part1*Part1)*10.472136+ (Point11*Point11))+0.5;
	}
				
//	if(N<GLB_Num_Of_Available_CTPT){
//		if(Pos_0_Or_Neg_1==0){
//			sprintf((char *)RAM_UART_BUFF,"Point1=	%7d	   Point2=	%7d	   Peak=	%7d",  Point1, Point2, (int32_t)Peak); Panel_Komaki_UARTX_For_Sprintf();
//		}
//		else{
//			sprintf((char *)RAM_UART_BUFF,"    Point1=	%7d	   Point2=	%7d	   Peak=	%7d\n",Point1, Point2, (int32_t)Peak); Panel_Komaki_UARTX_For_Sprintf();
//		}
//	}
	
	return (int32_t)Peak;
}
void    Calibration____Stage_1____Calculate_Signal_Peak_Value(void){
	int32_t i, CTPT_Index;
	int32_t Peak1;
	int32_t Peak2;
	int32_t Row;
	int8_t  type;
	
	for(CTPT_Index=GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index<GLB_Num_Of_Available_CTPT; CTPT_Index++){
		sprintf((char *)RAM_UART_BUFF,"------------M #%d\n",CTPT_Index+1); Panel_Komaki_UARTX_For_Sprintf();
		type = CALIB_DATA__Magni__Part1[4][CTPT_Index];
		for(i=0; i<(type==PT? GLB_Calib__V_Steps_Count:GLB_Calib__I_Steps_Count); i++){
			Peak1 = Calibration____Stage_1____Calculate_Signal_Peak_Value_Komaki(0, CTPT_Index, SDRAM____Magnitude_CTPT_Calib_Max_Last[GLB_Calib__VI_Max_Steps_Count *CTPT_Index + i], SDRAM____Magnitude_CTPT_Calib_Max[GLB_Calib__VI_Max_Steps_Count *CTPT_Index + i]);	
			Peak2 = Calibration____Stage_1____Calculate_Signal_Peak_Value_Komaki(1, CTPT_Index, SDRAM____Magnitude_CTPT_Calib_Min_Last[GLB_Calib__VI_Max_Steps_Count *CTPT_Index + i], SDRAM____Magnitude_CTPT_Calib_Min[GLB_Calib__VI_Max_Steps_Count *CTPT_Index + i]);	
			Row=(Peak1+Peak2)/2;
			
//		if(type==PT)sprintf((char *)RAM_UART_BUFF,"%7d mV 	 %7d\n",GLB_Calib__V_Steps[i], Row); else sprintf((char *)RAM_UART_BUFF,"%6d mA 	 %5d\n",GLB_Calib__I_Steps[i], Row); Panel_Komaki_UARTX_For_Sprintf();
			if((type==PT? GLB_Calib__V_Steps[i]==Scan_PTs_Ref_Voltage_mV_Peak: GLB_Calib__I_Steps[i]==Scan_CTs_Ref_Current_mA_Peak_CT)){
//			SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6) *CTPT_Index]=Row;
//			SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6) *CTPT_Index+4]=Modules_Type[CTPT_Index];
				
				CALIB_DATA__Magni__Part1[0][CTPT_Index] = Row;
				
				if((type==PT? (CALIB_DATA__Magni__Part1[0][CTPT_Index]<PT_Calib_Ref_Min || CALIB_DATA__Magni__Part1[0][CTPT_Index]>PT_Calib_Ref_Max) : (CALIB_DATA__Magni__Part1[0][CTPT_Index]<CT_Calib_Ref_Min || CALIB_DATA__Magni__Part1[0][CTPT_Index]>CT_Calib_Ref_Max)))
					GLB____Hardware_Fault__Message[1]|=(One<<Err____Calib____Ref_Val);
			}
			if(Row<GLB_Calib_CTPT_Last_Row[CTPT_Index]){
				GLB_num_Of_Eroors_Temppp[CTPT_Index]++;

				sprintf((char *)RAM_UART_BUFF,"%s     error:  %7d %s   Row=%5d  %5d %5d %5d",(type==PT? "V":"I"), GLB_Calib__V_Steps[i],(type==PT? "mV":"mA"), Row, GLB_Calib_CTPT_Last_Row[CTPT_Index], i, GLB_num_Of_Eroors_Temppp[CTPT_Index]); Panel_Komaki_UARTX_For_Sprintf();
				
				Row=GLB_Calib_CTPT_Last_Row[CTPT_Index]+(type==PT? 2:5);
				sprintf((char *)RAM_UART_BUFF,"   !!!New_Row=%5d\n",Row); Panel_Komaki_UARTX_For_Sprintf();
			}

			if(Row==GLB_Calib_CTPT_Last_Row[CTPT_Index]){
				GLB_Calibration__nums_Of_repetitions[CTPT_Index]++;
//			SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6) *CTPT_Index +i +6]=GLB_Calibration__nums_Of_repetitions[CTPT_Index]*10000+Row;	
				CALIB_DATA__Magni__Part2[i][CTPT_Index]=GLB_Calibration__nums_Of_repetitions[CTPT_Index]*10000+Row;	
			}
			else{
				GLB_Calibration__nums_Of_repetitions[CTPT_Index]=0;
//			SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6) *CTPT_Index +i +6]=Row;
				CALIB_DATA__Magni__Part2[i][CTPT_Index]=Row;
				
				
//sprintf((char *)RAM_UART_BUFF,"---- =%8d ",SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6) *CTPT_Index + i +6]); Panel_Komaki_UARTX_For_Sprintf();				
//sprintf((char *)RAM_UART_BUFF,"Row  =%8d \n",Row); Panel_Komaki_UARTX_For_Sprintf();				
			}
			GLB_Calib_CTPT_Last_Row[CTPT_Index]=Row;
		}
	}
}
void    Calibration____Stage_1____Determine_Two_Pos_And_Neg_Peak_Value(void){
	int32_t   i, j, k, Row, Row1, Komaki;
	int16_t   Value, Value1;

	Komaki=(GLB_4_Byte*GLB_Num_Of_Available_CTPT)+1;

	for(i=GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; i<GLB_Num_Of_Available_CTPT; i++){
		GLB_Max_Samples_Value[i]=0;
		GLB_Min_Samples_Value[i]=0;
		GLB_Max_Samples_Value_Last[i]=0;
		GLB_Min_Samples_Value_Last[i]=0;
	}

	for(i=0; i<GLB_Number_of_Sample_per_Cycle; i++){
		Row=GLB_Osc_Counter_For_Row_Of_V_I_Pre_Fault-i;
		Row=(Row<0? Row+GLB_Osc____Pre_fault_Max_Num_Of_Sample: Row);
		k=GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib;
		for(j=GLB_4_Byte*(GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib); j<GLB_4_Byte*GLB_Num_Of_Available_CTPT; j+=GLB_4_Byte){	
			Value=*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Row*Komaki+ j)); 
			if(GLB_Max_Samples_Value[k]<Value && Value>0){
				GLB_Max_Samples_Value_Last[k]=GLB_Max_Samples_Value[k];
				GLB_Max_Samples_Value[k]=Value;
				
				if(i==0){
					Row1=GLB_Osc_Counter_For_Row_Of_V_I_Pre_Fault-1;
					Row1=(Row1<0? Row1+GLB_Osc____Pre_fault_Max_Num_Of_Sample: Row1);
					Value1=*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Row1*Komaki+ j)); 
					GLB_Max_Samples_Value_Last[k]=Value1;
				}
			}
			if(GLB_Min_Samples_Value[k]>Value && Value<0){
				GLB_Min_Samples_Value_Last[k]=GLB_Min_Samples_Value[k];
				GLB_Min_Samples_Value[k]=Value;
				
				if(i==0){
					Row1=GLB_Osc_Counter_For_Row_Of_V_I_Pre_Fault-1;
					Row1=(Row1<0? Row1+GLB_Osc____Pre_fault_Max_Num_Of_Sample: Row1);
					Value1=*((int16_t *)(SDRAM____Analog_Digital_Comtrade + Row1*Komaki+ j)); 
					GLB_Min_Samples_Value_Last[k]=Value1;
				}
			}
			k++;
		}
	}
}
void    Calibration____Stage_1____Save_Result(void){
	int32_t   CTPT_Cont;
	uint32_t  i, k, n;
	int32_t CTPT_Adr_In_MHA ;
	
	if(GLB____Hardware_Fault__Message[1]==0){
		Calibration____Stage_1____Calculate_Signal_Peak_Value();
					
		if(GLB____Hardware_Fault__Message[1]==0){
			*(int32_t *)(SDRAM____1_Block_MMC)=GLB__CLK_CALIB____TIM2_TIMING_CORRECTION;
			Write_to_MMC(SDRAM____1_Block_MMC, MMC_TIM2_TIMING_CORRECTION____BLK_NUM____CPU, 1);	
			//----------S: Sefr kardane sampleha dar MHA ----------
			Reset_ANALOG__Samples__AND__FFT_VALS__In_MHA(1, 0, GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib, GLB_Num_Of_Available_CTPT);
			for(i=0; i<GLB_Number_of_Sample_per_Cycle+2; i++)
				MHA[VMA[FFT_BLK____First_Analog____Index_In_VMA + Calib____Ref_Phase_Angle____CTPT_Index-1] + PatternModel_1____First_Index_Of__DataWindow + i]=0;
			//----------E: Sefr kardane sampleha dar MHA ----------

			Calibration____Calib_Mode_Changed=1;
			Calibration____Stage_2____FFT_Factors__Mode=1;
			Calib_Mode=2;					
			//----------E: Switch to Calib Mode 2 FFTCalib
		}
		else{
			/*
			T6963_240_128_Write_String("  Calibrating (Magnitude) ",75,50,0);
			T6963_240_128_Write_String("     !! Failed !!         ",75,65,0);
			sprintf((char *)RAM_UART_BUFF,"ref=  ["); Panel_Komaki_UARTX_For_Sprintf();
			for(k=0;k<GLB_Num_Of_Available_CTPT; k++){
			}
			sprintf((char *)RAM_UART_BUFF,"]\n"); Panel_Komaki_UARTX_For_Sprintf();
			sprintf((char *)RAM_UART_BUFF,"\n\n     Ref. Factors Invalid !!!!\n"); Panel_Komaki_UARTX_For_Sprintf();
			*/
		}
	}
}
void    Calibration____Stage_1____Magnitude(void){
	int32_t   i;
	int32_t   CTPT_Index;
	int32_t   *RefAngle___Adr_In_MHA;
	int32_t 	Ref_Abs; 
		
	//----------S: tedate digitalha dar CMTRD movaghatan 0 mishavad ----------
	if(Calib____CMTRD____Num_Of_Digitals___Before_Calib_Stage1==1000000)
		Calib____CMTRD____Num_Of_Digitals___Before_Calib_Stage1 = MHA[VMA[Calib____Index_Of_CMTRD_BLK____In_VMA + CMTRD_BLK____NumOfDigitals____Index_In_BLK] + PatternModel_5____Index_Of____Value];
	MHA[VMA[Calib____Index_Of_CMTRD_BLK____In_VMA + CMTRD_BLK____NumOfDigitals____Index_In_BLK] + PatternModel_5____Index_Of____Value]=0;// tedade Digitalha
	//----------E: tedate digitalha dar CMTRD movaghatan 0 mishavad ----------
	//----------S: Save Sample Data On SDRAM ----------
	CFC_BLK__RECORD___CMTRD____Perfault____Analog(VMA + Calib____Index_Of_CMTRD_BLK____In_VMA+1);
	//----------E: Save Sample Data On SDRAM ----------
	
	if(GLB_Counter_Samples_Total_New == 2){
		Calibration_Stage = 1;
		TEMP__CFC_Run = 1;
		MHA[Calib____Index_In_MHA____PhaseAngle_Ref____Relay] = 1; //for Calib Stage 2
		GLB____Hardware_Fault__Message[1]=0;
		MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=1;
		GLB____Measure____FFT_In_While_1____FFT_In_1ms_0 = 0;
		
		for(CTPT_Index=0; CTPT_Index < GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index++){
			CALIB_DATA__Magni__Part1[1][CTPT_Index] = PT_Calib___RMS_Default_ScaleFactor;
			CALIB_DATA__Magni__Part1[2][CTPT_Index] = PT_Calib___H1_Default_ScaleFactor;
			CALIB_DATA__Magni__Part1[3][CTPT_Index] = PT_Calib___H2_Default_ScaleFactor;
		}
	}
	if(GLB_Counter_Samples_Total_New == 100){
		
		Ref_Abs = MHA[VMA[FFT_BLK____First_Analog____Index_In_VMA+ (Calib____Ref_Phase_Angle____CTPT_Index-1)] + PatternModel_1____First_Index____FFT+2];
		if(Ref_Abs < RefAngle___Min_Abs_Value)
			GLB____Hardware_Fault__Message[1]|=(One<<Err____Calib____RefAngle___Low_Abs);
	}
	if(GLB_Counter_Samples_Total_New < GLB__CLK_CALIB____Time_Needed_For_Clock_Calib_At_CalibMode1){
		//----------S: Calib Timer Clock Using RefAngle FFT ----------
		RefAngle___Adr_In_MHA = VMA + FFT_BLK____First_Analog____Index_In_VMA + (Calib____Ref_Phase_Angle____CTPT_Index-1);
		CALIB_DATA__Magni__Part1[2][Calib____Ref_Phase_Angle____CTPT_Index-1] = PT_Calib___H1_Default_ScaleFactor;
		CFC_BLK__SIG_PROC____FFT_MAIN(RefAngle___Adr_In_MHA, 0);
		//----------E: Calib Timer Clock Using RefAngle FFT ----------
	}
	else if(GLB_Counter_Samples_Total_New == GLB__CLK_CALIB____Time_Needed_For_Clock_Calib_At_CalibMode1){
		MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=0;
		TEMP__CFC_Run = 0;
		Calibration_Stage = 2;
		
		for(i=GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; i<GLB_Num_Of_Available_CTPT; i++){
			SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6)*i +2]=0;
			SDRAM____Magnitude_CTPT_Calib[(GLB_Calib__VI_Max_Steps_Count+6)*i +3]=0;
		}
	}
	else if(GLB_Counter_Samples_Total_New>GLB__CLK_CALIB____Time_Needed_For_Clock_Calib_At_CalibMode1+2 && ((GLB_Counter_Samples_Total_New - GLB__CLK_CALIB____Time_Needed_For_Clock_Calib_At_CalibMode1)% Scan_CTPTs_Any_ms)==0 && GLB_Calib__Count<GLB_Calib__VI_Max_Steps_Count){
//if(GLB_Calib__Count==2)
//	GLB_Calib__Count=GLB_Calib__Count;
		Calibration____Stage_1____Determine_Two_Pos_And_Neg_Peak_Value();

		for(CTPT_Index = GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index<GLB_Num_Of_Available_CTPT; CTPT_Index++){
			if((CALIB_DATA__Magni__Part1[4][CTPT_Index]==PT && GLB_Calib__Count<GLB_Calib__V_Steps_Count) || (CALIB_DATA__Magni__Part1[4][CTPT_Index]==CT && GLB_Calib__Count<GLB_Calib__I_Steps_Count)){
				SDRAM____Magnitude_CTPT_Calib_Max_Last [GLB_Calib__VI_Max_Steps_Count *CTPT_Index +GLB_Calib__Count] = GLB_Max_Samples_Value_Last[CTPT_Index];
				SDRAM____Magnitude_CTPT_Calib_Max	     [GLB_Calib__VI_Max_Steps_Count *CTPT_Index +GLB_Calib__Count] = GLB_Max_Samples_Value[CTPT_Index];
				SDRAM____Magnitude_CTPT_Calib_Min_Last [GLB_Calib__VI_Max_Steps_Count *CTPT_Index +GLB_Calib__Count] = GLB_Min_Samples_Value_Last[CTPT_Index];
				SDRAM____Magnitude_CTPT_Calib_Min	     [GLB_Calib__VI_Max_Steps_Count *CTPT_Index +GLB_Calib__Count] = GLB_Min_Samples_Value[CTPT_Index];
			}
		}

		GLB_Calib__Count++;
	}
	if(GLB_Calib__Count==GLB_Calib__VI_Max_Steps_Count){
		MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value] = 1;
		Calibration____Stage_1____Finished=1;
		//----------S: tedate digitalha dar CMTRD eslah mishavad ----------
		MHA[VMA[Calib____Index_Of_CMTRD_BLK____In_VMA + CMTRD_BLK____NumOfDigitals____Index_In_BLK] + PatternModel_5____Index_Of____Value] = Calib____CMTRD____Num_Of_Digitals___Before_Calib_Stage1;
		//----------E: tedate digitalha dar CMTRD eslah mishavad ----------
	}
} 
void    Calibration____Calib_Tasks_In_While(void){
	if(Calibration____Stage_1____Finished==1){
		Calibration____Stage_1____Finished=2;
		GLB_Calib__Count=0;
		Calibration____Stage_1____Save_Result();
	}
	else if(Calib_Mode==2 && Calibration____Stage_2____Finished==1){
		Calibration____Stage_2____Finished=0;
		Calibration____Stage_2____Save_Result();
	}

	//----------S: Switch to Calib Mode 2 FFTCalib
	if(Calib_Mode==2 && Calibration____Calib_Mode_Changed==1){
		Calibration____Calib_Mode_Changed=0;
		if(Calibration____Stage_2____FFT_Factors__Mode==1){
			Calibration____Stage_2____Load_Calibration_CT_PT_Magnit();
			usleep(100000);
			MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=0;
			if(GLB____Hardware_Fault__Message[1]!=0)
				Check__Ref_Calib_Factor_Validation_For_Disp();
			
			Calibration____Stage_2____FFTCalibVal____Init();
		}
	}
	//----------E: Switch to Calib Mode 2 FFTCalib
}
#endif
#if(1) // Measurement/Spontaneous_Message
void Measurement____Show_VI_H1_on_LCD(int32_t PhiVI, int32_t int_VI, int32_t Index_In_HF_INFO, int32_t Primary_Value, int32_t Secndary_Value, int32_t Module_Type, int32_t *VMA_PNT){
	int32_t   Divider, Multiplayer, POWER_Val=0;
	int32_t  	Num_Of_Sample_For_Measure = (GLB____Measure____FFT_In_While_1____FFT_In_1ms_0==0?RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure:(GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1));
	

	sprintf__Double_as_string(PhiVI,1,100,1 , 5, 1, SDRAM____MyStr_0);
	sprintf(VFC_Variable_Name , "%s", (SDRAM____HF_Vriables__INFO+Index_In_HF_INFO));
	sprintf(VFC_Variable_Label, "%s", (SDRAM____HF_Vriables__INFO+Index_In_HF_INFO + VFC____SIGNAL_NAME__Size));
	
	sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog                                          ,"%s", VFC_Variable_Name );//name
	sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + VFC____SIGNAL_NAME__Size               ,"%s", VFC_Variable_Label);// label
	
	switch(Module_Type){
		case CFC____Signal__Type____PT:{
			sprintf__Double_as_string(int_VI, 1, Num_Of_Sample_For_Measure ,10 ,3 ,1, SDRAM____MyStr_1);
			if(GLB_Int_to_Double_To_Char_Resulu_Is_Zero==1 ||  int_VI<Num_Of_Sample_For_Measure*5 ){
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Sec_Val____Start     ,"%s", "0.0    ");// sec. val
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____PhaseVal____Start    ,"%s", "0.0   "); // phase angle
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_1____Start      ,"%s", "V   "); 
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start    ,"%s", "0.0  "); //prim. val
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start      ,"%s", "V   ");
			}
			else{
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Sec_Val____Start     ,"%s", SDRAM____MyStr_1);// sec. val
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____PhaseVal____Start    ,"%s", SDRAM____MyStr_0); // phase angle
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_1____Start      ,"%s", "V   "); 

				sprintf__Double_as_string(int_VI, Primary_Value, Secndary_Value , Num_Of_Sample_For_Measure*10000, 3, 2, SDRAM____MyStr_1);
				if(Integer_part_64bit!=0){
					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start  ,"%s", SDRAM____MyStr_1); //prim. val
					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start    ,"%s", "kV  ");
//					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* GLB____LCD____Max_Num_Of_Char_In_a_Lines+25,"%8s kV",SDRAM____MyStr_1); 																		;
				}
				else{
					sprintf__Double_as_string(int_VI, Primary_Value, Secndary_Value , Num_Of_Sample_For_Measure, 3, 0, SDRAM____MyStr_1);
					if(Integer_part_64bit!=0){
//					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* GLB____LCD____Max_Num_Of_Char_In_a_Lines+25,"%8s  V",SDRAM____MyStr_1); 																	
						sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start  ,"%s", SDRAM____MyStr_1); //prim. val
					}
					else{
//					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* GLB____LCD____Max_Num_Of_Char_In_a_Lines+25,"       0  V");																													
						sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start  ,"%s", "0     "); //prim. val
					}
					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start      ,"%s", "V   ");
				}
			}
		}
		break;
		case CFC____Signal__Type____CT:{
			sprintf__Double_as_string(int_VI, 1, Num_Of_Sample_For_Measure , 1000, 5, 3, SDRAM____MyStr_1);
			
			if(GLB_Int_to_Double_To_Char_Resulu_Is_Zero==1 ||  10*int_VI<Num_Of_Sample_For_Measure*22*Secndary_Value ){
//			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog   ,"%s=%s", VFC_Variable_Label,"   0.000 <   0.0 A"); 																							
//			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog  +25,"       0  A");																															
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Sec_Val____Start    ,"%s", "0.000  ");// sec. val
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____PhaseVal____Start   ,"%s", "0.0   "); // phase angle
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_1____Start     ,"%s", "A   "); 
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start   ,"%s", "0    "); //prim. val
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start     ,"%s", "A   ");
			}
			else{
//			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog   ,"%s=%8s <%6s A", VFC_Variable_Label, SDRAM____MyStr_1, SDRAM____MyStr_0);	
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Sec_Val____Start     ,"%s", SDRAM____MyStr_1);// sec. val
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____PhaseVal____Start    ,"%s", SDRAM____MyStr_0); // phase angle
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_1____Start      ,"%s", "A   "); 

				sprintf__Double_as_string(int_VI, Primary_Value, Secndary_Value*1000 , Num_Of_Sample_For_Measure*1000, 3, 2, SDRAM____MyStr_1);
				
				if(Integer_part_64bit!=0){
//				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog+25,"%8s kA",SDRAM____MyStr_1); 																		
					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start  ,"%s", SDRAM____MyStr_1); //prim. val
					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start    ,"%s", "kA  ");
				}
				else{
					sprintf__Double_as_string(int_VI, Primary_Value, Secndary_Value*1000 , Num_Of_Sample_For_Measure, 5, 0, SDRAM____MyStr_1);
					if(Integer_part_64bit!=0){
//					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + 25,"%8s  A",SDRAM____MyStr_1); 																	
						sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start   ,"%s", SDRAM____MyStr_1); //prim. val
					}
					else{
//					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog+25,"       0  A");																													
						sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start  ,"%s", "0    "); //prim. val
					}
					sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start  ,"%s", "A   ");
				}
			}
		}
		break;
		case CFC____Signal__Type____ActivePower:
		case CFC____Signal__Type____ReactivePower:{
			Divider = *(MHA + *VMA_PNT + PatternModel_1____Index_Of____AmpDivider);
			Multiplayer = *(MHA + *VMA_PNT + PatternModel_1____Index_Of____Amp____Multiplayer);
			
			sprintf__Double_as_string(int_VI, Multiplayer, Num_Of_Sample_For_Measure , Divider*1000, 5, 3, SDRAM____MyStr_1);
			
//			POWER_Val = atoi(SDRAM____MyStr_1) ;
//			if(POWER_Val>999)
//				sprintf__Double_as_string(0, int_VI, Multiplayer, Num_Of_Sample_For_Measure , Divider*1000, 5, 3, SDRAM____MyStr_1);
				
			
			if(GLB_Int_to_Double_To_Char_Resulu_Is_Zero==1)
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Sec_Val____Start    ,"%s", "0.000  ");// sec. val
			else
				sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Sec_Val____Start     ,"%s", SDRAM____MyStr_1);// sec. val

			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____PhaseVal____Start   ,"%s", "      "); // phase angle
			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_1____Start     ,"%s", Module_Type ==CFC____Signal__Type____ActivePower?(POWER_Val<1000?"kW  ":"MW  "):(POWER_Val<1000?"kVAR":"MVAR")); 
			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Prim_Val____Start   ,"%s", "     "); //prim. val
			sprintf(SDRAM____Measurem_RECORDs_string + CFC____Measurement_BLK____Ofset+ Meas_Active_Analog_Inputs* CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measure____Unit_2____Start     ,"%s", "    ");
		}
		break;
	}
		
	Meas_Active_Analog_Inputs++;
} 
void Measurement____FFT(int32_t *VMA_PNT, int8_t Harm_Num){
//	int32_t  Temp_Cosfft;	
//	int32_t  Temp_Sinfft;	
//	int32_t  i;
//	int32_t  Calib_Factor;
//	int32_t  Phase_Calib =0;
//	int32_t  Real__WO_Unit =0;
//	int32_t  Imag__WO_Unit =0;
//	int32_t  Abs__WO_Unit =0;
//	int32_t  Sample;
//	int32_t  Real;
//	int32_t  Imag;
//	int32_t  Steps;
//	int32_t  Cosfft_Sinfft_Index;
//	int32_t  Phase_Calib_Row_part1;
//	int32_t  Sample_Row = GLB_Counter_Deleted_Row; 

//	int32_t *Type													= MHA + *(VMA_PNT) ;
//	int32_t *CTPT__Calib_Col							=	MHA + (*(VMA_PNT)+1) ;
//	

//	switch(Harm_Num){
//		case 0:
//			Calib_Factor = GLB__CALIB_DATA___FFT_Calib_Factor[*CTPT__Calib_Col];
//		break;
//		case 1:
//			Calib_Factor = GLB__CALIB_DATA___FFT_Calib_Factor[2*GLB_Num_Of_Available_CTPT + *CTPT__Calib_Col];	
//		break;
//	}
//		
//	
//	for(i=0; i<GLB_Number_of_Sample_per_Cycle; i++){
//		Cosfft_Sinfft_Index = (i * (Harm_Num+1))%GLB_Number_of_Sample_per_Cycle;
//		
//		
//		Temp_Cosfft= SDRAM____Cosfft_Sinfft[2*Cosfft_Sinfft_Index];
//		Temp_Sinfft= SDRAM____Cosfft_Sinfft[2*Cosfft_Sinfft_Index +1];
//		
//		Sample_Row++;
//		Sample_Row=(Sample_Row==GLB_Number_of_Sample_per_Cycle+2?0:Sample_Row);
//		Sample = (int16_t)MHA[*(VMA_PNT) + PatternModel_1____First_Index_Of__DataWindow + Sample_Row];
//		Real__WO_Unit += (Sample * Temp_Cosfft);
//		Imag__WO_Unit += (Sample * Temp_Sinfft);
//		
//		
////		*(uint32_t *)(SDRAM____CARDS_FLASH_DATA+ 2*GLB_Measre____FFT_In_While____Analog_Index * GLB_Number_of_Sample_per_Cycle + 2*i) = Sample;
//	}
//	
//	Abs__WO_Unit=Math_Radikal_a2_b2(Imag__WO_Unit, Real__WO_Unit);
//	Real= Real__WO_Unit/Calib_Factor;
//	Imag= Imag__WO_Unit/Calib_Factor;
//	GLB_Measre____FFT_In_While____Abs = Abs__WO_Unit/Calib_Factor;
//	
//	Phase_Calib_Row_part1= *CTPT__Calib_Col * GLB_Calib__VI_Max_Steps_Count_With_MidPoints; 
//	if(APLY_CMTRD___Triger != 1){
//		if(Harm_Num==0){
//			Steps=((*Type)==CFC____Signal__Type____PT?GLB_Calib__V_Steps_Count:GLB_Calib__I_Steps_Count);
//			if(GLB_Measre____FFT_In_While____Abs<Calib__VI_Steps((*Type), Steps-1))
//				Phase_Calib = SDRAM____Phase_Angle_Calibration[Phase_Calib_Row_part1 + GLB_Measre____FFT_In_While____Abs];
//			else
//				Phase_Calib = SDRAM____Phase_Angle_Calibration[Phase_Calib_Row_part1 + Calib__VI_Steps((*Type), Steps-1)-1];
//		}
//	}

//	GLB_Measre____FFT_In_While____Phase_Angle = Math_Arctan_Function_Using_Ram(Real, Imag) + Phase_Calib;
}





void Measurement____FFT_In_While____Part_0(void){
	int32_t   VI, Phase_Angle_Row;
	int32_t   i, j;

	if(GLB_Counter_Samples_Total_New>50 && CFC____Measurement_BLK____Num_Of_Analog_Inputs>0){
		
		GLB_Measre____FFT_In_While____Counter_Samples_Total = GLB_Counter_Samples_Total_New;

		if(GLB_Measre____FFT_In_While____Analog_Index>0 || GLB_Measre____FFT_In_While____Counter_Samples_Total != GLB_Measre____FFT_In_While____Counter_Samples_Start){
			//----------S: FFT ----------
			Measurement____FFT(VMA + FFT_BLK____First_Analog____Index_In_VMA + GLB_Measre____FFT_In_While____Analog_Index, Harm_1);
			//----------S: FFT ----------
//		SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index*4 + GLB_Measre____FFT_In_While____Analog_Index*4 + 3] = (int32_t)GLB_Measre____FFT_In_While____Counter_Samples_Total;
			if(GLB_Measre____FFT_In_While____Analog_Index == 0)
				GLB_Measre____FFT_In_While____Counter_Samples_Start = GLB_Measre____FFT_In_While____Counter_Samples_Total;
			else
				SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index*4 + GLB_Measre____FFT_In_While____Analog_Index*4 + 2] = (int32_t)(GLB_Counter_Samples_Total_New - GLB_Measre____FFT_In_While____Counter_Samples_Start);
			
			if(GLB_Measre____FFT_In_While____Counter_Samples_Total == GLB_Counter_Samples_Total_New){
				//----------S: Save ABS/ANGLE ----------
				SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index*4 + GLB_Measre____FFT_In_While____Analog_Index*4    ] = GLB_Measre____FFT_In_While____Abs;
				SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index*4 + GLB_Measre____FFT_In_While____Analog_Index*4 + 1] = GLB_Measre____FFT_In_While____Phase_Angle + SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index*4 + GLB_Measre____FFT_In_While____Analog_Index*4 + 2]*36000/GLB_Number_of_Sample_per_Cycle;
				//----------E: Save ABS/ANGLE ----------
				
				GLB_Measre____FFT_In_While____Analog_Index++;
				if(GLB_Measre____FFT_In_While____Analog_Index==CFC____Measurement_BLK____Num_Of_Analog_Inputs){
					GLB_Measre____FFT_In_While____Analog_Index =0;
					GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index++;
					if(GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index==GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)
						GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index=0;
				}
			}
		}
		//----------S: Average ----------
		if(GLB_Measre____FFT_In_While____Analog_Index == 0){
			for(i=0; i<CFC____Measurement_BLK____Num_Of_Analog_Inputs; i++){
				VI = 0;
				for(j=0; j<GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1; j++)
					VI += (SDRAM____Measre_In_While____Abs_Angle[i*4 + CFC____Measurement_BLK____Num_Of_Analog_Inputs * j*4]); 
				SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * (GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)*4 + i*4    ] = VI;

				Phase_Angle_Row = GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Index-1;
				if(Phase_Angle_Row<0)
					Phase_Angle_Row = GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-2;
				SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * (GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)*4 + i*4 + 1] = SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * Phase_Angle_Row*4 + i*4 +1];
			}
		}
		//----------E: Average ----------
	}
}
void Measurement(void){
	int32_t   k,n, i, j, CTPT_Index, V_or_I, LCD_Row_Komaki, Angel_Ref_Index=100, Analog_Index;
	int32_t   Index_In_HF_INFO;
	int32_t   *VMA_PNT;
	int32_t   Ref_Angle;	
	int32_t   Module_Type, Ref_Angle__Flag=0;
	int32_t   Primary, Secondary;
	int32_t   *MHA_PNT, FFTMEMINDEX;
	

	if(CFC____Measurement_BLK____Exist == En_YES && (GLB____Measure____FFT_In_While_1____FFT_In_1ms_0==1))
			Measurement____FFT_In_While____Part_0();
	
	if(Measure_Request!=0){
		if(CFC____Measurement_BLK____Exist == En_YES){
			for(i=0; i<CFC____Measurement_BLK____Num_Of_Analog_Inputs; i++){
				GLB_Meas_VI[i] =0;
				GLB_Meas_int_VIH2[i] =0;
				GLB_Meas_VI_RMS[i] = 0;
			}
			
			switch(Measure_Request){
				case Fundumental:{
					if(GLB____Measure____FFT_In_While_1____FFT_In_1ms_0==0){
						*(uint32_t *)(SDRAM____Measurem_RECORDs_string) = Measure_BLK____Num_Of_Analogs;

						//----------S: AMP ----------
						VMA_PNT = VMA + GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA;
						MHA_PNT = MHA + *VMA_PNT + PatternModels____CommonPart_Size;
						for(Analog_Index = 0; Analog_Index < CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
							if(*(MHA + *MHA_PNT + PatternModels____PARRENT__From_FFT_PNT) != *(VMA_PNT)){
								FFTMEMINDEX = *(MHA + *MHA_PNT + PatternModels____FFT_RMS_MemoryIndex__From_FFT_PNT);
								for(j = 0; j < RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure; j++){
									k = LCL_FFT_Counter_For_Row_Of_Memory_FFT - j; 
									if(k < 0)
										k += GLB_FFT_Memory____Max_Num_Of_FFT_Samples;	
									GLB_Meas_VI[Analog_Index]     += (SDRAM____FFTMemory_H1 [k * 4* CFC____FFT_Memory____Num_Of_Analogs + 4* FFTMEMINDEX + 2]); 
									GLB_Meas_VI_RMS[Analog_Index] += (SDRAM____RMS_Memory   [k *    CFC____FFT_Memory____Num_Of_Analogs +    FFTMEMINDEX    ]); 
								}
							}
							else{
								GLB_Meas_VI[Analog_Index] = 0;
								GLB_Meas_VI_RMS[Analog_Index] = 0;
							}
							MHA_PNT += PatternModels____Repetition_Part____Size;
						}
						//----------E: AMP ----------
						//----------S: Determine Phase Angle Reference ----------
						MHA_PNT = MHA + *VMA_PNT + PatternModels____CommonPart_Size;
						for(Analog_Index = 0; Analog_Index < CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
							if(*(MHA + *MHA_PNT + PatternModels____PARRENT__From_FFT_PNT) != *(VMA_PNT)){
//								Index_In_HF_INFO = *(MHA + *MHA_PNT + PatternModel_1____INFO);						
								Module_Type      = *(MHA + *MHA_PNT + PatternModels____SigType__From_FFT_PNT);
								switch(Module_Type){
									case CFC____Signal__Type____PT:
										if(GLB_Meas_VI[Analog_Index] > Measure__MinVolt_For_AngleRef * RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure)
											Ref_Angle__Flag=1;
									break;
									case CFC____Signal__Type____CT:
										if(GLB_Meas_VI[Analog_Index] > Measure__MinAmp_For_AngleRef * RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure)
											Ref_Angle__Flag=1;
									break;
								}
								if(Ref_Angle__Flag == 1){
									Ref_Angle = *(MHA + *MHA_PNT + 3);
									break;
								}
							}
							MHA_PNT += PatternModels____Repetition_Part____Size;
						}
						//----------E: Determine Phase Angle Reference ----------
						
						//----------S: AMP & Phase ----------
						MHA_PNT = MHA + *VMA_PNT + PatternModels____CommonPart_Size;
						for(Analog_Index = 0; Analog_Index < CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
							if(*(MHA + *MHA_PNT + PatternModels____PARRENT__From_FFT_PNT) != *(VMA_PNT)){
								//----------S: Phase ----------
								GLB_Meas_int_phaseVI[Analog_Index] = *(MHA + *MHA_PNT + 3);
//									Ref_Angle = GLB_Meas_int_phaseVI[0];
								
								if(GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle> 18000)
									GLB_Meas_int_phi[Analog_Index]=GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle - 36000;
								else if(GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle < -18000)
									GLB_Meas_int_phi[Analog_Index]=GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle + 36000;
								else
									GLB_Meas_int_phi[Analog_Index]=GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle;
								//----------E: Phase ----------
								Index_In_HF_INFO = *(MHA + *MHA_PNT + PatternModels____INFO__From_FFT_PNT); 
								Primary          = *(MHA + *MHA_PNT + PatternModels____Primary__From_FFT_PNT);
								Secondary        = *(MHA + *MHA_PNT + PatternModels____Secondary__From_FFT_PNT);
								Module_Type      = *(MHA + *MHA_PNT + PatternModels____SigType__From_FFT_PNT);
								Measurement____Show_VI_H1_on_LCD(GLB_Meas_int_phi[Analog_Index], GLB_Meas_VI[Analog_Index], Index_In_HF_INFO, Primary, Secondary, Module_Type, VMA_PNT);
							}
							MHA_PNT += PatternModels____Repetition_Part____Size;
						}

		//			//-----------ُ: Phase Angle ------------
		//			for(i=0; i<GLB_Num_Of_Available_CTPT; i++){
		//				if(GLB_Meas_int_phaseVI[i]-GLB_Meas_Ref_Angle>18000)
		//					GLB_Meas_int_phi[i]=GLB_Meas_int_phaseVI[i]-GLB_Meas_Ref_Angle-36000;
		//				else if(GLB_Meas_int_phaseVI[i]-GLB_Meas_Ref_Angle<-18000)
		//					GLB_Meas_int_phi[i]=GLB_Meas_int_phaseVI[i]-GLB_Meas_Ref_Angle+36000;
		//				else
		//					GLB_Meas_int_phi[i]=GLB_Meas_int_phaseVI[i]-GLB_Meas_Ref_Angle;
		//			}
		//			//-----------E: Phase Angle ------------
						//----------S: Angle ----------
	//					for(Analog_Index=0; Analog_Index<CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
	//						if(Modules_Type[i]==PT && GLB_Meas_VI[i]>Measure__MinVolt_For_AngleRef*RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure){
	//							GLB_Meas_Ref_Angle=GLB_Meas_int_phaseVI[i];
	//							break;
	//						}
	//						else if(Modules_Type[i]==CT && GLB_Meas_VI[i]>Measure__MinAmp_For_AngleRef * GLB_Meas_CT_Secndary * RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure){
	//							GLB_Meas_Ref_Angle=GLB_Meas_int_phaseVI[i];
	//							break;
	//						}
	//					}
						//----------E: Angle ----------

						Meas_Active_Analog_Inputs = 0;
						//----------E: AMP & Phase ----------
						//----------S: Send to FP ----------
						if(Calib_Mode==0){ 
							while(CPU____QTL____ADD_ITEM(FP_CPU____Measurement__Fundumental, 0,Measure_BLK____Num_Of_Analogs*CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measurement_BLK____Ofset, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string) != 1U);
						}
						//----------E: Send to FP ----------
						//----------S: CALIB MODE 2 ----------
						if(Calib_Mode==2){
							/*
							if(GLB_Counter_Samples_Total_New>4000*GLB_Number_of_Sample_per_Cycle/20){

								sprintf((char *)RAM_UART_BUFF,"\n"); Panel_Komaki_UARTX_For_Sprintf();
								for(CTPT_Index=GLB_Num_Of_Available_CTPT-Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index<GLB_Num_Of_Available_CTPT; CTPT_Index++){
									//sprintf((char *)RAM_UART_BUFF,".... %d %8d %d\n", GLB__CALIB_DATA___FFT_Calib_Factor[CTPT_Index],GLB_Meas_VI[CTPT_Index],  Modules_Type[CTPT_Index]); Panel_Komaki_UARTX_For_Sprintf();
//								if(Modules_Type[CTPT_Index]==PT)
//									GLB__CALIB_DATA___FFT_Calib_Factor[CTPT_Index] = (int32_t)((int64_t)PT_Calib___H1_Default_ScaleFactor * (int64_t)GLB_Meas_VI[CTPT_Index]/(int64_t)GLB_Measur_Calib_Factors__Ref_DeciVolt/(int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure);
//								else
//									GLB__CALIB_DATA___FFT_Calib_Factor[CTPT_Index] = (int32_t)((int64_t)GLB__CALIB_DATA___FFT_Calib_Factor[CTPT_Index] * (int64_t)GLB_Meas_VI[CTPT_Index] /(int64_t)GLB_Measur_Calib_Factors__Ref_miliAmper/(int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure);

									MHA_PNT = *(VMA + GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA+ CTPT_Index);
									
									if(CALIB_DATA__Magni__Part1[4][CTPT_Index] == PT){
//									CALIB_DATA__Magni__Part1[1][CTPT_Index] =                     CALIB_DATA__Magni__Part1[1][CTPT_Index]  *          GLB_Measur_Calib_Factors__Ref_DeciVolt / *(MHA + MHA_PNT + PatternModel_1____Index_Of____RMS);
										CALIB_DATA__Magni__Part1[1][CTPT_Index] = (int32_t)((int64_t)(CALIB_DATA__Magni__Part1[1][CTPT_Index]) * (int64_t)GLB_Measur_Calib_Factors__Ref_DeciVolt * (int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure) / (int64_t)GLB_Meas_VI_RMS[CTPT_Index];
										CALIB_DATA__Magni__Part1[2][CTPT_Index] = (int32_t)((int64_t)(CALIB_DATA__Magni__Part1[2][CTPT_Index]) * (int64_t)GLB_Meas_VI[CTPT_Index]/(int64_t)GLB_Measur_Calib_Factors__Ref_DeciVolt/(int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure);
									}
									else{
//									CALIB_DATA__Magni__Part1[1][CTPT_Index] = CALIB_DATA__Magni__Part1[1][CTPT_Index] * GLB_Measur_Calib_Factors__Ref_miliAmper / *(MHA + MHA_PNT + PatternModel_1____Index_Of____RMS);
										CALIB_DATA__Magni__Part1[1][CTPT_Index] = (int32_t)((int64_t)(CALIB_DATA__Magni__Part1[1][CTPT_Index]) * (int64_t)GLB_Measur_Calib_Factors__Ref_miliAmper * (int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure) / (int64_t)GLB_Meas_VI_RMS[CTPT_Index];
										CALIB_DATA__Magni__Part1[2][CTPT_Index] = (int32_t)((int64_t)(CALIB_DATA__Magni__Part1[2][CTPT_Index]) * (int64_t)GLB_Meas_VI[CTPT_Index] /(int64_t)GLB_Measur_Calib_Factors__Ref_miliAmper/(int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure);
									}
//									sprintf((char *)RAM_UART_BUFF,"M#%3d  Calib_Factor=%7d\n",CTPT_Index, GLB__CALIB_DATA___FFT_Calib_Factor[CTPT_Index]); Panel_Komaki_UARTX_For_Sprintf();
//									CALIB_DATA__Magni__Part1[2][CTPT_Index] = GLB__CALIB_DATA___FFT_Calib_Factor[CTPT_Index];
								}	
								MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=1;
								Measure_Request = H2;
								GLB_Counter_Samples_Total_New = 0;
							}
							*/
						}
						//----------E: CALIB MODE 2 ----------
					}
					else{
						*(uint32_t *)(SDRAM____Measurem_RECORDs_string) = Measure_BLK____Num_Of_Analogs;
						
						//----------S: Determine Phase Angle Reference ----------
						for(Analog_Index=0; Analog_Index<CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
							GLB_Meas_VI[Analog_Index] = SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * (GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)*4 + Analog_Index*4]/(GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1);
							
							Index_In_HF_INFO = MHA[VMA[GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA+ Analog_Index] + PatternModel_1____Index_Of____INFO_Index];						
							Module_Type = SDRAM____HF_Vriables__INFO[Index_In_HF_INFO*VFC____SIGNAL_INFO__Total_Size + VFC____SIGNAL_LABEL_AND_NAME__Size];
							switch(Module_Type){
								case CFC____Signal__Type____PT:
									if(GLB_Meas_VI[Analog_Index]> Measure__MinVolt_For_AngleRef)
										Ref_Angle__Flag=1;
								break;
								case CFC____Signal__Type____CT:
									if(GLB_Meas_VI[Analog_Index]> Measure__MinAmp_For_AngleRef)
										Ref_Angle__Flag=1;
								break;
							}
							if(Ref_Angle__Flag == 1){
								Ref_Angle=SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * (GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)*4 + Analog_Index*4 + 1];
								break;
							}
						}
						//----------E: Determine Phase Angle Reference ----------
						
						for(Analog_Index=0; Analog_Index<CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
							GLB_Meas_VI[Analog_Index] = SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * (GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)*4 + Analog_Index*4];
							//----------S: Phase ----------
							GLB_Meas_int_phaseVI[Analog_Index] = SDRAM____Measre_In_While____Abs_Angle[CFC____Measurement_BLK____Num_Of_Analog_Inputs * (GLB_Measre____FFT_In_While____SDRAM____Circular_Buffer____Num_Of_Parts-1)*4 + Analog_Index*4 + 1];
							
//							Ref_Angle = GLB_Meas_int_phaseVI[0];
							
							if(GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle>18000)
								GLB_Meas_int_phi[Analog_Index]=GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle-36000;
							else if(GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle<-18000)
								GLB_Meas_int_phi[Analog_Index]=GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle+36000;
							else
								GLB_Meas_int_phi[Analog_Index]=GLB_Meas_int_phaseVI[Analog_Index]-Ref_Angle;
							//----------E: Phase ----------
							
							Primary = MHA[VMA[GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA+ Analog_Index] +PatternModel_1____Index_Of____Primary];
							Primary = MHA[VMA[GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA+ Analog_Index] +PatternModel_1____Index_Of____Secondary];
							Module_Type = *(MHA + *(VMA + GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA+ Analog_Index) +PatternModel_1____Index_Of____CTPT_Type);
							VMA_PNT = VMA + GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA+ Analog_Index;
							Measurement____Show_VI_H1_on_LCD(GLB_Meas_int_phi[Analog_Index], GLB_Meas_VI[Analog_Index], Index_In_HF_INFO, Primary, Secondary, Module_Type, VMA_PNT);
						}
						Meas_Active_Analog_Inputs = 0;
						//----------S: Send to FP ----------
						if(Calib_Mode==0){
							while(CPU____QTL____ADD_ITEM(FP_CPU____Measurement__Fundumental, 0,Measure_BLK____Num_Of_Analogs*CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measurement_BLK____Ofset, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string) != 1U);
						}
						//----------E: Send to FP ----------
					}
				}
				break;
				case H2:{
					//----------S: AMP ----------
					for(Analog_Index=0; Analog_Index<CFC____Measurement_BLK____Num_Of_Analog_Inputs; Analog_Index++){
						for(j=0; j<RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure; j++){
							k=LCL_FFT_Counter_For_Row_Of_Memory_FFT-j;
							if(k<0)
								k=k+GLB_FFT_Memory____Max_Num_Of_FFT_Samples; 	
							GLB_Meas_VI[Analog_Index] += (SDRAM____FFTMemory_H2 [k* 4* CFC____FFT_Memory____Num_Of_Analogs + 4* Analog_Index+2]); 
						}
					}
					Meas_Active_Analog_Inputs = 0;
					//----------E: AMP ----------
					//----------S: Send to FP ----------
					if(Calib_Mode==0){
						while(CPU____QTL____ADD_ITEM(FP_CPU____Measurement__H2, 0,Measure_BLK____Num_Of_Analogs*CFC____Measurement_BLK____Num_Of_Bytes_For_Any_Analog + CFC____Measurement_BLK____Ofset, 1, GLB__SDRM_START_BYTE____Measurem_RECORD_string) != 1U);
					}
					//----------E: Send to FP ----------
					//----------S: CALIB MODE 2 ----------
					if(Calib_Mode==2){
						if(GLB_Counter_Samples_Total_New>4*RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure*GLB_Number_of_Sample_per_Cycle/20){
							for(CTPT_Index = GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib; CTPT_Index < CFC____Measurement_BLK____Num_Of_Analog_Inputs; CTPT_Index++){
								if(CALIB_DATA__Magni__Part1[4][CTPT_Index] == CT)
									CALIB_DATA__Magni__Part1[3][CTPT_Index] = (int32_t)((int64_t)(CALIB_DATA__Magni__Part1[3][CTPT_Index]) * (int64_t)GLB_Meas_VI[CTPT_Index] /(int64_t)GLB_Measur_Calib_Factors__Ref_miliAmper/(int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure);
								else
									CALIB_DATA__Magni__Part1[3][CTPT_Index] = (int32_t)((int64_t)(CALIB_DATA__Magni__Part1[3][CTPT_Index]) * (int64_t)GLB_Meas_VI[CTPT_Index] /(int64_t)GLB_Measur_Calib_Factors__Ref_DeciVolt /(int64_t)RMS_FFT_Memory___Num_Of_FFT_Samples_For_Measure);
							}
							
							Calibration____Stage_2____FFT_Factors__Mode=0;
							MHA[Calib____Index_In_MHA____OUTPUT_For_CALIB + PatternModel_0____Index_Of____Value]=0;
							usleep(100000);

							{				
								GLB_Calib__Count=0;

								Check_Validation_Of_FFT_Scale_Factors(GLB_Num_Of_Available_CTPT - Calib____Num_Of_CTPTs_On_4th_Card_For_Calib);
								Measure_Request = 0;
								GLB_Counter_Samples_Total_New=-1;
							}
							Calibration_Stage = 4;
						}
					}
					//----------E: CALIB MODE 2 ----------
				}
				break;
			}
		}
		
		LCL_FFT_Counter_For_Row_Of_Memory_FFT=GLB____FFT_Memory____Counter-1;	
		if(LCL_FFT_Counter_For_Row_Of_Memory_FFT<0)
			LCL_FFT_Counter_For_Row_Of_Memory_FFT=GLB_FFT_Memory____Max_Num_Of_FFT_Samples-1;	
		
		if(Calib_Mode!=2)
			Measure_Request=0;
	}
}
void Spontaneous_Message_On_LCD(void){
	int8_t Line_Index=0;
	int32_t GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last = Sequense_Of_BLK_that_Triped_Lastly_2;

	

	


	GLB_Meas__No_Trip=0;
	
	if(Active_Spontaneous_Message_On_Display==1){
		Active_Spontaneous_Message_On_Display = 0;
		GLB_Meas__Func_Picked_Up_First = Function_That_Picked_Up_First_2;
		GLB_Meas__Func_Triped_Last = Protection_Function_That_Tripped_Last_2;
		GLB_Meas__General_PU_To_Drop_Count = General_Pickup_To_Dropout_Counter_2;
		GLB_Meas__General_PU_To_First_Trip_Count = General_Pickup_To_First_Trip_Counter_2;
		GLB_Meas__VFC_BLK_Sequense_that_Pickup_First = BLK_Sequense_that_Pickup_First_2;
		
		GLB_Meas__Dist_Sensitiv_Func_That_PU=Dist_Protection_Function_That_Picked_Up_2;
		GLB_Meas__Dist_Sensitiv_Func_That_Trip=Dist_Protecton_Function_Trip_2;
//		if(RAM_Setting_Matrix[Row____Setting____General_Device_Settings____Spontaneous_Fault_Disp_____1173]==0){
			GLB_Fault_Is_Displying=1;
			if(Measure_Request==0){
//				Clear_LCD_Array();
				switch(GLB_Meas__Func_Picked_Up_First){ 
					case EN__51_PU			          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "51 PICKUP"           , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__50_x_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50 PICKUP"           , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__51N_PU			          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "51N PICKUP"          , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__50N_1_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50N-1 PICKUP"        , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__50N_2_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50N-2 PICKUP"        , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__50N_3_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50N-3 PICKUP"        , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__67_TOC_PU	          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67-TOC PICKUP"       , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__67_x_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67 PICKUP"           , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__67N_TOC_PU	          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-TOC PICKUP"      , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__67N_1_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-1 PICKUP"        , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__67N_2_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-2 PICKUP"        , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__67N_3_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-3 PICKUP"        , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__59_1_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "59-1 PICKUP"         , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__59_2_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "59-2 PICKUP"         , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__27_1_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "27-1 PICKUP"         , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__27_2_PU		          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "27-2 PICKUP"         , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__27_1_PU_CS	          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "27-1 PICKUP With CS" , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__27_2_PU_CS	          : 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "27-2 PICKUP With CS" , GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__87_PU	          		: 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "87 PICKUP"   				, GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
					case EN__21_PU	          		: 	  sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "21 PICKUP"   				, GLB_Meas__VFC_BLK_Sequense_that_Pickup_First);		break;
				}
//				switch(GLB_Meas__Func_Triped_Last){
//					case EN__51_TRIP							: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "51 TRIP", 	            Line_Index++, 0); }		break;
//					case EN__50_1_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50-1 TRIP",             Line_Index++, 0); }		break;
//					case EN__50_2_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50-2 TRIP",             Line_Index++, 0); }		break;
//					case EN__50_3_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50-3 TRIP",             Line_Index++, 0); }		break;
//					case EN__51N_TRIP							: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "51N TRIP",              Line_Index++, 0); }		break;
//					case EN__50N_1_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50N-1 TRIP",            Line_Index++, 0); }		break;
//					case EN__50N_2_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50N-2 TRIP",            Line_Index++, 0); }		break;
//					case EN__50N_3_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50N-3 TRIP",            Line_Index++, 0); }		break;
//					case EN__67_TOC_TRIP					: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67-TOC TRIP",           Line_Index++, 0); }		break;
//					case EN__67_1_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67-1 TRIP",             Line_Index++, 0); }		break;
//					case EN__67_2_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67-2 TRIP",             Line_Index++, 0); }		break;
//					case EN__67_3_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67-3 TRIP",             Line_Index++, 0); }		break;
//					case EN__67N_TOC_TRIP					: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67N-TOC TRIP",          Line_Index++, 0); }		break;
//					case EN__67N_1_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67N-1 TRIP",            Line_Index++, 0); }		break;
//					case EN__67N_2_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67N-2 TRIP",            Line_Index++, 0); }		break;
//					case EN__67N_3_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67N-3 TRIP",            Line_Index++, 0); }		break;
//					case EN__59_1_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "59-1 TRIP",             Line_Index++, 0); }		break;
//					case EN__59_2_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "59-2 TRIP",             Line_Index++, 0); }		break;
//					case EN__27_1_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-1 TRIP",             Line_Index++, 0); }		break;
//					case EN__27_2_TRIP						: 		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-2 TRIP",             Line_Index++, 0); }		break;
//					case 0: GLB_Meas__No_Trip=1;				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "No TRIP",   	          Line_Index++, 0); }		break;
//				}

				Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD(SDRAM____String_Komaki, 	    Line_Index++, 0);
				
				if     ((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__51_TRIP				))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "51 TRIP", 	     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__50_x_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50 TRIP",       GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__51N_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "51N TRIP",      GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__50N_1_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50N-1 TRIP",    GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__50N_2_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50N-2 TRIP",    GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__50N_3_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "50N-3 TRIP",    GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67_TOC_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67-TOC TRIP",   GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67_x_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67 TRIP",       GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67_2_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67-2 TRIP",     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67_3_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67-3 TRIP",     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67N_TOC_TRIP	))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-TOC TRIP",  GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67N_1_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-1 TRIP",    GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67N_2_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-2 TRIP",    GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__67N_3_TRIP		))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "67N-3 TRIP",    GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__59_1_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "59-1 TRIP",     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__59_2_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "59-2 TRIP",     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__27_1_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "27-1 TRIP",     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__27_2_TRIP			))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "27-2 TRIP",     GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__87_TRIP				))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "87 TRIP",     	 GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<EN__21_TRIP				))!=0)		{ sprintf(SDRAM____String_Komaki, "%s(Seq#%d)", "21 TRIP",     	 GLB_Meas__Sequense_Of_VFC_BLK_that_Triped_Last);  	}
				else {GLB_Meas__No_Trip=1;                                                          sprintf(SDRAM____String_Komaki, "No Trip");   }                                                       
				
				Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD(SDRAM____String_Komaki, 	    Line_Index++, 0);
				
				
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<14))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "46-TOC PICKUP", 0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<15))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "Differential PICKUP", 0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<16))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "Distance PICKUP", 0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<17))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "Under-Current PICKUP", 0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<18))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "46-1 PICKUP", 0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<19))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "46-2 PICKUP", 0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<20))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50 1Ph. Stage1 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<21))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50 1Ph. Stage2 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<22))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-1 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<23))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-1 PU With CS", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<24))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-2 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<25))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-2 PU With CS", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<26))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "59-1 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<27))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "59-2 PU", 0, 0);}
	//			else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<28))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67-3 PICKUP",   0, 0);	}
	//			else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<29))!=0) 			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67N-3 PICKUP",  0, 0);	}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<30))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50Ns_1 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<31))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50Ns_2 PU", 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<32))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "51Ns PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<33))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "51M PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<34))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "48 PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<35))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-1 PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<36))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-2 PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<37))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-3 PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<38))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-4 PU"  , 0, 0);}
//				else if((GLB_Meas__Func_Picked_Up_First  & (GLB_int64_t_1<<39))!=0)				{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "46M PU"  , 0, 0);}
				
				
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<1))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "AZ1 PU", 6, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<2))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "AZ2 PU", 7, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<3))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "AZ3 PU", 8, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<4))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BZ1 PU", 9, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<5))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BZ2 PU", 10, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<6))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BZ3 PU", 11, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<7))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CZ1 PU", 12, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<8))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CZ2 PU", 13, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<9))!=0)			  { Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CZ3 PU", 14, 0);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<10))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "ABZ1 PU", 6, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<11))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "ABZ2 PU", 7, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<12))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "ABZ3 PU", 8, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<13))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BCZ1 PU", 9, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<14))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BCZ2 PU", 10, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<15))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BCZ3 PU", 11, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<16))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CAZ1 PU", 12, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<17))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CAZ2 PU", 13, 10);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_PU 	  & (GLB_int64_t_1<<18))!=0)			{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CAZ3 PU", 14, 10);}
				//-----------E: ????? ????? ?? ?????? ???? ?? ????? ??? ???????? ????? ???? ?????? ------------
				//-----------S: ????? ????? ?? ???? ????  ?? ????? ??? ???????? ????? ???? ?????? ------------
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<14))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "46 TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<15))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "Differential TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<16))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "Distance TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<17))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "Under-Current TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<18))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50 1Ph. Stage1 TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<19))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50 1Ph. Stage2 TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<20))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-1 TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<21))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "27-2 TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<22))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "59-1 TRIP",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<23))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "59-2 TRIP",  1, 0);  	}
	//			else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<24))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67-3 TRIP",    1, 0);	 	}
	//			else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<25))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "67N-3 TRIP",   1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<26))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50Ns_1 Trip",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<27))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "50Ns_2 Trip",  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<28))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "51Ns Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<29))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "51M Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<30))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "48 Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<31))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-1 Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<32))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-2 Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<33))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-3 Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<34))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "81-4 Trip"  ,  1, 0);  	}
//				else if((GLB_Meas__Func_Triped_Last & (GLB_int64_t_1<<35))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "46M Trip"  ,  1, 0);  	}
//				else { GLB_Meas__No_Trip=1; Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "No Trip",1, 0); }
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<1))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "AZ1 Trip", 6,  20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<2))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "AZ2 Trip", 7,  20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<3))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "AZ3 Trip", 8,  20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<4))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BZ1 Trip", 9,  20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<5))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BZ2 Trip", 10, 20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<6))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BZ3 Trip", 11, 20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<7))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CZ1 Trip", 12, 20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<8))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CZ2 Trip", 13, 20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<9))!=0)		{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CZ3 Trip", 14, 20);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<10))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "ABZ1 Trip", 6, 30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<11))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "ABZ2 Trip", 7, 30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<12))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "ABZ3 Trip", 8, 30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<13))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BCZ1 Trip", 9, 30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<14))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BCZ2 Trip", 10,30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<15))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "BCZ3 Trip", 11,30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<16))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CAZ1 Trip", 12,30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<17))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CAZ2 Trip", 13,30);}
				if((GLB_Meas__Dist_Sensitiv_Func_That_Trip 	  		& (GLB_int64_t_1<<18))!=0)	{ Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( "CAZ3 Trip", 14,30);}
				//-----------E: ????? ????? ?? ???? ????  ?? ????? ??? ???????? ????? ???? ?????? ------------
				//-----------S: ????? ????? ????? ?????? ?? ????? ???????? ?? ??? ?????????? ?? ??? ??? ???????? ????? ???? ?????? ------------
				sprintf__Double_as_string(GLB_Meas__General_PU_To_Drop_Count,1000,GLB_Rated_Frequency,GLB_Number_of_Sample_per_Cycle , 0, 0, SDRAM____MyStr_0);
				sprintf(SDRAM____Measurem_RECORDs_string,"PU Time:%s ms",SDRAM____MyStr_0); Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( SDRAM____Measurem_RECORDs_string, Line_Index++, 0);
				//-----------E: ????? ????? ????? ?????? ?? ????? ???????? ?? ??? ?????????? ?? ??? ??? ???????? ????? ???? ?????? ------------
				//-----------S: ????? ????? ????? ?????? ?? ????? ???? ?? ??? ?????????? ?? ??? ????? ???????? ????? ???? ?????? ------------
				if(GLB_Meas__No_Trip==0){
					sprintf__Double_as_string(GLB_Meas__General_PU_To_First_Trip_Count,1000,GLB_Rated_Frequency,GLB_Number_of_Sample_per_Cycle , 0, 0, SDRAM____MyStr_0);
					sprintf(SDRAM____Measurem_RECORDs_string,"TRIP Time:%s ms",SDRAM____MyStr_0); Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( SDRAM____Measurem_RECORDs_string, Line_Index++, 0);
				}
				//-----------E: ????? ????? ????? ?????? ?? ????? ???? ?? ??? ?????????? ?? ??? ????? ???????? ????? ???? ?????? ------------
				//-----------S: ????? ?? ??? ???? ??? ?? ??? ???? ???????? ????? ???? ?????? ------------
		// 		sprintf(st,"Dist. To Fault:");
		// 		Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( st, 4, 0);
		// 		if(RAM_Setting_Matrix[Row____Setting____Power_System_Data_1____Power_system____Distance_measurement_unit____48]==0)
		// 			sprintf(st,"%d km",10);
		// 		else
		// 			sprintf(st,"%d miles",10);
		// 		Fill_New_LCD_Ascii_Code_Of_Chars_Shows_On_LCD( st, 4, 21);
				//-----------E: ????? ?? ??? ???? ??? ?? ??? ???? ???????? ????? ???? ?????? ------------
				GLB_Number_Of_Hiden_Item_Above=0;
				GLB_Number_Of_Hiden_Item_Down=0;
				T6963_240_128_Write_String_Komaki(-2);
			}
			GLB_Number_Of_Hiden_Item_Above=0;
			GLB_Number_Of_Hiden_Item_Down=0;
			GLB_Start_Of_High_Light_Line=0;
			GLB_End_Of_High_Light_Line=0;
			GLB_High_Low_Latch_Unlatch_Sent_To_LCD=0;
//		}
	}
}
#endif
#if(1) // Send Recieve.
void Send_Recieve_Data(void){
	int8_t  	MismachBlkVers;     
	int32_t 	Start_Index;     
	int32_t 	End_Index;
	int32_t 	YEAR;     
	int32_t 	DAYOFMONTH;
	int32_t 	DAYOFWeek;
	int32_t 	MONTH;
	int32_t 	HOUR;     
	int32_t 	MINUTE;   
	int32_t 	SECOND;   
	int32_t 	i, k, j, SigGrp, Num_Of_UD_Sigs_In_This_SigGrp, Sig_Adr, IOLED_END=0, Status=0, Packet_Index, CMTRD__CFG__Digital_Index;
	uint32_t	Sig_Block_Data_Adr;
	uint16_t	TL_Blk_Conter;
	uint8_t 	TL_Num_Of_Events_In_This_Paket;
	int32_t 	Adr, Num_Of_Event_In_This_MMCBLK;
	uint16_t	RELAY_RESET____0_NO____1_YES____Temp = 0U;
	int32_t 	Unit_Index, Card_Index, Module_Type, Secondary, Adr_Of_Last_TL, BLK_PNT, TL_Index, BLK_Index;
	int32_t		Byte_Index;
	int32_t		APLY_CMTRD___FileIndex;
	int32_t		APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col;
	int32_t		APLY_CMTRD___First_Sample_Index;
	int32_t		APLY_CMTRD___Last_Sample_Index;
	int32_t		SDRAM____Apply_Cmtrd_FP;
	int32_t		APLY_CMTRD___ColIndex;
	int32_t		*MHA_PNT, TEMP, ColIndex;
	
	
	
	if(U0000_Recive_Ready!=0){
		for(GLB_Main_j=0;GLB_Main_j<U0000_Recieve_Len;GLB_Main_j++)
			Connection____Recieve_Packet[GLB_Main_j]=SDRAM____U0000_Recieve[GLB_Main_j];

		GLB_Main__Reciv_Len=U0000_Recieve_Len;
		U0000_Recive_Ready=0;
		GLB_Main_Recieve_Code=11;
	}
	else if(U3333_Recive_Ready!=0){
		for(GLB_Main_j=0;GLB_Main_j<U3333_Recieve_Len;GLB_Main_j++)
			Connection____Recieve_Packet[GLB_Main_j]=SDRAM____U3333_Recieve[GLB_Main_j];				
		U3333_Recive_Ready=0;
		GLB_Main_Recieve_Code=22;
		
		U3333_Recive_Ready=0;
		GLB_Main_Recieve_Code=22;
		GLB_Main__Reciv_Len=U3333_Recieve_Len;
	}
	else if(netTCP____Recieve_Packet____Length!=0){
		for(j=0; j<netTCP____Recieve_Packet____Length; j++)
			Connection____Recieve_Packet[j]=netTCP____Recieve_Packet[j];

		GLB_Main__Reciv_Len = netTCP____Recieve_Packet____Length; 
		netTCP____Recieve_Packet____Length=0;
		GLB_Main_Recieve_Code=33;	
	}
	else if(FP_ETHERNET_Recive_Ready!=0){
		FP_ETHERNET_Recive_Ready=0;
		GLB_Main_Recieve_Code=44;
	}
	GLB_Main_IO_Setting_Is_Changing_Via_Cs=0;
	
	if(GLB_Main_Recieve_Code!=0){
		//sprintf((char *)RAM_UART_BUFF,"---------------l=%d\n",*(uint32_t*)(Connection____Recieve_Packet)); Panel_Komaki_UARTX_For_Sprintf();
	
		switch (*(uint32_t*)(Connection____Recieve_Packet)){
			case CaseNumbers__GetFlahsData:{
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);
				
				for(i=0; i<512; i++)
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + i] = SDRAM____CARDS_FLASH_DATA[Packet_Index * 512 + i];
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__GetFlahsData;
				SendIsOK = send_data(netTCP____Transmit_Packet, 512 + PROTOCOL____Data____Index); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__SetFlahsData:{
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);
				
				for(i=0; i<512; i++)
					SDRAM____CARDS_FLASH_DATA[Packet_Index * 512 + i] = Connection____Recieve_Packet[PROTOCOL____Data____Index + i];
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__SetFlahsData;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__IP__Get:{
				*(uint32_t *)(netTCP____Transmit_Packet+0) = CaseNumbers__IP__Get;

				for(Main__i=0; Main__i<20; Main__i++)
					netTCP____Transmit_Packet[Main__i+4] = ReadMyCfg.IPConfig[Main__i];
				
				*(uint16_t *)(netTCP____Transmit_Packet+24) = ReadMyCfg.Port;
				*(uint64_t *)(netTCP____Transmit_Packet+26) = ReadMyCfg.Serial;

				SendIsOK=send_data (netTCP____Transmit_Packet, 34); if(SendIsOK==0){/*Glb_Error=Glb_Error | Error_Send; E_Stop_Test;*/ }		
//						sprintf((char *)RAM_UART_BUFF,"Serial=%ud   Serial=%d\n", ReadMyCfg.Serial, ReadMyCfg.Serial); Panel_Komaki_UARTX_For_Sprintf();
//						sprintf((char *)RAM_UART_BUFF,"Answer To Read Ip=%d %d %d %d\n", netTCP____Transmit_Packet[0], netTCP____Transmit_Packet[1], netTCP____Transmit_Packet[2], netTCP____Transmit_Packet[3]); Panel_Komaki_UARTX_For_Sprintf();
			break;
			}
			case CaseNumbers__IP__Set:{
				//---------S: Recive IP,... ----------
				// IP
				WriteMyCfg.IPConfig[0 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index     ];
				WriteMyCfg.IPConfig[1 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 1 ];
				WriteMyCfg.IPConfig[2 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 2 ];
				WriteMyCfg.IPConfig[3 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 3 ];
				// GATEWAY
				WriteMyCfg.IPConfig[4 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 4 ];
				WriteMyCfg.IPConfig[5 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 5 ];
				WriteMyCfg.IPConfig[6 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 6 ];
				WriteMyCfg.IPConfig[7 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 7 ];
				// SUBNET
				WriteMyCfg.IPConfig[8 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 8 ];
				WriteMyCfg.IPConfig[9 ] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 9 ];
				WriteMyCfg.IPConfig[10] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 10];
				WriteMyCfg.IPConfig[11] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 11];
				// PRI DNS
				WriteMyCfg.IPConfig[12] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 12];
				WriteMyCfg.IPConfig[13] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 13];
				WriteMyCfg.IPConfig[14] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 14];
				WriteMyCfg.IPConfig[15] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 15];
				// SEC DNS
//			WriteMyCfg.IPConfig[16] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 16];
//			WriteMyCfg.IPConfig[17] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 17];
//			WriteMyCfg.IPConfig[18] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 18];
//			WriteMyCfg.IPConfig[19] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 19];
				// PORT
				WriteMyCfg.Port=*(uint16_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 16);
//			for(i=0; i<16; i++)
//				ReadMyCfg.IPConfig[i] = WriteMyCfg.IPConfig[i];
//			ReadMyCfg.Port = WriteMyCfg.Port;
				//---------E: Recive IP,... ----------
				//---------S: Write IP,... ----------
				WriteMyCfg.readwriteMode = WriteMode_IP;
				Init____WriteConfig();
				WriteMyCfg.readwriteMode = WriteMode_Port;
				Init____WriteConfig();
				//---------E: Write IP,... ----------
				//---------S: Check IP,... Data ----------
				Init____ReadConfig();

				GLB_Main__CheckBool = 1;
//				for(j=0; j<18; j++) // IP
//					if(Connection____Recieve_Packet[PROTOCOL____Data____Index + j] != ReadMyCfg.IPConfig[j])
//						GLB_Main__CheckBool = 2;
//				if(*(uint16_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 16) != ReadMyCfg.Port)
//					GLB_Main__CheckBool = 3;

//				netTCP____Transmit_Packet[0] = GLB_Main__CheckBool;
//				netTCP____Transmit_Packet[1] = 0;
//				netTCP____Transmit_Packet[2] = 0;
//				netTCP____Transmit_Packet[3] = 0;
				
				Set____NetIF();
				
//			while(CPU____QTL____ADD_ITEM(FP_CPU____IP, 0, 20, 1, (uint32_t) &(ReadMyCfg.IPConfig[0])) != 1U);
//			while(CPU____QTL____ADD_ITEM(FP_CPU____PORT, 0, 1, 2, (uint32_t) &(ReadMyCfg.Port)) != 1U);
//			while(CPU____QTL____ADD_ITEM(FP_CPU____SERIAL, 0, 1, 8, (uint32_t) &(ReadMyCfg.Serial)) != 1U);
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__IP__Set;
				SendIsOK = send_data (netTCP____Transmit_Packet, 4); if(SendIsOK==0){/*Glb_Error=Glb_Error | Error_Send; E_Stop_Test;*/ }					

			break;
			}
			case CaseNumbers__ClearLogs:{
				
				if(Connection____Recieve_Packet[PROTOCOL____Data____Index]==1)
					GLB_Main__Reset_Osc_In_Relay=1;
				if(Connection____Recieve_Packet[PROTOCOL____Data____Index+1]==1)
					GLB_Main__Reset_TL_In_Relay=1;
				if(Connection____Recieve_Packet[PROTOCOL____Data____Index+2]==1)
					GLB_Main__Reset_EL_In_Relay=1;
				
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__ClearLogs;
				send_data (netTCP____Transmit_Packet, PROTOCOL____Data____Index);				
				break;
			}
			case CaseNumbers__LiveStatus__Force_LiveStatus_Contact_To_Operate_Or_Not:{
				/*
				if((*(uint32_t*)(Connection____Recieve_Packet+4))==9999 && (*(uint32_t*)(Connection____Recieve_Packet+8))==9999){
					netTCP____Transmit_Packet[0]=200;
					netTCP____Transmit_Packet[1]=201;
					netTCP____Transmit_Packet[2]=202;
					if(RAM_IO_Signals_val_Struct[Row_IO__Power_System_Data_2____Relay_PICKUP____OUT].Value==0){
//						Live_Status_Output_OFF;
						LED_RUN_OFF;
						LED_ERROR_ON;

						netTCP____Transmit_Packet[3]=203;
					}
					else{
						netTCP____Transmit_Packet[3]=204;
					}
						GLB_Main__Send_Len=4;
				}
				else if((*(uint32_t*)(Connection____Recieve_Packet+4))==8888 && (*(uint32_t*)(Connection____Recieve_Packet+8))==8888){
//					Live_Status_Output_ON;
					LED_RUN_ON;
					LED_ERROR_OFF;

					netTCP____Transmit_Packet[0]=200;
					netTCP____Transmit_Packet[1]=201;
					netTCP____Transmit_Packet[2]=202;
					netTCP____Transmit_Packet[3]=203;
					GLB_Main__Send_Len=4;
				}
				*/
				break;
			}
			case CaseNumbers__Comtrade__Save_Cmtrd_By_Protocol:{
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Save_Cmtrd_By_Protocol;
				GLB_Osc_Triger_By_Protocol=1;
				GLB_Osc_Triger_By_Protocol_Time = Connection____Recieve_Packet[PROTOCOL____Data____Index];
				GLB_Main__Send_Len = PROTOCOL____Data____Index;
				break;
			}
			case CaseNumbers__Comtrade__Load_Comtrade_Part_1:{
				CMTRD_LOAD____This_Event_Is_Saved=1;
//			Packet_Index = *((uint32_t*)(Connection____Recieve_Packet+5));
				Packet_Index = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Load_Comtrade_Part_1;				
				if(Packet_Index==0){
					CMTRD_LOAD____INDEX_of_LOADING_CMTRD = Connection____Recieve_Packet[PROTOCOL____Data____Index];
//				GLB_Main__Num_Of_Total_Osc_Has_Saved = GLB_CMTRD____Num_Of_Total_Saved_CMTRD; 
					if(GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1>=GLB_Osc____MMC____FST_BLK____Save_Adr_of_Osc_Record____CPU)
						read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1, 1);
					else
						read_from_MMC(SDRAM____1_Block_MMC, GLB_CMTRD____Adr_For_Save_Adr_Of_CMTRD-1+GLB_Osc__MMC____NUM_OF_BLKs____For_Save_Adr_Of_Osc_Record, 1);
					CMTRD_LOAD____Recorded_Osc_Exceed_Max_Num_Of_Osc = SDRAM____1_Block_MMC[4];

// 				sprintf((char *)RAM_UART_BUFF," CMTRD_LOAD____INDEX_of_LOADING_CMTRD=%d\n",CMTRD_LOAD____INDEX_of_LOADING_CMTRD); Panel_Komaki_UARTX_For_Sprintf();
//	 			sprintf((char *)RAM_UART_BUFF," CMTRD_LOAD____Recorded_Osc_Exceed_Max_Num_Of_Osc =%d\n",CMTRD_LOAD____Recorded_Osc_Exceed_Max_Num_Of_Osc); Panel_Komaki_UARTX_For_Sprintf();
//	 			sprintf((char *)RAM_UART_BUFF," GLB_Main__Num_Of_Total_Osc_Has_Saved         =%d\n\n",GLB_Main__Num_Of_Total_Osc_Has_Saved); Panel_Komaki_UARTX_For_Sprintf();

					if(GLB_CMTRD____Num_Of_Total_Saved_CMTRD!=0){
						if(CMTRD_LOAD____Recorded_Osc_Exceed_Max_Num_Of_Osc==1 || CMTRD_LOAD____INDEX_of_LOADING_CMTRD <= GLB_CMTRD____Num_Of_Total_Saved_CMTRD){
							//CMTRD_LOAD____Circular_INDEX_of_LOADING_CMTRD=(GLB_Main__Num_Of_Total_Osc_Has_Saved-GLB_menu_current_position[CMTRD_LOAD____INDEX_of_LOADING_CMTRD-1]);
							CMTRD_LOAD____Circular_INDEX_of_LOADING_CMTRD = GLB_CMTRD____Num_Of_Total_Saved_CMTRD - CMTRD_LOAD____INDEX_of_LOADING_CMTRD;
							if(CMTRD_LOAD____Circular_INDEX_of_LOADING_CMTRD <0)
								CMTRD_LOAD____Circular_INDEX_of_LOADING_CMTRD += GLB_Osc____Total_Num_Of_Osc_Can_Record;
	
							CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event = GLB_Osc____MMC____FST_BLK____Save_Osc_Analog____CPU + CMTRD_LOAD____Circular_INDEX_of_LOADING_CMTRD* GLB_Osc____Total_Num_Of_uSDBlocks___For_Any_Osc + 4;
							
							read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event-4, 4);
							
							CMTRD_LOAD____uSD_Last_Block_Of__AnalogDigital_Data__At_This_Event = *((uint32_t*)(SDRAM____4_Block_MMC));
							CMTRD_LOAD____Last_Sample_Index =	*((uint32_t*)(SDRAM____4_Block_MMC+4));
							CMTRD_LOAD____uSDBlock__Contains_First_Two_Rows_Of_CFG = *((uint32_t*)(SDRAM____4_Block_MMC+8));
							CMTRD_LOAD____uSDBlock__Contains_End_7_Rows_Of_CFG =	*((uint32_t*)(SDRAM____4_Block_MMC+12));	
							CMTRD_LOAD____uSD_First_Block__Contains_Digital_Info_at_CFG =	*((uint32_t*)(SDRAM____4_Block_MMC+16));	

							read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSD_Last_Block_Of__AnalogDigital_Data__At_This_Event, 4);
							GLB_Main_max=(*((uint32_t*)(SDRAM____4_Block_MMC+(GLB_Osc_Show_V_Or_I_Phase_A_Or_B_Or_C<<2))));
							
							read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSDBlock__Contains_First_Two_Rows_Of_CFG, 4);
							CMTRD_LOAD____Num_of_Analog_channels  = SDRAM____4_Block_MMC[56];
							CMTRD_LOAD____Num_of_Digital_channels = SDRAM____4_Block_MMC[57];

// 						sprintf((char *)RAM_UART_BUFF," CMTRD_LOAD____Last_Sample_Index=%d\n", CMTRD_LOAD____Last_Sample_Index); Panel_Komaki_UARTX_For_Sprintf();
//	 					sprintf((char *)RAM_UART_BUFF," GLB_Main_Number_of_Digital_=%d\n", CMTRD_LOAD____Num_of_Digital_channels); Panel_Komaki_UARTX_For_Sprintf();
// 						sprintf((char *)RAM_UART_BUFF," Adress_Of_First=%d\n", CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event); Panel_Komaki_UARTX_For_Sprintf();
// 						sprintf((char *)RAM_UART_BUFF," Adress_Of_End  =%d\n", CMTRD_LOAD____uSD_Last_Block_Of__AnalogDigital_Data__At_This_Event); Panel_Komaki_UARTX_For_Sprintf();
// 						sprintf((char *)RAM_UART_BUFF,"*************************************\n"); Panel_Komaki_UARTX_For_Sprintf();
							read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSDBlock__Contains_End_7_Rows_Of_CFG, 4);
						}
						else
							CMTRD_LOAD____This_Event_Is_Saved=0;
					}
				}

// 			sprintf((char *)RAM_UART_BUFF," GLB_Main__Num_Of_Total_Osc_Has_Saved=%d\n", GLB_Main__Num_Of_Total_Osc_Has_Saved); Panel_Komaki_UARTX_For_Sprintf();
// 			sprintf((char *)RAM_UART_BUFF," CMTRD_LOAD____This_Event_Is_Saved=%d\n", CMTRD_LOAD____This_Event_Is_Saved); Panel_Komaki_UARTX_For_Sprintf();
				//-----------S: if this event has saved ----------
				if(GLB_CMTRD____Num_Of_Total_Saved_CMTRD!=0 && CMTRD_LOAD____This_Event_Is_Saved==1){
					if(CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event + Packet_Index < CMTRD_LOAD____uSDBlock__Contains_First_Two_Rows_Of_CFG){
						
//	        sprintf((char *)RAM_UART_BUFF," Adr=%8d\n", CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event + Packet_Index); Panel_Komaki_UARTX_For_Sprintf();
						read_from_MMC(SDRAM____1_Block_MMC, CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event + Packet_Index, 1);
						for(CMTRD_LOAD____Counter=0; CMTRD_LOAD____Counter<512; CMTRD_LOAD____Counter++){
							netTCP____Transmit_Packet[PROTOCOL____Data____Index]=254;
							if(Packet_Index%4==3){
								if(CMTRD_LOAD____Counter + 3*512 == 2048/(CMTRD_LOAD____Num_of_Analog_channels* GLB_4_Byte + (CMTRD_LOAD____Num_of_Digital_channels>>3) +1) * (CMTRD_LOAD____Num_of_Analog_channels*GLB_4_Byte+(CMTRD_LOAD____Num_of_Digital_channels>>3)+1)){
									*((uint16_t*)(netTCP____Transmit_Packet+PROTOCOL____Data____Index+1))= CMTRD_LOAD____Counter;
									break;
								}
							}
							
//						if(((Packet_Index%4)*512+CMTRD_LOAD____Counter) % (CMTRD_LOAD____Num_of_Analog_channels*4+(CMTRD_LOAD____Num_of_Digital_channels>>3)+1)==16){ //16:Ia
//							sprintf((char *)RAM_UART_BUFF,"%3d	%5d	%d  %d\n", CMTRD_LOAD____Counter, (Packet_Index%4)*512+CMTRD_LOAD____Counter,  *((int16_t*)(SDRAM____1_Block_MMC+CMTRD_LOAD____Counter)), CMTRD_LOAD____uSD_First_Block_Of__AnalogDigital_Data__At_This_Event + Packet_Index); Panel_Komaki_UARTX_For_Sprintf();
//						}
							//sprintf((char *)RAM_UART_BUFF,"Row=%4d  count=%5d  MMC[%3d]=%4d\n",Packet_Index,GLB_Main_Total_Bytes_Sent_For_Comtrade_DAT,CMTRD_LOAD____Counter,SDRAM____1_Block_MMC[CMTRD_LOAD____Counter]); Panel_Komaki_UARTX_For_Sprintf();

							CMTRD_LOAD____Total_Bytes_Sent_For_CMTRD_DAT++;
							*((uint16_t*)(netTCP____Transmit_Packet+PROTOCOL____Data____Index+1))= 512;
							netTCP____Transmit_Packet[CMTRD_LOAD____Counter+PROTOCOL____Data____Index+5] = SDRAM____1_Block_MMC[CMTRD_LOAD____Counter];
// 						sprintf((char *)RAM_UART_BUFF,"%4d  %6d  %4d\n", netTCP____Transmit_Packet[CMTRD_LOAD____Counter+5], *((int16_t*)(SDRAM____1_Block_MMC+CMTRD_LOAD____Counter))  , SDRAM____1_Block_MMC[CMTRD_LOAD____Counter]); Panel_Komaki_UARTX_For_Sprintf();
							//-----------S: DAT.file Last Packet ----------	
							if(CMTRD_LOAD____Total_Bytes_Sent_For_CMTRD_DAT/(CMTRD_LOAD____Num_of_Analog_channels* GLB_4_Byte+ (CMTRD_LOAD____Num_of_Digital_channels>>3)+ 1) == CMTRD_LOAD____Last_Sample_Index){
								netTCP____Transmit_Packet[PROTOCOL____Data____Index]=255;
								*((uint16_t*)(netTCP____Transmit_Packet+PROTOCOL____Data____Index+1)) = CMTRD_LOAD____Counter;
								CMTRD_LOAD____Total_Bytes_Sent_For_CMTRD_DAT=0;
								break;
							}
							//-----------E: DAT.file Last Packet ----------
						}
						GLB_Main__Send_Len=517+PROTOCOL____Data____Index;
					}
					else{
						CMTRD_LOAD____Total_Bytes_Sent_For_CMTRD_DAT=0;
						netTCP____Transmit_Packet[PROTOCOL____Data____Index]=0;
						*((uint32_t*)(netTCP____Transmit_Packet+PROTOCOL____Data____Index+1))= GLB_Main_max;
						GLB_Main__Send_Len=517+PROTOCOL____Data____Index;
					}
				}
				//-----------E: if this event has saved ----------
				//-----------S: if this event has'nt saved ----------
				else{
					CMTRD_LOAD____Total_Bytes_Sent_For_CMTRD_DAT=0;
					netTCP____Transmit_Packet[PROTOCOL____Data____Index]=240;
					GLB_Main__Send_Len=517+PROTOCOL____Data____Index;
				}
				//-----------E: if this event has'nt saved ----------
				send_data (netTCP____Transmit_Packet, GLB_Main__Send_Len);
				break;
			}
			case CaseNumbers__Comtrade__Load_Comtrade__CFG_DATA:{
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Load_Comtrade__CFG_DATA;
				//sprintf((char *)RAM_UART_BUFF," Analog_Signal_Num=%2d  ", Connection____Recieve_Packet[4]); Panel_Komaki_UARTX_For_Sprintf();
				//----------S: CFG/2 FIRST Rows  ----------
				if(Connection____Recieve_Packet[PROTOCOL____Data____Index]==0){
					read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSDBlock__Contains_First_Two_Rows_Of_CFG, 4);
					netTCP____Transmit_Packet[PROTOCOL____Data____Index]=250;
					for(k=0; k<66; k++)
						netTCP____Transmit_Packet[PROTOCOL____Data____Index + k+1]=SDRAM____4_Block_MMC[k];
					
					GLB_Main___CMTRD____Byte_Count_For_Any_Analog____In_CFG  = *(int32_t*)(SDRAM____4_Block_MMC+58);
					GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG = *(int32_t*)(SDRAM____4_Block_MMC+62);
					GLB_Main___CMTRD____CFG____Num_Of_Digitals__In_2048_byte = 2048/GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG;
					
					
					GLB_Main__Send_Len=67 + PROTOCOL____Data____Index;
					GLB_Main__H=0;
// 				sprintf((char *)RAM_UART_BUFF,"%d,",  SDRAM____4_Block_MMC[56]); Panel_Komaki_UARTX_For_Sprintf();
// 				sprintf((char *)RAM_UART_BUFF,"%d,",  SDRAM____4_Block_MMC[57]); Panel_Komaki_UARTX_For_Sprintf();					
				}
				//----------E: CFG/2 FIRST Rows  ----------
				//----------S: CFG/ANALOG INFO ----------
				else if(Connection____Recieve_Packet[PROTOCOL____Data____Index]<CMTRD_LOAD____Num_of_Analog_channels+1){
					read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSDBlock__Contains_First_Two_Rows_Of_CFG + 4+ (Connection____Recieve_Packet[PROTOCOL____Data____Index]*GLB_Main___CMTRD____Byte_Count_For_Any_Analog____In_CFG/2048)*4, 4);
					
//					sprintf((char *)RAM_UART_BUFF,"T= %d\n",  CMTRD_LOAD____Counter); Panel_Komaki_UARTX_For_Sprintf();
					//sprintf((char *)RAM_UART_BUFF,"... =%d\n",  SDRAM____4_Block_MMC[GLB_Main__H+88]); Panel_Komaki_UARTX_For_Sprintf();
					
					strncpy((char*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 ),                                             (char*)(SDRAM____4_Block_MMC  + GLB_Main__H), VFC____SIGNAL_LABEL__Size);
					strncpy((char*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 + VFC____SIGNAL_LABEL__Size),                  (char*)(SDRAM____4_Block_MMC  + GLB_Main__H + VFC____SIGNAL_LABEL__Size), VFC____SIGNAL_NAME__Size);
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 + VFC____SIGNAL_LABEL_AND_NAME__Size))=  *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H +     VFC____SIGNAL_LABEL_AND_NAME__Size));
					strncpy((char*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +5 + VFC____SIGNAL_LABEL_AND_NAME__Size),         (char*)(SDRAM____4_Block_MMC  + GLB_Main__H + 4 + VFC____SIGNAL_LABEL_AND_NAME__Size), 1);
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +6 + VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 5 + VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +10+ VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 9 + VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +14+ VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 13+ VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +18+ VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 17+ VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +22+ VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 21+ VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +26+ VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint32_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 25+ VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)  (netTCP____Transmit_Packet + PROTOCOL____Data____Index +30+ VFC____SIGNAL_LABEL_AND_NAME__Size))=	 *((uint16_t*)(SDRAM____4_Block_MMC  + GLB_Main__H + 29+ VFC____SIGNAL_LABEL_AND_NAME__Size));
					strncpy((char*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +32+ VFC____SIGNAL_LABEL_AND_NAME__Size),   (char*)(SDRAM____4_Block_MMC        + GLB_Main__H + 31+ VFC____SIGNAL_LABEL_AND_NAME__Size), 1);
					netTCP____Transmit_Packet[PROTOCOL____Data____Index +33+ VFC____SIGNAL_LABEL_AND_NAME__Size] = SDRAM____4_Block_MMC[GLB_Main__H + 32+ VFC____SIGNAL_LABEL_AND_NAME__Size];
					
					GLB_Main__H += GLB_Main___CMTRD____Byte_Count_For_Any_Analog____In_CFG;
					
//					GLB_Main__k=0;
//					GLB_Main__Counter_Digital_Inf_CFG=0;
//					GLB_Main__Count_Addres_Digital_Inf_CFG=-1;

					netTCP____Transmit_Packet[PROTOCOL____Data____Index]=251;							
					GLB_Main__Send_Len = GLB_Main___CMTRD____Byte_Count_For_Any_Analog____In_CFG + PROTOCOL____Data____Index+ 1;
					//sprintf((char *)RAM_UART_BUFF,"=%s \n", (char*)(netTCP____Transmit_Packet+1)); Panel_Komaki_UARTX_For_Sprintf();
				}
				//----------E: CFG/ANALOG INFO ----------
				//----------S: CFG/DIGITAL INFO ----------
				else if(Connection____Recieve_Packet[PROTOCOL____Data____Index]==255){
					CMTRD__CFG__Digital_Index = *(uint32_t *)(Connection____Recieve_Packet+PROTOCOL____Data____Index+1);
					GLB_Main__H = CMTRD__CFG__Digital_Index * GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG;
					
					read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSD_First_Block__Contains_Digital_Info_at_CFG + 4 * (GLB_Main__H / 2048), 4);
					
					strncpy((char*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +1) , (char*)(SDRAM____4_Block_MMC + (CMTRD__CFG__Digital_Index % GLB_Main___CMTRD____CFG____Num_Of_Digitals__In_2048_byte)*GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG ), VFC____SIGNAL_LABEL__Size);
					strncpy((char*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 + VFC____SIGNAL_LABEL__Size) , (char*)(SDRAM____4_Block_MMC + (CMTRD__CFG__Digital_Index % GLB_Main___CMTRD____CFG____Num_Of_Digitals__In_2048_byte)*GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG  + VFC____SIGNAL_LABEL__Size ), VFC____SIGNAL_NAME__Size);
					*((uint32_t*)( (netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 + VFC____SIGNAL_LABEL_AND_NAME__Size))) = *((uint32_t*)( SDRAM____4_Block_MMC + (CMTRD__CFG__Digital_Index % GLB_Main___CMTRD____CFG____Num_Of_Digitals__In_2048_byte)*GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG + VFC____SIGNAL_LABEL_AND_NAME__Size));
					*((uint32_t*)( (netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 + VFC____SIGNAL_LABEL_AND_NAME__Size +4))) = *((uint32_t*)( SDRAM____4_Block_MMC + (CMTRD__CFG__Digital_Index % GLB_Main___CMTRD____CFG____Num_Of_Digitals__In_2048_byte)*GLB_Main___CMTRD____Byte_Count_For_Any_Digital____In_CFG + VFC____SIGNAL_LABEL_AND_NAME__Size +4));
					
					netTCP____Transmit_Packet[PROTOCOL____Data____Index] = 252;
					GLB_Main__Send_Len = GLB____CMTRD____Byte_Count_For_Any_DIGITAL____In_CFG + PROTOCOL____Data____Index+ 1;
					
				}
				//----------E: CFG/DIGITAL INFO ----------
				//----------S: CFG/7 Last Rows  ----------
				else if(Connection____Recieve_Packet[PROTOCOL____Data____Index]==254){
					read_from_MMC(SDRAM____4_Block_MMC, CMTRD_LOAD____uSDBlock__Contains_End_7_Rows_Of_CFG, 4);
				
					netTCP____Transmit_Packet[PROTOCOL____Data____Index]=111;
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 1]=SDRAM____4_Block_MMC[0];
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 2))=SDRAM____4_Block_MMC[1];
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 6))=*((uint32_t*)(SDRAM____4_Block_MMC+2));
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 10))=*((uint32_t*)(SDRAM____4_Block_MMC+6));
					
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 14]=SDRAM____4_Block_MMC[10];
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 15]=SDRAM____4_Block_MMC[11];
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 16))=*((uint16_t*)(SDRAM____4_Block_MMC+12));
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 20]=SDRAM____4_Block_MMC[14];
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 21]=SDRAM____4_Block_MMC[15];
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 22]=SDRAM____4_Block_MMC[16];
					*((uint32_t *)(netTCP____Transmit_Packet+ PROTOCOL____Data____Index + 23))=*((uint32_t*)(SDRAM____4_Block_MMC+17));

					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 27]=SDRAM____4_Block_MMC[21];
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 28]=SDRAM____4_Block_MMC[22];
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 29))=*((uint16_t*)(SDRAM____4_Block_MMC+23));
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 33]=SDRAM____4_Block_MMC[25];
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 34]=SDRAM____4_Block_MMC[26];
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + 35]=SDRAM____4_Block_MMC[27];
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 36))=*((uint32_t*)(SDRAM____4_Block_MMC+28));

					strncpy((char*)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 40), "ASCII",50);
					*((uint32_t *)(netTCP____Transmit_Packet+PROTOCOL____Data____Index + 90))=SDRAM____4_Block_MMC[32];

					GLB_Main__Send_Len=94 + PROTOCOL____Data____Index;
					
// 				sprintf((char *)RAM_UART_BUFF,"... =%d   %d\n",netTCP____Transmit_Packet[0],  netTCP____Transmit_Packet[39]); Panel_Komaki_UARTX_For_Sprintf();
// 				sprintf((char *)RAM_UART_BUFF,"... =%d   %d\n",netTCP____Transmit_Packet[0],  netTCP____Transmit_Packet[40]); Panel_Komaki_UARTX_For_Sprintf();
// 				sprintf((char *)RAM_UART_BUFF,"... =%d   %d\n",netTCP____Transmit_Packet[0],  netTCP____Transmit_Packet[41]); Panel_Komaki_UARTX_For_Sprintf();
// 				sprintf((char *)RAM_UART_BUFF,"... =%d   %d\n",netTCP____Transmit_Packet[0],  netTCP____Transmit_Packet[42]); Panel_Komaki_UARTX_For_Sprintf();
// 				sprintf((char *)RAM_UART_BUFF,"... =%d   %d\n",netTCP____Transmit_Packet[0],  netTCP____Transmit_Packet[43]); Panel_Komaki_UARTX_For_Sprintf();
				} 				
				//----------S: CFG/7 Last Rows  ----------
				send_data (netTCP____Transmit_Packet, GLB_Main__Send_Len);
				break;
			}
			case CaseNumbers__Comtrade__Get_CMTRDsNames:{
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Get_CMTRDsNames;
				i = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);		
				
				if(i==0){
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +1 ))=MIN(GLB_CMTRD____Num_Of_Total_Saved_CMTRD, GLB_number_Of_Oscillograph_For_Display_On_LCD);
					GLB_Main__Send_Len=PROTOCOL____Data____Index + 5;
				}
				else{
					Main__OSCName_Address = GLB_Osc_Adr_Of_RAM_Last_Osc_Enter_For_Disp_On_Menu-28*i;

					if(Main__OSCName_Address>=28*GLB_number_Of_Oscillograph_For_Display_On_LCD)
						Main__OSCName_Address=0;
					if(Main__OSCName_Address<0)
						Main__OSCName_Address+=(28*GLB_number_Of_Oscillograph_For_Display_On_LCD);
				
					Panel_Komaki_Get_Date_For_Osc_From_RAM_To_Display_On_LCD(Main__OSCName_Address);
					
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index    ))  =GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Year;
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +4 ))=GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Day_Of_Month;
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +8 ))=GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Month;
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +12))=GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Hour;
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +16))=GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Minute;
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +20))=GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Second;
					*((uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index +24))=GLB_Get_Osc_Date_From_RAM_To_Disp_On_LCD__Mili_Second;
					
					GLB_Main__Send_Len=PROTOCOL____Data____Index + 28;
				}
				
				send_data (netTCP____Transmit_Packet, GLB_Main__Send_Len);
				break;
			}
			case CaseNumbers__Comtrade__Apply_Cmtrd_INFO:{
				if(APLY_CMTRD___Triger == 0){
					Packet_Index = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);
					Byte_Index =4;
					
					if(Packet_Index == 0){
						APLY_CMTRD___MMC_Byte_Index = 0;
						APLY_CMTRD___MMC_Block_Index = 0;
						
						
//						APLY_CMTRD___Total_Repetition = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);
						*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);											APLY_CMTRD___MMC_Byte_Index += 4;
						Byte_Index += 4;
//						APLY_CMTRD___Initial_Interval = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index) * GLB_Number_of_Sample_per_Cycle/20;
						*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index) * GLB_Number_of_Sample_per_Cycle/20;		APLY_CMTRD___MMC_Byte_Index += 4;
						Byte_Index += 4;
//						APLY_CMTRD___Initial_Interval__At_Any_Repetition = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);
						*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);											APLY_CMTRD___MMC_Byte_Index += 4;
						Byte_Index += 4;
//						APLY_CMTRD___Num_Of_ANALOGs_In_Files  = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index];
						SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index] = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index];																			APLY_CMTRD___MMC_Byte_Index++;
						Byte_Index++;
//						APLY_CMTRD___Num_Of_DIGITALs_In_Files = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index]; 
						SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index] = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index]; 																			APLY_CMTRD___MMC_Byte_Index++;
						Byte_Index++;
//						APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs = (APLY_CMTRD___Num_Of_DIGITALs_In_Files%32==0 ? APLY_CMTRD___Num_Of_DIGITALs_In_Files/32: APLY_CMTRD___Num_Of_DIGITALs_In_Files/32 + 1);
						APLY_CMTRD___Num_Of_Files   = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index];
						SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index] = APLY_CMTRD___Num_Of_Files;																														APLY_CMTRD___MMC_Byte_Index++;
						Byte_Index++;
//						APLY_CMTRD___Total_Num_Of_Samples = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);
						*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);											APLY_CMTRD___MMC_Byte_Index += 4;
						Byte_Index += 4;
						
						
						for(i=0; i<APLY_CMTRD___Num_Of_Files; i++){
//							APLY_CMTRD___Files_Repetition[i] = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);
							SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index] = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);														APLY_CMTRD___MMC_Byte_Index++;
							Byte_Index += 4;
						}
						for(i=0; i < APLY_CMTRD___Num_Of_Files; i++){
//							APLY_CMTRD___Files_Interval[i] = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index) * GLB_Number_of_Sample_per_Cycle/20;
							*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index) * GLB_Number_of_Sample_per_Cycle/20;	APLY_CMTRD___MMC_Byte_Index += 4;						
							Byte_Index += 4;
						}
						for(i=0; i<APLY_CMTRD___Num_Of_Files; i++){
//							APLY_CMTRD___Files_Samples_Count[i] = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);
							*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);										APLY_CMTRD___MMC_Byte_Index += 4;						
							Byte_Index += 4;
						}
						
											
						Write_to_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + APLY_CMTRD___MMC_Block_Index, 1U);
						APLY_CMTRD___MMC_Block_Index ++;
						APLY_CMTRD___MMC_Byte_Index = 0;
						
						// max num of files = 40
						// max Repetition of files = 128
					}
					else{
						APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index++];
						
//						APLY_CMTRD___MHA_ADRs[0][Packet_Index - 1] = APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col;
						SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index] = APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col;																										APLY_CMTRD___MMC_Byte_Index++;
						
						for(i=0; i<APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col; i++){
							TEMP = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index + 4*i);
							*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = TEMP;																														APLY_CMTRD___MMC_Byte_Index += 4;
						}
						
						Write_to_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + APLY_CMTRD___MMC_Block_Index, 1U);
						APLY_CMTRD___MMC_Block_Index ++;
						APLY_CMTRD___MMC_Byte_Index = 0;
						// max MHA_ADRs = 128
					}
					
					*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Apply_Cmtrd_INFO;
				}
				else{
					*(uint32_t *)(netTCP____Transmit_Packet) = -1;
				}
				SendIsOK = send_data(Connection____Recieve_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__Comtrade__Apply_Cmtrd:{
				Byte_Index = 0;
				APLY_CMTRD___ColIndex  = Connection____Recieve_Packet[PROTOCOL____Data____Index + Byte_Index++]; 
				APLY_CMTRD___First_Sample_Index  = *(uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + Byte_Index);
				Byte_Index += 4;
				APLY_CMTRD___Last_Sample_Index    = *(uint32_t*)(Connection____Recieve_Packet +  PROTOCOL____Data____Index + Byte_Index);
				Byte_Index += 4;
				
//				SDRAM____Apply_Cmtrd_FP = APLY_CMTRD___ColIndex * APLY_CMTRD___Total_Num_Of_Samples + APLY_CMTRD___First_Sample_Index;
				
				APLY_CMTRD___MMC_Byte_Index = 0;
				
				for(i=0; i <= APLY_CMTRD___Last_Sample_Index - APLY_CMTRD___First_Sample_Index; i++){
//					SDRAM____Apply_Cmtrd_1[SDRAM____Apply_Cmtrd_FP + i] = *(uint32_t*)(Connection____Recieve_Packet +  PROTOCOL____Data____Index + Byte_Index);
					TEMP = *(uint32_t*)(Connection____Recieve_Packet +  PROTOCOL____Data____Index + Byte_Index);
					*(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index) = TEMP;																		APLY_CMTRD___MMC_Byte_Index += 4;
					Byte_Index += 4;
				}
				
				Write_to_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + APLY_CMTRD___MMC_Block_Index, 1U);
				APLY_CMTRD___MMC_Block_Index ++;

				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Apply_Cmtrd;
				SendIsOK = send_data(Connection____Recieve_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__Comtrade__Apply_Cmtrd_Finish:{
				APLY_CMTRD___MMC_Block_Index = 0;
				APLY_CMTRD___MMC_Byte_Index = 0;
				read_from_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + APLY_CMTRD___MMC_Block_Index, 1U);
				
				APLY_CMTRD___Total_Repetition 								= *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);					APLY_CMTRD___MMC_Byte_Index += 4;
				APLY_CMTRD___Initial_Interval 								= *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);					APLY_CMTRD___MMC_Byte_Index += 4;
				APLY_CMTRD___Initial_Interval__At_Any_Repetition 			= *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);					APLY_CMTRD___MMC_Byte_Index += 4;
				APLY_CMTRD___Num_Of_ANALOGs_In_Files  						= SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index];									APLY_CMTRD___MMC_Byte_Index ++;
				APLY_CMTRD___Num_Of_DIGITALs_In_Files 						= SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index];									APLY_CMTRD___MMC_Byte_Index ++;
				APLY_CMTRD___Num_Of_Files									= SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index];									APLY_CMTRD___MMC_Byte_Index ++;
				APLY_CMTRD___Total_Num_Of_Samples 							= *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);					APLY_CMTRD___MMC_Byte_Index += 4;
				
				APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs = (APLY_CMTRD___Num_Of_DIGITALs_In_Files%32==0 ? APLY_CMTRD___Num_Of_DIGITALs_In_Files/32: APLY_CMTRD___Num_Of_DIGITALs_In_Files/32 + 1);
				
				for(i=0; i<APLY_CMTRD___Num_Of_Files; i++){
					APLY_CMTRD___Files_Repetition[i] 						= SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index];									APLY_CMTRD___MMC_Byte_Index++;
				}
				for(i=0; i < APLY_CMTRD___Num_Of_Files; i++){
					APLY_CMTRD___Files_Interval[i] 							= *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);					APLY_CMTRD___MMC_Byte_Index += 4;						
				}
				for(i=0; i<APLY_CMTRD___Num_Of_Files; i++){
					APLY_CMTRD___Files_Samples_Count[i] 					= *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);					APLY_CMTRD___MMC_Byte_Index += 4;						
				}
				
				
				for(ColIndex = 0; ColIndex < APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_DIGITALs_In_Files; ColIndex++){
					APLY_CMTRD___MMC_Block_Index ++;
					APLY_CMTRD___MMC_Byte_Index = 0;
					read_from_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + APLY_CMTRD___MMC_Block_Index, 1U);
					APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col = SDRAM____1_Block_MMC[APLY_CMTRD___MMC_Byte_Index];													APLY_CMTRD___MMC_Byte_Index++;
					
					APLY_CMTRD___MHA_ADRs[0][ColIndex] = APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col;

					for(i = 0; i < APLY_CMTRD___Num_Of_MHA_Adrs__For_This_Col; i++){
						APLY_CMTRD___MHA_ADRs[i + 1][ColIndex] = *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);									APLY_CMTRD___MMC_Byte_Index += 4;
					}
				}				
						
				
				APLY_CMTRD___Total_Num_Of_Samples__Multiply__Analogs_and_32bitDIGITALs = APLY_CMTRD___Total_Num_Of_Samples * (APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs);
				APLY_CMTRD___Num_Of_MMC_Parts = (APLY_CMTRD___Total_Num_Of_Samples__Multiply__Analogs_and_32bitDIGITALs % APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part == 0 ? APLY_CMTRD___Total_Num_Of_Samples__Multiply__Analogs_and_32bitDIGITALs / APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part: APLY_CMTRD___Total_Num_Of_Samples__Multiply__Analogs_and_32bitDIGITALs/APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part + 1);
				
				int32_t remained_Sample;
				int32_t Passed_Sample = 0;
				for(i = 0; i< APLY_CMTRD___Num_Of_MMC_Parts; i++){
					remained_Sample = (APLY_CMTRD___Total_Num_Of_Samples__Multiply__Analogs_and_32bitDIGITALs - i * APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part);
					APLY_CMTRD___Num_Of_Samples_At_Any_Part[i][0] = remained_Sample / APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part > 0 ? APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part / (APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs) : remained_Sample / (APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs);
					APLY_CMTRD___Num_Of_Samples_At_Any_Part[i][1] = APLY_CMTRD___MMC_Block_Index + 1 + Passed_Sample / 128; // First Block index
					APLY_CMTRD___Num_Of_Samples_At_Any_Part[i][2] = (Passed_Sample % 128) * 4; // First Block Byte index
					Passed_Sample += APLY_CMTRD___Num_Of_Samples_At_Any_Part[i][0];
				}
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				APLY_CMTRD___Total_Num_Of_Samples_For_Current_Part = (APLY_CMTRD___Num_Of_MMC_Parts == 1 ? APLY_CMTRD___Total_Num_Of_Samples : APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part / (APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs));
				
				
				APLY_CMTRD___Applying_Part_Index = 1;
				APLY_CMTRD___Filling_Part_Index = 0;
				for(ColIndex = 0; ColIndex < APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs; ColIndex++){
					Adr = ColIndex * (APLY_CMTRD___Total_Num_Of_Samples%128 == 0? APLY_CMTRD___Total_Num_Of_Samples / 128 : APLY_CMTRD___Total_Num_Of_Samples / 128 + 1);
					
					i=0;
					while(i < APLY_CMTRD___Total_Num_Of_Samples_For_Current_Part){
						if(i % 128 == 0){
							Adr ++;
							APLY_CMTRD___MMC_Byte_Index = 0;
							read_from_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + APLY_CMTRD___MMC_Block_Index + Adr, 1U);
						}
						
						SDRAM____Apply_Cmtrd_1[ColIndex * APLY_CMTRD___Total_Num_Of_Samples_For_Current_Part + i] = *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);	APLY_CMTRD___MMC_Byte_Index += 4;
						i++;
					}
				}
								
				
				APLY_CMTRD___Total_Repetition__Conter = 0;
				APLY_CMTRD___Files_Repetition__Counter = 0;
				APLY_CMTRD___Sample_Index = 0;
				APLY_CMTRD___File_Index = 0;
				if(APLY_CMTRD___Initial_Interval == 0)
					APLY_CMTRD___Interval_Triger = 0;
				else 
					APLY_CMTRD___Interval_Triger = 1;
				APLY_CMTRD___Interval_Index = 0;
				
				
				APLY_CMTRD___Total_Samples_at_End_Of_This_File = APLY_CMTRD___Files_Samples_Count[0];
				APLY_CMTRD___Applying_Part__Sample_Index = 0; 
				SDRAM____Apply_Cmtrd = SDRAM____Apply_Cmtrd_1;
				APLY_CMTRD___Triger = 1;
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Comtrade__Apply_Cmtrd_Finish;
				SendIsOK = send_data(Connection____Recieve_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			
			case CaseNumbers__SetTime:{
				MONTH     = *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index     )) ;
				DAYOFMONTH= *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4 )) ;
				YEAR      = *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 8 )) ;
				HOUR      = *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 12)) ;
				MINUTE    = *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 16)) ;
				SECOND    = *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 20)) ;
				DAYOFWeek = *((uint32_t*)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 24)) ;
				
				SET_RTC_TIME_DATE(HOUR, MINUTE, SECOND, DAYOFWeek, DAYOFMONTH, MONTH, YEAR, LL_RTC_TIME_FORMAT_AM_OR_24);
									

//					YEAR,       *((uint32_t*)(Connection____Recieve_Packet+5 ))	
//					DAYOFMONTH, *((uint32_t*)(Connection____Recieve_Packet+9 ))
//					MONTH,      *((uint32_t*)(Connection____Recieve_Packet+13))
//					HOUR,       *((uint32_t*)(Connection____Recieve_Packet+17))
//					MINUTE,     *((uint32_t*)(Connection____Recieve_Packet+21))
//					SECOND,     *((uint32_t*)(Connection____Recieve_Packet+25))
//					sprintf((char *)RAM_UART_BUFF,"%5d %5d %5d %5d %5d %5d\n",*((uint32_t*)(Connection____Recieve_Packet+17)), *((uint32_t*)(Connection____Recieve_Packet+21)), *((uint32_t*)(Connection____Recieve_Packet+25)),LL_RTC_WEEKDAY_SUNDAY,*((uint32_t*)(Connection____Recieve_Packet+9 )), *((uint32_t*)(Connection____Recieve_Packet+13))); Panel_Komaki_UARTX_For_Sprintf();
					
					// H,M,S, DOW, DOM, MONTH, YEAR, 24H___AM_PM
//					SET_RTC_TIME_DATE((*((uint32_t*)(Connection____Recieve_Packet+17))), (*((uint32_t*)(Connection____Recieve_Packet+21))), (*((uint32_t*)(Connection____Recieve_Packet+25))),\
//														(*((uint8_t*)(Connection____Recieve_Packet+29 ))), (*((uint32_t*)(Connection____Recieve_Packet+9 ))), (*((uint32_t*)(Connection____Recieve_Packet+13))), (*((uint32_t*)(Connection____Recieve_Packet+5))), LL_RTC_TIME_FORMAT_AM_OR_24);
										
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__SetTime;		
				GLB_Main__Send_Len=4;
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Send_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__EL__Get_Num_Of_Files:{			
				read_from_MMC(SDRAM____1_Block_MMC, EL__Adr_For_Save, 1);
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index)  = *(uint32_t *)(SDRAM____1_Block_MMC + 4) + 1; // Num Of MMC BLKs used for EL
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__EL__Get_Num_Of_Files;
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
 			case CaseNumbers__EL__Get_Data:{
				Packet_Index = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);
				
				Adr = EL__Adr_For_Save - Packet_Index;
				if(Adr < EL__MMC____FST_BLK____SAVE_EL__CPU)
					Adr += EL__MMC____NUM_OF_BLKs____FOR_SAVE_EL;
				
				read_from_MMC(SDRAM____1_Block_MMC, Adr, 1);
				
				Num_Of_Event_In_This_MMCBLK = SDRAM____1_Block_MMC[11];
				for(i=0; i < Num_Of_Event_In_This_MMCBLK * 100 + 1; i++)
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + i] = SDRAM____1_Block_MMC[11 + i];
				
				*(uint32_t *)(netTCP____Transmit_Packet)  = CaseNumbers__EL__Get_Data;
				
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + Num_Of_Event_In_This_MMCBLK * 100 + 1); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__TL__Get_Num_Of_TLs:{
				if(TL___Has_Any_Log == No_0)
					*(int32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index) = 0;
				else{
					if(TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU >= GLB_TL__MMC____FST_BLK____SAVE_TL____CPU)
						Adr_Of_Last_TL = TL___Adr_For_Save - GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU;
					else
						Adr_Of_Last_TL = TL___Adr_For_Save + (GLB_TL_Max_Numb_Of_TL_Can_Save - 1) * GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU;
					
					read_from_MMC(SDRAM____1_Block_MMC, Adr_Of_Last_TL, 1);
					*(int32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index) = *(uint32_t*)(SDRAM____1_Block_MMC + 4);		//Num_Of_TLs			
				}
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__TL__Get_Num_Of_TLs;
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__TL__Get_Name:{
				Packet_Index = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);
				
				Adr = TL___Adr_For_Save - (Packet_Index + 1) * GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU;
				if(Adr < GLB_TL__MMC____FST_BLK____SAVE_TL____CPU)
					Adr += (GLB_TL_Max_Numb_Of_TL_Can_Save * GLB_TL__MMC____NUM_OF_BLKs____FOR_SAVE_ANY_TL____CPU);
					
				read_from_MMC(SDRAM____1_Block_MMC, Adr, 1);
				
				BLK_PNT = 8;
				*(uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index) = Adr;  //Adr of THIS TL on uSD
				*(uint32_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 4) = *(uint32_t*)(SDRAM____1_Block_MMC + BLK_PNT);  //EVENT COUNT IN THIS TL
				BLK_PNT+=4;
				*(uint16_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 8) = *(uint16_t*)(SDRAM____1_Block_MMC + BLK_PNT);  //Year
				BLK_PNT+=2;
				netTCP____Transmit_Packet[PROTOCOL____Data____Index + 10] = SDRAM____1_Block_MMC[BLK_PNT++]; //Month
				netTCP____Transmit_Packet[PROTOCOL____Data____Index + 11] = SDRAM____1_Block_MMC[BLK_PNT++]; //DOM
				netTCP____Transmit_Packet[PROTOCOL____Data____Index + 12] = SDRAM____1_Block_MMC[BLK_PNT++]; //Hour
				netTCP____Transmit_Packet[PROTOCOL____Data____Index + 13] = SDRAM____1_Block_MMC[BLK_PNT++]; //Min
				netTCP____Transmit_Packet[PROTOCOL____Data____Index + 14] = SDRAM____1_Block_MMC[BLK_PNT++]; //Sec
				*(uint16_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 15) = *(uint16_t*)(SDRAM____1_Block_MMC + BLK_PNT); //mS
								
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__TL__Get_Name;
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 8 + TL__DATE_TIME_LENGTH); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__TL__Get_Data:{
				Adr  = *(uint32_t*)(Connection____Recieve_Packet+ PROTOCOL____Data____Index);				
				read_from_MMC(SDRAM____1_Block_MMC, Adr, 1);
				for(i=0; i < 500; i++)
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + i] = SDRAM____1_Block_MMC[i];
				*(uint32_t*)(netTCP____Transmit_Packet) = CaseNumbers__TL__Get_Data;		
				send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 500);
				break;
			}
			case CaseNumbers__VFC__StartVFCTask:{
				VFC_Bypassed__Flag = true;
				VMA_Is_Bypassed_OLD = VFC_Is_Bypassed;
				VFC_Is_Bypassed__Reason = VFC_Bypassed__Loading_VMA_From_Cs;
				VFC_Is_Bypassed=1;
				for(i=0; i<MHA_Size; i++)
					MHA[i]=0;
		
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__VFC__StartVFCTask;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__VMA:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);
				if(Packet_Index==0){
					VMA_Index=0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				k=0;
				for(i = VMA_Index; i< VMA_Index + PACKET____DATA_SIZE/4; i++)
					VMA[i]=*(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4*k++);
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index)){
					VMA[i] = 0x7FFFFFFF;
					Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__VMA,  Write, VMA_Index+ PACKET____DATA_SIZE/4+1);
				}
				
				VMA_Index+=PACKET____DATA_SIZE/4;
				GLB__VFC_Signal_Value_Refresh___Determined = 0;
				Measure_BLK____Num_Of_Analogs_Determined=0;
				
				SendIsOK = send_data(Connection____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__Blocks_SETTINGs:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				if(Packet_Index==0){
					MHA_SETTING_COUNT=0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				
				for(i=0; i<PACKET____DATA_SIZE/4; i++)
					SDRAM____Blocks_Settings_Adress_And_Value_In_MHA[MHA_SETTING_COUNT++] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 4*i);
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index)){
					SDRAM____Blocks_Settings_Adress_And_Value_In_MHA[MHA_SETTING_COUNT] = 0x7FFFFFFF;
					Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING,  Write, MHA_SETTING_COUNT* 2+ 1);
				}
			
				SendIsOK = send_data(Connection____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__HF_IO:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				if(Packet_Index==0){
					CFC__HF_IO____Signal_Index=0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				for(i=0; i<GLB_Main__Reciv_Len/VFC____SIGNAL_INFO__Total_Size; i++){
					sprintf(SDRAM____HF_Vriables__INFO + CFC__HF_IO____Signal_Index * VFC____SIGNAL_INFO__Total_Size,"%s\n", (Connection____Recieve_Packet + PROTOCOL____Data____Index + i * VFC____SIGNAL_INFO__Total_Size));
					sprintf(SDRAM____HF_Vriables__INFO + CFC__HF_IO____Signal_Index * VFC____SIGNAL_INFO__Total_Size + VFC____SIGNAL_NAME__Size,"%s\n", (Connection____Recieve_Packet + PROTOCOL____Data____Index + VFC____SIGNAL_NAME__Size + i*VFC____SIGNAL_INFO__Total_Size));
					sprintf(SDRAM____HF_Vriables__INFO + CFC__HF_IO____Signal_Index * VFC____SIGNAL_INFO__Total_Size + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size,"%s\n", (Connection____Recieve_Packet + PROTOCOL____Data____Index+ VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size  + i * VFC____SIGNAL_INFO__Total_Size));
					sprintf(SDRAM____HF_Vriables__INFO + CFC__HF_IO____Signal_Index * VFC____SIGNAL_INFO__Total_Size + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size + VFC____SIGNAL_Unit__Size,"%s\n", (Connection____Recieve_Packet + PROTOCOL____Data____Index + VFC____SIGNAL_NAME__Size + VFC____SIGNAL_LABEL__Size + VFC____SIGNAL_Unit__Size + i * VFC____SIGNAL_INFO__Total_Size));
					CFC__HF_IO____Signal_Index++;
				}
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index))
					Var_Init__VFC__HF_VAR____Read_Write_uSD(1, CFC__HF_IO____Signal_Index);
				
				SendIsOK = send_data(Connection____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__TRHA:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				if(Packet_Index==0){
					TRHA__SIZE = 0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				for(i=0; i<PACKET____DATA_SIZE/4; i++)
					TRHA[TRHA__SIZE++] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 4*i);
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index)){
					TRHA[TRHA__SIZE] = 0x7FFFFFFF;
//				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING,  Write, MHA_SETTING_COUNT* 2+ 1);
				}
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__VFC__TRHA;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__TSHA:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				if(Packet_Index==0){
					TSHA__SIZE = 0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				for(i=0; i<PACKET____DATA_SIZE/4; i++)
					TSHA[TSHA__SIZE++] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 4*i);
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index)){
					TSHA[TSHA__SIZE] = 0x7FFFFFFF;
//				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING,  Write, MHA_SETTING_COUNT* 2+ 1);
				}
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__VFC__TSHA;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__TRFA:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				if(Packet_Index==0){
					TRFA__SIZE = 0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				for(i=0; i<PACKET____DATA_SIZE/4; i++)
					TRFA[TRFA__SIZE++] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 4*i);
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index)){
					TRFA[TRFA__SIZE] = 0x7FFFFFFF;
//				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING,  Write, MHA_SETTING_COUNT* 2+ 1);
				}
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__VFC__TRFA;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__TSFA:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				if(Packet_Index==0){
					TSFA__SIZE = 0;
					PACKET____DATA_SIZE____TOTAL = PACKET____DATA_SIZE; 
				}
				else 
					PACKET____DATA_SIZE____TOTAL += PACKET____DATA_SIZE;
				
				for(i=0; i<PACKET____DATA_SIZE/4; i++)
					TSFA[TSFA__SIZE++] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 4*i);
				
				if(PACKET____DATA_SIZE____TOTAL == *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Total_Size____Index)){
					TSFA[TSFA__SIZE] = 0x7FFFFFFF;
//				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(MHA_SETTING,  Write, MHA_SETTING_COUNT* 2+ 1);
				}
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__VFC__TSFA;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__VFC__FinishVFCTask:{
				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TRHA, Write, TRHA__SIZE + 1);
				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TSHA, Write, TSHA__SIZE + 1);
				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TRFA, Write, TRFA__SIZE + 1);
				Var_Init__VFC__VMA__MHASETTING____Read_Write_uSD(EN__TSFA, Write, TSFA__SIZE + 1);
				TRFA_And_TSFA_Ready = true;
				if(!Simulation_Flag)
					Var_Init__HW__Read_Write_uSD__init(false);
				VFC_Is_Bypassed = 2;
				Var_Init__Find_Sett_Index_In_MHA_Setting();
				CFC__Blocks_Main_Settings();
				Reset_ANALOG__Samples__AND__FFT_VALS__In_MHA(1, 1, FFT_BLK____First_Analog____Index_In_VMA, VMA[FFT_BLK____Num_Of__Analog____Index_In_VMA]);
				VFC_Bypassed__Flag = false;
				VFC_Is_Bypassed = 0;
				TEMP__CFC_Run = 1;
				VFC_Is_Bypassed__Reason = 0;
				if(VMA_Is_Bypassed_OLD == 1)
					T6963_240_128_Write_String("VFC Is Running",75,50,0, 0);
				
				VFC_Conter++;
			
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__VFC__FinishVFCTask;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers_FlasInProgramMode:{				
				*(uint32_t *)(netTCP____Transmit_Packet+0U) = CaseNumbers_FlasInProgramMode;
				*(uint32_t *)(netTCP____Transmit_Packet+20U) = CPU____FW_VERSION           ;
				GLB_Main__Send_Len=24                                                      ;
        
				if ((*(uint32_t *)(Connection____Recieve_Packet+24U)==1U || ((*(uint32_t *)(Connection____Recieve_Packet+20U)!=CPU____FW_VERSION)))){	
					//memset(SDRAM____1_Block_MMC, 0U, 2048);
					//					*(uint32_t *)(SDRAM____1_Block_MMC  ) = 0;
					//					*(uint32_t *)(SDRAM____1_Block_MMC+4) = 0;
					//					*(uint32_t *)(SDRAM____1_Block_MMC+8) = 0;
					//Write_to_MMC(SDRAM___Read_1_Block_From_MMC, MMC__BLK_NUM___VFC_Data_Has_Written_Flag, 4U);
					
					*(uint32_t *)SDRAM_Base_Address=START_IN_BOOTLOADER_MODE_KEY;
					RELAY_RESET____0_NO____1_YES____Temp = 1U                   ;
				}
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Send_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers_TPS_TEST:{
				for(i=0; i<8; i++){
					GLB_TPS1[i]=Connection____Recieve_Packet[4+i];
					GLB_TPS2[i]=Connection____Recieve_Packet[12+i];
				}
				netTCP____Transmit_Packet[0]=253;
				GLB_Main__Send_Len=1;
				break;
			}
			case CaseNumbers_Reset_Micro:{
				GLB_Reset_Micro_Active=1;
//						
//						
//						
//						GLB_WatchDog_Triger=1;
//						
//						
//						
//						
				netTCP____Transmit_Packet[0]=253;
				GLB_Main__Send_Len=4;
				break;
			}
			case CaseNumbers_Check_LED:{					
				netTCP____Transmit_Packet[0]=253;
				GLB_Main__Send_Len=4;
				break;
			}
			case CaseNumbers_Test_Mode:{
				WriteMyCfg.readwriteMode=WriteMode_Test_Mode;
				Test_Mode_Cod=0;
				Init____WriteConfig();
				//NVIC_SystemReset();
				break;	
			}
			case CaseNumbers_Apply_AMR_State_Seq_To_Device:{
				if(Connection____Recieve_Packet[5]==0)
					GLB_Apply_AMR_State_Seq_To_Device__NumOfSates=Connection____Recieve_Packet[4];
				else{
					for(Main__i=0; Main__i<79; Main__i++){
						*(int32_t *)(SDRAM____Apply_AMR_State_Seq_To_Device+(Connection____Recieve_Packet[5]-1)*GLB_Apply_AMR_State_Seq_To_Device__Num_Of_Bytes + 4*Main__i)=*(int32_t *)(Connection____Recieve_Packet+6+4*Main__i);
//	sprintf((char *)RAM_UART_BUFF,"%d  ", *(int32_t *)(SDRAM____Apply_AMR_State_Seq_To_Device+(Connection____Recieve_Packet[5]-1)*GLB_Apply_AMR_State_Seq_To_Device__Num_Of_Bytes + 4*Main__i));  Panel_Komaki_UARTX_For_Sprintf();	
					}
//	sprintf((char *)RAM_UART_BUFF,"\n");  Panel_Komaki_UARTX_For_Sprintf();	
					if(Connection____Recieve_Packet[5]==GLB_Apply_AMR_State_Seq_To_Device__NumOfSates){
						GLB_Apply_AMR_State_Seq_To_Device__StateConter=0;
						GLB_Apply_AMR_State_Seq_To_Device__ms_Conter=0;
						GLB_Apply_AMR_State_Seq_To_Device__Started=1;
						GLB_1ms_Busy=Connection____Recieve_Packet[6+GLB_Apply_AMR_State_Seq_To_Device__Num_Of_Bytes];
					}
				}
				
				netTCP____Transmit_Packet[0]=253;
				GLB_Main__Send_Len=1;
				break;
			}
			case CaseNumbers_GPSClockCalibrationSet:{
				
				netTCP____Transmit_Packet[0]=200;
				send_data (netTCP____Transmit_Packet, 1);

				//----------S: Disable Kardane Timers----------
//						LL_TIM_DisableCounter(TIM2);
//						LL_TIM_DisableCounter(TIM4);
				//----------E: Disable Kardane Timers----------

				//----------S: Set GPS for 5s, 100ms----------
				Main_Ublox_Cfg_Tp(Intv_5_SEC,PL_100_mSEC,GPS_Time);
				//----------E: Set GPS for 5s, 100ms----------
				
				//----------S: Reset If GPS Disconnected----------
//						Timer3_on();
//						Read_Timer1()=0;
				//----------E: Reset If GPS Disconnected----------
				
				//----------S: Enable GPS Interapt----------
//						NVIC_EnableIRQ(GPIO_IRQn);
				//----------E: Enable GPS Interapt----------
				
				//----------S: Init Variables----------
				Glb_GPS.TimePulse_Counter=0;
				Glb_GPS.Check_While=1;
				Main__i=0;
				Main__counter_Run_On=300000;
				Glb_GPS.Wait_For_TimePulse=30;
				//----------E: Init Variables----------
				
				//----------S: Main While----------
				while(Glb_GPS.Check_While){
					//----------S: GPS Timeout----------
					if(Read_Timer1()>Glb_GPS.Wait_For_TimePulse*60000000){
						Main_Show_Error_During_GPS_Set_Time();
					}
					//----------E: GPS Timeout----------

					//----------S: Serial Read----------
					if(U2_Recive_Ready){
						U2_Recive_Ready=0;
						Main_NMEA_GPRMC_Analysis(&Glb_nmea_msg,(uint8_t*)SDRAM____UART2_Recieve_Buff);
					}
					//----------E: Serial Read----------

					//----------S: Blink----------
					Main__i++;
					if(Main__i==Main__counter_Run_On){
//						LED_RUN_ON;
					}
					if(Main__i==2*Main__counter_Run_On){
//						LED_RUN_OFF;
						Main__i=0;
					}
					//----------E: Blink----------
				}
//						Timer3_off();
				AD_CalculateDate();
				//----------E: Main While----------
				break;
			}
			case CaseNumbers_GPSClockCalibrationTimeGet:{
				netTCP____Transmit_Packet[0]=CaseNumbers_GPSClockCalibrationTimeGet;
				netTCP____Transmit_Packet[1]=0;
				netTCP____Transmit_Packet[2]=0;
				netTCP____Transmit_Packet[3]=0;
				*(uint32_t *)(netTCP____Transmit_Packet+4) = ReadMyCfg.ClockCalibration;
				netTCP____Transmit_Packet[8]=Glb_nmea_msg.utc.sec;
				netTCP____Transmit_Packet[9]=Glb_nmea_msg.utc.min;
				netTCP____Transmit_Packet[10]=Glb_nmea_msg.utc.hour;
				netTCP____Transmit_Packet[11]=Glb_nmea_msg.utc.date;
				netTCP____Transmit_Packet[12]=Glb_nmea_msg.utc.month;
				*(uint16_t *)(netTCP____Transmit_Packet+13) = Glb_nmea_msg.utc.year;
				send_data (netTCP____Transmit_Packet, 15);
				break;	
			}
			case CaseNumbers_SideSync:{
//				GLB_Is_Sync_With_Cs=1;
				GLB_Key_Temp_SideSync=*(uint16_t *)(Connection____Recieve_Packet+4);
//				Panel_KeyPad_Function();
//				GLB_Is_Sync_With_Cs=0;
				netTCP____Transmit_Packet[0]=253;
				GLB_Main__Send_Len=1;
				while(CPU____QTL____ADD_ITEM(FP_CPU____SideSync, 0, 1, 2, (uint32_t) &GLB_Key_Temp_SideSync)!= 1U);
				break;
			}
			case CMD____GET_MODE:{
				*(uint32_t *)(netTCP____Transmit_Packet + 0U) = CMD____GET_MODE;
				*(uint32_t *)(netTCP____Transmit_Packet + 4U) = CMD____MAIN_MODE;
				
				SendIsOK = send_data(netTCP____Transmit_Packet, 8U); if(SendIsOK==0){ /* Show Error */ }
				break;	
			}			
			case CMD____CONNECTION_LIVE_CHECKER:{
					//Just Test the connection status: Live Connection Checker
					SendIsOK = send_data(netTCP____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }				
					break;	
			}
			case CaseNumbers__Menu____Disp_Array:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);
				if(Packet_Index==0){
					Recive_Menu_Data____Index=1;
					Menu____Disp_Array___Size = 4;
				}
				k=0;
				for(i = Recive_Menu_Data____Index; i< Recive_Menu_Data____Index + PACKET____DATA_SIZE/4; i++)
					SDRAM____Menu____Disp_Array[i]=*(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4*k++);
				Recive_Menu_Data____Index += PACKET____DATA_SIZE/4;
				Menu____Disp_Array___Size += PACKET____DATA_SIZE;
				
        
				SendIsOK = send_data(Connection____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			} 
			case CaseNumbers__Menu____Line_Address:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);
				if(Packet_Index==0){
					Recive_Menu_Data____Index=1;
					Menu____Line_Address_Array___Size=4;
				}
				
				k=0;
				for(i = Recive_Menu_Data____Index; i< Recive_Menu_Data____Index + PACKET____DATA_SIZE/4; i++)
					SDRAM____Menu____Line_Address_Array[i]=*(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4*k++);
				Recive_Menu_Data____Index += PACKET____DATA_SIZE/4;
				Menu____Line_Address_Array___Size += PACKET____DATA_SIZE;
				
				
				SendIsOK = send_data(Connection____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__Menu____String_Array:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);
				if(Packet_Index==0)
					Menu____String_Array___Size=4;
				
				k=0;
				for(i = Menu____String_Array___Size; i< Menu____String_Array___Size + PACKET____DATA_SIZE; i++)
					SDRAM____Menu____String_Array[i]=Connection____Recieve_Packet[PROTOCOL____Data____Index + k++];
				Menu____String_Array___Size += PACKET____DATA_SIZE;			
				
				SendIsOK = send_data(Connection____Recieve_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__Menu____Method_ComboBox:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index);
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				
				if(Packet_Index==0)
					Menu____Method_ComboBox___Size=4;
				
				k=0;
				for(i = Menu____Method_ComboBox___Size; i< Menu____Method_ComboBox___Size + PACKET____DATA_SIZE; i++)
					SDRAM____Menu____Method_ComboBox[i] = Connection____Recieve_Packet[PROTOCOL____Data____Index + k++];
				
				Menu____Method_ComboBox___Size += PACKET____DATA_SIZE;
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Menu____Method_ComboBox;
				GLB_Main__Send_Len = 4;
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Send_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__Menu____Method_Range:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index);
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Index____Index);		
				
				if(Packet_Index==0)
					Menu____Method_Range___Size=4;
							
				for(i = 0; i< PACKET____DATA_SIZE; i++)
					SDRAM____Menu____Method_Range[Menu____Method_Range___Size + i] = Connection____Recieve_Packet[PROTOCOL____Data____Index + i];
				
				Menu____Method_Range___Size += PACKET____DATA_SIZE;
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Menu____Method_Range;
				GLB_Main__Send_Len = 4;
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Send_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__Menu____FinishMenuTask:{
				SDRAM____Menu____Line_Address_Array[0] = Menu____Line_Address_Array___Size;
				*(uint32_t*)SDRAM____Menu____String_Array = Menu____String_Array___Size;
				SDRAM____Menu____Disp_Array[0] = Menu____Disp_Array___Size; 
				SDRAM____Menu____Line_Address_Array[0] = Menu____Line_Address_Array___Size;
				*(uint32_t*)SDRAM____Menu____Method_ComboBox = Menu____Method_ComboBox___Size;
				*(uint32_t*)SDRAM____Menu____Method_Range = Menu____Method_Range___Size;
				
				Var_Init__Menu_Data____Write_On_uSD();
				Var_Init__Menu_Data____Send_to_FP();
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Menu____FinishMenuTask;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__GetBootlodedVersion:{
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__GetBootlodedVersion;
				
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index			) = CSharpVMAVersion      ;
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 4	) = CSharpKeilVersion     ;
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 8	) = RelayControllerVersion;
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 12) = RelayUIVersion        ;
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 16) = EnumVersion		        ;
				
				GLB_Main__Send_Len = 20 + PROTOCOL____Data____Index;
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Send_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__GET_HW_INFO:{
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__GET_HW_INFO;
				for(Unit_Index=MP_MASTER; Unit_Index<=MAX_NUM_OF_UNITS; Unit_Index++){
					for(Card_Index=CARD_SLOT_1; Card_Index<=CARD_SLOT_4; Card_Index++)
						*(uint16_t*)(netTCP____Transmit_Packet + PROTOCOL____Data____Index+  2* (Unit_Index * NUM_OF_UNIT_CARDS + Card_Index))= MP_UNIT[Unit_Index][Card_Index].TYPE;
				}
				GLB_Main__Reciv_Len = 2* MAX_NUM_OF_UNITS* NUM_OF_UNIT_CARDS + PROTOCOL____Data____Index;
				
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Reciv_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__SetCurrentFile___Num_Of_Packets:{
				*(int32_t *)(SDRAM____1_Block_MMC)      = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);
				*(int32_t *)(SDRAM____1_Block_MMC + 4 ) = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4);
				Write_to_MMC(SDRAM____1_Block_MMC, GLB__SET_FILE____MMC____FST_BLK____CPU, 1);
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__SetCurrentFile___Num_Of_Packets; 
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__SetCurrentFile:{
				Packet_Index        = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);			
				for(i=0; i<512; i++)
					SDRAM____1_Block_MMC[i] = Connection____Recieve_Packet[PROTOCOL____Data____Index + 4 + i];
				Write_to_MMC(SDRAM____1_Block_MMC, GLB__SET_FILE____MMC____FST_BLK____CPU + Packet_Index + 1, 1);
//			Write_to_MMC(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4, GLB__SET_FILE____MMC____FST_BLK____CPU + Packet_Index + 1, 1);
								
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__SetCurrentFile; 
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__GetCurrentFile___Num_Of_Packets:{
				read_from_MMC(SDRAM____1_Block_MMC, GLB__SET_FILE____MMC____FST_BLK____CPU, 1);
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__GetCurrentFile___Num_Of_Packets; 
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index) = *(int32_t *)(SDRAM____1_Block_MMC); 
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index + 4) = *(int32_t *)(SDRAM____1_Block_MMC + 4);
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 8); if(SendIsOK==0){ /* Show Error */ }
				break;
			}
			case CaseNumbers__GetCurrentFile:{
				Packet_Index = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);
				read_from_MMC(SDRAM____1_Block_MMC, GLB__SET_FILE____MMC____FST_BLK____CPU + Packet_Index + 1, 1);
				for(i=0; i<512; i++)
					netTCP____Transmit_Packet[PROTOCOL____Data____Index + i] = SDRAM____1_Block_MMC[i];
				
//			read_from_MMC((netTCP____Transmit_Packet + PROTOCOL____Data____Index), GLB__SET_FILE____MMC____FST_BLK____CPU + Packet_Index + 1, 1);
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__GetCurrentFile; 
				
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 512); if(SendIsOK==0){ /* Show Error */ }
				break;
			} 
			case CaseNumbers__Password____GetPassword:{
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Password____GetPassword;
				*(uint32_t *)(netTCP____Transmit_Packet + PROTOCOL____Data____Index) = GLB_Password_For_Parameter_Set[0];

				GLB_Main__Send_Len = PROTOCOL____Data____Index +4;
				SendIsOK = send_data(netTCP____Transmit_Packet, GLB_Main__Send_Len); if(SendIsOK==0){ /* Show Error */ }
				break;
			}			
			case CaseNumbers__ApplyHardware:{
				i=0;
				for(Unit_Index = MP_MASTER; Unit_Index <= MP_SLAVE_8; Unit_Index++){
					for(Card_Index = CARD_SLOT_1; Card_Index <= CARD_SLOT_4; Card_Index++){
						SDRAM____Simulation__Cards_ID[i] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index + 4*i);
						i++;
					}
				}
				
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__ApplyHardware;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				*(uint8_t *)(SDRAM_Base_Address+100) = 200;	
				RELAY_SYSTEM_RESET=1U;
				break;
			}			
			case CaseNumbers__Password____SetPassword:{
				GLB_Password_For_Parameter_Set[0] = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index);
				GLB_Password_For_Parameter_Set[1] = 6;
				
				Var_Init__Write_Password();

				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Password____SetPassword;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}			
			case CaseNumbers__SetWatchDog:{
//			IWDG_FLAG____0_DISABLE____1_ENABLE = Connection____Recieve_Packet[PROTOCOL____Data____Index];
				Var_Init__WatchDogStatus(Write, Connection____Recieve_Packet[PROTOCOL____Data____Index]);

				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__SetWatchDog;
				SendIsOK = send_data(netTCP____Transmit_Packet, 4); if(SendIsOK==0){ /* Show Error */ }
				break;
			}			
			case CaseNumbers__GetMeasurementData:{
//			Measure_Request = Fundumental;
				Byte_Index = PROTOCOL____Data____Index;
				
				for(i=0; i<CFC____Measurement_BLK____Num_Of_Analog_Inputs; i++){
					MHA_PNT = MHA + *(VMA + GLB____Measurement_BLK____Index_Of_ANALOGs_In_VMA + i);
					if(*(MHA_PNT + PatternModel_1____Index_Of____AssignedSigStatus) == 1){
						*(int32_t*)(netTCP____Transmit_Packet + Byte_Index) = *(MHA_PNT + PatternModel_1____First_Index____FFT + 2);
						Byte_Index += 4;
						*(int32_t*)(netTCP____Transmit_Packet + Byte_Index) = *(MHA_PNT + PatternModel_1____First_Index____FFT + 3);
						Byte_Index += 4;						
					}
				}
					
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__GetMeasurementData;
				SendIsOK = send_data(netTCP____Transmit_Packet, Byte_Index); if(SendIsOK==0){ /* Show Error */ }
				break;
			}			
			case CaseNumbers__Check_Block_Version:{
				PACKET____DATA_SIZE = *(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Packet_Size____Index );
				MismachBlkVers = 0;
				
				for(i=0; i<PACKET____DATA_SIZE/6; i++){
					if(*(int32_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 6*i + 2) != BlockVer[*(int16_t *)(Connection____Recieve_Packet + PROTOCOL____Data____Index+ 6*i)]){
						MismachBlkVers = 1;
						break;
					}
				}
					
				*(uint32_t *)(netTCP____Transmit_Packet) = CaseNumbers__Check_Block_Version;
				netTCP____Transmit_Packet[PROTOCOL____Data____Index] = MismachBlkVers;
				SendIsOK = send_data(netTCP____Transmit_Packet, PROTOCOL____Data____Index + 1); if(SendIsOK==0){ /* Show Error */ }
				break;
			}			
			default:{
				//----------S: write All To Relay ---------- 
				if(Connection____Recieve_Packet[0]==2 && Connection____Recieve_Packet[1]==2 && Connection____Recieve_Packet[2]==2 && Connection____Recieve_Packet[3]==2){
	// 				GLB_Main_counter_Busy++;
	// 				if(GLB_Main_counter_Busy==1)
	// 					LED_ERROR_OFF;
	// 				if(GLB_Main_counter_Busy==10)
	// 					LED_ERROR_ON;				
	// 				if(GLB_Main_counter_Busy==20 )
	// 					GLB_Main_counter_Busy=0;
					
					GLB_Main_Address=*((uint32_t *)(Connection____Recieve_Packet+4));
					for(GLB_Main_i=0;GLB_Main_i<512;GLB_Main_i++)
						Connection____Recieve_Packet[GLB_Main_i]=Connection____Recieve_Packet[GLB_Main_i+8];
					//sprintf((char *)RAM_UART_BUFF,"Address=%d  counter_Busy=%d\n", GLB_Main_Address, GLB_Main_counter_Busy); Panel_Komaki_UARTX_For_Sprintf();
					Write_to_MMC(Connection____Recieve_Packet, GLB_Main_Address, 1);		

					netTCP____Transmit_Packet[0]=253;
					GLB_Main__Send_Len=1;				
				}
				//----------E: write All To Relay ----------		
				//----------S: write On GLB_Address_Of_Block_That_Shows_MMC_Has_Written_Already ----------
				else if(Connection____Recieve_Packet[0]==3 && Connection____Recieve_Packet[1]==3 && Connection____Recieve_Packet[2]==3 && Connection____Recieve_Packet[3]==3){
					*((uint32_t*)SDRAM____1_Block_MMC)=My_INF;
					//sprintf((char *)RAM_UART_BUFF," Address_Shows_MMC_Has_Written_Already \n"); Panel_Komaki_UARTX_For_Sprintf();				
//						Write_to_MMC(SDRAM____1_Block_MMC, GLB_Addr_That_Shows_MMC_Has_Written_Already, 1);		
					netTCP____Transmit_Packet[0]=253;
					GLB_Main__Send_Len=1;
				}
				//----------E: write On GLB_Address_Of_Block_That_Shows_MMC_Has_Written_Already ----------					
				else if(!(GLB_Main_Recieve_Code==22 && Connection____Recieve_Packet[0]==SLAVE_ADDR)){
					//sprintf((char *)RAM_UART_BUFF,"Moshkel Dri\n"); Panel_Komaki_UARTX_For_Sprintf();
					//for(GLB_Main_j=0;GLB_Main_j<4;GLB_Main_j++){
						//sprintf((char *)RAM_UART_BUFF," Connection____Recieve_Packet[%d]=%d\n",GLB_Main_j, Connection____Recieve_Packet[GLB_Main_j]); Panel_Komaki_UARTX_For_Sprintf();
					//}
					GLB_Main_Recieve_Code=0;
				}
				break;
			}
		}
		switch(GLB_Main_Recieve_Code){
			case 33:{
				//do{GLB_Main_tcp_check=tcp_check_send(socket_tcp); timer_poll(); main_TcpNet(); } while(!GLB_Main_tcp_check);
// 					sprintf((char *)RAM_UART_BUFF,"%d   %d\n",netTCP____Transmit_Packet[0], GLB_Main__Send_Len); Panel_Komaki_UARTX_For_Sprintf();
//				send_data (netTCP____Transmit_Packet, GLB_Main__Send_Len);	
				break;
			}
			case 11:{
				RS232_Send_Data(netTCP____Transmit_Packet, GLB_Main__Send_Len);
				break;
			}
			case 22:{
				RS485_Send_Data(netTCP____Transmit_Packet, GLB_Main__Send_Len);
				break;
			}
		}
	
		GLB_Main_Recieve_Code=0;
		netTCP____Transmit_Packet[0]=0;
		
		if(RELAY_RESET____0_NO____1_YES____Temp == 1U){
			RELAY_SYSTEM_RESET = 1U;
		}
	}
}
#endif
#if(1) // Main 
void Simulation(void){
//	int32_t 	Card_Conter=0, CTPT_Index;
//	int32_t		Unit_Index, Card_Index, POINT=0, CTPTs__In_All_Cards__Conter=0;
//
//	for(Unit_Index = MP_MASTER; Unit_Index <= MP_SLAVE_8; Unit_Index++){
//		for(Card_Index = CARD_SLOT_1; Card_Index <= CARD_SLOT_4; Card_Index++){
//			SDRAM____CARDS_FLASH_DATA[Card_Conter*2048] = Simulation__Cards_ID[Card_Conter];
//			MP_UNIT[Unit_Index][Card_Index].TYPE = HW__Check__CARD_TYPE(SDRAM____CARDS_FLASH_DATA[Card_Conter*2048]);
//				POINT=(4096* Card_Conter+ GLB_CPU_MP__Calib_Data__Start_Byte)/2;
//
//				switch(MP_UNIT[Unit_Index][Card_Index].TYPE){
//					case CARD_TYPE____PS:{
//					}
//					break;
//					case CARD_TYPE____CPU:{
//					}
//					break;
//					case CARD_TYPE____4_CT__6_BI:{
//						for(CTPT_Index=0; CTPT_Index<CARD_TYPE____4_CT__6_BI____NUM_OF_CTS; CTPT_Index++){
//							CALIB_DATA____Magnitude____Part1[0][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1000; // ref
//							CALIB_DATA____Magnitude____Part1[1][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1000; // rms
//							CALIB_DATA____Magnitude____Part1[2][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 7071; // H1 (1/(2^0.5)
//							CALIB_DATA____Magnitude____Part1[3][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 7071; // H2 (1/(2^0.5)
//							CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1; 	 // type
//						}
//						CTPTs__In_All_Cards__Conter += CARD_TYPE____4_CT__6_BI____NUM_OF_CTS;
//					}
//					break;
//					case CARD_TYPE____4_PT__6_BO:{
//						for(CTPT_Index=0; CTPT_Index<CARD_TYPE____4_PT__6_BO____NUM_OF_PTS; CTPT_Index++){
//							CALIB_DATA____Magnitude____Part1[0][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1000;  // ref
//							CALIB_DATA____Magnitude____Part1[1][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1000;  // rms
//							CALIB_DATA____Magnitude____Part1[2][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 7071;  // H1 (1/(2^0.5)
//							CALIB_DATA____Magnitude____Part1[3][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 7071;  // H2 (1/(2^0.5)
//							CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 0; 	  // type
//						}
//						CTPTs__In_All_Cards__Conter += CARD_TYPE____4_PT__6_BO____NUM_OF_PTS;
//					}
//					break;
//					case CARD_TYPE____E1:{
//					}
//					break;
//					case CARD_TYPE____12_CT:{
//						for(CTPT_Index=0; CTPT_Index<CARD_TYPE____4_PT__6_BO____NUM_OF_PTS; CTPT_Index++){
//							CALIB_DATA____Magnitude____Part1[0][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1000; // ref
//							CALIB_DATA____Magnitude____Part1[1][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1000; // rms
//							CALIB_DATA____Magnitude____Part1[2][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 7071; // H1 (1/(2^0.5)
//							CALIB_DATA____Magnitude____Part1[3][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 7071; // H2 (1/(2^0.5)
//							CALIB_DATA____Magnitude____Part1[4][CTPTs__In_All_Cards__Conter+ CTPT_Index] = 1; 	 // type
//						}
//						CTPTs__In_All_Cards__Conter += CARD_TYPE____12_CT____NUM_OF_CTS;
//					}
//					break;
//					case CARD_TYPE____9_BI__9_BO:{
//					}
//					break;
//				}
//			Card_Conter++;
//		}
//	}
}
void Main_Functions(void){
	Main__Counters_In_1ms();		
	
	if(CPU_MODE____FROM_FP____0_STARTUP____1_BOOTLOADER____2_MAIN == 1){
		if(VFC_Is_Bypassed == 0){
			VFC_Is_Bypassed__Reason = FP_Update;
			VFC_Is_Bypassed = 1;
		}
	}
	else{
		if(VFC_Is_Bypassed__Reason == FP_Update){
			VFC_Is_Bypassed = 2;
			CFC__Blocks_Main_Settings();
			VFC_Is_Bypassed = 0;
			VFC_Is_Bypassed__Reason = 0;
		}
	}
	if(Calib_Mode == 1){
		if(Calibration____Stage_1____Finished==0)
			Calibration____Stage_1____Magnitude();
	}
	else if(Calib_Mode == 2){
		Calibration____Stage_2____FFTCalibVal____FFT();
		if(Calibration____Stage_2____FFT_Factors__Mode == 0 && Measure_Request == 0)
			Calibration____Stage_2____Phase_Angles();
	}
	if(VFC_Is_Bypassed==0){		
		Protection__Analog_Signal_Connection_Processing();
		
//		if(APLY_CMTRD___Triger == 0 && !Simulation_Flag)
			Copy_RHA_to_MHA();
			APLY_CMTRD();	
		
		if(GLB_Counter_Samples_Total_New==0)
			CFC__Blocks_Main_Settings();
		else if(TEMP__CFC_Run==1)
			CFC();
		if(VFC_Is_Bypassed == 0){
			if(!Simulation_Flag)
				Copy_MHA_to_SHA();

			if(GLB__Spontaneous_Fault_Display__Flag == En_YES)
				Disp__Fault_Info_On_LCD();
		}
	}
	else{
//		Reset_ANALOG__Samples__AND__FFT_VALS__In_MHA(1, 1, 0, VMA[FFT_BLK____NextBlockIndex____Index_In_VMA]-2);
	}
}
void Reset_ANALOG__Samples__AND__FFT_VALS__In_MHA(int8_t Reset_Samples, int8_t Reset_FFT_VALs, int32_t First_Analog, int32_t Num_Of__Analog){
//   Reset_ANALOG__Samples__AND__FFT_VALS__In_MHA(1                  , 1,                             FFT_BLK____First_Analog____Index_In_VMA, VMA[FFT_BLK____Num_Of__Analog____Index_In_VMA]);
	int32_t CTPT_Index, i;
	
	//----------S: Sefr kardane sampleha dar MHA ----------
	if(Reset_Samples == 1){
		for(CTPT_Index = 0; CTPT_Index < Num_Of__Analog; CTPT_Index++){
			for(i = 0; i < GLB_Number_of_Sample_per_Cycle + 2 + 1; i++) 
				*(MHA + *(VMA + First_Analog + CTPT_Index) + PatternModels____DataWindow__From_FFT_PNT + i) = 0;
		}
	}
	if(Reset_FFT_VALs == 1){
		*(MHA + *(VMA + First_Analog + CTPT_Index) + PatternModel_1____RMS) = 0;
		for(CTPT_Index = 0; CTPT_Index < Num_Of__Analog; CTPT_Index++){
			for(i = 0; i < 2 * FFT____Max_Num_Of_Harmonics * 4; i++)
				*(MHA + *(VMA + First_Analog + CTPT_Index) + i) = 0;
		}
	}
	//----------E: Sefr kardane sampleha dar MHA ----------
}
void Main_Live_Status(void){
	if(Test_Mode==0 && Calib_Mode==0){
		if(GLB_Live_Status==0 && GLB_WatchDog_Saved_On_RAM==0 && GLB_Counter_Samples_Total_New>60*GLB_Rated_Frequency*GLB_Number_of_Sample_per_Cycle){
			*(uint8_t *)(SDRAM_Base_Address+100)=0;
			GLB_WatchDog_Saved_On_RAM=1;
		}
		if(GLB_WatchDog_Occured_Later==0 && GLB_WatchDog_Triger==1){
			if(WatchDog_Count==1){
				if(GLB_Counter_Samples_Total_New<30*GLB_Rated_Frequency*GLB_Number_of_Sample_per_Cycle){
					WatchDog_Count=2;
					WatchDog_Mode_Write__Time=GLB_Counter_Samples_Total_New;
				}
				else{
					WatchDog_Count=1;
					WatchDog_Mode_Write__Time=0;
				}
			}
			else if(WatchDog_Count==2){
				if((GLB_Counter_Samples_Total_New+WatchDog_Time) <30*GLB_Rated_Frequency*GLB_Number_of_Sample_per_Cycle){
					WatchDog_Count=3;
					WatchDog_Mode_Write__Time=0;
				}
				else{
					if(GLB_Counter_Samples_Total_New<30*GLB_Rated_Frequency*GLB_Number_of_Sample_per_Cycle){
						WatchDog_Count=2;
						WatchDog_Mode_Write__Time=GLB_Counter_Samples_Total_New;
					}
					else{
						WatchDog_Count=1;
						WatchDog_Mode_Write__Time=0;
					}
				}
			}
			else{
				WatchDog_Count=1;
				WatchDog_Mode_Write__Time=0;
			}
			
			*(uint8_t *)(SDRAM_Base_Address+100)=128;
			*(uint8_t *)(SDRAM_Base_Address+104)=WatchDog_Count;
			*(uint32_t *)(SDRAM_Base_Address+108)=WatchDog_Mode_Write__Time;				
			
			GLB_WatchDog_Occured_Later=1;	
			//NVIC_SystemReset();
		}
	}
}
void Main__Counters_In_1ms(void){
	GLB_Counter_Samples_Total_New++;
	GLB_Index_Of_New_Sample++;
	GLB_Index_Of_New_Sample = (GLB_Index_Of_New_Sample==GLB_Number_of_Sample_per_Cycle+2?0:GLB_Index_Of_New_Sample);
	GLB_Counter_Deleted_Row = GLB_Index_Of_New_Sample+1;
	GLB_Counter_Deleted_Row=(GLB_Counter_Deleted_Row==GLB_Number_of_Sample_per_Cycle+2?0:GLB_Counter_Deleted_Row);
	GLB_Counter_Current_Sample=GLB_Index_Of_New_Sample-1;
	GLB_Counter_Current_Sample=(GLB_Counter_Current_Sample==-1?GLB_Number_of_Sample_per_Cycle+1:GLB_Counter_Current_Sample);
	GLB_Counter_Prev_Sample = GLB_Counter_Current_Sample - 1;
	GLB_Counter_Prev_Sample = (GLB_Counter_Prev_Sample == -1 ? GLB_Number_of_Sample_per_Cycle + 1 : GLB_Counter_Prev_Sample);
	GLB_Counter_For_FFT_Total++;
	GLB_Counter_For_FFT_Total=(GLB_Counter_For_FFT_Total==GLB_Number_of_Sample_per_Cycle?0:GLB_Counter_For_FFT_Total);
	
	if(GLB_Osc_Triger_By_Protocol==1){
		GLB_Osc_Triger_By_Protocol_Counter++;
		if(GLB_Osc_Triger_By_Protocol_Counter>GLB_Osc_Triger_By_Protocol_Time* GLB_Rated_Frequency* GLB_Number_of_Sample_per_Cycle){
			GLB_Osc_Triger_By_Protocol=0;
			GLB_Osc_Triger_By_Protocol_Counter=0;
		}
	}
	
	if(GLB_Reset_Micro_Active==1)
		GLB_Counter_For_Reset_Micro++;
}
void Main_Sub_Functions(void){
	
	if(GLB_Main__Reset_Osc_In_Relay==1){
		Panel_Komaki__Osc__Format_MMC_Osc_Log_Part();
		GLB_Main__Reset_Osc_In_Relay=0;
	}
	if(GLB_Main__Reset_TL_In_Relay==1){
		Panel_Komaki__TL__Format_MMC_TL_Part();
		GLB_Main__Reset_TL_In_Relay=0;
	}
	if(GLB_Main__Reset_EL_In_Relay==1){
		Panel_Komaki__EL__Format_MMC_EL_Part();
		GLB_Main__Reset_EL_In_Relay=0;
	}
	
	if(GLB_Reset_Micro_Active==1 && GLB_Counter_For_Reset_Micro>500){
		RELAY_SYSTEM_RESET=1U;
		GLB_Reset_Micro_Active=0;
	}
	//----------S: APLY CMTRD SDRAM_Part Switching ----------
	if(APLY_CMTRD___Triger == 1){
		if(APLY_CMTRD___Applying_Part_Index != APLY_CMTRD___Filling_Part_Index && APLY_CMTRD___Applying_Part_Index < APLY_CMTRD___Num_Of_MMC_Parts){
			int32_t ColIndex, Adr, i;
			int32_t *SDRAM_PNT;
			
			if((APLY_CMTRD___Filling_Part_Index % 2) == 0)
				SDRAM_PNT = SDRAM____Apply_Cmtrd_2;
			else
				SDRAM_PNT = SDRAM____Apply_Cmtrd_1;

			APLY_CMTRD___Filling_Part_Index++;
				
//			APLY_CMTRD___Total_Num_Of_Remained_Samples = APLY_CMTRD___Total_Num_Of_Samples - APLY_CMTRD___Total_Num_Of_Samples_For_Current_Part;
//			APLY_CMTRD___Total_Num_Of_Samples_For_Current_Part = (APLY_CMTRD___Num_Of_MMC_Parts == 1 ? APLY_CMTRD___Total_Num_Of_Samples : APLY_CMTRD___Max_Samples__Multiple_Cols__at_Any_SDRAM_Part / (APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs));
			
			
			int32_t Adr_Ofset = APLY_CMTRD___Num_Of_Samples_At_Any_Part[APLY_CMTRD___Filling_Part_Index][1];
			int j;
			
			for(ColIndex = 0; ColIndex < APLY_CMTRD___Num_Of_ANALOGs_In_Files + APLY_CMTRD___Num_Of_32bit_Cols_For_DIGITALs; ColIndex++){
				Adr = ColIndex * (APLY_CMTRD___Total_Num_Of_Samples%128 == 0? APLY_CMTRD___Total_Num_Of_Samples / 128 : APLY_CMTRD___Total_Num_Of_Samples / 128 + 1) + Adr_Ofset;
				read_from_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + Adr, 1U);
				
				i = 0;
				APLY_CMTRD___MMC_Byte_Index = APLY_CMTRD___Num_Of_Samples_At_Any_Part[APLY_CMTRD___Filling_Part_Index][2];
				while(i < APLY_CMTRD___Num_Of_Samples_At_Any_Part[APLY_CMTRD___Filling_Part_Index][0]){
					if(APLY_CMTRD___MMC_Byte_Index % 512 == 0){
						APLY_CMTRD___MMC_Byte_Index = 0;
						Adr ++;
						read_from_MMC(SDRAM____1_Block_MMC, GLB__APLY_CMTRD____MMC____FST_BLK____CPU + APLY_CMTRD___MMC_Part_Index * GLB__APLY_CMTRD__MMC____NUM_OF_BLKs____For_Any_Part + Adr, 1U);
					}
					
					SDRAM_PNT[ColIndex * APLY_CMTRD___Num_Of_Samples_At_Any_Part[APLY_CMTRD___Filling_Part_Index][0] + i] = *(uint32_t *)(SDRAM____1_Block_MMC + APLY_CMTRD___MMC_Byte_Index);	APLY_CMTRD___MMC_Byte_Index += 4;
					i++;
				}
			}
		}
	}
	//----------E: APLY CMTRD SDRAM_Part Switching ----------
}
void Main_Show_Error_During_GPS_Set_Time(void){
	uint32_t i;
//	LED_ERROR_ON;
	for(i=0; i<100000000;i++){};
	//NVIC_SystemReset();
	RELAY_SYSTEM_RESET = 1U;
}
void Main_Ublox_CheckSum(uint8_t *buf,uint16_t len,uint8_t* cka,uint8_t*ckb){
	uint16_t i;
	*cka=0;*ckb=0;
	for(i=0;i<len;i++)
	{
		*cka=*cka+buf[i];
		*ckb=*ckb+*cka;
	}
}
void Main_UART2_DMA_Send(uint32_t len){
}
void Main_Ublox_Cfg_Tp(uint32_t interval,uint32_t length,signed char status){
	Glb_ublox_cfg_tp.header=0x62B5;
	Glb_ublox_cfg_tp.id=0x0706;			
	Glb_ublox_cfg_tp.dlength=20;			
	Glb_ublox_cfg_tp.interval=interval;	
	Glb_ublox_cfg_tp.length=length;		
	Glb_ublox_cfg_tp.status=status;	   	
	Glb_ublox_cfg_tp.timeref=0x01;			
	Glb_ublox_cfg_tp.flags=0;			
	Glb_ublox_cfg_tp.reserved=0;		 	
	Glb_ublox_cfg_tp.antdelay=50;    	
	Glb_ublox_cfg_tp.rfdelay=0;    		
	Glb_ublox_cfg_tp.userdelay=0;    
	Main_Ublox_CheckSum((uint8_t*)(&Glb_ublox_cfg_tp.id),sizeof(ublox_cfg_tp)-4,&Glb_ublox_cfg_tp.cka,&Glb_ublox_cfg_tp.ckb);
	Main_UART2_DMA_Send(sizeof(ublox_cfg_tp));
}
uint32_t Main_NMEA_Pow(uint8_t m,uint8_t n){
	uint32_t result=1;	 
	while(n--)result*=m;    
	return result;
}
int Main_NMEA_Str2num(uint8_t *buf,uint8_t*dx){
	uint8_t *p=buf;
	uint32_t ires=0,fres=0;
	uint8_t ilen=0,flen=0,i;
	uint8_t mask=0;
	int res;
	while(1){
		if(*p=='-'){mask|=0X02;p++;}
		if(*p==','||(*p=='*'))break;
		if(*p=='.'){mask|=0X01;p++;}
		else if(*p>'9'||(*p<'0'))
		{	
			ilen=0;
			flen=0;
			break;
		}	
		if(mask&0X01)flen++;
		else ilen++;
		p++;
	}
	if(mask&0X02)buf++;	
	for(i=0;i<ilen;i++){  
		ires+=Main_NMEA_Pow(10,ilen-1-i)*(buf[i]-'0');
	}
	if(flen>5)flen=5;	
	*dx=flen;	 		
	for(i=0;i<flen;i++){  
		fres+=Main_NMEA_Pow(10,flen-1-i)*(buf[ilen+1+i]-'0');
	} 
	res=ires*Main_NMEA_Pow(10,flen)+fres;
	if(mask&0X02)res=-res;		   
	return res;
}
uint8_t Main_NMEA_Comma_Pos(uint8_t *buf,uint8_t cx){	 		    
	uint8_t *p=buf;
	while(cx){		 
		if(*buf=='*'||*buf<' '||*buf>'z')return 0XFF;
		if(*buf==',')cx--;
		buf++;
	}
	return buf-p;	 
}
void Main_NMEA_GPRMC_Analysis(nmea_msg *gpsx,uint8_t *buf){
	uint8_t *p1,dx;			 
	uint8_t posx;     
	uint32_t temp;	   
	float rs;  

	p1=(uint8_t*)strstr((const char *)buf,"$GPRMC");
	posx=Main_NMEA_Comma_Pos(p1,1);								
	if(posx!=0XFF){
		temp=Main_NMEA_Str2num(p1+posx,&dx)/Main_NMEA_Pow(10,dx);	 	

		gpsx->utc.hour=temp/10000;
		gpsx->utc.min=(temp/100)%100;
		gpsx->utc.sec=temp%100;	 	
		
		gpsx->utc.min+=30;
		if(gpsx->utc.min>59){
			gpsx->utc.min-=60;
			gpsx->utc.hour+=5;
		}
		else{
			gpsx->utc.hour+=4;
		}
		
//		LPC_RTC->SEC=gpsx->utc.sec;
//		LPC_RTC->MIN=gpsx->utc.min;
//		LPC_RTC->HOUR=gpsx->utc.hour;
		//CalculateData();
	}			  			  
	posx=Main_NMEA_Comma_Pos(p1,3);								
	if(posx!=0XFF){
		temp=Main_NMEA_Str2num(p1+posx,&dx);		 	 
		gpsx->latitude=temp/Main_NMEA_Pow(10,dx+2);	
		rs=temp%Main_NMEA_Pow(10,dx+2);						 
		gpsx->latitude=gpsx->latitude*Main_NMEA_Pow(10,5)+(rs*Main_NMEA_Pow(10,5-dx))/60; 
	}
	posx=Main_NMEA_Comma_Pos(p1,4);								
	if(posx!=0XFF)gpsx->nshemi=*(p1+posx);					 
 	posx=Main_NMEA_Comma_Pos(p1,5);								
	if(posx!=0XFF){												  
		temp=Main_NMEA_Str2num(p1+posx,&dx);		 	 
		gpsx->longitude=temp/Main_NMEA_Pow(10,dx+2);	
		rs=temp%Main_NMEA_Pow(10,dx+2);						 
		gpsx->longitude=gpsx->longitude*Main_NMEA_Pow(10,5)+(rs*Main_NMEA_Pow(10,5-dx))/60;
	}
	posx=Main_NMEA_Comma_Pos(p1,6);								
	if(posx!=0XFF)
		gpsx->ewhemi=*(p1+posx);		 
	posx=Main_NMEA_Comma_Pos(p1,9);								
	if(posx!=0XFF){
		temp=Main_NMEA_Str2num(p1+posx,&dx);		 				
		gpsx->utc.date=temp/10000;
		gpsx->utc.month=(temp/100)%100;
		gpsx->utc.year=2000+temp%100;	
		
//		LPC_RTC->DOM=gpsx->utc.date;
//		LPC_RTC->MONTH=gpsx->utc.month;
//		LPC_RTC->YEAR=gpsx->utc.year;
	}
}
void Write_Cards_Flash_Data_On_uSD(void){
	int32_t Unit_Index=0, Card_Index=0;

	for(Unit_Index=MP_MASTER; Unit_Index<=MP_SLAVE_8; Unit_Index++){
		for(Card_Index=CARD_SLOT_1; Card_Index<=CARD_SLOT_4; Card_Index++){
//			Write_to_MMC((uint8_t*)(SDRAM____CARDS_FLASH_DATA+ (Unit_Index*NUM_OF_UNIT_CARDS+ Card_Index)*2048     ), GLB_Cards_Flash_Data____MMC____FST_BLK____CPU + (Unit_Index*NUM_OF_UNIT_CARDS+ Card_Index)*8    , 4);
//			Write_to_MMC((uint8_t*)(SDRAM____CARDS_FLASH_DATA+ (Unit_Index*NUM_OF_UNIT_CARDS+ Card_Index)*2048+1024), GLB_Cards_Flash_Data____MMC____FST_BLK____CPU + (Unit_Index*NUM_OF_UNIT_CARDS+ Card_Index)*8+4  , 4);
			//read_from_MMC(SDRAM____4_Block_MMC, GLB_Cards_Flash_Data____MMC____FST_BLK____CPU+ (i*NUM_OF_UNIT_CARDS+j)*8, 4);
		}
	}
}
int8_t Check_Cards_Flash_Data(uint8_t Unit, uint8_t Card){
	int8_t  Valid;
	int32_t i=0;
	uint8_t CARD_Index = Unit* NUM_OF_UNIT_CARDS+ Card;
	
//	read_from_MMC(SDRAM____4_Block_MMC, GLB_Cards_Flash_Data____MMC____FST_BLK____CPU+ CARD_Index*8  , 4);
	
	if(SDRAM____CARDS_FLASH_DATA[CARD_Index*2048] != *(uint16_t*)(SDRAM____4_Block_MMC)){
		GLB____Hardware_Fault__Message[1] |= (One<<Err____Hardware____MisMatch_Cards_with_uSD_Saved_INFO);
		GLB_Mismatch_Cards____Flag = 1;
		Valid= No_0;
//		if(Different_Cards_COnter==0)
//			T6963_240_128_Write_String((char*)RAM_UART_BUFF, 0, 10*(Different_Cards_COnter+2), 0, 0);
//		else
//			T6963_240_128_Write_String_WO_CLEAR_LCD_In_2_Column(SDRAM____String_Komaki, 0, 10*(Different_Cards_COnter+2), 0);
		
		Different_Cards_COnter++;
//		LL_mDelay(100);
//		sprintf(SDRAM____String_Komaki,"U%dC%d  %#06hX - %#04hX",Unit+1, Card+1, SDRAM____CARDS_FLASH_DATA[CARD_Index*2048], (*(uint16_t*)(SDRAM____4_Block_MMC))); Panel_Komaki_UARTX_For_Sprintf();
		
	}
	else
		Valid= Yes_1;

	GLB_Mismatch_Cards____Data[GLB_Mismatch_Cards____Counter * 2+1] = SDRAM____CARDS_FLASH_DATA[CARD_Index*2048];
	GLB_Mismatch_Cards____Data[GLB_Mismatch_Cards____Counter * 2+2] = *(uint16_t*)(SDRAM____4_Block_MMC);
	GLB_Mismatch_Cards____Counter++;
	GLB_Mismatch_Cards____Data[0] = GLB_Mismatch_Cards____Counter;
	
	return Valid;
	/*
	for(i=0; i<1024; i++){
		if(SDRAM____CARDS_FLASH_DATA[CARD_Index*2048+i]!=(*(uint16_t*)(SDRAM____4_Block_MMC+2*i)))
			break;
	}
	
	if(i==1024){
		read_from_MMC(SDRAM____4_Block_MMC, GLB_Cards_Flash_Data____MMC____FST_BLK____CPU+ CARD_Index*8+4, 4);
		for(i=0; i<1024; i++){
			if(SDRAM____CARDS_FLASH_DATA[CARD_Index*2048+1024+i]!=(*(uint16_t*)(SDRAM____4_Block_MMC+2*i)))
				break;
		}
		if(i==1024)
			return Yes_1;
		else
			return No_0;
	}
	else
		return No_0;
	*/
}
void VFC_Bypass_Status___Disp_On_LCD(void){
	if(Loading_Percent != 100)
		return;
	
	if(Disp_CLK_CLB){
		Disp_CLK_CLB = false;
		sprintf((char *)RAM_UART_BUFF, "CLK CLB VALUE: %d",GLB__CLK_CALIB____TIM2_TIMING_CORRECTION);
		T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0);
	}
	
	if(VFC_Is_Bypassed == 1){
		if(Invalid_VFC_Block_Type != -1){
			sprintf((char *)RAM_UART_BUFF,"Invalid VFC Block(# %d)\n", Invalid_VFC_Block_Type);
			Invalid_VFC_Block_Type = -1;
			T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
		}
		if(VFC_Bypassed__Flag == false && VFC_Is_Bypassed__Reason != FP_Update){
			T6963_240_128_Write_String("VFC Bypassed",75,50,0, 0);
			VFC_Bypassed__Flag = true;
		}
		if(VMA_Invalid_Next_Block){
			sprintf((char *)RAM_UART_BUFF,"VMA(Invalid Next Block Index)(%ld)\n", GLB__VFC__BLK_Sequense);
			T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
			VMA_Invalid_Next_Block = false;
		}
		if(VMA_Invalid_Block_Type){
			sprintf((char *)RAM_UART_BUFF,"VMA(Invalid Block Type)\n");
			T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
			VMA_Invalid_Block_Type = false;
		}
		
		if((LED_Run_Counter%1000)<500)
			MHA[LED_RUN___MHA_PNT]=1;
		else
			MHA[LED_RUN___MHA_PNT]=0;
		if(LED_Run_Counter==1000)
			LED_Run_Counter=0;
		
		if(GLB____Hardware_Fault__Message[0] !=0 || GLB____Hardware_Fault__Message[1] !=0)
			MHA[LED_Error___MHA_PNT]=1;
	}
	else{		
		if(GLB____Hardware_Fault__Message[0] ==0 || GLB____Hardware_Fault__Message[1] ==0){
			MHA[LED_RUN___MHA_PNT]=1;
			MHA[LED_Error___MHA_PNT]=0;
		}
		else{
			MHA[LED_RUN___MHA_PNT]=0;
			MHA[LED_Error___MHA_PNT]=1;
		}
	}
}
void While_Functions(void){
	//----------S: TEMP ----------
	/*
	if(TEMP_FLAG___Close_MessageBox == 1){
		while(CPU____QTL____ADD_ITEM(FP_CPU____Close_Message_Box, 0,1, 1, (uint32_t) &TEMP_FLAG___Close_MessageBox) != 1U);
		TEMP_FLAG___Close_MessageBox = 0;
	}
	if(TEMPPPPP4>0){
		                                                       
//			TEMP_CALIB_DATA();
//			FILL_RAM_CARDS_FLASH_DATA(1);
//			MP____FLASH_MODE____0_NA____1_READ____2_WRITE=2U;		
//			MP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG=2U;
		
//		while(CPU____QTL____ADD_ITEM(FP_CPU____VMA, 0, CPU____VMA____Filled_Size+1, 4, (uint32_t) &VMA[0]) != 1U);
//		
//		TEMPPPPP4=0;
		sprintf((char *)RAM_UART_BUFF, "CLK CLB: %d",TEMPPPPP4);
		T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0);
		
		TEMPPPPP4=0;                                           
	}
	if(GLB____Calib____Reset_Calib_Factors_On_4th_Kard == 1){
		FILL_RAM_CARDS_FLASH_DATA(0);
		MP____FLASH_MODE____0_NA____1_READ____2_WRITE=2U;		
		MP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG=2U;
		GLB____Calib____Reset_Calib_Factors_On_4th_Kard=0;
	}
	*/
	//----------E: TEMP ----------
	if(MP_Flash_Data_Total_Size != 0 && Flash_Data_Counter != MP_Flash_Data_Total_Size){
		Loading_Percent= Loading_Percent_Part_1 + (Flash_Data_Counter*80/MP_Flash_Data_Total_Size);
	}
	
	Calibration____Disp_Messages_On_LCD();
	
	//----------S: Send Mesurement & Refresh Signal Info for FP ----------
	{
			if(GLB__VFC_Signal_Value_Refresh___Determined == 1){
				GLB__VFC_Signal_Value_Refresh___Determined = 2;
				while(CPU____QTL____ADD_ITEM(FP_CPU____VFC_SIG_REFRESH_FLAG, 0, 1, 4, (uint32_t) &GLB__VFC_Signal_Value_Refresh_FLAG) != 1U);
			}
			if(Measure_BLK____Num_Of_Analogs_Determined == 1){
				Measure_BLK____Num_Of_Analogs_Determined = 2;
				while(CPU____QTL____ADD_ITEM(FP_CPU____Measure___Num_Of_Assigned_Analog, 0, 1, 4, (uint32_t) &Measure_BLK____Num_Of_Analogs) != 1U);
			}
		}
	//----------E: Send Mesurement & Refresh Signal Info for FP ----------
	//----------S: Send Calib Data when Calib. Failed ----------
	{
		if(GLB____Hardware_Fault__Message[1] != GLB____Hardware_Fault__Message_OLD[1] && Send_Message__Permision){
			while(CPU____QTL____ADD_ITEM(FP_CPU____Close_Message_Box, 0,1, 1, (uint32_t) &TEMP_FLAG___Close_MessageBox) != 1U);
			if((GLB____Hardware_Fault__Message[1] & (One<<Err____Calib____Ref_Val)) != 0 || (GLB____Hardware_Fault__Message[1] & (One<<Err____Calib____FFT_Factors)) != 0){
				while(CPU____QTL____ADD_ITEM(FP_CPU____Calib____Magnitude____Part1, 0, GLB__CALIB_DATA____Magnitude____Part1___Row_Count * GLB_Max_Num_Of_CTPTs__In_All_Units, 4, (uint32_t) &CALIB_DATA__Magni__Part1[0][0]) != 1U);
			}
			while(CPU____QTL____ADD_ITEM(FP_CPU____Hardware_Error, 0, 10, 4, (uint32_t) &GLB____Hardware_Fault__Message[0]) != 1U);
			GLB____Hardware_Fault__Message_OLD[1] = GLB____Hardware_Fault__Message[1];
			while(CPU____QTL____ADD_ITEM(FP_CPU____Calib_Mode, 0, 1, 1,  (uint32_t) &Calib_Mode) != 1U);	
		}
	}
	//----------E: Send Calib Data when Calib. Failed ----------
	//--------------S: Process Initial Flash Data -----------------
	if(MP____Flash_Data_Download____0_NA____1_RECIEVED____2_VERIFIED____3_PROCESSED == 2U && Flash_Data_Is_Valid == Yes_1){
		if(Simulation_Flag){
			Simulation();
		}
		READ_CALIB_DATA_FROM___RAM_CARDS_FLASH_DATA();
		
		if(!Simulation_Flag)
			Var_Init__HW__Read_Write_uSD__init(true);
//		Var_Init__VFC__TRHA__TSHA____TRFA__TSFA____Fill_From_Flash_Data();
		Loading_Percent +=2;

		ANALOG_MODULES_DATA__TRANSFER_BUFFER[0]=GLB_Num_Of_Available_Inputs;
		ANALOG_MODULES_DATA__TRANSFER_BUFFER[1]=GLB_Num_Of_Available_Outputs;
		ANALOG_MODULES_DATA__TRANSFER_BUFFER[2]=GLB_Num_Of_Available_CTPT;
		while(CPU____QTL____ADD_ITEM(FP_CPU____ANALOG_MODULES_DATA, 0,3, 4, (uint32_t) &ANALOG_MODULES_DATA__TRANSFER_BUFFER[0]) != 1U);
		
//		GLB_Mismatch_Cards____Flag = 0;	
//		GLB_Mismatch_Cards____Counter = 0;	
//		for(i=MP_MASTER; i<=MP_SLAVE_8; i++){
//			for(j=CARD_SLOT_1; j<=CARD_SLOT_4; j++)
//				Valid=Check_Cards_Flash_Data(i, j);
//		}
//		if(GLB_Mismatch_Cards____Flag ==1)
//			while(CPU____QTL____ADD_ITEM(FP_CPU____Mismatch_Cards, 0, MAX_NUM_OF_UNITS * NUM_OF_UNIT_CARDS*2+1, 4, (uint32_t) &GLB_Mismatch_Cards____Data[0]) != 1U);
		
		
		
		
		
		if(Calib_Mode==0){
			Calibration____Mode_0_____Load_Calib_Data___Magnit_And_Phase();
			if(!Simulation_Flag)
				Check_Validation_Of_FFT_Scale_Factors(0);
		}
		Loading_Percent +=2;
		if(VFC_Is_Bypassed==0)
			Var_Init__Find_Sett_Index_In_MHA_Setting();
		MP____Flash_Data_Download____0_NA____1_RECIEVED____2_VERIFIED____3_PROCESSED=3;
		MP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG=1;
		Loading_Percent =100;
		
//  TEMP_CALIB_DATA();
//  FILL_RAM_CARDS_FLASH_DATA(1);
//  MP____FLASH_MODE____0_NA____1_READ____2_WRITE=2U;		
//  MP____WORKING_MODE____0_NA____1_NORMAL____2_FLASH____3_CONFIG=2U;
	}
	//--------------E: Process Initial Flash Data -----------------
	Process_Recieve_Data_in_Queue();
	Send_Recieve_Data();
	VFC_Bypass_Status___Disp_On_LCD();
	//--------------S: Send Data to FP -----------------
	if(FP_STATUS____0_DISATTACHED____1_ATTACHED____2_PROCCESSED == 1 && FP_Is_Ready == Yes_1 && CPU____QTL____SIZE == 0 && Loading_Percent == 100){
		if(!VFC_Data_Is_Empty)
			Var_Init__Menu_Data____Send_to_FP(); // hatman aval bashad
		
		while(CPU____QTL____ADD_ITEM(FP_CPU____ANALOG_MODULES_DATA, 0,3, 4, (uint32_t) &ANALOG_MODULES_DATA__TRANSFER_BUFFER[0]) != 1U);
//		while(CPU____QTL____ADD_ITEM(Osc_Date_For_Menu, 0, GLB_number_Of_Oscillograph_For_Display_On_LCD, 28, GLB__SDRM_START_BYTE____Osc_DateTime____For_Menu) != 1U);
//		while(CPU____QTL____ADD_ITEM(TL_Date_For_Menu, 0, GLB_TL__Num_Of_TLs_For_Display_On_LCD, 28, GLB__SDRM_START_BYTE____TL_DateTime____For_Menu) != 1U);
		while(CPU____QTL____ADD_ITEM(FP_CPU____IP, 0, 20, 1, (uint32_t) &(ReadMyCfg.IPConfig[0])) != 1U);
		while(CPU____QTL____ADD_ITEM(FP_CPU____PORT, 0, 1, 2, (uint32_t) &(ReadMyCfg.Port)) != 1U);
		while(CPU____QTL____ADD_ITEM(FP_CPU____SERIAL, 0, 1, 8, (uint32_t) &(ReadMyCfg.Serial)) != 1U);
		while(CPU____QTL____ADD_ITEM(FP_CPU____Pasword, 0, 2, 4, (uint32_t) &GLB_Password_For_Parameter_Set) != 1U);
		while(CPU____QTL____ADD_ITEM(FP_CPU____VFC_SIG_REFRESH_FLAG, 0, 1, 4, (uint32_t) &GLB__VFC_Signal_Value_Refresh_FLAG) != 1U);
		while(CPU____QTL____ADD_ITEM(FP_CPU____Measure___Num_Of_Assigned_Analog, 0, 1, 4, (uint32_t) &Measure_BLK____Num_Of_Analogs) != 1U);

		
		if(VFC_Is_Bypassed__Reason == Empty_VFC_Data){
			sprintf((char *)RAM_UART_BUFF,"VFC Data Not Found.\n");
			T6963_240_128_Write_String((char *)RAM_UART_BUFF,75,50,0, 0); 
		}
			
		FP_Is_Ready = No_0;
		FP_STATUS____0_DISATTACHED____1_ATTACHED____2_PROCCESSED = 2U;
		GLB____Hardware_Fault__Message_OLD[1] = 0;
//	Send_Message_to_FP____Counter = 0;
	}
	
	
	


	
	//--------------E: Send Data to FP -----------------
	Calibration____Calib_Tasks_In_While();
	Measurement();
	Spontaneous_Message_On_LCD();
	Records__TL();
	Records__Comtrade();
	Records__EL();
	Main_Sub_Functions();
}

uint32_t EID_Generate(uint8_t CardID, uint32_t CardSerial){
	return (uint32_t)(((CardID & CARD_TYPE____MASK)<<21U) | (CardSerial & CARD_SERIAL____MASK));
}
int main(void) {
	uint32_t i = 0, j = 0;
	uint32_t Byte_Counter_Rx = 0, Byte_Counter_Tx = 0, k = 0, Temp = 0, Valid;
	uint64_t tickstart = 0U;
	bool Relay_Device____Restart_Need = false;
	uint32_t Next_Start_Cycle = 0U;

	init_platform();



	GPIOConfigPtr = XGpioPs_LookupConfig(XPAR_XGPIOPS_0_DEVICE_ID);
	XGpioPs_CfgInitialize(&xGpioPs, GPIOConfigPtr, GPIOConfigPtr->BaseAddr);

	XGpioPs_SetDirectionPin(&xGpioPs, MIO_PS_500_RESET_OUTn, 1);
	XGpioPs_SetOutputEnablePin(&xGpioPs, MIO_PS_500_RESET_OUTn, 1);

	//----------S: WiFi GPIO -----------
	XGpioPs_SetDirectionPin(&xGpioPs, MIO_SDIO_Selector____0_uSD____1_WiFi, 1);
	XGpioPs_SetOutputEnablePin(&xGpioPs, MIO_SDIO_Selector____0_uSD____1_WiFi, 1);
	XGpioPs_WritePin(&xGpioPs, MIO_SDIO_Selector____0_uSD____1_WiFi, 0);

	XGpioPs_SetDirectionPin(&xGpioPs, MIO_WIFI_REG_ON, 1);
	XGpioPs_SetOutputEnablePin(&xGpioPs, MIO_WIFI_REG_ON, 1);
	XGpioPs_WritePin(&xGpioPs, MIO_WIFI_REG_ON, 0);

	XGpioPs_SetDirectionPin(&xGpioPs, MIO_WIFI_INT, 0);
	//----------E: WiFi GPIO -----------

	//----------S: BL_Entry GPIO -----------
	XGpioPs_SetDirectionPin(&xGpioPs, BL_Entry, 0);
	//----------E: BL_Entry GPIO -----------

	//----------S: CANFD GPIO -----------
	XGpioPs_SetDirectionPin(&xGpioPs, CANFD1_Mode, 1);
	XGpioPs_SetOutputEnablePin(&xGpioPs, CANFD1_Mode, 1);
	XGpioPs_WritePin(&xGpioPs, CANFD1_Mode, 0);

	XGpioPs_SetDirectionPin(&xGpioPs, CANFD2_Mode, 1);
	XGpioPs_SetOutputEnablePin(&xGpioPs, CANFD2_Mode, 1);
	XGpioPs_WritePin(&xGpioPs, CANFD2_Mode, 0);
	//----------E: CANFD GPIO -----------

	//----------S: USB_OVC GPIO -----------
	XGpioPs_SetDirectionPin(&xGpioPs, USB_OVC, 0);
	//----------E: USB_OVC GPIO -----------

	//----------S: EMIO_LED_ONBOARD GPIO -----------
	XGpioPs_SetDirectionPin(&xGpioPs, EMIO_LED_ONBOARD, 1);
	XGpioPs_SetOutputEnablePin(&xGpioPs, EMIO_LED_ONBOARD, 1);
	XGpioPs_WritePin(&xGpioPs, EMIO_LED_ONBOARD, 1);
	//----------E: EMIO_LED_ONBOARD GPIO -----------

	//----------S: Peripheral IC Reset -----------
	XGpioPs_WritePin(&xGpioPs, MIO_PS_500_RESET_OUTn, 0);
	usleep(100);
	XGpioPs_WritePin(&xGpioPs, MIO_PS_500_RESET_OUTn, 1);
	//----------E: Peripheral IC Reset -----------

	//-----------S: PL GPS_SYNCHRONIZER IPCore Start ------------
	GPS_SYNCHRONIZER____AXI_BUS[149] = 0xABCD1234;
	//-----------E: PL GPS_SYNCHRONIZER IPCore Start ------------

	Init__relay_init();

	GLB_Main__H=0;
	GLB_Main__Send_Len=0;
	GLB_Main__Reciv_Len=0;
	CMTRD_LOAD____Recorded_Osc_Exceed_Max_Num_Of_Osc=0;
	CMTRD_LOAD____Total_Bytes_Sent_For_CMTRD_DAT=0;
	GLB_Main__Adr_For_Sav_This_TL=0;
	

	//-------S: Test, Remove -------
	System_Boots____Flag = SB____Main____CARDS_BOOT;
	//-------E: Test, Remove -------

	while (1) {
		switch (System_Boots____Flag) {
			case SB____Bootloader____CARDS_BOOT: {
				tickstart = HAL_GetTick();
				while ((HAL_GetTick() - tickstart) < 2000U) {}; // 2000ms, Wait for other devices startup
				System_Boots____Flag = SB____Bootloader____ID_QUERY;
			}
			break;

			case SB____Bootloader____ID_QUERY: {
				CANFD_NET____Node_ID_Query(&canfd0_i);
				tickstart = HAL_GetTick();
				while ((HAL_GetTick() - tickstart) < 1000U) {};
				System_Boots____Flag = SB____Bootloader____READ_VERSION;
			}
			break;

			case SB____Bootloader____READ_VERSION: {
				for (i = 0U; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					CANFD_NET____Node_Read_Version(&canfd0_i, Device_DB[i].NID);
					tickstart = HAL_GetTick();
					while ((HAL_GetTick() - tickstart) < 3U) {}; // 3ms, Wait for other devices answer
				}

				System_Boots____Flag = SB____Bootloader____UPDATE_FIRMWARE;
			}
			break;

			case SB____Bootloader____UPDATE_FIRMWARE: {
				// -------------S: Test, Remove --------------
				RELAY_CARD____eMMC_DB____TABLE[0][0] = 0x000000A4;	// [FILE_ID]
				RELAY_CARD____eMMC_DB____TABLE[0][1] = 0U;	 		// [VERSION]
				RELAY_CARD____eMMC_DB____TABLE[0][2] = 25388; 		// [SIZE]
				RELAY_CARD____eMMC_DB____TABLE[0][3] = 0U;			// [START_BYTE_ADDRESS_IN_RAM]
				RELAY_CARD____FW_DB____COUNTER = 1;

				for (i = 0; i < RELAY_CARD____eMMC_DB____TABLE[0][2]; i++) {
					RELAY_CARD____FW_DB[RELAY_CARD____eMMC_DB____TABLE[0][3] + i] = STM32H750VB____PS[i];
				}
				// -------------E: Test, Remove --------------

				for (i = 0U; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					for (j = 0; j < RELAY_CARD____FW_DB____COUNTER; j++) {
						if (Device_DB[i].Type == RELAY_CARD____eMMC_DB____TABLE[j][0]) {
							Device_DB[i].FW_Exist = true;
							if (Device_DB[i].FW_Version != RELAY_CARD____eMMC_DB____TABLE[j][1]) {
								Device_DB[i].FW_Flash_Status = CANFD_NET____Node_FW_File_Transfer(&canfd0_i, Device_DB[i].NID, RELAY_CARD____eMMC_DB____TABLE[i][0],\
															   (uint8_t *) &RELAY_CARD____FW_DB[RELAY_CARD____eMMC_DB____TABLE[j][3]], RELAY_CARD____eMMC_DB____TABLE[j][2]);
							}
						}
						else {
							Device_DB[i].FW_Exist = false;
							Relay_Device____Restart_Need = true; // firmware not found !!!!
							xil_printf("Error: Firmware not found for CARD_ID: 0x%02X \r\n", Device_DB[i].Type);
						}
					}
				}

				if (Relay_Device____Restart_Need == true) {
					xil_printf("Error: No cards were identified. The system is reset to re-identify the Cards. \r\n", Device_DB[i].Type);
					CANFD_NET____Node_Reset(&canfd0_i, CARD____GID);
					tickstart = HAL_GetTick();
					while ((HAL_GetTick() - tickstart) < 3U) {}; // 3ms
					NVIC_SystemReset();
				}

				System_Boots____Flag = SB____Main____CARDS_BOOT;
			}
			break;

			case SB____Main____CARDS_BOOT: {
				CANFD_NET____LOOKUP_ID____COUNT = 0U;
				memset(Device_DB, 0U, sizeof(Device_DB)); // Reset Card info
				tickstart = HAL_GetTick();
				while ((HAL_GetTick() - tickstart) < 2000U) {}; // 2sec wait for all card boot.
				System_Boots____Flag = SB____Main____ID_QUERY;
			}
			break;

			case SB____Main____ID_QUERY: {
				CANFD_NET____Node_ID_Query(&canfd0_i);
				tickstart = HAL_GetTick();
				while ((HAL_GetTick() - tickstart) < 1000U) {};
				System_Boots____Flag = SB____Main____READ_VERSION;
			}
			break;

			case SB____Main____READ_VERSION: {
				for (i = 0U; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					CANFD_NET____Node_Read_Version(&canfd0_i, Device_DB[i].NID);
					tickstart = HAL_GetTick();
					while ((HAL_GetTick() - tickstart) < 3U) {}; // 3ms, Wait for other devices answer
				}

				System_Boots____Flag = SB____Main____TIME_CYCLE_CALCULATION;
			}
			break;

			case SB____Main____TIME_CYCLE_CALCULATION: {
//				Device_DB[0].Cycle_Start = 1U;
//				for (i = 1U; i < (CANFD_NET____LOOKUP_ID____COUNT + 1U); i++) {
//					Device_DB[i].Cycle_Start = Device_DB[i - 1U].Cycle_Start + Device_DB[i - 1U].Max_Cycle;
//				}

				i = 0U;
				while(true){

					if(CARD_Placement[i][0] == 0U)
						break;

					if(Device_DB[i].NID == EID_Generate(CARD_Placement[0][0], CARD_Placement[0][1])){
						Device_DB[i].Cycle_Start = 1U;
						Next_Start_Cycle = Device_DB[i].Cycle_Start + Device_DB[i].Max_Cycle;
						break;
					}

					i += 1U;
				}

				i = 0U;
				j = 0U;
				if(Next_Start_Cycle != 0U){
					while(true){
						if(CARD_Placement[i+1][0] == 0U)
							break;

						for(j=0U; j<CARD_Specifications____Max_Slot_Card_Capacity; j++){
							if(Device_DB[j].NID == 0U)
								break;

							if(EID_Generate(CARD_Placement[i+1][0], CARD_Placement[i+1][1]) == Device_DB[j].NID){
								Device_DB[j].Cycle_Start = Next_Start_Cycle;
								Next_Start_Cycle += Device_DB[j].Max_Cycle;
								break;
							}
						}

						i += 1U;
					}
				}

				if(Next_Start_Cycle != 0U){
					System_Boots____Flag = SB____Main____SET_TIME_CYCLE;
					xil_printf("Card placement array verified.\r\n");
				}
				else{
					// Error jump to main
					System_Boots____Flag = SB____Main____START;
					while(true){
						xil_printf("Error! Please check the card placement array.\r\n");
						sleep(1);
					}
				}
			}
			break;

			case SB____Main____SET_TIME_CYCLE: {
				for (i = 0U; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					CANFD_NET____Node_Set_Cycle(&canfd0_i, Device_DB[i].NID, Device_DB[i].Cycle_Start);
				}

				System_Boots____Flag = SB____Main____READ_4KB_CARDS_FLASH;
			}
			break;

			case SB____Main____READ_4KB_CARDS_FLASH: {
				for (i = 0U; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					Device_DB[i].Factory_Data_Read_Status = CANFD_NET____Node_Read_Data_Flash(&canfd0_i, Device_DB[i].NID, 0, 1, &Device_DB[i].Factory_Data[0]);
					Device_DB[i].Calibration_Data_Read_Status = CANFD_NET____Node_Read_Data_Flash(&canfd0_i, Device_DB[i].NID, 1, 1, &Device_DB[i].Calibration_Data[0]);
				}
				System_Boots____Flag = SB____Main____TIMING_START;

			}
			break;

			case SB____Main____TIMING_START:{

				GPS_SYNCHRONIZER____AXI_BUS[144] = 0xABCD1234; // SPI Timing Start

				for (i = 0U; i < CANFD_NET____LOOKUP_ID____COUNT; i++) {
					CANFD_NET____Node_Enable_SPI_BUS_Trancieve(&canfd0_i, Device_DB[i].NID);
				}
				System_Boots____Flag = SB____Main____START;
			}
			break;

			case SB____Main____START: {
//				While_Functions();
				GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[0] = 1;
				GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[5] = 1;
				GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[6] = 1;
				XGpioPs_WritePin(&xGpioPs, EMIO_LED_ONBOARD, 0);
				sleep(1);
				GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[0] = 0;
				GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[5] = 0;
				GPS_SYNCHRONIZER____AXI_BUS____DATA_WRITE[6] = 0;
				XGpioPs_WritePin(&xGpioPs, EMIO_LED_ONBOARD, 1);
				sleep(1);
			}
			break;

			default: {
				// Fault!
			}
			break;
		}

		//-----------------S: Ethernet Handler -----------------
//#if(One_Core)
//		//----------S: Core 1 ----------
//		if (TcpFastTmrFlag) {
//			tcp_fasttmr();
//			TcpFastTmrFlag = 0;
//		}
//		if (TcpSlowTmrFlag) {
//			tcp_slowtmr();
//			TcpSlowTmrFlag = 0;
//		}
//		XEmacPs_IntrHandler(0x07273b40);
//		xemacif_input(echo_netif);
//		timer_callback();
//		//----------E: Core 1----------
//#endif
		//-----------------E: Ethernet Handler -----------------
	}

	return XST_SUCCESS;
}
#endif

#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line){
	/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
	
	printf("Wrong parameters value: file %s on line %d", file, line);
  /* Infinite loop */
  while (1){};
}
#endif

